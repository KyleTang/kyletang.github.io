(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{442:function(n,s,h){n.exports=h.p+"assets/img/2017-08-24-string_hash_to_number.7c3f6425.png"},474:function(n,s,h){"use strict";h.r(s);var a=h(62),t=Object(a.a)({},(function(){var n=this,s=n.$createElement,a=n._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"【转】字符串哈希函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#【转】字符串哈希函数"}},[n._v("#")]),n._v(" 【转】字符串哈希函数")]),n._v(" "),a("p",[n._v("2017-08-24")]),n._v(" "),a("p",[n._v("原文：http://www.cnblogs.com/uvsjoh/archive/2012/03/27/2420120.html 备份在此")]),n._v(" "),a("h2",{attrs:{id:"基本概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[n._v("#")]),n._v(" 基本概念")]),n._v(" "),a("p",[n._v("所谓完美哈希函数，就是指没有冲突的哈希函数，即对任意的 key1 != key2 有h(key1) != h(key2)。\n设定义域为X，值域为Y, n=|X|,m=|Y|，那么肯定有m>=n,如果对于不同的key1,key2属于X,有h(key1)!=h(key2)，那么称h为完美哈希函数，当m=n时，h称为最小完美哈希函数（这个时候就是一一映射了）。")]),n._v(" "),a("p",[n._v("在处理大规模字符串数据时，经常要为每个字符串分配一个整数ID。这就需要一个字符串的哈希函数。怎么样找到一个完美的字符串hash函数呢？\n有一些常用的字符串hash函数。像BKDRHash，APHash，DJBHash，JSHash，RSHash，SDBMHash，PJWHash，ELFHash等等。都是比较经典的。")]),n._v(" "),a("p",[n._v("下面是转载的对几个常用字符串hash函数的分析：\nhttp://www.cnblogs.com/atlantis13579/archive/2010/02/06/1664792.html")]),n._v(" "),a("p",[n._v("常用的字符串Hash函数还有ELFHash，APHash等等，都是十分简单有效的方法。这些函数使用位运算使得每一个字符都对最后的函数值产生影响。另外还有以MD5和SHA1为代表的杂凑函数，这些函数几乎不可能找到碰撞。")]),n._v(" "),a("p",[n._v("常用字符串哈希函数有 BKDRHash，APHash，DJBHash，JSHash，RSHash，SDBMHash，PJWHash，ELFHash等等。对于以上几种哈希函数，我对其进行了一个小小的评测。")]),n._v(" "),a("p",[a("img",{attrs:{src:h(442),alt:"img"}})]),n._v(" "),a("p",[n._v("其中数据1为100000个字母和数字组成的随机串哈希冲突个数。数据2为100000个有意义的英文句子哈希冲突个数。数据3为数据1的哈希值与 1000003(大素数)求模后存储到线性表中冲突的个数。数据4为数据1的哈希值与10000019(更大素数)求模后存储到线性表中冲突的个数。")]),n._v(" "),a("p",[n._v("经过比较，得出以上平均得分。平均数为平方平均数。可以发现，BKDRHash无论是在实际效果还是编码实现中，效果都是最突出的。APHash也是较为优秀的算法。DJBHash,JSHash,RSHash与SDBMHash各有千秋。PJWHash与ELFHash效果最差，但得分相似，其算法本质是相似的。")]),n._v(" "),a("h2",{attrs:{id:"c代码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#c代码"}},[n._v("#")]),n._v(" C代码")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("unsigned int SDBMHash(char *str)\n{\n    unsigned int hash = 0;\n \n    while (*str)\n    {\n        // equivalent to: hash = 65599*hash + (*str++);\n        hash = (*str++) + (hash << 6) + (hash << 16) - hash;\n    }\n \n    return (hash & 0x7FFFFFFF);\n}\n \n// RS Hash Function\nunsigned int RSHash(char *str)\n{\n    unsigned int b = 378551;\n    unsigned int a = 63689;\n    unsigned int hash = 0;\n \n    while (*str)\n    {\n        hash = hash * a + (*str++);\n        a *= b;\n    }\n \n    return (hash & 0x7FFFFFFF);\n}\n \n// JS Hash Function\nunsigned int JSHash(char *str)\n{\n    unsigned int hash = 1315423911;\n \n    while (*str)\n    {\n        hash ^= ((hash << 5) + (*str++) + (hash >> 2));\n    }\n \n    return (hash & 0x7FFFFFFF);\n}\n \n// P. J. Weinberger Hash Function\nunsigned int PJWHash(char *str)\n{\n    unsigned int BitsInUnignedInt = (unsigned int)(sizeof(unsigned int) * 8);\n    unsigned int ThreeQuarters    = (unsigned int)((BitsInUnignedInt  * 3) / 4);\n    unsigned int OneEighth        = (unsigned int)(BitsInUnignedInt / 8);\n    unsigned int HighBits         = (unsigned int)(0xFFFFFFFF) << (BitsInUnignedInt - OneEighth);\n    unsigned int hash             = 0;\n    unsigned int test             = 0;\n \n    while (*str)\n    {\n        hash = (hash << OneEighth) + (*str++);\n        if ((test = hash & HighBits) != 0)\n        {\n            hash = ((hash ^ (test >> ThreeQuarters)) & (~HighBits));\n        }\n    }\n \n    return (hash & 0x7FFFFFFF);\n}\n \n// ELF Hash Function\nunsigned int ELFHash(char *str)\n{\n    unsigned int hash = 0;\n    unsigned int x    = 0;\n \n    while (*str)\n    {\n        hash = (hash << 4) + (*str++);\n        if ((x = hash & 0xF0000000L) != 0)\n        {\n            hash ^= (x >> 24);\n            hash &= ~x;\n        }\n    }\n \n    return (hash & 0x7FFFFFFF);\n}\n \n// BKDR Hash Function\nunsigned int BKDRHash(char *str)\n{\n    unsigned int seed = 131; // 31 131 1313 13131 131313 etc..\n    unsigned int hash = 0;\n \n    while (*str)\n    {\n        hash = hash * seed + (*str++);\n    }\n \n    return (hash & 0x7FFFFFFF);\n}\n \n// DJB Hash Function\nunsigned int DJBHash(char *str)\n{\n    unsigned int hash = 5381;\n \n    while (*str)\n    {\n        hash += (hash << 5) + (*str++);\n    }\n \n    return (hash & 0x7FFFFFFF);\n}\n \n// AP Hash Function\nunsigned int APHash(char *str)\n{\n    unsigned int hash = 0;\n    int i;\n \n    for (i=0; *str; i++)\n    {\n        if ((i & 1) == 0)\n        {\n            hash ^= ((hash << 7) ^ (*str++) ^ (hash >> 3));\n        }\n        else\n        {\n            hash ^= (~((hash << 11) ^ (*str++) ^ (hash >> 5)));\n        }\n    }\n \n    return (hash & 0x7FFFFFFF);\n}\n")])])]),a("h2",{attrs:{id:"编程珠玑中的一个hash函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编程珠玑中的一个hash函数"}},[n._v("#")]),n._v(" 编程珠玑中的一个hash函数")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("//用跟元素个数最接近的质数作为散列表的大小\n#define NHASH 29989\n#define MULT 31\n\nunsigned in hash(char *p)\n{\n    unsigned int h = 0;\n    for (; *p; p++)\n        h = MULT *h + *p;\n    return h % NHASH;\n}\n")])])])])}),[],!1,null,null,null);s.default=t.exports}}]);