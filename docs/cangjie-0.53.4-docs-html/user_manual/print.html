<!DOCTYPE HTML>
<html lang="zh-cn" class="ayu" dir="ltr">
    <head>
            <script type="text/x-mathjax-config">
                MathJax.Hub.Config({
                    showProcessingMessages: false,
                    messageStyle: "none",
                    extensions: ['tex2jax.js'],
                    jax: ['input/TeX', 'output/HTML-CSS'],
                    tex2jax: {
                        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
                        processEscapes: true
                    },
                    "HTML-CSS": { availableFonts: ["STIX", "TeX"] }
                });
            </script>
            
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>仓颉语言用户指南</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="assets/style.css">
        <link rel="stylesheet" href="assets/theme.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('ayu')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><div><strong aria-hidden="true">1.</strong> 初识仓颉语言</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="source_zh_cn/first_understanding/basic.html"><strong aria-hidden="true">1.1.</strong> 初识仓颉语言</a></li><li class="chapter-item "><a href="source_zh_cn/first_understanding/install_Community.html"><strong aria-hidden="true">1.2.</strong> 安装仓颉工具链</a></li><li class="chapter-item "><a href="source_zh_cn/first_understanding/hello_world.html"><strong aria-hidden="true">1.3.</strong> 运行第一个仓颉程序</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.</strong> 基本概念</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="source_zh_cn/basic_programming_concepts/identifier.html"><strong aria-hidden="true">2.1.</strong> 标识符</a></li><li class="chapter-item "><a href="source_zh_cn/basic_programming_concepts/program_structure.html"><strong aria-hidden="true">2.2.</strong> 程序结构</a></li><li class="chapter-item "><a href="source_zh_cn/basic_programming_concepts/expression.html"><strong aria-hidden="true">2.3.</strong> 表达式</a></li><li class="chapter-item "><a href="source_zh_cn/basic_programming_concepts/function.html"><strong aria-hidden="true">2.4.</strong> 函数</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">3.</strong> 基础数据类型</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="source_zh_cn/basic_data_type/integer.html"><strong aria-hidden="true">3.1.</strong> 整数类型</a></li><li class="chapter-item "><a href="source_zh_cn/basic_data_type/float.html"><strong aria-hidden="true">3.2.</strong> 浮点类型</a></li><li class="chapter-item "><a href="source_zh_cn/basic_data_type/bool.html"><strong aria-hidden="true">3.3.</strong> 布尔类型</a></li><li class="chapter-item "><a href="source_zh_cn/basic_data_type/characters.html"><strong aria-hidden="true">3.4.</strong> 字符类型</a></li><li class="chapter-item "><a href="source_zh_cn/basic_data_type/strings.html"><strong aria-hidden="true">3.5.</strong> 字符串类型</a></li><li class="chapter-item "><a href="source_zh_cn/basic_data_type/tuple.html"><strong aria-hidden="true">3.6.</strong> 元组类型</a></li><li class="chapter-item "><a href="source_zh_cn/basic_data_type/array.html"><strong aria-hidden="true">3.7.</strong> 数组类型</a></li><li class="chapter-item "><a href="source_zh_cn/basic_data_type/range.html"><strong aria-hidden="true">3.8.</strong> 区间类型</a></li><li class="chapter-item "><a href="source_zh_cn/basic_data_type/unit.html"><strong aria-hidden="true">3.9.</strong> Unit 类型</a></li><li class="chapter-item "><a href="source_zh_cn/basic_data_type/nothing.html"><strong aria-hidden="true">3.10.</strong> Nothing 类型</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">4.</strong> 函数</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="source_zh_cn/function/define_functions.html"><strong aria-hidden="true">4.1.</strong> 定义函数</a></li><li class="chapter-item "><a href="source_zh_cn/function/call_functions.html"><strong aria-hidden="true">4.2.</strong> 调用函数</a></li><li class="chapter-item "><a href="source_zh_cn/function/first_class_citizen.html"><strong aria-hidden="true">4.3.</strong> 函数类型</a></li><li class="chapter-item "><a href="source_zh_cn/function/nested_functions.html"><strong aria-hidden="true">4.4.</strong> 嵌套函数</a></li><li class="chapter-item "><a href="source_zh_cn/function/lambda.html"><strong aria-hidden="true">4.5.</strong> Lambda 表达式</a></li><li class="chapter-item "><a href="source_zh_cn/function/closure.html"><strong aria-hidden="true">4.6.</strong> 闭包</a></li><li class="chapter-item "><a href="source_zh_cn/function/function_call_desugar.html"><strong aria-hidden="true">4.7.</strong> 函数调用语法糖</a></li><li class="chapter-item "><a href="source_zh_cn/function/function_overloading.html"><strong aria-hidden="true">4.8.</strong> 函数重载</a></li><li class="chapter-item "><a href="source_zh_cn/function/operator_overloading.html"><strong aria-hidden="true">4.9.</strong> 操作符重载</a></li><li class="chapter-item "><a href="source_zh_cn/function/const_func_and_eval.html"><strong aria-hidden="true">4.10.</strong> const 函数和常量求值</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">5.</strong> 结构类型</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="source_zh_cn/struct/define_struct.html"><strong aria-hidden="true">5.1.</strong> 定义 struct 类型</a></li><li class="chapter-item "><a href="source_zh_cn/struct/create_instance.html"><strong aria-hidden="true">5.2.</strong> 创建 struct 实例</a></li><li class="chapter-item "><a href="source_zh_cn/struct/mut.html"><strong aria-hidden="true">5.3.</strong> mut 函数</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">6.</strong> 枚举类型和模式匹配</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="source_zh_cn/enum_and_pattern_match/enum.html"><strong aria-hidden="true">6.1.</strong> 枚举类型</a></li><li class="chapter-item "><a href="source_zh_cn/enum_and_pattern_match/option_type.html"><strong aria-hidden="true">6.2.</strong> Option 类型</a></li><li class="chapter-item "><a href="source_zh_cn/enum_and_pattern_match/pattern_overview.html"><strong aria-hidden="true">6.3.</strong> 模式概述</a></li><li class="chapter-item "><a href="source_zh_cn/enum_and_pattern_match/pattern_refutability.html"><strong aria-hidden="true">6.4.</strong> 模式的 Refutability</a></li><li class="chapter-item "><a href="source_zh_cn/enum_and_pattern_match/match.html"><strong aria-hidden="true">6.5.</strong> match 表达式</a></li><li class="chapter-item "><a href="source_zh_cn/enum_and_pattern_match/if_let.html"><strong aria-hidden="true">6.6.</strong> if-let 表达式</a></li><li class="chapter-item "><a href="source_zh_cn/enum_and_pattern_match/while_let.html"><strong aria-hidden="true">6.7.</strong> while-let 表达式</a></li><li class="chapter-item "><a href="source_zh_cn/enum_and_pattern_match/other.html"><strong aria-hidden="true">6.8.</strong> 其他使用模式的地方</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">7.</strong> 类和接口</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="source_zh_cn/class_and_interface/class.html"><strong aria-hidden="true">7.1.</strong> 类</a></li><li class="chapter-item "><a href="source_zh_cn/class_and_interface/interface.html"><strong aria-hidden="true">7.2.</strong> 接口</a></li><li class="chapter-item "><a href="source_zh_cn/class_and_interface/prop.html"><strong aria-hidden="true">7.3.</strong> 属性</a></li><li class="chapter-item "><a href="source_zh_cn/class_and_interface/subtype.html"><strong aria-hidden="true">7.4.</strong> 子类型关系</a></li><li class="chapter-item "><a href="source_zh_cn/class_and_interface/typecast.html"><strong aria-hidden="true">7.5.</strong> 类型转换</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">8.</strong> 泛型</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="source_zh_cn/generic/generic_overview.html"><strong aria-hidden="true">8.1.</strong> 泛型概述</a></li><li class="chapter-item "><a href="source_zh_cn/generic/generic_function.html"><strong aria-hidden="true">8.2.</strong> 泛型函数</a></li><li class="chapter-item "><a href="source_zh_cn/generic/generic_interface.html"><strong aria-hidden="true">8.3.</strong> 泛型接口</a></li><li class="chapter-item "><a href="source_zh_cn/generic/generic_class.html"><strong aria-hidden="true">8.4.</strong> 泛型类</a></li><li class="chapter-item "><a href="source_zh_cn/generic/generic_struct.html"><strong aria-hidden="true">8.5.</strong> 泛型结构体</a></li><li class="chapter-item "><a href="source_zh_cn/generic/generic_enum.html"><strong aria-hidden="true">8.6.</strong> 泛型枚举</a></li><li class="chapter-item "><a href="source_zh_cn/generic/generic_subtype.html"><strong aria-hidden="true">8.7.</strong> 泛型类型的子类型关系</a></li><li class="chapter-item "><a href="source_zh_cn/generic/typealias.html"><strong aria-hidden="true">8.8.</strong> 类型别名</a></li><li class="chapter-item "><a href="source_zh_cn/generic/generic_constraint.html"><strong aria-hidden="true">8.9.</strong> 泛型约束</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">9.</strong> 扩展</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="source_zh_cn/extension/extend_overview.html"><strong aria-hidden="true">9.1.</strong> 扩展概述</a></li><li class="chapter-item "><a href="source_zh_cn/extension/direct_extension.html"><strong aria-hidden="true">9.2.</strong> 直接扩展</a></li><li class="chapter-item "><a href="source_zh_cn/extension/interface_extension.html"><strong aria-hidden="true">9.3.</strong> 接口扩展</a></li><li class="chapter-item "><a href="source_zh_cn/extension/access_rules.html"><strong aria-hidden="true">9.4.</strong> 访问规则</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">10.</strong> Collection 类型</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="source_zh_cn/Collections/collection_overview.html"><strong aria-hidden="true">10.1.</strong> 基础 Collection 类型概述</a></li><li class="chapter-item "><a href="source_zh_cn/Collections/collection_arraylist.html"><strong aria-hidden="true">10.2.</strong> ArrayList</a></li><li class="chapter-item "><a href="source_zh_cn/Collections/collection_hashset.html"><strong aria-hidden="true">10.3.</strong> HashSet</a></li><li class="chapter-item "><a href="source_zh_cn/Collections/collection_hashmap.html"><strong aria-hidden="true">10.4.</strong> HashMap</a></li><li class="chapter-item "><a href="source_zh_cn/Collections/collection_iterable_collections.html"><strong aria-hidden="true">10.5.</strong> Iterable 和 Collections</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">11.</strong> 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="source_zh_cn/package/package_overview.html"><strong aria-hidden="true">11.1.</strong> 包的概述</a></li><li class="chapter-item "><a href="source_zh_cn/package/package_name.html"><strong aria-hidden="true">11.2.</strong> 包的声明</a></li><li class="chapter-item "><a href="source_zh_cn/package/toplevel_access.html"><strong aria-hidden="true">11.3.</strong> 顶层声明的可见性</a></li><li class="chapter-item "><a href="source_zh_cn/package/import.html"><strong aria-hidden="true">11.4.</strong> 包的导入</a></li><li class="chapter-item "><a href="source_zh_cn/package/entry.html"><strong aria-hidden="true">11.5.</strong> 程序入口</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">12.</strong> 异常处理</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="source_zh_cn/error_handle/exception_overview.html"><strong aria-hidden="true">12.1.</strong> 定义异常</a></li><li class="chapter-item "><a href="source_zh_cn/error_handle/handle.html"><strong aria-hidden="true">12.2.</strong> throw 和处理异常</a></li><li class="chapter-item "><a href="source_zh_cn/error_handle/common_runtime_exceptions.html"><strong aria-hidden="true">12.3.</strong> 常见运行时异常</a></li><li class="chapter-item "><a href="source_zh_cn/error_handle/use_option.html"><strong aria-hidden="true">12.4.</strong> 使用 Option</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">13.</strong> 并发编程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="source_zh_cn/concurrency/concurrency_overview.html"><strong aria-hidden="true">13.1.</strong> 并发概述</a></li><li class="chapter-item "><a href="source_zh_cn/concurrency/create_thread.html"><strong aria-hidden="true">13.2.</strong> 创建线程</a></li><li class="chapter-item "><a href="source_zh_cn/concurrency/use_thread.html"><strong aria-hidden="true">13.3.</strong> 访问线程</a></li><li class="chapter-item "><a href="source_zh_cn/concurrency/terminal_thread.html"><strong aria-hidden="true">13.4.</strong> 终止线程</a></li><li class="chapter-item "><a href="source_zh_cn/concurrency/sync.html"><strong aria-hidden="true">13.5.</strong> 同步机制</a></li><li class="chapter-item "><a href="source_zh_cn/concurrency/sleep.html"><strong aria-hidden="true">13.6.</strong> 线程睡眠指定时长 sleep</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">14.</strong> 基础 I/O 操作</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="source_zh_cn/Basic_IO/basic_IO_overview.html"><strong aria-hidden="true">14.1.</strong> I/O 流概述</a></li><li class="chapter-item "><a href="source_zh_cn/Basic_IO/basic_IO_source_stream.html"><strong aria-hidden="true">14.2.</strong> I/O 节点流</a></li><li class="chapter-item "><a href="source_zh_cn/Basic_IO/basic_IO_process_stream.html"><strong aria-hidden="true">14.3.</strong> I/O 处理流</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">15.</strong> 网络编程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="source_zh_cn/Net/net_overview.html"><strong aria-hidden="true">15.1.</strong> 网络编程概述</a></li><li class="chapter-item "><a href="source_zh_cn/Net/net_socket.html"><strong aria-hidden="true">15.2.</strong> Socket 编程</a></li><li class="chapter-item "><a href="source_zh_cn/Net/net_http.html"><strong aria-hidden="true">15.3.</strong> Http 编程</a></li><li class="chapter-item "><a href="source_zh_cn/Net/net_websocket.html"><strong aria-hidden="true">15.4.</strong> Websocket 编程</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">16.</strong> 宏</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="source_zh_cn/Macro/macro_introduction.html"><strong aria-hidden="true">16.1.</strong> 宏的简介</a></li><li class="chapter-item "><a href="source_zh_cn/Macro/Tokens_types_and_quote_expressions.html"><strong aria-hidden="true">16.2.</strong> Tokens 相关类型和 quote 表达式</a></li><li class="chapter-item "><a href="source_zh_cn/Macro/sytax_node.html"><strong aria-hidden="true">16.3.</strong> 语法节点</a></li><li class="chapter-item "><a href="source_zh_cn/Macro/implementation_of_macros.html"><strong aria-hidden="true">16.4.</strong> 宏的实现</a></li><li class="chapter-item "><a href="source_zh_cn/Macro/compiling_error_reporting_and_debugging.html"><strong aria-hidden="true">16.5.</strong> 编译、报错与调试</a></li><li class="chapter-item "><a href="source_zh_cn/Macro/defining_and_importing_macro_package.html"><strong aria-hidden="true">16.6.</strong> 宏包定义和导入</a></li><li class="chapter-item "><a href="source_zh_cn/Macro/builtin_compilation_flags.html"><strong aria-hidden="true">16.7.</strong> 内置编译标记</a></li><li class="chapter-item "><a href="source_zh_cn/Macro/pratical_case.html"><strong aria-hidden="true">16.8.</strong> 实用案例</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">17.</strong> 反射和注解</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="source_zh_cn/reflect_and_annotation/dynamic_feature.html"><strong aria-hidden="true">17.1.</strong> 动态特性</a></li><li class="chapter-item "><a href="source_zh_cn/reflect_and_annotation/anno.html"><strong aria-hidden="true">17.2.</strong> 注解</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">18.</strong> 跨语言互操作</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="source_zh_cn/FFI/cangjie-c.html"><strong aria-hidden="true">18.1.</strong> 仓颉-C 互操作</a></li><li class="chapter-item "><a href="source_zh_cn/FFI/cangjie-python.html"><strong aria-hidden="true">18.2.</strong> 仓颉-Python 互操作</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">19.</strong> 编译和构建</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="source_zh_cn/Compile-And-Build/cjc_usage.html"><strong aria-hidden="true">19.1.</strong> cjc 使用</a></li><li class="chapter-item "><a href="source_zh_cn/Compile-And-Build/cjpm_usage.html"><strong aria-hidden="true">19.2.</strong> cjpm 介绍</a></li><li class="chapter-item "><a href="source_zh_cn/Compile-And-Build/conditional_compilation.html"><strong aria-hidden="true">19.3.</strong> 条件编译</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">20.</strong> 附录</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="source_zh_cn/Appendix/compile_options.html"><strong aria-hidden="true">20.1.</strong> cjc 编译选项</a></li><li class="chapter-item "><a href="source_zh_cn/Appendix/linux_toolchain_install.html"><strong aria-hidden="true">20.2.</strong> Linux 版本工具链的支持与安装</a></li><li class="chapter-item "><a href="source_zh_cn/Appendix/runtime_env.html"><strong aria-hidden="true">20.3.</strong> runtime 环境变量使用手册</a></li><li class="chapter-item "><a href="source_zh_cn/Appendix/keyword.html"><strong aria-hidden="true">20.4.</strong> 关键字</a></li><li class="chapter-item "><a href="source_zh_cn/Appendix/operator.html"><strong aria-hidden="true">20.5.</strong> 操作符</a></li><li class="chapter-item "><a href="source_zh_cn/Appendix/operator_function.html"><strong aria-hidden="true">20.6.</strong> 操作符函数</a></li><li class="chapter-item "><a href="source_zh_cn/Appendix/tokenkind_type.html"><strong aria-hidden="true">20.7.</strong> TokenKind 类型</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">仓颉语言用户指南</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="初识仓颉语言"><a class="header" href="#初识仓颉语言">初识仓颉语言</a></h1>
<p>仓颉编程语言是一种面向全场景应用开发的通用编程语言，可以兼顾开发效率和运行性能，并提供良好的编程体验，主要具有如下特点：</p>
<ul>
<li><strong>语法简明高效</strong>：仓颉编程语言提供了一系列简明高效的语法，旨在减少冗余书写、提升开发效率，例如插值字符串、主构造函数、Flow 表达式、<code>match</code>、<code>if-let</code>、<code>while-let</code> 和重导出等语法，让开发者可以用较少编码表达相关逻辑。</li>
<li><strong>多范式编程</strong>：仓颉编程语言支持函数式、命令式和面向对象等多范式编程，融合了高阶函数、代数数据类型、模式匹配、泛型等函数式语言的先进特性，还有封装、接口、继承、子类型多态等支持模块化开发的面向对象语言特性，以及值类型、全局函数等简洁高效的命令式语言特性。开发者可以根据开发偏好或应用场景，选用不同的编程范式。</li>
<li><strong>类型安全</strong>：仓颉编程语言是静态强类型语言，通过编译时类型检查尽早识别程序错误，降低运行时风险，也便于代码维护。同时，仓颉编译器提供了强大的类型推断能力，可以减少类型标注工作，提高开发效率。</li>
<li><strong>内存安全</strong>：仓颉编程语言支持自动内存管理，并在运行时进行数组下标越界检查、溢出检查等，确保运行时内存安全。</li>
<li><strong>高效并发</strong>：仓颉编程语言提供了用户态轻量化线程（原生协程），以及简单易用的并发编程机制，保证并发场景的高效开发和运行。</li>
<li><strong>兼容语言生态</strong>：仓颉编程语言支持和 C 等主流编程语言的互操作，并采用便捷的声明式编程范式，可实现对其他语言库的高效复用和生态兼容。</li>
<li><strong>领域易扩展</strong>：仓颉编程语言提供了基于词法宏的元编程能力，支持在编译时变换代码，此外，还提供了尾随 <code>lambda</code>、属性、操作符重载、部分关键字可省略等特性，开发者可由此深度定制程序的语法和语义，有利于内嵌式领域专用语言（Embedded Domain Specific Languages，EDSL）的构建。</li>
<li><strong>助力 UI 开发</strong>：UI 开发是构建端侧应用的重要环节，基于仓颉编程语言的元编程和尾随 <code>lambda</code> 等特性，可以搭建声明式 UI 开发框架，提升 UI 开发效率和体验。</li>
<li><strong>内置库功能丰富</strong>：仓颉编程语言提供了功能丰富的内置库，涉及数据结构、常用算法、数学计算、正则匹配、系统交互、文件操作、网络通信、数据库访问、日志打印、解压缩、编解码、加解密和序列化等功能。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安装仓颉工具链"><a class="header" href="#安装仓颉工具链">安装仓颉工具链</a></h1>
<p>在开发仓颉程序时，必用的工具之一是仓颉编译器，它可以将仓颉源代码编译为可运行的二进制文件，但现代编程语言的配套工具并不止于此，实际上，我们为开发者提供了编译器、调试器、包管理器、静态检查工具、格式化工具和覆盖率统计工具等一整套仓颉开发工具链，同时提供了友好的安装和使用方式，基本能做到“开箱即用”。</p>
<p>目前仓颉工具链已适配部分版本的 Linux 和 Windows 平台，但是仅针对部分 Linux 发行版做了完整功能测试，详情可参阅附录<a href="source_zh_cn/first_understanding/../../Appendix/linux_toolchain_install.html">Linux 版本工具链的支持与安装</a>章节，在暂未进行过完整功能测试的平台上，仓颉工具链的功能完整性不受到保证。此外，当前 Windows 平台上的仓颉编译器基于 MinGW 实现，相较于 Linux 版本的仓颉编译器，功能会有部分欠缺，二者的具体差异请见版本 Release Note。</p>
<h2 id="linux"><a class="header" href="#linux">Linux</a></h2>
<h3 id="环境准备"><a class="header" href="#环境准备">环境准备</a></h3>
<p>Linux 版仓颉工具链的系统环境要求如下：</p>
<div class="table-wrapper"><table><thead><tr><th>架构</th><th>环境要求</th></tr></thead><tbody>
<tr><td>x86_64</td><td>glibc 2.22，Linux Kernel 4.12 或更高版本，系统安装 libstdc++ 6.0.24 或更高版本</td></tr>
<tr><td>aarch64</td><td>glibc 2.27，Linux Kernel 4.15 或更高版本，系统安装 libstdc++ 6.0.24 或更高版本</td></tr>
</tbody></table>
</div>
<p>除此之外，对于不同的 Linux 发行版，还需要安装相应的依赖软件包：</p>
<p><strong>Ubuntu 18.04</strong></p>
<pre><code class="language-bash">$ apt-get install binutils libc-dev libc++-dev libgcc-7-dev
</code></pre>
<p><strong>EulerOS R11</strong></p>
<pre><code class="language-bash">$ yum install binutils glibc-devel gcc
</code></pre>
<p>此外，仓颉工具链还依赖 OpenSSL 3 组件，由于该组件可能无法从以上发行版的默认软件源直接安装，因此你需要自行手动安装，安装方式请参考附录<a href="source_zh_cn/first_understanding/../../Appendix/linux_toolchain_install.html">Linux 版本工具链的支持与安装</a>章节。</p>
<p><strong>其他 Linux 发行版</strong></p>
<p>您可以在附录<a href="source_zh_cn/first_understanding/../../Appendix/linux_toolchain_install.html">Linux 版本工具链的支持与安装</a>章节找到更多 Linux 发行版的依赖安装命令。</p>
<h4 id="安装指导"><a class="header" href="#安装指导">安装指导</a></h4>
<p>首先请前往仓颉官方发布渠道，下载适配您平台架构的安装包：</p>
<ul>
<li><code>Cangjie-x.y.z-linux_x64.tar.gz</code>：适用于 x86_64 架构 Linux 系统的仓颉工具链</li>
<li><code>Cangjie-x.y.z-linux_aarch64.tar.gz</code>：适用于 aarch64 架构 Linux 系统的仓颉工具链</li>
</ul>
<p>假设这里选择了 <code>Cangjie-x.y.z-linux_x64.tar.gz</code>，下载到本地后，请执行如下命令解压：</p>
<pre><code class="language-bash">tar xvf Cangjie-x.y.z-linux_x64.tar.gz
</code></pre>
<p>解压完成，您会在当前工作路径下看到一个名为 <code>cangjie</code> 的目录，其中存放了仓颉工具链的全部内容，请执行如下命令完成仓颉工具链的安装配置：</p>
<pre><code class="language-bash">source cangjie/envsetup.sh
</code></pre>
<p>为了验证是否安装成功，可以执行如下命令：</p>
<pre><code class="language-bash">cjc -v
</code></pre>
<p>其中 <code>cjc</code> 是仓颉编译器的可执行文件名，如果您在命令行中看到了仓颉编译器版本信息，那么恭喜您，已经成功安装了仓颉工具链。值得说明的是，<code>envsetup.sh</code> 脚本只是在当前 shell 环境中配置了工具链相关的环境变量，所以仓颉工具链仅在当前 shell 环境中可用，在新的 shell 环境中，您需要重新执行 <code>envsetup.sh</code> 脚本配置环境。</p>
<h3 id="卸载与更新"><a class="header" href="#卸载与更新">卸载与更新</a></h3>
<p>在 Linux 平台，删除上述仓颉工具链的安装包目录，同时移除上述环境变量（最简单的，您可以新开一个 shell 环境），即可完成卸载。</p>
<pre><code class="language-bash">$ rm -rf &lt;path&gt;/&lt;to&gt;/cangjie
</code></pre>
<p>若需要更新仓颉工具链，您需要先卸载当前版本，然后按上述指导重新安装最新版本的仓颉工具链。</p>
<h2 id="windows"><a class="header" href="#windows">Windows</a></h2>
<p>本节以 Windows 10 平台为例，介绍仓颉工具链的安装方式。</p>
<h3 id="安装指导-1"><a class="header" href="#安装指导-1">安装指导</a></h3>
<p>在 Windows 平台上，我们为开发者提供了 <code>exe</code> 和 <code>zip</code> 两种格式的安装包，请前往仓颉官方发布渠道，选择和下载适配您平台架构的 Windows 版安装包。</p>
<p>如果您选择了 <code>exe</code> 格式的安装包（例如 <code>Cangjie-x.y.z-windows_x64.exe</code>），请直接执行此文件，跟随安装向导点击操作，即可完成安装。</p>
<p>如果您选择了 <code>zip</code> 格式的安装包（例如 <code>Cangjie-x.y.z-windows_x64.zip</code>），请将它解压到适当目录，在安装包中，我们为开发者提供了三种不同格式的安装脚本，分别是 <code>envsetup.bat</code>，<code>envsetup.ps1</code> 和 <code>envsetup.sh</code>，您可以根据使用习惯及环境配置，选择一种执行：</p>
<p>若使用 Windows 命令提示符（CMD）环境，请执行：</p>
<pre><code class="language-bash">path\to\cangjie\envsetup.bat
</code></pre>
<p>若使用 PowerShell 环境，请执行：</p>
<pre><code class="language-bash">. path\to\cangjie\envsetup.ps1
</code></pre>
<p>若使用 MSYS shell、bash 等环境，请执行：</p>
<pre><code class="language-bash">source path/to/cangjie/envsetup.sh
</code></pre>
<p>为了验证是否安装成功，请在以上命令环境中继续执行 <code>cjc -v</code> 命令，如果输出了仓颉编译器版本信息，那么恭喜您，已经成功安装了仓颉工具链。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>基于 <code>zip</code> 安装包和执行脚本的安装方式，类似于 Linux 平台，即 <code>envsetup</code> 脚本所配置的环境变量，只在当前命令行环境中有效，如果打开新的命令行窗口，需要重新执行 <code>envsetup</code> 脚本配置环境。</p>
</blockquote>
<h3 id="卸载与更新-1"><a class="header" href="#卸载与更新-1">卸载与更新</a></h3>
<p>运行仓颉安装目录下的 <code>unins000.exe</code> 可执行文件，跟随卸载向导点击操作，即可完成卸载。</p>
<p>若需要更新仓颉工具链，您需要先卸载当前版本，然后按上述指导重新安装最新版本的仓颉工具链。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="运行第一个仓颉程序"><a class="header" href="#运行第一个仓颉程序">运行第一个仓颉程序</a></h1>
<p>万事俱备，让我们编写和运行第一个仓颉程序吧！</p>
<p>首先，请在适当目录下新建一个名为 <code>hello.cj</code> 的文本文件，并向文件中写入以下仓颉代码：</p>
<!-- verify -->
<pre><code class="language-cangjie">// hello.cj
main() {
    println(&quot;你好，仓颉&quot;)
}
</code></pre>
<p>在这段代码中，使用了仓颉的注释语法，您可以在 <code>//</code> 符号之后写单行注释，也可以在一对 <code>/*</code> 和 <code>*/</code> 符号之间写多行注释，这与 C/C++ 等语言的注释语法相同。注释内容不影响程序的编译和运行。</p>
<p>然后，请在此目录下执行如下命令：</p>
<pre><code class="language-bash">cjc hello.cj -o hello
</code></pre>
<p>这里仓颉编译器会将 <code>hello.cj</code> 中的源代码编译为此平台上的可执行文件 <code>hello</code>，在命令行环境中运行此文件，您将看到程序输出了如下内容：</p>
<pre><code class="language-text">你好，仓颉
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p>以上编译命令是针对 Linux 平台的，如果您使用 Windows 平台，只需要将编译命令改为 <code>cjc hello.cj -o hello.exe</code> 即可。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="标识符"><a class="header" href="#标识符">标识符</a></h1>
<p>在仓颉编程语言中，开发者可以给一些程序元素命名，这些名字也被称为“标识符”，标识符分为普通标识符和原始标识符两类，它们分别遵从不同的命名规则。</p>
<p><strong>普通标识符</strong>不能和仓颉关键字相同，可以取自以下两类字符序列：</p>
<ul>
<li>由 XID_Start 字符开头，后接任意长度的 XID_Continue 字符</li>
<li>由一个<code>_</code>开头，后接至少一个 XID_Continue 字符</li>
</ul>
<p>其中，XID_Start、XID_Continue 定义见<a href="https://www.unicode.org/reports/tr31/tr31-37.html">Unicode 标准</a>。仓颉使用 Unicode 标准 15.0.0。</p>
<p>仓颉把所有标识符识别为 <a href="https://www.unicode.org/reports/tr15/tr15-53.html">Normalization Form C (NFC)</a> 后的形式。两个标识符如果在 NFC 后相等，则认为是相同的标识符。</p>
<p>例如，以下每行字符串都是合法的普通标识符：</p>
<pre><code class="language-cangjie">abc
_abc
abc_
a1b2c3
a_b_c
a1_b2_c3
仓颉
__こんにちは
</code></pre>
<p>以下每行字符串都是不合法的普通标识符：</p>
<pre><code class="language-cangjie">ab&amp;c  // 使用了非法字符 “&amp;”
3abc  // 数字不能出现在头部
while // 不能使用仓颉关键字
</code></pre>
<p><strong>原始标识符</strong>是在普通标识符或仓颉关键字的外面加上一对反引号，主要用于将仓颉关键字作为标识符的场景。</p>
<p>例如，以下每行字符串都是合法的原始标识符：</p>
<pre><code class="language-cangjie">`abc`
`_abc`
`a1b2c3`
`if`
`while`
`à֮̅̕b`
</code></pre>
<p>以下每行字符串，由于反引号内的部分是不合法的普通标识符，所以它们整体也是不合法的原始标识符：</p>
<pre><code class="language-cangjie">`ab&amp;c`
`3abc`
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="程序结构"><a class="header" href="#程序结构">程序结构</a></h1>
<p>通常，我们都会在扩展名为 <code>.cj</code> 的文本文件中编写仓颉程序，这些程序和文件也被称为源代码和源文件，在程序开发的最后阶段，这些源代码将被编译为特定格式的二进制文件。</p>
<p>在仓颉程序的顶层作用域中，可以定义一系列的变量、函数和自定义类型（如 <code>struct</code>、<code>class</code>、<code>enum</code> 和 <code>interface</code> 等），其中的变量和函数分别被称为<strong>全局变量</strong>和<strong>全局函数</strong>。如果要将仓颉程序编译为可执行文件，您需要在顶层作用域中定义一个 <code>main</code> 函数作为<strong>程序入口</strong>，它可以有 <code>Array&lt;String&gt;</code> 类型的参数，也可以没有参数，它的返回值类型可以是整数类型或 <code>Unit</code> 类型。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>定义 <code>main</code> 函数时，不需要写 <code>func</code> 修饰符。此外，如果需要获取程序启动时的命令行参数，可以声明和使用 <code>Array&lt;String&gt;</code> 类型参数。</p>
</blockquote>
<p>例如在以下程序中，我们在顶层作用域定义了全局变量 <code>a</code> 和全局函数 <code>b</code>，还有自定义类型 <code>C</code>、<code>D</code> 和 <code>E</code>，以及作为程序入口的 <code>main</code> 函数。</p>
<!-- compile -->
<pre><code class="language-cangjie">// example.cj
let a = 2023
func b() {}
struct C {}
class D {}
enum E { F | G }

main() {
    println(a)
}
</code></pre>
<p>在非顶层作用域中不能定义上述自定义类型，但可以定义变量和函数，称之为<strong>局部变量</strong>和<strong>局部函数</strong>。特别地，对于定义在自定义类型中的变量和函数，称之为<strong>成员变量</strong>和<strong>成员函数</strong>。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p><code>enum</code> 和 <code>interface</code> 中仅支持定义成员函数，不支持定义成员变量。</p>
</blockquote>
<p>例如在以下程序中，我们在顶层作用域定义了全局函数 <code>a</code> 和自定义类型 <code>A</code>，在函数 <code>a</code> 中定义了局部变量 <code>b</code> 和局部函数 <code>c</code>，在自定义类型 <code>A</code> 中定义了成员变量 <code>b</code> 和成员函数 <code>c</code>。</p>
<!-- verify -->
<pre><code class="language-cangjie">// example.cj
func a() {
    let b = 2023
    func c() {
        println(b)
    }
    c()
}

class A {
    let b = 2024
    public func c() {
        println(b)
    }
}

main() {
    a()
    A().c()
}
</code></pre>
<p>运行以上程序，将输出：</p>
<pre><code class="language-text">2023
2024
</code></pre>
<h2 id="变量"><a class="header" href="#变量">变量</a></h2>
<p>在仓颉编程语言中，一个变量由对应的变量名、数据（值）和若干属性构成，开发者通过变量名访问变量对应的数据，但访问操作需要遵从相关属性的约束（如数据类型、可变性和可见性等）。</p>
<p>变量定义的具体形式为：</p>
<pre><code class="language-text">修饰符 变量名: 变量类型 = 初始值
</code></pre>
<p>其中<strong>修饰符</strong>用于设置变量的各类属性，可以有一个或多个，常用的修饰符包括：</p>
<ul>
<li>可变性修饰符：<code>let</code> 与 <code>var</code>，分别对应不可变和可变属性，可变性决定了变量被初始化后其值还能否改变，仓颉变量也由此分为不可变变量和可变变量两类。</li>
<li>可见性修饰符：<code>private</code> 与 <code>public</code> 等，影响全局变量和成员变量的可引用范围，详见后续章节的相关介绍。</li>
<li>静态性修饰符：<code>static</code>，影响成员变量的存储和引用方式，详见后续章节的相关介绍。</li>
</ul>
<p>在定义仓颉变量时，可变性修饰符是必要的，在此基础上，还可以根据需要添加其他修饰符。</p>
<ul>
<li><strong>变量名</strong>应是一个合法的仓颉标识符。</li>
<li><strong>变量类型</strong>指定了变量所持有数据的类型。当初始值具有明确类型时，可以省略变量类型标注，此时编译器可以自动推断出变量类型。</li>
<li><strong>初始值</strong>是一个仓颉表达式，用于初始化变量，如果标注了变量类型，需要保证初始值类型和变量类型一致。在定义全局变量或静态成员变量时，必须指定初始值。在定义局部变量或实例成员变量时，可以省略初始值，但需要标注变量类型，同时要在此变量被引用前完成初始化，否则编译会报错。</li>
</ul>
<p>例如，下列程序定义了两个 <code>Int64</code> 类型的不可变变量 <code>a</code> 和可变变量 <code>b</code>，随后修改了变量 <code>b</code> 的值，并调用 <code>println</code> 函数打印 <code>a</code> 与 <code>b</code> 的值。</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    let a: Int64 = 20
    var b: Int64 = 12
    b = 23
    println(&quot;${a}${b}&quot;)
}
</code></pre>
<p>编译运行此程序，将输出：</p>
<pre><code class="language-text">2023
</code></pre>
<p>如果尝试修改不可变变量，编译时会报错，例如：</p>
<pre><code class="language-cangjie">main() {
    let pi: Float64 = 3.14159
    pi = 2.71828 // Error, cannot assign to immutable value
}
</code></pre>
<p>当初始值具有明确类型时，可以省略变量类型标注，例如：</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    let a: Int64 = 2023
    let b = a
    println(&quot;a - b = ${a - b}&quot;)
}
</code></pre>
<p>其中变量 <code>b</code> 的类型可以由其初值 <code>a</code> 的类型自动推断为 <code>Int64</code>，所以此程序也可以被正常编译和运行，将输出：</p>
<pre><code class="language-text">a - b = 0
</code></pre>
<p>在定义局部变量时，可以不进行初始化，但一定要在变量被引用前赋予初值，例如：</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    let text: String
    text = &quot;仓颉造字&quot;
    println(text)
}
</code></pre>
<p>编译运行此程序，将输出：</p>
<pre><code class="language-text">仓颉造字
</code></pre>
<p>在定义全局变量和静态成员变量时必须初始化，否则编译会报错，例如：</p>
<pre><code class="language-cangjie">// example.cj
let global: Int64 // Error, variable in top-level scope must be initialized
</code></pre>
<pre><code class="language-cangjie">// example.cj
class Player {
    static let score: Int32 // Error, static variable 'score' needs to be initialized when declaring
}
</code></pre>
<h3 id="值类型和引用类型变量"><a class="header" href="#值类型和引用类型变量">值类型和引用类型变量</a></h3>
<p>程序在运行阶段，只有指令流转和数据变换，仓颉程序中的各种标识符已不复存在。由此可见，编译器使用了一些机制，将这些名字和编程所取用的数据实体/存储空间绑定起来。</p>
<p>从编译器实现层面看，任何变量总会关联一个值（一般是通过内存地址/寄存器关联），只是在使用时，对有些变量，我们将直接取用这个值本身，这被称为<strong>值类型变量</strong>，而对另一些变量，我们把这个值作为索引、取用这个索引指示的数据，这被称为<strong>引用类型变量</strong>。值类型变量通常在线程栈上分配，每个变量都有自己的数据副本；引用类型变量通常在进程堆中分配，多个变量可引用同一数据对象，对一个变量执行的操作可能会影响其他变量。</p>
<p>从语言层面看，值类型变量对它所绑定的数据/存储空间是独占的，而引用类型变量所绑定的数据/存储空间可以和其他引用类型变量共享。</p>
<p>基于上述原理，在使用值类型变量和引用类型变量时，会存在一些行为差异，以下几点值得注意：</p>
<ol>
<li>在给值类型变量赋值时，一般会产生拷贝操作，且原来绑定的数据/存储空间被覆写。在给引用类型变量赋值时，只是改变了引用关系，原来绑定的数据/存储空间不会被覆写。</li>
<li>用 <code>let</code> 定义的变量，要求变量被初始化后都不能再赋值。对于引用类型，这只是限定了引用关系不可改变，但是所引用的数据是可以被修改的。</li>
</ol>
<p>在仓颉编程语言中，基础数据类型和 <code>struct</code> 等类型属于值类型，而 <code>class</code> 和 <code>Array</code> 等类型属于引用类型。</p>
<p>例如，以下程序演示了 <code>struct</code> 和 <code>class</code> 类型变量的行为差异：</p>
<!-- verify -->
<pre><code class="language-cangjie">struct Copy {
    var data = 2012
}

class Share {
    var data = 2012
}

main() {
    let c1 = Copy()
    var c2 = c1
    c2.data = 2023
    println(&quot;${c1.data}, ${c2.data}&quot;)

    let s1 = Share()
    let s2 = s1
    s2.data = 2023
    println(&quot;${s1.data}, ${s2.data}&quot;)
}
</code></pre>
<p>运行以上程序，将输出：</p>
<pre><code class="language-text">2012, 2023
2023, 2023
</code></pre>
<p>由此可以看出，对于值类型的 <code>Copy</code> 类型变量，在赋值时总是获取 <code>Copy</code> 实例的拷贝，如 <code>c2 = c1</code>，随后对 <code>c2</code> 成员的修改并不影响 <code>c1</code>。对于引用类型的 <code>Share</code> 类型变量，在赋值时将建立变量和实例之间的引用关系，如 <code>s2 = s1</code>，随后对 <code>s2</code> 成员的修改会影响 <code>s1</code>。</p>
<p>如果将以上程序中的 <code>var c2 = c1</code> 改成 <code>let c2 = c1</code>，则编译会报错，例如：</p>
<pre><code class="language-cangjie">struct Copy {
    var data = 2012
}

main() {
    let c1 = Copy()
    let c2 = c1
    c2.data = 2023 // Error, cannot assign to immutable value
}
</code></pre>
<h2 id="作用域"><a class="header" href="#作用域">作用域</a></h2>
<p>在前文中，我们初步介绍了如何给仓颉程序元素命名，实际上，除了变量，我们还可以给函数和自定义类型等命名，在程序中将使用这些名字访问对应的程序元素。</p>
<p>但在实际应用中，需要考虑一些特殊情况：</p>
<ul>
<li>当程序规模较大时，那些简短的名字很容易重复，即产生命名冲突。</li>
<li>结合运行时考虑，在有些代码片段中，另一些程序元素是无效的，对它们的引用会导致运行时错误。</li>
<li>在某些逻辑构造中，为了表达元素之间的包含关系，不应通过名字直接访问子元素，而是要通过其父元素名间接访问。</li>
</ul>
<p>为了应对这些问题，现代编程语言引入了“作用域”的概念及设计，将名字和程序元素的绑定关系限制在一定范围里。不同作用域之间可以是并列或无关的，也可以是嵌套或包含关系。一个作用域将明确我们能用哪些名字访问哪些程序元素，具体规则是：</p>
<ol>
<li>当前作用域中定义的程序元素与名字的绑定关系，在当前作用域和其内层作用域中是有效的，可以通过此名字直接访问对应的程序元素。</li>
<li>内层作用域中定义的程序元素与名字的绑定关系，在外层作用域中无效。</li>
<li>内层作用域可以使用外层作用域中的名字重新定义绑定关系，根据规则 1，此时内层作用域中的命名相当于遮盖了外层作用域中的同名定义，对此我们称内层作用域的级别比外层作用域的级别高。</li>
</ol>
<p>在仓颉编程语言中，用一对大括号“{}”包围一段仓颉代码，即构造了一个新的作用域，其中可以继续使用大括号“{}”包围仓颉代码，由此产生了嵌套作用域，这些作用域均服从上述规则。特别的，在一个仓颉源文件中，不被任何大括号“{}”包围的代码，它们所属的作用域被称为“顶层作用域”，即当前文件中“最外层”的作用域，按上述规则，其作用域级别最低。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>用大括号“{}”包围代码构造作用域时，其中不限于使用表达式，还可以定义函数和自定义类型等。</p>
</blockquote>
<p>例如在以下名为 <code>test.cj</code> 的仓颉源文件里，在顶层作用域中定义了名字 <code>element</code>，它和字符串“仓颉”绑定，而 <code>main</code> 和 <code>if</code> 引导的代码块中也定义了名字 <code>element</code>，分别对应整数 9 和整数 2023。由上述作用域规则，在第 4 行，<code>element</code> 的值为“仓颉”，在第 8 行，<code>element</code> 的值为 2023，在第 10 行，<code>element</code> 的值为 9。</p>
<!-- verify -->
<pre><code class="language-cangjie">// test.cj
let element = &quot;仓颉&quot;
main() {
    println(element)
    let element = 9
    if (element &gt; 0) {
        let element = 2023
        println(element)
    }
    println(element)
}
</code></pre>
<p>运行以上程序，将输出：</p>
<pre><code class="language-text">仓颉
2023
9
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="表达式"><a class="header" href="#表达式">表达式</a></h1>
<p>在一些传统编程语言中，一个表达式由一个或多个操作数（operand）通过零个或多个操作符（operator）组合而成，表达式总是隐含着一个计算过程，因此每个表达式都会有一个计算结果，对于只有操作数而没有操作符的表达式，其计算结果就是操作数自身，对于包含操作符的表达式，计算结果是对操作数执行操作符定义的计算而得到的值。在这种定义下的表达式也被称为算术运算表达式。</p>
<p>在仓颉编程语言中，我们简化并延伸了表达式的传统定义——凡是可求值的语言元素都是表达式。因此，仓颉不仅有传统的算术运算表达式，还有条件表达式、循环表达式和 <code>try</code> 表达式等，它们都可以被求值，并作为值去使用，如作为变量定义的初值和函数实参等。此外，因为仓颉是强类型的编程语言，所以仓颉表达式不仅可求值，还有确定的类型。</p>
<p>仓颉编程语言的各种表达式将在后续章节中逐一介绍，本节介绍最常用的条件表达式、循环表达式以及部分控制转移表达式（<code>break</code>、<code>continue</code>）。</p>
<p>我们知道，任何一段程序的执行流程，只会涉及三种基本结构——顺序结构、分支结构和循环结构。实际上，分支结构和循环结构，是由某些指令控制当前顺序执行流产生跳转而得到的，它们让程序能够表达更复杂的逻辑，在仓颉中，这种用来控制执行流的语言元素就是条件表达式和循环表达式。</p>
<p>在仓颉编程语言中，条件表达式分为 <code>if</code> 表达式和 <code>if-let</code> 表达式两种，它们的值与类型需要根据使用场景来确定。循环表达式有四种：<code>for-in</code> 表达式、<code>while</code> 表达式、<code>do-while</code> 表达式和 <code>while-let</code> 表达式，它们的类型都是 <code>Unit</code>、值为 <code>()</code>。其中 <code>if-let</code> 表达式和 <code>while-let</code> 表达式都与模式匹配相关，请参见<a href="source_zh_cn/basic_programming_concepts/../enum_and_pattern_match/if_let.html">if-let 表达式</a>和<a href="source_zh_cn/basic_programming_concepts/../enum_and_pattern_match/while_let.html">while-let 表达式</a>章节，本节只介绍以上提及的其他几种表达式。</p>
<p>在仓颉程序中，由一对大括号“{}”包围起来的一组表达式，被称为“代码块”，它将作为程序的一个顺序执行流，其中的表达式将按编码顺序依次执行。如果代码块中有至少一个表达式，我们规定此代码块的值与类型等于其中最后一个表达式的值与类型，如果代码块中没有表达式，规定这种空代码块的类型为 <code>Unit</code>、值为 <code>()</code>。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>代码块本身不是一个表达式，不能被单独使用，它将依附于函数、条件表达式和循环表达式等执行和求值。</p>
</blockquote>
<h2 id="if-表达式"><a class="header" href="#if-表达式">if 表达式</a></h2>
<p><code>if</code> 表达式的基本形式为：</p>
<pre><code class="language-cangjie">if (条件) {
  分支 1
} else {
  分支 2
}
</code></pre>
<p>其中“条件”是布尔类型表达式，“分支 1”和“分支 2”是两个代码块。<code>if</code> 表达式将按如下规则执行：</p>
<ol>
<li>计算“条件”表达式，如果值为 <code>true</code> 则转到第 2 步，值为 <code>false</code> 则转到第 3 步。</li>
<li>执行“分支 1”，转到第 4 步。</li>
<li>执行“分支 2”，转到第 4 步。</li>
<li>继续执行 <code>if</code> 表达式后面的代码。</li>
</ol>
<p>在一些场景中，我们可能只关注条件成立时该做些什么，所以 <code>else</code> 和对应的代码块是允许省略的。</p>
<p>如下程序演示了 <code>if</code> 表达式的基本用法：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.random.*

main() {
    let number: Int8 = Random().nextInt8()
    println(number)
    if (number % 2 == 0) {
        println(&quot;偶数&quot;)
    } else {
        println(&quot;奇数&quot;)
    }
}
</code></pre>
<p>在这段程序中，我们使用仓颉标准库的 <code>random</code> 包生成了一个随机整数，然后使用 <code>if</code> 表达式判断这个整数是否能被 2 整除，并在不同的条件分支中打印“偶数”或“奇数”。</p>
<p>仓颉编程语言是强类型的，<code>if</code> 表达式的条件只能是布尔类型，不能使用整数或浮点数等类型，和 C 语言等不同，仓颉不以条件取值是否为 0 作为分支选择依据，例如以下程序将编译报错：</p>
<pre><code class="language-cangjie">main() {
    let number = 1
    if (number) { // Error, mismatched types
        println(&quot;非零数&quot;)
    }
}
</code></pre>
<p>在许多场景中，当一个条件不成立时，我们可能还要判断另一个或多个条件、再执行对应的动作，仓颉允许在 <code>else</code> 之后跟随新的 <code>if</code> 表达式，由此支持多级条件判断和分支执行，例如：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.random.*

main() {
    let speed = Random().nextFloat64() * 20.0
    println(&quot;${speed} km/s&quot;)
    if (speed &gt; 16.7) {
        println(&quot;第三宇宙速度，鹊桥相会&quot;)
    } else if (speed &gt; 11.2) {
        println(&quot;第二宇宙速度，嫦娥奔月&quot;)
    } else if (speed &gt; 7.9) {
        println(&quot;第一宇宙速度，腾云驾雾&quot;)
    } else {
        println(&quot;脚踏实地，仰望星空&quot;)
    }
}
</code></pre>
<p><code>if</code> 表达式的值与类型，需要根据使用形式与场景来确定：</p>
<ul>
<li>
<p>当含 <code>else</code> 分支的 <code>if</code> 表达式被求值时，需要根据求值上下文确定 <code>if</code> 表达式的类型：</p>
<ul>
<li>如果上下文明确要求值类型为 <code>T</code>，则 <code>if</code> 表达式各分支代码块的类型必须是 <code>T</code> 的子类型，这时 <code>if</code> 表达式的类型被确定为 <code>T</code>，如果不满足子类型约束，编译会报错。</li>
<li>如果上下文没有明确的类型要求，则 <code>if</code> 表达式的类型是其各分支代码块类型的最小公共父类型，如果最小公共父类型不存在，编译会报错。</li>
</ul>
<p>如果编译通过，则 <code>if</code> 表达式的值就是所执行分支代码块的值。</p>
</li>
<li>
<p>如果含 <code>else</code> 分支的 <code>if</code> 表达式没有被求值，在这种场景里，开发者一般只想在不同分支里做不同操作，不会关注各分支最后一个表达式的值与类型，为了不让上述类型检查规则影响这一思维习惯，仓颉规定这种场景下的 <code>if</code> 表达式类型为 <code>Unit</code>、值为 <code>()</code>，且各分支不参与上述类型检查。</p>
</li>
<li>
<p>对于不含 <code>else</code> 分支的 <code>if</code> 表达式，由于 <code>if</code> 分支也可能不被执行，所以我们规定这类 <code>if</code> 表达式的类型为 <code>Unit</code>、值为 <code>()</code>。</p>
</li>
</ul>
<p>例如，以下程序基于 <code>if</code> 表达式求值，模拟一次简单的模数转换过程：</p>
<!-- run -->
<pre><code class="language-cangjie">main() {
    let zero: Int8 = 0
    let one: Int8 = 1
    let voltage = 5.0
    let bit = if (voltage &lt; 2.5) {
        zero
    } else {
        one
    }
}
</code></pre>
<p>在以上程序中，<code>if</code> 表达式作为变量定义的初值使用，由于变量 <code>bit</code> 没有被标注类型、需要从初值中推导，所以 <code>if</code> 表达式的类型取为两个分支代码块类型的最小公共父类型，根据前文对“代码块”的介绍，可知两个分支代码块类型都是 <code>Int8</code>，所以 <code>if</code> 表达式的类型被确定为 <code>Int8</code>，其值为所执行分支即 <code>else</code> 分支代码块的值，所以变量 <code>bit</code> 的类型为 <code>Int8</code>、值为 1。</p>
<h2 id="while-表达式"><a class="header" href="#while-表达式">while 表达式</a></h2>
<p><code>while</code> 表达式的基本形式为：</p>
<pre><code class="language-cangjie">while (条件) {
  循环体
}
</code></pre>
<p>其中“条件”是布尔类型表达式，“循环体”是一个代码块。<code>while</code> 表达式将按如下规则执行：</p>
<ol>
<li>计算“条件”表达式，如果值为 <code>true</code> 则转第 2 步，值为 <code>false</code> 转第 3 步。</li>
<li>执行“循环体”，转第 1 步。</li>
<li>结束循环，继续执行 <code>while</code> 表达式后面的代码。</li>
</ol>
<p>例如，以下程序使用 <code>while</code> 表达式，基于二分法，近似计算数字 2 的平方根：</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    var root = 0.0
    var min = 1.0
    var max = 2.0
    var error = 1.0
    let tolerance = 0.1 ** 10

    while (error ** 2 &gt; tolerance) {
        root = (min + max) / 2.0
        error = root ** 2 - 2.0
        if (error &gt; 0.0) {
            max = root
        } else {
            min = root
        }
    }
    println(&quot;2 的平方根约等于：${root}&quot;)
}
</code></pre>
<p>运行以上程序，将输出：</p>
<pre><code class="language-text">2 的平方根约等于：1.414215
</code></pre>
<h2 id="do-while-表达式"><a class="header" href="#do-while-表达式">do-while 表达式</a></h2>
<p><code>do-while</code> 表达式的基本形式为：</p>
<pre><code>do {
  循环体
} while (条件)
</code></pre>
<p>其中“条件”是布尔类型表达式，“循环体”是一个代码块。<code>do-while</code> 表达式将按如下规则执行：</p>
<ol>
<li>执行“循环体”，转第 2 步。</li>
<li>计算“条件”表达式，如果值为 <code>true</code> 则转第 1 步，值为 <code>false</code> 转第 3 步。</li>
<li>结束循环，继续执行 <code>do-while</code> 表达式后面的代码。</li>
</ol>
<p>例如，以下程序使用 <code>do-while</code> 表达式，基于蒙特卡洛算法，近似计算圆周率的值：</p>
<!-- verify -->
<pre><code class="language-cangjie">import std.random.*

main() {
    let random = Random()
    var totalPoints = 0
    var hitPoints = 0

    do {
        // 在 ((0, 0), (1, 1)) 这个正方形中随机取点
        let x = random.nextFloat64()
        let y = random.nextFloat64()
        // 判断是否落在正方形内接圆里
        if ((x - 0.5) ** 2 + (y - 0.5) ** 2 &lt; 0.25) {
            hitPoints++
        }
        totalPoints++
    } while (totalPoints &lt; 1000000)

    let pi = 4.0 * Float64(hitPoints) / Float64(totalPoints)
    println(&quot;圆周率近似值为：${pi}&quot;)
}
</code></pre>
<p>运行以上程序，将输出：</p>
<pre><code class="language-text">圆周率近似值为：3.141872
</code></pre>
<blockquote>
<p><strong>说明：</strong></p>
<p>由于算法涉及随机数，所以每次运行程序输出的数值可能都不同，但都会约等于 3.14。</p>
</blockquote>
<h2 id="for-in-表达式"><a class="header" href="#for-in-表达式">for-in 表达式</a></h2>
<p><code>for-in</code> 表达式可以遍历那些扩展了迭代器接口 <code>Iterable&lt;T&gt;</code> 的类型实例。<code>for-in</code> 表达式的基本形式为：</p>
<pre><code class="language-cangjie">for (迭代变量 in 序列) {
  循环体
}
</code></pre>
<p>其中“循环体”是一个代码块。“迭代变量”是单个标识符或由多个标识符构成的元组，用于绑定每轮遍历中由迭代器指向的数据，可以作为“循环体”中的局部变量使用。“序列”是一个表达式，它只会被计算一次，遍历是针对此表达式的值进行的，其类型必须扩展了迭代器接口 <code>Iterable&lt;T&gt;</code>。<code>for-in</code> 表达式将按如下规则执行：</p>
<ol>
<li>计算“序列”表达式，将其值作为遍历对象，并初始化遍历对象的迭代器。</li>
<li>更新迭代器，如果迭代器终止，转第 4 步，否则转第 3 步。</li>
<li>将当前迭代器指向的数据与“迭代变量”绑定，并执行“循环体”，转第 2 步。</li>
<li>结束循环，继续执行 <code>for-in</code> 表达式后面的代码。</li>
</ol>
<blockquote>
<p><strong>说明：</strong></p>
<p>仓颉内置的区间和数组等类型已经扩展了 <code>Iterable&lt;T&gt;</code> 接口。</p>
</blockquote>
<p>例如，以下程序使用 <code>for-in</code> 表达式，遍历中国地支字符构成的数组 <code>noumenonArray</code>，输出农历 2024 年各月的干支纪法：</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    let metaArray = [r'甲', r'乙', r'丙', r'丁', r'戊',
        r'己', r'庚', r'辛', r'壬', r'癸']
    let noumenonArray = [r'寅', r'卯', r'辰', r'巳', r'午', r'未',
        r'申', r'酉', r'戌', r'亥', r'子', r'丑']
    let year = 2024
    // 年份对应的天干索引
    let metaOfYear = ((year % 10) + 10 - 4) % 10
    // 此年首月对应的天干索引
    var index = (2 * metaOfYear + 3) % 10 - 1
    println(&quot;农历 2024 年各月干支：&quot;)
    for (noumenon in noumenonArray) {
        print(&quot;${metaArray[index]}${noumenon} &quot;)
        index = (index + 1) % 10
    }
}
</code></pre>
<p>运行以上程序，将输出：</p>
<pre><code class="language-text">农历 2024 年各月干支：
丙寅 丁卯 戊辰 己巳 庚午 辛未 壬申 癸酉 甲戌 乙亥 丙子 丁丑
</code></pre>
<h3 id="遍历区间"><a class="header" href="#遍历区间">遍历区间</a></h3>
<p><code>for-in</code> 表达式可以遍历区间类型实例，例如：</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    var sum = 0
    for (i in 1..=100) {
        sum += i
    }
    println(sum)
}
</code></pre>
<p>运行以上程序，将输出：</p>
<pre><code class="language-text">5050
</code></pre>
<p>关于区间类型的详细内容，请参阅基本数据类型<a href="source_zh_cn/basic_programming_concepts/../basic_data_type/range.html">区间类型</a>章节。</p>
<h3 id="遍历元组构成的序列"><a class="header" href="#遍历元组构成的序列">遍历元组构成的序列</a></h3>
<p>如果一个序列的元素是元组类型，则使用 <code>for-in</code> 表达式遍历时，“迭代变量”可以写成元组形式，以此实现对序列元素的解构，例如：</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    let array = [(1, 2), (3, 4), (5, 6)]
    for ((x, y) in array) {
        println(&quot;${x}, ${y}&quot;)
    }
}
</code></pre>
<p>运行以上程序，将输出：</p>
<pre><code class="language-text">1, 2
3, 4
5, 6
</code></pre>
<h3 id="迭代变量不可修改"><a class="header" href="#迭代变量不可修改">迭代变量不可修改</a></h3>
<p>在 <code>for-in</code> 表达式的循环体中，不能修改迭代变量，例如以下程序在编译时会报错：</p>
<pre><code class="language-cangjie">main() {
    for (i in 0..5) {
        i = i * 10 // Error, cannot assign to value which is an initialized 'let' constant
        println(i)
    }
}
</code></pre>
<h3 id="使用通配符-_-代替迭代变量"><a class="header" href="#使用通配符-_-代替迭代变量">使用通配符 _ 代替迭代变量</a></h3>
<p>在一些应用场景中，我们只需要循环执行某些操作，但并不使用迭代变量，这时您可以使用通配符 <code>_</code> 代替迭代变量，例如：</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    var number = 2
    for (_ in 0..5) {
        number *= number
    }
    println(number)
}
</code></pre>
<p>运行以上程序，将输出：</p>
<pre><code class="language-text">4294967296
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p>在这种场景下，如果您使用普通的标识符定义迭代变量，编译会输出“unused variable”告警，使用通配符 <code>_</code> 则可以避免这一告警。</p>
</blockquote>
<h3 id="where-条件"><a class="header" href="#where-条件">where 条件</a></h3>
<p>在部分循环遍历场景中，对于特定取值的迭代变量，我们可能需要直接跳过、进入下一轮循环，虽然可以使用 <code>if</code> 表达式和 <code>continue</code> 表达式在循环体中实现这一逻辑，但仓颉为此提供了更便捷的表达方式——可以在所遍历的“序列”之后用 <code>where</code> 关键字引导一个布尔表达式，这样在每次将进入循环体执行前，会先计算此表达式，如果值为 <code>true</code> 则执行循环体，反之直接进入下一轮循环。例如：</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    for (i in 0..8 where i % 2 == 1) { // i 为奇数才会执行循环体
        println(i)
    }
}
</code></pre>
<p>运行以上程序，将输出：</p>
<pre><code class="language-text">1
3
5
7
</code></pre>
<h2 id="break-与-continue-表达式"><a class="header" href="#break-与-continue-表达式">break 与 continue 表达式</a></h2>
<p>在循环结构的程序中，有时我们需要根据特定条件提前结束循环或跳过本轮循环，为此仓颉引入了 <code>break</code> 与 <code>continue</code> 表达式，它们可以出现在循环表达式的循环体中，<code>break</code> 用于终止当前循环表达式的执行、转去执行循环表达式之后的代码，<code>continue</code> 用于提前结束本轮循环、进入下一轮循环。<code>break</code> 与 <code>continue</code> 表达式的类型都是 <code>Nothing</code>。</p>
<p>例如，以下程序使用 <code>for-in</code> 表达式和 <code>break</code> 表达式，在给定的整数数组中，找到第一个能被 5 整除的数字：</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    let numbers = [12, 18, 25, 36, 49, 55]
    for (number in numbers) {
        if (number % 5 == 0) {
            println(number)
            break
        }
    }
}
</code></pre>
<p>当 <code>for-in</code> 迭代至 <code>numbers</code> 数组的第三个数 25 时，由于 25 可以被 5 整除，所以将执行 <code>if</code> 分支中的 <code>println</code> 和 <code>break</code>，<code>break</code> 将终止 <code>for-in</code> 循环，<code>numbers</code>中的后续数字不会被遍历到，因此运行以上程序，将输出：</p>
<pre><code class="language-text">25
</code></pre>
<p>以下程序使用 <code>for-in</code> 表达式和 <code>continue</code> 表达式，将给定整数数组中的奇数打印出来：</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    let numbers = [12, 18, 25, 36, 49, 55]
    for (number in numbers) {
        if (number % 2 == 0) {
            continue
        }
        println(number)
    }
}
</code></pre>
<p>在循环迭代中，当 <code>number</code> 是偶数时，<code>continue</code> 将被执行，这会提前结束本轮循环、进入下一轮循环，<code>println</code> 不会被执行，因此运行以上程序，将输出：</p>
<pre><code class="language-text">25
49
55
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数"><a class="header" href="#函数">函数</a></h1>
<p>仓颉使用关键字 <code>func</code> 来表示函数定义的开始，<code>func</code> 之后依次是函数名、参数列表、可选的函数返回值类型、函数体。其中，函数名可以是任意的合法标识符，参数列表定义在一对圆括号内（多个参数间使用逗号分隔），参数列表和函数返回值类型（如果存在）之间使用冒号分隔，函数体定义在一对花括号内。</p>
<p>函数定义举例：</p>
<pre><code class="language-cangjie">func add(a: Int64, b: Int64): Int64 {
    return a + b
}
</code></pre>
<p>上例中定义了一个名为 <code>add</code> 的函数，其参数列表由两个 <code>Int64</code> 类型的参数 <code>a</code> 和 <code>b</code> 组成，函数返回值类型为 <code>Int64</code>，函数体中将 <code>a</code> 和 <code>b</code> 相加并返回。</p>
<p>详细介绍可参考<a href="source_zh_cn/basic_programming_concepts/../function/define_functions.html">函数</a>模块介绍。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="整数类型"><a class="header" href="#整数类型">整数类型</a></h1>
<p>整数类型分为有符号（signed）整数类型和无符号（unsigned）整数类型。</p>
<p><strong>有符号整数类型</strong>包括 <code>Int8</code>、<code>Int16</code>、<code>Int32</code>、<code>Int64</code> 和 <code>IntNative</code>，分别用于表示编码长度为 <code>8-bit</code>、<code>16-bit</code>、<code>32-bit</code>、<code>64-bit</code> 和平台相关大小的有符号整数值的类型。</p>
<p><strong>无符号整数类型</strong>包括 <code>UInt8</code>、<code>UInt16</code>、<code>UInt32</code>、<code>UInt64</code> 和 <code>UIntNative</code>，分别用于表示编码长度为 <code>8-bit</code>、<code>16-bit</code>、<code>32-bit</code>、<code>64-bit</code> 和平台相关大小的无符号整数值的类型。</p>
<p>对于编码长度为 <code>N</code> 的有符号整数类型，其表示范围为：$-2^{N-1} \sim 2^{N-1}-1$；对于编码长度为 <code>N</code> 的无符号整数类型，其表示范围为：$0 \sim 2^{N}-1$。下表列出了所有整数类型的表示范围：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">类型</th><th style="text-align: left">表示范围</th></tr></thead><tbody>
<tr><td style="text-align: left">Int8</td><td style="text-align: left">$-2^7 \sim 2^7-1 (-128 \sim 127)$</td></tr>
<tr><td style="text-align: left">Int16</td><td style="text-align: left">$-2^{15} \sim 2^{15}-1 (-32,768 \sim 32,767)$</td></tr>
<tr><td style="text-align: left">Int32</td><td style="text-align: left">$-2^{31} \sim 2^{31}-1 (-2,147,483,648 \sim 2,147,483,647)$</td></tr>
<tr><td style="text-align: left">Int64</td><td style="text-align: left">$-2^{63} \sim 2^{63}-1 (-9,223,372,036,854,775,808 \sim 9,223,372,036,854,775,807)$</td></tr>
<tr><td style="text-align: left">IntNative</td><td style="text-align: left">platform dependent</td></tr>
<tr><td style="text-align: left">UInt8</td><td style="text-align: left">$0 \sim 2^8-1 (0 \sim 255)$</td></tr>
<tr><td style="text-align: left">UInt16</td><td style="text-align: left">$0 \sim 2^{16}-1 (0 \sim 65,535)$</td></tr>
<tr><td style="text-align: left">UInt32</td><td style="text-align: left">$0 \sim 2^{32}-1 (0 \sim 4,294,967,295)$</td></tr>
<tr><td style="text-align: left">UInt64</td><td style="text-align: left">$0 \sim 2^{64}-1 (0 \sim 18,446,744,073,709,551,615)$</td></tr>
<tr><td style="text-align: left">UIntNative</td><td style="text-align: left">platform dependent</td></tr>
</tbody></table>
</div>
<p>程序具体使用哪种整数类型，取决于该程序中需要处理的整数的性质和范围。在 <code>Int64</code> 类型适合的情况下，首选 <code>Int64</code> 类型，因为 <code>Int64</code> 的表示范围足够大，并且<a href="source_zh_cn/basic_data_type/./integer.html#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%AD%97%E9%9D%A2%E9%87%8F">整数类型字面量</a>在没有类型上下文的情况下默认推断为 <code>Int64</code> 类型，可以避免不必要的类型转换。</p>
<h2 id="整数类型字面量"><a class="header" href="#整数类型字面量">整数类型字面量</a></h2>
<p>整数类型字面量有 4 种进制表示形式：二进制（使用 <code>0b</code> 或 <code>0B</code> 前缀）、八进制（使用 <code>0o</code> 或 <code>0O</code> 前缀）、十进制（没有前缀）、十六进制（使用 <code>0x</code> 或 <code>0X</code> 前缀）。例如，对于十进制数 <code>24</code>，表示成二进制是 <code>0b00011000</code>（或 <code>0B00011000</code>），表示成八进制是 <code>0o30</code>（或 <code>0O30</code>），表示成十六进制是 <code>0x18</code>（或 <code>0X18</code>）。</p>
<p>在各进制表示中，可以使用下划线 <code>_</code> 充当分隔符的作用，方便识别数值的位数，如 <code>0b0001_1000</code>。</p>
<p>对于整数类型字面量，如果它的值超出了上下文要求的整数类型的表示范围，编译器将会报错。</p>
<pre><code class="language-cangjie">let x: Int8 = 128          // Error, 128 out of the range of Int8
let y: UInt8 = 256         // Error, 256 out of the range of UInt8
let z: Int32 = 0x8000_0000 // Error, 0x8000_0000 out of the range of Int32
</code></pre>
<p>在使用整数类型字面量时，可以通过加入后缀来明确整数字面量的类型，后缀与类型的对应为：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">后缀</th><th style="text-align: left">类型</th><th style="text-align: left">后缀</th><th style="text-align: left">类型</th></tr></thead><tbody>
<tr><td style="text-align: left">i8</td><td style="text-align: left">Int8</td><td style="text-align: left">u8</td><td style="text-align: left">UInt8</td></tr>
<tr><td style="text-align: left">i16</td><td style="text-align: left">Int16</td><td style="text-align: left">u16</td><td style="text-align: left">UInt16</td></tr>
<tr><td style="text-align: left">i32</td><td style="text-align: left">Int32</td><td style="text-align: left">u32</td><td style="text-align: left">UInt32</td></tr>
<tr><td style="text-align: left">i64</td><td style="text-align: left">Int64</td><td style="text-align: left">u64</td><td style="text-align: left">UInt64</td></tr>
</tbody></table>
</div>
<p>加入了后缀的整数字面量可以像下面的方式来使用：</p>
<!-- compile -->
<pre><code class="language-cangjie">var x = 100i8  // x is 100 with type Int8
var y = 0x10u64 // y is 16 with type UInt64
var z = 0o432i32  // z is 282 with type Int32
</code></pre>
<h2 id="字符字节字面量"><a class="header" href="#字符字节字面量">字符字节字面量</a></h2>
<p>仓颉编程语言支持字符字节字面量，以方便使用 ASCII 码表示 <code>UInt8</code> 类型的值。字符字节字面量由字符 b、一对标识首尾的单引号、以及一个 <code>ASCII</code> 字符组成，例如：</p>
<pre><code class="language-cangjie">var a = b'x' // a is 120 with type UInt8
var b = b'\n' // b is 10 with type UInt8
var c = b'\u{78}' // c is 120 with type UInt8
</code></pre>
<p><code>b'x'</code> 表示类型为 UInt8 大小是 120 的字面值。另外还可以通过 <code>b'\u{78}'</code> 这种转义形式表示类型为 <code>UInt8</code>，16 进制大小为 0x78 或 10 进制大小为 120 的字面值。需要注意的是，<code>\u</code> 内部最多有两位 16 进制数，并且值必须小于 256（十进制）。</p>
<h2 id="整数类型支持的操作"><a class="header" href="#整数类型支持的操作">整数类型支持的操作</a></h2>
<p>整数类型默认支持的操作符包括：算术操作符、位操作符、关系操作符、自增和自减操作符、赋值操作符、复合赋值操作符。各操作符的优先级参见附录中的<a href="source_zh_cn/basic_data_type/../Appendix/operator.html">操作符</a>。</p>
<ol>
<li>
<p>算术操作符包括：一元负号（<code>-</code>）、加法（<code>+</code>）、减法（<code>-</code>）、乘法（<code>*</code>）、除法（<code>/</code>）、取模（<code>%</code>）、幂运算（<code>**</code>）。</p>
<ul>
<li>
<p>除了一元负号（<code>-</code>）和幂运算（<code>**</code>），其他操作符要求左右操作数是相同的类型。</p>
</li>
<li>
<p><code>*</code>，<code>/</code>，<code>+</code> 和 <code>-</code> 的操作数可以是整数类型或浮点类型。</p>
</li>
<li>
<p><code>%</code> 的操作数只支持整数类型。</p>
</li>
<li>
<p><code>**</code> 的左操作数只能为 <code>Int64</code> 类型或 <code>Float64</code> 类型，并且：</p>
<ul>
<li>当左操作数类型为 <code>Int64</code> 时，右操作数只能为 <code>UInt64</code> 类型，表达式的类型为 <code>Int64</code>。</li>
<li>当左操作数类型为 <code>Float64</code> 时，右操作数只能为 <code>Int64</code> 类型或 <code>Float64</code> 类型，表达式的类型为 <code>Float64</code>。</li>
</ul>
</li>
</ul>
<p>幂运算的使用，见如下示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">let p1 = 2 ** 3               // p1 = 8
let p2 = 2 ** UInt64(3 ** 2)  // p2 = 512
let p3 = 2.0 ** 3.0           // p3 = 8.0
let p4 = 2.0 ** 3 ** 2        // p4 = 512.0
let p5 = 2.0 ** 3.0           // p5 = 8.0
let p6 = 2.0 ** 3.0 ** 2.0    // p6 = 512.0
</code></pre>
</li>
<li>
<p>位操作符包括：按位求反（<code>!</code>）、左移（<code>&lt;&lt;</code>）、右移（<code>&gt;&gt;</code>）、按位与（<code>&amp;</code>）、按位异或（<code>^</code>）、按位或（<code>|</code>）。注意，按位与、按位异或和按位或操作符要求左右操作数是相同的整数类型。</p>
</li>
<li>
<p>关系操作符包括：小于（<code>&lt;</code>）、大于（<code>&gt;</code>）、小于等于（<code>&lt;=</code>）、大于等于（<code>&gt;=</code>）、相等（<code>==</code>）、不等（<code>!=</code>）。要求关系操作符的左右操作数是相同的整数类型。</p>
</li>
<li>
<p>自增和自减操作符包括：自增（<code>++</code>）和自减（<code>--</code>）。注意，仓颉中的自增和自减操作符只能作为一元后缀操作符使用。</p>
</li>
<li>
<p>赋值操作符即 <code>=</code>，复合赋值操作符包括：<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>、<code>**=</code>、<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>、<code>&amp;=</code>、<code>^=</code>、<code>|=</code>。</p>
</li>
</ol>
<blockquote>
<p><strong>注意：</strong></p>
<p>本章中我们所提及的某个类型支持的操作，均是指在没有<a href="source_zh_cn/basic_data_type/../function/operator_overloading.html">操作符重载</a>的前提下。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="浮点类型"><a class="header" href="#浮点类型">浮点类型</a></h1>
<p>浮点类型包括 <code>Float16</code>、 <code>Float32</code> 和 <code>Float64</code>，分别用于表示编码长度为 <code>16-bit</code>、 <code>32-bit</code> 和 <code>64-bit</code> 的浮点数（带小数部分的数字，如 3.14159、8.24 和 0.1 等）的类型。<code>Float16</code>、 <code>Float32</code> 和 <code>Float64</code> 分别对应 IEEE 754 中的半精度格式（即 binary16）、单精度格式（即 binary32）和双精度格式（即 binary64）。</p>
<p><code>Float64</code> 的精度约为小数点后 15 位，<code>Float32</code> 的精度约为小数点后 6 位，<code>Float16</code> 的精度约为小数点后 3 位。使用哪种浮点类型，取决于代码中需要处理的浮点数的性质和范围。在多种浮点类型都适合的情况下，首选精度高的浮点类型，因为精度低的浮点类型的累计计算误差很容易扩散，并且它能精确表示的整数范围也很有限。</p>
<h2 id="浮点类型字面量"><a class="header" href="#浮点类型字面量">浮点类型字面量</a></h2>
<p>浮点类型字面量有两种进制表示形式：十进制、十六进制。在十进制表示中，一个浮点字面量至少要包含一个整数部分或一个小数部分，没有小数部分时必须包含指数部分（以 <code>e</code> 或 <code>E</code> 为前缀，底数为 10）。在十六进制表示中，一个浮点字面量除了至少要包含一个整数部分或小数部分（以 <code>0x</code> 或 <code>0X</code> 为前缀），同时必须包含指数部分（以 <code>p</code> 或 <code>P</code> 为前缀，底数为 2）。</p>
<p>下面的例子展示了浮点字面量的使用：</p>
<!-- compile -->
<pre><code class="language-cangjie">let a: Float32 = 3.14
let b: Float32 = 2e3
let c: Float32 = 2.4e-1
let d: Float64 = .123e2
let e: Float64 = 0x1.1p0
let f: Float64 = 0x1p2
let g: Float64 = 0x.2p4
</code></pre>
<p>在使用十进制浮点数字面量时，可以通过加入后缀来明确浮点数字面量的类型，后缀与类型的对应为：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">后缀</th><th style="text-align: left">类型</th></tr></thead><tbody>
<tr><td style="text-align: left">f16</td><td style="text-align: left">Float16</td></tr>
<tr><td style="text-align: left">f32</td><td style="text-align: left">Float32</td></tr>
<tr><td style="text-align: left">f64</td><td style="text-align: left">Float64</td></tr>
</tbody></table>
</div>
<p>加入了后缀的浮点数字面量可以像下面的方式来使用：</p>
<!-- compile -->
<pre><code class="language-cangjie">let a = 3.14f32   // a is 3.14 with type Float32
let b = 2e3f32    // b is 2e3 with type Float32
let c = 2.4e-1f64 // c is 2.4e-1 with type Float64
let d = .123e2f64 // d is .123e2 with type Float64
</code></pre>
<h2 id="浮点类型支持的操作"><a class="header" href="#浮点类型支持的操作">浮点类型支持的操作</a></h2>
<p>浮点类型默认支持的操作符包括：算术操作符、关系操作符、赋值操作符、复合赋值操作符。浮点类型不支持自增和自减操作符。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="布尔类型"><a class="header" href="#布尔类型">布尔类型</a></h1>
<p>布尔类型使用 <code>Bool</code> 表示，用来表示逻辑中的真和假。</p>
<h2 id="布尔类型字面量"><a class="header" href="#布尔类型字面量">布尔类型字面量</a></h2>
<p>布尔类型只有两个字面量：<code>true</code> 和 <code>false</code>。</p>
<p>下面的例子展示了布尔字面量的使用：</p>
<!-- compile -->
<pre><code class="language-cangjie">let a: Bool = true
let b: Bool = false
</code></pre>
<h2 id="布尔类型支持的操作"><a class="header" href="#布尔类型支持的操作">布尔类型支持的操作</a></h2>
<p>布尔类型支持的操作符包括：逻辑操作符（逻辑非 <code>!</code>，逻辑与 <code>&amp;&amp;</code>，逻辑或 <code>||</code>）、部分关系操作符（<code>==</code> 和 <code>!=</code>）、赋值操作符、部分复合赋值操作符（<code>&amp;&amp;=</code> 和 <code>||=</code>）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符类型"><a class="header" href="#字符类型">字符类型</a></h1>
<p>字符类型使用 <code>Rune</code> 表示，可以表示 Unicode 字符集中的所有字符。</p>
<h2 id="字符类型字面量"><a class="header" href="#字符类型字面量">字符类型字面量</a></h2>
<p>字符类型字面量有三种形式：单个字符、转义字符和通用字符。一个 <code>Rune</code> 字面量由字符 <code>r</code> 开头，后跟一个由一对单引号或双引号包含的字符。</p>
<p>单个字符的字符字面量举例：</p>
<!-- compile -->
<pre><code class="language-cangjie">let a: Rune = r'a'
let b: Rune = r&quot;b&quot;
</code></pre>
<p>转义字符是指在一个字符序列中对后面的字符进行另一种解释的字符。转义字符使用转义符号 <code>\</code> 开头，后面加需要转义的字符。举例如下：</p>
<!-- compile -->
<pre><code class="language-cangjie">let slash: Rune = r'\\'
let newLine: Rune = r'\n'
let tab: Rune = r'\t'
</code></pre>
<p>通用字符以 <code>\u</code> 开头，后面加上定义在一对花括号中的 1~8 个十六进制数，即可表示对应的 Unicode 值代表的字符。举例如下：</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    let he: Rune = r'\u{4f60}'
    let llo: Rune = r'\u{597d}'
    print(he)
    print(llo)
}
</code></pre>
<p>编译并执行上述代码，输出结果为：</p>
<pre><code class="language-text">你好
</code></pre>
<h2 id="字符类型支持的操作"><a class="header" href="#字符类型支持的操作">字符类型支持的操作</a></h2>
<p>字符类型仅支持关系操作符：小于（<code>&lt;</code>）、大于（<code>&gt;</code>）、小于等于（<code>&lt;=</code>）、大于等于（<code>&gt;=</code>）、相等（<code>==</code>）、不等（<code>!=</code>）。比较的是字符的 Unicode 值。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符串类型"><a class="header" href="#字符串类型">字符串类型</a></h1>
<p>字符串类型使用 <code>String</code> 表示，用于表达文本数据，由一串 Unicode 字符组合而成。</p>
<h2 id="字符串字面量"><a class="header" href="#字符串字面量">字符串字面量</a></h2>
<p>字符串字面量分为三类：单行字符串字面量，多行字符串字面量，多行原始字符串字面量。</p>
<p><strong>单行字符串字面量</strong>的内容定义在一对单引号或一对双引号之内，引号中的内容可以是任意数量的（除了非转义的双引号和单独出现的 <code>\</code> 之外的）任意字符。单行字符串字面量只能写在同一行，不能跨越多行。举例如下：</p>
<!-- compile -->
<pre><code class="language-cangjie">let s1: String = &quot;&quot;
let s2 = 'Hello Cangjie Lang'
let s3 = &quot;\&quot;Hello Cangjie Lang\&quot;&quot;
let s4 = 'Hello Cangjie Lang\n'
</code></pre>
<p><strong>多行字符串字面量</strong>开头结尾需各存在三个双引号（<code>&quot;&quot;&quot;</code>）或三个单引号（<code>'''</code>）。字面量的内容从开头的三个引号换行后的第一行开始，到结尾的三个引号之前为止，之间的内容可以是任意数量的（除单独出现的 <code>\</code> 之外的）任意字符。不同于单行字符串字面量，多行字符串字面量可以跨越多行。举例如下：</p>
<!-- compile -->
<pre><code class="language-cangjie">let s1: String = &quot;&quot;&quot;
    &quot;&quot;&quot;
let s2 = '''
    Hello,
    Cangjie Lang'''
</code></pre>
<p><strong>多行原始字符串字面量</strong>以一个或多个井号（<code>#</code>）和一个单引号（<code>'</code>）或双引号（<code>&quot;</code>）开头，后跟任意数量的合法字符，直到出现与字符串开头相同的引号和与字符串开头相同数量的井号为止。在当前文件结束之前，如果还没遇到匹配的双引号和相同个数的井号，则编译报错。与多行字符串字面量一样，原始多行字符串字面量可以跨越多行。不同之处在于，转义规则不适用于多行原始字符串字面量，字面量中的内容会维持原样（转义字符不会被转义，如下例中 <code>s2</code> 中的 <code>\n</code> 不是换行符，而是由 <code>\</code> 和 <code>n</code> 组成的字符串 <code>\n</code>）。举例如下：</p>
<!-- compile -->
<pre><code class="language-cangjie">let s1: String = #&quot;&quot;#
let s2 = ##'\n'##
let s3 = ###&quot;
    Hello,
    Cangjie
    Lang&quot;###
</code></pre>
<p>对于形如 <code>left = right</code> 的赋值操作，如果左操作数的类型是 <code>Byte</code>（内置类型 <code>UInt8</code> 的别名），并且右操作数是一个表示 ASCII 字符的字符串字面量，那么右操作数的字符串将分别被强制转换为 <code>Byte</code> 类型，再进行赋值；如果左操作数的类型是 <code>Rune</code>，并且右操作数是一个单字符的字符串字面量，那么右操作数的字符串将分别被强制转换为 <code>Rune</code> 类型，再进行赋值。</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    var b: Byte = &quot;0&quot;
    print(b)
    b = &quot;1&quot;
    print(b)
    var r: Rune = &quot;0&quot;
    print(r)
    r = &quot;1&quot;
    print(r)
}
</code></pre>
<p>编译并执行上述代码，输出结果为：</p>
<pre><code class="language-text">484901
</code></pre>
<h2 id="插值字符串"><a class="header" href="#插值字符串">插值字符串</a></h2>
<p>插值字符串是一种包含一个或多个插值表达式的字符串字面量（不适用于多行原始字符串字面量），通过将表达式插入到字符串中，可以有效避免字符串拼接的问题。虽然我们直到现在才介绍它，但其实它早已经出现在之前的示例代码中，因为我们经常在 <code>println</code> 函数中输出非字符串类型的变量值，例如 <code>println(&quot;${x}&quot;)</code>。</p>
<p>插值表达式必须用花括号 <code>{}</code> 包起来，并在 <code>{}</code> 之前加上 <code>$</code> 前缀。<code>{}</code> 中可以包含一个或者多个声明或表达式。</p>
<p>当插值字符串求值时，每个插值表达式所在位置会被 <code>{}</code> 中的最后一项的值替换，整个插值字符串最终仍是一个字符串。</p>
<p>下面是插值字符串的简单示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    let fruit = &quot;apples&quot;
    let count = 10
    let s = &quot;There are ${count * count} ${fruit}&quot;
    println(s)

    let r = 2.4
    let area = &quot;The area of a circle with radius ${r} is ${let PI = 3.141592; PI * r * r}&quot;
    println(area)
}
</code></pre>
<p>编译并执行上述代码，输出结果为：</p>
<pre><code class="language-text">There are 100 apples
The area of a circle with radius 2.400000 is 18.095570
</code></pre>
<h2 id="字符串类型支持的操作"><a class="header" href="#字符串类型支持的操作">字符串类型支持的操作</a></h2>
<p>字符串类型支持使用关系操作符进行比较，支持使用 <code>+</code> 进行拼接。下面的例子展示了字符串类型的判等和拼接：</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    let s1 = &quot;abc&quot;
    var s2 = &quot;ABC&quot;
    let r1 = s1 == s2
    println(&quot;The result of 'abc' == 'ABC' is: ${r1}&quot;)
    let r2 = s1 + s2
    println(&quot;The result of 'abc' + 'ABC' is: ${r2}&quot;)
}
</code></pre>
<p>编译并执行上述代码，输出结果为：</p>
<pre><code class="language-text">The result of 'abc' == 'ABC' is: false
The result of 'abc' + 'ABC' is: abcABC
</code></pre>
<p>字符串还支持其他常见操作，例如拆分、替换等。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="元组类型"><a class="header" href="#元组类型">元组类型</a></h1>
<p>元组（Tuple）可以将多个不同的类型组合在一起，成为一个新的类型。元组类型使用 <code>(T1, T2, ..., TN)</code> 表示，其中 <code>T1</code> 到 <code>TN</code> 可以是任意类型，不同类型间使用逗号（<code>,</code>）连接。元组至少是二元，例如，<code>(Int64, Float64)</code> 表示一个二元组类型，<code>(Int64, Float64, String)</code> 表示一个三元组类型。</p>
<p>元组的长度是固定的，即一旦定义了一个元组类型的实例，它的长度不能再被更改。</p>
<p>元组类型是不可变类型，即一旦定义了一个元组类型的实例，它的内容不能再被更新。例如</p>
<pre><code class="language-cangjie">var tuple = (true, false)
tuple[0] = false // Error, 'tuple element' can not be assigned
</code></pre>
<h2 id="元组类型的字面量"><a class="header" href="#元组类型的字面量">元组类型的字面量</a></h2>
<p>元组类型的字面量使用 <code>(e1, e2, ..., eN)</code> 表示，其中 <code>e1</code> 到 <code>eN</code> 是表达式，多个表达式之间使用逗号分隔。下面的例子中，分别定义了一个 <code>(Int64, Float64)</code> 类型的变量 <code>x</code>，以及一个 <code>(Int64, Float64, String)</code> 类型的变量 <code>y</code>，并且使用元组类型的字面量为它们定义了初值：</p>
<pre><code class="language-cangjie">let x: (Int64, Float64) = (3, 3.141592)
let y: (Int64, Float64, String) = (3, 3.141592, &quot;PI&quot;)
</code></pre>
<p>元组支持通过 <code>t[index]</code> 的方式访问某个具体位置的元素，其中 <code>t</code> 是一个元组，<code>index</code> 是下标，并且 <code>index</code> 只能是从 <code>0</code> 开始且小于元组元素个数的整数类型字面量，否则，编译报错。下面的例子中，使用 <code>pi[0]</code> 和 <code>pi[1]</code> 可以分别访问二元组 <code>pi</code> 的第一个元素和第二个元素。</p>
<pre><code class="language-cangjie">main() {
    var pi = (3.14, &quot;PI&quot;)
    println(pi[0])
    println(pi[1])
}
</code></pre>
<p>编译并执行上述代码，输出结果为：</p>
<pre><code class="language-text">3.140000
PI
</code></pre>
<p>在赋值表达式中，可使用元组字面量对表达式的右值进行解构，这要求赋值表达式等号左边必须是一个元组字面量，这个元组字面量里面的元素必须都是左值（左值即出现在赋值操作符左边的，可保存值的表达式，具体参见各章节对赋值操作的描述）或者一个元组字面量，当元组字面量中出现 <code>_</code> 时，表示忽略等号右侧 <code>tuple</code> 对应位置处的求值结果（意味着这个位置处的类型检查总是可以通过的），等号右边的表达式也必须是 <code>tuple</code> 类型，右边 <code>tuple</code> 每个元素的类型必须是对应位置左值类型的子类型。注意，复合赋值不支持这种解构方式。求值顺序上先计算等号右边表达式的值，再对左值部分从左往右逐个赋值，例如：</p>
<pre><code class="language-cangjie">var a: Int64
var b: String
var c: Unit
var f = { =&gt; ((1, &quot;abc&quot;), ())}
((a, b), c) = f() // value of a is 1, value of b is &quot;abc&quot;, value of c is '()'
((a, b), _) = ((2, &quot;def&quot;), 3.0) // value of a is 2, value of b is &quot;def&quot;, 3.0 is ignored
</code></pre>
<h2 id="元组类型的类型参数"><a class="header" href="#元组类型的类型参数">元组类型的类型参数</a></h2>
<p>可以为元组类型标记显式的类型参数名，下面例子中的 <code>name</code> 和 <code>price</code> 就是 <code>类型参数名</code>。</p>
<pre><code class="language-cangjie">func getFruitPrice (): (name: String, price: Int64) {
    return (&quot;banana&quot;, 10)
}
</code></pre>
<p>对于一个元组类型，只允许统一写类型参数名，或者统一不写类型参数名，不允许交替存在。</p>
<pre><code class="language-cangjie">let c: (name: String, Int64) = (&quot;banana&quot;, 5)   // Error
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数组类型"><a class="header" href="#数组类型">数组类型</a></h1>
<h2 id="array"><a class="header" href="#array">Array</a></h2>
<p>我们可以使用 Array 类型来构造单一元素类型，有序序列的数据。</p>
<p>仓颉使用 <code>Array&lt;T&gt;</code> 来表示 Array 类型。T 表示 Array 的元素类型，T 可以是任意类型。</p>
<pre><code class="language-cangjie">var a: Array&lt;Int64&gt; = ... // Array whose element type is Int64
var b: Array&lt;String&gt; = ... // Array whose element type is String
</code></pre>
<p>元素类型不相同的 Array 是不相同的类型，所以它们之间不可以互相赋值。</p>
<p>因此以下例子是不合法的。</p>
<pre><code class="language-cangjie">b = a // Type mismatch
</code></pre>
<p>我们可以轻松使用字面量来初始化一个 Array，只需要使用方括号将逗号分隔的值列表括起来即可。</p>
<p>编译器会根据上下文自动推断 Array 字面量的类型。</p>
<!-- compile -->
<pre><code class="language-cangjie">let a: Array&lt;String&gt; = [] // Created an empty Array whose element type is String
let b = [1, 2, 3, 3, 2, 1] // Created a Array whose element type is Int64, containing elements 1, 2, 3, 3, 2, 1
</code></pre>
<p>也可以使用构造函数的方式构造一个指定元素类型的 Array。</p>
<p>需要注意的是，当通过 item 指定的初始值初始化 Array 时，该构造函数不会拷贝 item，如果 item 是一个引用类型，构造后数组的每一个元素都将指向相同的引用。</p>
<!-- compile -->
<pre><code class="language-cangjie">let a = Array&lt;Int64&gt;() // Created an empty Array whose element type is Int64
let b = Array&lt;Int64&gt;(a) // Use another Array to initialize b
let c = Array&lt;Int64&gt;(3, item: 0) // Created an Array whose element type is Int64, length is 3 and all elements are initialized as 0
let d = Array&lt;Int64&gt;(3, {i =&gt; i + 1}) // Created an Array whose element type is Int64, length is 3 and all elements are initialized by the initialization function
</code></pre>
<h3 id="访问-array-成员"><a class="header" href="#访问-array-成员">访问 Array 成员</a></h3>
<p>当我们需要对 Array 的所有元素进行访问时，可以使用 for-in 循环遍历 Array 的所有元素。</p>
<p>Array 是按元素插入顺序排列的，因此对 Array 遍历的顺序总是恒定的。</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    let arr = [0, 1, 2]
    for (i in arr) {
        println(&quot;The element is ${i}&quot;)
    }
}
</code></pre>
<p>编译并执行上面的代码，会输出：</p>
<pre><code class="language-text">The element is 0
The element is 1
The element is 2
</code></pre>
<p>当我们需要知道某个 Array 包含的元素个数时，可以使用 size 属性获得对应信息。</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    let arr = [0, 1, 2]
    if (arr.size == 0) {
        println(&quot;This is an empty array&quot;)
    } else {
        println(&quot;The size of array is ${arr.size}&quot;)
    }
}
</code></pre>
<p>编译并执行上面的代码，会输出：</p>
<pre><code class="language-text">The size of array is 3
</code></pre>
<p>当我们想访问单个指定位置的元素时，可以使用下标语法访问（下标的类型必须是 Int64）。非空 Array 的第一个元素总是从位置 0 开始的。我们可以从 0 开始访问 Array 的任意一个元素，直到最后一个位置（Array 的 size - 1）。索引值不能使用负数或者大于等于 size，当编译器能检查出索引值非法时，会在编译时报错，否则会在运行时抛异常。</p>
<pre><code class="language-cangjie">main() {
    let arr = [0, 1, 2]
    let a = arr[0] // a == 0
    let b = arr[1] // b == 1
    let c = arr[-1] // array size is '3', but access index is '-1', which would overflow
}
</code></pre>
<p>如果我们想获取某一段 Array 的元素，可以在下标中传入 Range 类型的值，就可以一次性取得 Range 对应范围的一段 Array。</p>
<!-- compile -->
<pre><code class="language-cangjie">let arr1 = [0, 1, 2, 3, 4, 5, 6]
let arr2 = arr1[0..5] // arr2 contains the elements 0, 1, 2, 3, 4
</code></pre>
<p>当 Range 字面量在下标语法中使用时，我们可以省略 start 或 end。</p>
<p>当省略 start 时，Range 会从 0 开始；当省略 end 时，Range 的 end 会延续到最后一位。</p>
<!-- compile -->
<pre><code class="language-cangjie">let arr1 = [0, 1, 2, 3, 4, 5, 6]
let arr2 = arr1[..3] // arr2 contains elements 0, 1, 2
let arr3 = arr1[2..] // arr3 contains elements 2, 3, 4, 5, 6
</code></pre>
<h3 id="修改-array"><a class="header" href="#修改-array">修改 Array</a></h3>
<p>Array 是一种长度不变的 Collection 类型，因此 Array 没有提供添加和删除元素的成员函数。</p>
<p>但是 Array 允许我们对其中的元素进行修改，同样使用下标语法。</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    let arr = [0, 1, 2, 3, 4, 5]
    arr[0] = 3
    println(&quot;The first element is ${arr[0]}&quot;)
}
</code></pre>
<p>编译并执行上面的代码，会输出：</p>
<pre><code class="language-text">The first element is 3
</code></pre>
<p>Array 是引用类型，因此 Array 在作为表达式使用时不会拷贝副本，同一个 Array 实例的所有引用都会共享同样的数据。</p>
<p>因此对 Array 元素的修改会影响到该实例的所有引用。</p>
<!-- compile -->
<pre><code class="language-cangjie">let arr1 = [0, 1, 2]
let arr2 = arr1
arr2[0] = 3
// arr1 contains elements 3, 1, 2
// arr2 contains elements 3, 1, 2
</code></pre>
<h2 id="varray"><a class="header" href="#varray">VArray</a></h2>
<p>仓颉编程语言引入了值类型数组 <code>VArray&lt;T, $N&gt;</code> ，其中 <code>T</code> 表示该值类型数组的元素类型，<code>$N</code> 是一个固定的语法，通过 <code>$</code> 加上一个数值字面量表示这个值类型数组的长度。需要注意的是，<code>VArray&lt;T, $N&gt;</code> 不能省略 <code>&lt;T, $N&gt;</code>，且使用类型别名时，不允许拆分 <code>VArray</code> 关键字与其泛型参数。</p>
<pre><code class="language-cangjie">type varr1 = VArray&lt;Int64, $3&gt; // Ok
type varr2 = VArray // Error
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p>由于运行时后端限制，当前 <code>VArray&lt;T, $N&gt;</code> 的元素类型 <code>T</code> 或 <code>T</code> 的成员不能包含引用类型、枚举类型、Lambda 表达式（<code>CFunc</code> 除外）以及未实例化的泛型类型。</p>
</blockquote>
<p><code>VArray</code> 可以由一个数组的字面量来进行初始化，左值 <code>a</code> 必须标识出 <code>VArray</code> 的实例化类型：</p>
<!-- compile -->
<pre><code class="language-cangjie">var a: VArray&lt;Int64, $3&gt; = [1, 2, 3]
</code></pre>
<p>同时，它拥有两个构造函数：</p>
<!-- compile -->
<pre><code class="language-cangjie">// VArray&lt;T, $N&gt;(initElement: (Int64) -&gt; T)
let b = VArray&lt;Int64, $5&gt;({ i =&gt; i}) // [0, 1, 2, 3, 4]
// VArray&lt;T, $N&gt;(item!: T)
let c = VArray&lt;Int64, $5&gt;(item: 0) // [0, 0, 0, 0, 0]
</code></pre>
<p>除此之外，<code>VArray&lt;T, $N&gt;</code> 类型提供了两个成员方法：</p>
<ul>
<li>
<p>用于下标访问和修改的 <code>[]</code> 操作符方法：</p>
<!-- compile -->
<pre><code class="language-cangjie">var a: VArray&lt;Int64, $3&gt; = [1, 2, 3]
let i = a[1] // i is 2
a[2] = 4 // a is [1, 2, 4]
</code></pre>
</li>
<li>
<p>用于获取 <code>VArray</code> 长度的 <code>size</code> 成员：</p>
<!-- compile -->
<pre><code class="language-cangjie">var a: VArray&lt;Int64, $3&gt; = [1, 2, 3]
let s = a.size // s is 3
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="区间类型"><a class="header" href="#区间类型">区间类型</a></h1>
<p>区间类型用于表示拥有固定步长的序列，区间类型是一个泛型（详见<a href="source_zh_cn/basic_data_type/../generic/generic_overview.html">泛型</a>章节），使用 <code>Range&lt;T&gt;</code> 表示。当 <code>T</code> 被实例化不同的类型时（要求此类型必须支持关系操作符，并且可以和 <code>Int64</code> 类型的值做加法），会得到不同的区间类型，如最常用的 <code>Range&lt;Int64&gt;</code> 用于表示整数区间。</p>
<p>每个区间类型的实例都会包含 <code>start</code>、<code>end</code> 和 <code>step</code> 三个值。其中，<code>start</code> 和 <code>end</code> 分别表示序列的起始值和终止值，<code>step</code> 表示序列中前后两个元素之间的差值（即步长）；<code>start</code> 和 <code>end</code> 的类型相同（即 <code>T</code> 被实例化的类型），<code>step</code> 类型是 <code>Int64</code>，并且它的值不能等于 <code>0</code>。</p>
<p>下面的例子给出了区间类型的实例化方式（关于区间类型定义和其中的属性，详见《仓颉编程语言库 API》）：</p>
<!-- compile -->
<pre><code class="language-cangjie">// Range&lt;T&gt;(start: T, end: T, step: Int64, hasStart: Bool, hasEnd: Bool, isClosed: Bool)
let r1 = Range&lt;Int64&gt;(0, 10, 1, true, true, true) // r1 contains 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
let r2 = Range&lt;Int64&gt;(0, 10, 1, true, true, false) // r2 contains 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
let r3 = Range&lt;Int64&gt;(10, 0, -2, true, true, false) // r3 contains 10, 8, 6, 4, 2
</code></pre>
<h2 id="区间类型字面量"><a class="header" href="#区间类型字面量">区间类型字面量</a></h2>
<p>区间字面量有两种形式：“左闭右开”区间和“左闭右闭”区间。</p>
<ul>
<li>“左闭右开”区间的格式是 <code>start..end : step</code>，它表示一个从 <code>start</code> 开始，以 <code>step</code> 为步长，到 <code>end</code>（不包含 <code>end</code>）为止的区间；</li>
<li>“左闭右闭”区间的格式是 <code>start..=end : step</code>，它表示一个从 <code>start</code> 开始，以 <code>step</code> 为步长，到 <code>end</code>（包含 <code>end</code>）为止的区间。</li>
</ul>
<p>下面的例子定义了若干区间类型的变量：</p>
<!-- compile -->
<pre><code class="language-cangjie">let n = 10
let r1 = 0..10 : 1   // r1 contains 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
let r2 = 0..=n : 1   // r2 contains 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
let r3 = n..0 : -2   // r3 contains 10, 8, 6, 4, 2
let r4 = 10..=0 : -2 // r4 contains 10, 8, 6, 4, 2, 0
</code></pre>
<p>区间字面量中，可以不写 <code>step</code>，此时 <code>step</code> 默认等于 <code>1</code>，但是注意，<code>step</code> 的值不能等于 <code>0</code>。另外，区间也有可能是空的（即不包含任何元素的空序列），举例如下：</p>
<pre><code class="language-cangjie">let r5 = 0..10   // the step of r5 is 1, and it contains 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
let r6 = 0..10 : 0 // Error, step cannot be 0

let r7 = 10..0 : 1 // r7 to r10 are empty ranges
let r8 = 0..10 : -1
let r9 = 10..=0 : 1
let r10 = 0..=10 : -1
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>表达式 <code>start..end : step</code> 中，当 <code>step &gt; 0</code> 且 <code>start &gt;= end</code>，或者 <code>step &lt; 0</code> 且 <code>start &lt;= end</code> 时，<code>start..end : step</code> 是一个空区间；</li>
<li>表达式 <code>start..=end : step</code> 中，当 <code>step &gt; 0</code> 且 <code>start &gt; end</code>，或者 <code>step &lt; 0</code> 且 <code>start &lt; end</code> 时，<code>start..=end : step</code> 是一个空区间。</li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unit-类型"><a class="header" href="#unit-类型">Unit 类型</a></h1>
<p>对于那些只关心副作用而不关心值的表达式，它们的类型是 <code>Unit</code>。例如，<code>print</code> 函数、赋值表达式、复合赋值表达式、自增和自减表达式、循环表达式，它们的类型都是 <code>Unit</code>。</p>
<p><code>Unit</code> 类型只有一个值，也是它的字面量：<code>()</code>。除了赋值、判等和判不等外，<code>Unit</code> 类型不支持其他操作。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nothing-类型"><a class="header" href="#nothing-类型">Nothing 类型</a></h1>
<p><code>Nothing</code> 是一种特殊的类型，它不包含任何值，并且 <code>Nothing</code> 类型是所有类型的子类型。</p>
<p><code>break</code>、<code>continue</code>、<code>return</code> 和 <code>throw</code> 表达式的类型是 <code>Nothing</code>，程序执行到这些表达式时，它们之后的代码将不会被执行。其中 <code>break</code>、<code>continue</code> 只能在循环体中使用，<code>return</code> 只能在函数体中使用。</p>
<p>包围着的循环体“无法穿越”函数边界。在下面的例子中，<code>break</code> 出现在函数 <code>f</code> 中，外层的 while 循环体不被视作包围着它的循环体；<code>continue</code> 出现在 lambda 表达式中，外层的 while 循环体不被视作包围着它的循环体。</p>
<pre><code class="language-cangjie">while (true) {
    func f() {
        break // Error, break must be used directly inside a loop
    }
    let g = { =&gt;
        continue // Error, continue must be used directly inside a loop
    }
}
</code></pre>
<p>由于函数的形参和其默认值不属于该函数的函数体，所以下面例子中的 return 表达式缺少包围它的函数体——它既不属于外层函数 <code>f</code>（因为内层函数定义 <code>g</code> 已经开始），也不在内层函数 <code>g</code> 的函数体中：</p>
<pre><code class="language-cangjie">func f() {
    func g(x!: Int64 = return) { // Error, return must be used inside a function body
        0
    }
    1
}
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p>目前编译器还不允许在使用类型的地方显式地使用 Nothing 类型。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="定义函数"><a class="header" href="#定义函数">定义函数</a></h1>
<p>仓颉使用关键字 <code>func</code> 来表示函数定义的开始，<code>func</code> 之后依次是函数名、参数列表、可选的函数返回值类型、函数体。其中，函数名可以是任意的合法标识符，参数列表定义在一对圆括号内（多个参数间使用逗号分隔），参数列表和函数返回值类型（如果存在）之间使用冒号分隔，函数体定义在一对花括号内。</p>
<p>函数定义举例：</p>
<!-- compile -->
<pre><code class="language-cangjie">func add(a: Int64, b: Int64): Int64 {
    return a + b
}
</code></pre>
<p>上例中定义了一个名为 <code>add</code> 的函数，其参数列表由两个 <code>Int64</code> 类型的参数 <code>a</code> 和 <code>b</code> 组成，函数返回值类型为 <code>Int64</code>，函数体中将 <code>a</code> 和 <code>b</code> 相加并返回。</p>
<p>下面依次对函数定义中的参数列表、函数返回值类型和函数体作进一步介绍。</p>
<h2 id="参数列表"><a class="header" href="#参数列表">参数列表</a></h2>
<p>一个函数可以拥有 0 个或多个参数，这些参数均定义在函数的参数列表中。根据函数调用时是否需要给定参数名，可以将参数列表中的参数分为两类：非命名参数和命名参数。</p>
<p>非命名参数的定义方式是 <code>p: T</code>，其中 <code>p</code> 表示参数名，<code>T</code> 表示参数 <code>p</code> 的类型，参数名和其类型间使用冒号连接。例如，上例中 <code>add</code> 函数的两个参数 <code>a</code> 和 <code>b</code> 均为非命名参数。</p>
<p>命名参数的定义方式是 <code>p!: T</code>，与非命名参数的不同是在参数名 <code>p</code> 之后多了一个 <code>!</code>。可以将上例中 <code>add</code> 函数的两个非命名参数修改为命名参数，如下所示：</p>
<!-- compile -->
<pre><code class="language-cangjie">func add(a!: Int64, b!: Int64): Int64 {
    return a + b
}
</code></pre>
<p>命名参数还可以设置默认值，通过 <code>p!: T = e</code> 方式将参数 <code>p</code> 的默认值设置为表达式 <code>e</code> 的值。例如，可以将上述 <code>add</code> 函数的两个参数的默认值都设置为 <code>1</code>：</p>
<!-- compile -->
<pre><code class="language-cangjie">func add(a!: Int64 = 1, b!: Int64 = 1): Int64 {
    return a + b
}
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p>只能为命名参数设置默认值，不能为非命名参数设置默认值。</p>
</blockquote>
<p>参数列表中可以同时定义非命名参数和命名参数，但是需要注意的是，非命名参数只能定义在命名参数之前，也就意味着命名参数之后不能再出现非命名参数。例如，下例中 <code>add</code> 函数的参数列表定义是不合法的：</p>
<pre><code class="language-cangjie">func add(a!: Int64, b: Int64): Int64 { // Error, named parameter 'a' must be defined after non-named parameter 'b'
    return a + b
}
</code></pre>
<p>非命名参数和命名参数的主要差异在于调用时的不同，具体可参见下文<a href="source_zh_cn/function/./call_functions.html">调用函数</a>中的介绍。</p>
<p>函数参数均为不可变变量，在函数定义内不能对其赋值。</p>
<pre><code class="language-cangjie">func add(a: Int64, b: Int64): Int64 {
    a = a + b // Error
    return a
}
</code></pre>
<p>函数参数作用域从定义处起至函数体结束：</p>
<pre><code class="language-cangjie">func add(a: Int64, b: Int64): Int64 {
    var a_ = a // OK
    var b = b  // Error, redefinition of declaration 'b'
    return a
}
</code></pre>
<h2 id="函数返回值类型"><a class="header" href="#函数返回值类型">函数返回值类型</a></h2>
<p>函数返回值类型是函数被调用后得到的值的类型。函数定义时，返回值类型是可选的：可以显式地定义返回值类型（返回值类型定义在参数列表和函数体之间），也可以不定义返回值类型，交由编译器推导确定。</p>
<p>当显式地定义了函数返回值类型时，就要求函数体的类型（关于如何确定函数体的类型可参见下节<a href="source_zh_cn/function/./define_functions.html#%E5%87%BD%E6%95%B0%E4%BD%93">函数体</a>）、函数体中所有 <code>return e</code> 表达式中 <code>e</code> 的类型是返回值类型的子类型。例如，对于上述 <code>add</code> 函数，显式地定义了它的返回值类型为 <code>Int64</code>，如果将函数体中的 <code>return a + b</code> 修改为 <code>return (a, b)</code>，则会因为类型不匹配而报错：</p>
<pre><code class="language-cangjie">// Error, the type of the expression after return does not match the return type of the function
func add(a: Int64, b: Int64): Int64 {
    return (a, b)
}
</code></pre>
<p>在函数定义时如果未显式定义返回值类型，编译器将根据函数体的类型以及函数体中所有的 <code>return</code> 表达式来共同推导出函数的返回值类型。例如，下例中 <code>add</code> 函数的返回值类型虽然被省略，但编译器可以根据 <code>return a + b</code> 推导出 <code>add</code> 函数的返回值类型是 <code>Int64</code>：</p>
<!-- compile -->
<pre><code class="language-cangjie">func add(a: Int64, b: Int64) {
    return a + b
}
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p>函数的返回值类型并不是任何情况下都可以被推导出来的，如果返回值类型推导失败，编译器会报错。</p>
</blockquote>
<h2 id="函数体"><a class="header" href="#函数体">函数体</a></h2>
<p>函数体中定义了函数被调用时执行的操作，通常包含一系列的变量定义和表达式，也可以包含新的函数定义（即嵌套函数）。如下 <code>add</code> 函数的函数体中首先定义了 <code>Int64</code> 类型的变量 <code>r</code>（初始值为 <code>0</code>），接着将 <code>a + b</code> 的值赋值给 <code>r</code>，最后将 <code>r</code> 的值返回：</p>
<!-- compile -->
<pre><code class="language-cangjie">func add(a: Int64, b: Int64) {
    var r = 0
    r = a + b
    return r
}
</code></pre>
<p>在函数体的任意位置都可以使用 <code>return</code> 表达式来终止函数的执行并返回。<code>return</code> 表达式有两种形式：<code>return</code> 和 <code>return expr</code>（<code>expr</code> 是一个表达式）。</p>
<p>对于 <code>return expr</code>，要求 <code>expr</code> 的类型与函数定义中的返回值类型保持一致。例如，下例中会因为 <code>return 100</code> 中 <code>100</code> 类型（<code>Int64</code>）和函数 <code>foo</code> 的返回值类型（<code>String</code>）不同而报错。</p>
<pre><code class="language-cangjie">// Error, cannot convert an integer literal to type 'Struct-String'
func foo(): String {
    return 100
}
</code></pre>
<p>对于 <code>return</code>，其等价于 <code>return ()</code>，所以要求函数的返回值类型为 <code>Unit</code>。</p>
<!-- compile -->
<pre><code class="language-cangjie">func add(a: Int64, b: Int64) {
    var r = 0
    r = a + b
    return r
}

func foo(): Unit {
    add(1, 2)
    return
}
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p><code>return</code> 表达式作为一个整体，其类型并不由后面跟随的表达式决定，而是 <code>Nothing</code> 类型。</p>
</blockquote>
<p>在函数体内定义的变量属于局部变量的一种（如上例中的 <code>r</code> 变量），它的作用域从其定义之后开始到函数体结束。</p>
<p>对于一个局部变量，允许在其外层作用域中定义同名变量，并且在此局部变量的作用域内，局部变量会“遮盖”外层作用域的同名变量。例如：</p>
<!-- compile -->
<pre><code class="language-cangjie">let r = 0
func add(a: Int64, b: Int64) {
    var r = 0
    r = a + b
    return r
}
</code></pre>
<p>上例中，<code>add</code> 函数之前定义了 <code>Int64</code> 类型的全局变量 <code>r</code>，同时 <code>add</code> 函数体内定义了同名的局部变量 <code>r</code>，那么在函数体内，所有使用变量 <code>r</code> 的地方（如 <code>r = a + b</code>），用到的将是局部变量 <code>r</code>，即（在函数体内）局部变量 <code>r</code> “遮盖”了全局变量 <code>r</code>。</p>
<p><a href="source_zh_cn/function/./define_functions.html#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B">函数返回值类型</a>中我们提到函数体也是有类型的，函数体的类型是函数体内最后一“项”的类型：若最后一项为表达式，则函数体的类型是此表达式的类型，若最后一项为变量定义或函数声明，或函数体为空，则函数体的类型为 <code>Unit</code>。例如：</p>
<!-- compile -->
<pre><code class="language-cangjie">func add(a: Int64, b: Int64): Int64 {
    a + b
}
</code></pre>
<p>上例中，因为函数体的最后一“项”是 <code>Int64</code> 类型的表达式（即 <code>a + b</code>），所以函数体的类型也是 <code>Int64</code>，与函数定义的返回值类型相匹配。又如，下例中函数体的最后一项是 <code>print</code> 函数调用，所以函数体的类型是 <code>Unit</code>，同样与函数定义的返回值类型相匹配：</p>
<!-- compile -->
<pre><code class="language-cangjie">func foo(): Unit {
    let s = &quot;Hello&quot;
    print(s)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="调用函数"><a class="header" href="#调用函数">调用函数</a></h1>
<p>函数调用的形式为 <code>f(arg1, arg2, ..., argn)</code>。其中，<code>f</code> 是要调用的函数的名字，<code>arg1</code> 到 <code>argn</code> 是 <code>n</code> 个调用时的参数（称为实参），要求每个实参的类型必须是对应参数类型的子类型。实参可以有 0 个或多个，当实参个数为 0 时，调用方式为 <code>f()</code>。</p>
<p>根据函数定义时参数是非命名参数还是命名参数的不同，函数调用时传实参的方式也有所不同：对于非命名参数，它对应的实参是一个表达式，对于命名参数，它对应的实参需要使用 <code>p: e</code> 的形式，其中 <code>p</code> 是命名参数的名字，<code>e</code> 是表达式（即传递给参数 <code>p</code> 的值）。</p>
<p>非命名参数调用举例：</p>
<!-- verify -->
<pre><code class="language-cangjie">func add(a: Int64, b: Int64) {
    return a + b
}

main() {
    let x = 1
    let y = 2
    let r = add(x, y)
    println(&quot;The sum of x and y is ${r}&quot;)
}
</code></pre>
<p>执行结果为：</p>
<pre><code class="language-text">The sum of x and y is 3
</code></pre>
<p>命名参数调用举例：</p>
<!-- verify -->
<pre><code class="language-cangjie">func add(a: Int64, b!: Int64) {
    return a + b
}

main() {
    let x = 1
    let y = 2
    let r = add(x, b: y)
    println(&quot;The sum of x and y is ${r}&quot;)
}
</code></pre>
<p>执行结果为：</p>
<pre><code class="language-text">The sum of x and y is 3
</code></pre>
<p>对于多个命名参数，调用时的传参顺序可以和定义时的参数顺序不同。例如，下例中调用 <code>add</code> 函数时 <code>b</code> 可以出现在 <code>a</code> 之前：</p>
<!-- verify -->
<pre><code class="language-cangjie">func add(a!: Int64, b!: Int64) {
    return a + b
}

main() {
    let x = 1
    let y = 2
    let r = add(b: y, a: x)
    println(&quot;The sum of x and y is ${r}&quot;)
}
</code></pre>
<p>执行结果为：</p>
<pre><code class="language-text">The sum of x and y is 3
</code></pre>
<p>对于拥有默认值的命名参数，调用时如果没有传实参，那么此参数将使用默认值作为实参的值。例如，下例中调用 <code>add</code> 函数时没有为参数 <code>b</code> 传实参，那么参数 <code>b</code> 的值等于其定义时的默认值 <code>2</code>：</p>
<!-- verify -->
<pre><code class="language-cangjie">func add(a: Int64, b!: Int64 = 2) {
    return a + b
}

main() {
    let x = 1
    let r = add(x)
    println(&quot;The sum of x and y is ${r}&quot;)
}
</code></pre>
<p>执行结果为：</p>
<pre><code class="language-text">The sum of x and y is 3
</code></pre>
<p>对于拥有默认值的命名参数，调用时也可以为其传递新的实参，此时命名参数的值等于新的实参的值，即定义时的默认值将失效。例如，下例中调用 <code>add</code> 函数时为参数 <code>b</code> 传了新的实参值 <code>20</code>，那么参数 <code>b</code> 的值就等于 <code>20</code>：</p>
<!-- verify -->
<pre><code class="language-cangjie">func add(a: Int64, b!: Int64 = 2) {
    return a + b
}

main() {
    let x = 1
    let r = add(x, b: 20)
    println(&quot;The sum of x and y is ${r}&quot;)
}
</code></pre>
<p>执行结果为：</p>
<pre><code class="language-text">The sum of x and y is 21
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数类型"><a class="header" href="#函数类型">函数类型</a></h1>
<p>仓颉编程语言中，函数是一等公民（first-class citizens），可以作为函数的参数或返回值，也可以赋值给变量。因此函数本身也有类型，称之为函数类型。</p>
<p>函数类型由函数的参数类型和返回类型组成，参数类型和返回类型之间使用 <code>-&gt;</code> 连接。参数类型使用圆括号 <code>()</code> 括起来，可以有 0 个或多个参数，如果参数超过一个，参数类型之间使用逗号（<code>,</code>）分隔。</p>
<p>例如：</p>
<!-- compile -->
<pre><code class="language-cangjie">func hello(): Unit {
    println(&quot;Hello!&quot;)
}
</code></pre>
<p>上述示例定义了一个函数，函数名为 hello，其类型是 <code>() -&gt; Unit</code>，表示该函数没有参数，返回类型为 <code>Unit</code>。</p>
<p>以下给出另一些示例：</p>
<ul>
<li>
<p>示例：函数名为 <code>display</code>，其类型是 <code>(Int64) -&gt; Unit</code>，表示该函数有一个参数，参数类型为 <code>Int64</code>，返回类型为 <code>Unit</code>。</p>
<!-- compile -->
<pre><code class="language-cangjie">func display(a: Int64): Unit {
    println(a)
}
</code></pre>
</li>
<li>
<p>示例：函数名为 <code>add</code>，其类型是 <code>(Int64, Int64) -&gt; Int64</code>，表示该函数有两个参数，两个参数类型均为 <code>Int64</code>，返回类型为 <code>Int64</code>。</p>
<!-- compile -->
<pre><code class="language-cangjie">func add(a: Int64, b: Int64): Int64 {
    a + b
}
</code></pre>
</li>
<li>
<p>示例：函数名为 <code>returnTuple</code>，其类型是 <code>(Int64, Int64) -&gt; (Int64, Int64)</code>，两个参数类型均为 <code>Int64</code>, 返回类型为元组类型：<code>(Int64, Int64)</code>。</p>
<!-- compile -->
<pre><code class="language-cangjie">func returnTuple(a: Int64, b: Int64): (Int64, Int64) {
    (a, b)
}
</code></pre>
</li>
</ul>
<h2 id="函数类型的类型参数"><a class="header" href="#函数类型的类型参数">函数类型的类型参数</a></h2>
<p>可以为函数类型标记显式的类型参数名，下面例子中的 <code>name</code> 和 <code>price</code> 就是 <code>类型参数名</code>。</p>
<!-- run -->
<pre><code class="language-cangjie">main() {
    let fruitPriceHandler: (name: String, price: Int64) -&gt; Unit
    fruitPriceHandler = {n, p =&gt; println(&quot;fruit: ${n} price: ${p} yuan&quot;)}
    fruitPriceHandler(&quot;banana&quot;, 10)
}
</code></pre>
<p>另外对于一个函数类型，只允许统一写类型参数名，或者统一不写类型参数名，不能交替存在。</p>
<pre><code class="language-cangjie">let handler: (name: String, Int64) -&gt; Int64   // Error
</code></pre>
<h2 id="函数类型作为参数类型"><a class="header" href="#函数类型作为参数类型">函数类型作为参数类型</a></h2>
<p>示例：函数名为 <code>printAdd</code>，其类型是 <code>((Int64, Int64) -&gt; Int64, Int64, Int64) -&gt; Unit</code>，表示该函数有三个参数，参数类型分别为函数类型 <code>(Int64, Int64) -&gt; Int64</code> 和两个 <code>Int64</code>，返回类型为 <code>Unit</code>。</p>
<!-- compile -->
<pre><code class="language-cangjie">func printAdd(add: (Int64, Int64) -&gt; Int64, a: Int64, b: Int64): Unit {
    println(add(a, b))
}
</code></pre>
<h2 id="函数类型作为返回类型"><a class="header" href="#函数类型作为返回类型">函数类型作为返回类型</a></h2>
<p>函数类型可以作为另一个函数的返回类型。</p>
<p>如下示例中，函数名为 <code>returnAdd</code>，其类型是 <code>() -&gt; (Int64, Int64) -&gt; Int64</code>，表示该函数无参数，返回类型为函数类型 <code>(Int64, Int64) -&gt; Int64</code>。注意，<code>-&gt;</code> 是右结合的。</p>
<!-- run -->
<pre><code class="language-cangjie">func add(a: Int64, b: Int64): Int64 {
    a + b
}

func returnAdd(): (Int64, Int64) -&gt; Int64 {
    add
}

main() {
    var a = returnAdd()
    println(a(1,2))
}
</code></pre>
<h2 id="函数类型作为变量类型"><a class="header" href="#函数类型作为变量类型">函数类型作为变量类型</a></h2>
<p>函数名本身也是表达式，它的类型为对应的函数类型。</p>
<!-- compile -->
<pre><code class="language-cangjie">func add(p1: Int64, p2: Int64): Int64 {
    p1 + p2
}

let f: (Int64, Int64) -&gt; Int64 = add
</code></pre>
<p>上述示例中，函数名是 <code>add</code>，其类型为 <code>(Int64, Int64) -&gt; Int64</code>。变量 <code>f</code> 的类型与 <code>add</code> 类型相同，<code>add</code> 被用来初始化 <code>f</code>。</p>
<p>若一个函数在当前作用域中被重载（见<a href="source_zh_cn/function/./function_overloading.html">函数重载</a>）了，那么直接使用该函数名作为表达式可能产生歧义，如果产生歧义编译器会报错，例如：</p>
<pre><code class="language-cangjie">func add(i: Int64, j: Int64) {
    i + j
}

func add(i: Float64, j: Float64) {
    i + j
}

main() {
    var f = add   // Error, ambiguous function 'add'
    var plus: (Int64, Int64) -&gt; Int64 = add  // OK
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="嵌套函数"><a class="header" href="#嵌套函数">嵌套函数</a></h1>
<p>定义在源文件顶层的函数被称为全局函数。定义在函数体内的函数被称为嵌套函数。</p>
<p>示例，函数 <code>foo</code> 内定义了一个嵌套函数 <code>nestAdd</code>，可以在 <code>foo</code> 内调用该嵌套函数 <code>nestAdd</code>，也可以将嵌套函数 <code>nestAdd</code> 作为返回值返回，在 <code>foo</code> 外对其进行调用：</p>
<!-- verify -->
<pre><code class="language-cangjie">func foo() {
    func nestAdd(a: Int64, b: Int64) {
        a + b + 3
    }

    println(nestAdd(1, 2))  // 6

    return nestAdd
}

main() {
    let f = foo()
    let x = f(1, 2)
    println(&quot;result: ${x}&quot;)
}
</code></pre>
<p>程序会输出：</p>
<pre><code class="language-text">6
result: 6
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lambda-表达式"><a class="header" href="#lambda-表达式">Lambda 表达式</a></h1>
<h2 id="lambda-表达式定义"><a class="header" href="#lambda-表达式定义">Lambda 表达式定义</a></h2>
<p>Lambda 表达式的语法为如下形式： <code>{ p1: T1, ..., pn: Tn =&gt; expressions | declarations }</code>。</p>
<p>其中，<code>=&gt;</code> 之前为参数列表，多个参数之间使用 <code>,</code> 分隔，每个参数名和参数类型之间使用 <code>:</code> 分隔。<code>=&gt;</code> 之前也可以没有参数。<code>=&gt;</code> 之后为 lambda 表达式体，是一组表达式或声明序列。Lambda 表达式的参数名的作用域与函数的相同，为 lambda 表达式的函数体部分，其作用域级别可视为与 lambda 表达式的函数体内定义的变量等同。</p>
<!-- run -->
<pre><code class="language-cangjie">let f1 = { a: Int64, b: Int64 =&gt; a + b }

var display = { =&gt; println(&quot;Hello&quot;) }   // Parameterless lambda expression.
</code></pre>
<p>Lambda 表达式不管有没有参数，都不可以省略 <code>=&gt;</code>，除非其作为尾随 lambda。例如：</p>
<!-- run -->
<pre><code class="language-cangjie">var display = { =&gt; println(&quot;Hello&quot;) }

func f2(lam: () -&gt; Unit) { }
let f2Res = f2{ println(&quot;World&quot;) } // OK to omit the =&gt;
</code></pre>
<p>Lambda 表达式中参数的类型标注可缺省。以下情形中，若参数类型省略，编译器会尝试进行类型推断，当编译器无法推断出类型时会编译报错：</p>
<ul>
<li>Lambda 表达式赋值给变量时，其参数类型根据变量类型推断；</li>
<li>Lambda 表达式作为函数调用表达式的实参使用时，其参数类型根据函数的形参类型推断。</li>
</ul>
<!-- run -->
<pre><code class="language-cangjie">// The parameter types are inferred from the type of the variable sum1
var sum1: (Int64, Int64) -&gt; Int64 = { a, b =&gt; a + b }

var sum2: (Int64, Int64) -&gt; Int64 = { a: Int64, b =&gt; a + b }

func f(a1: (Int64) -&gt; Int64): Int64 {
    a1(1)
}

main(): Int64 {
    // The parameter type of lambda is inferred from the type of function f
    f({ a2 =&gt; a2 + 10 })
}
</code></pre>
<p>Lambda 表达式中不支持声明返回类型，其返回类型总是从上下文中推断出来，若无法推断则报错。</p>
<ul>
<li>
<p>若上下文明确指定了 lambda 表达式的返回类型，则其返回类型为上下文指定的类型。</p>
<ul>
<li>
<p>Lambda 表达式赋值给变量时，其返回类型根据变量类型推断返回类型：</p>
<pre><code class="language-cangjie">let f: () -&gt; Unit = { ... }
</code></pre>
</li>
<li>
<p>Lambda 表达式作为参数使用时，其返回类型根据使用处所在的函数调用的形参类型推断：</p>
<!-- run -->
<pre><code class="language-cangjie">func f(a1: (Int64) -&gt; Int64): Int64 {
    a1(1)
}

main(): Int64 {
    f({ a2: Int64 =&gt; a2 + 10 })
}
</code></pre>
</li>
<li>
<p>Lambda 表达式作为返回值使用时，其返回类型根据使用处所在函数的返回类型推断：</p>
<!-- compile -->
<pre><code class="language-cangjie">func f(): (Int64) -&gt; Int64 {
    { a: Int64 =&gt; a }
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>若上下文中类型未明确，与推导函数的返回值类型类似，编译器会根据 lambda 表达式体中所有 return 表达式 <code>return xxx</code> 中 xxx 的类型，以及 lambda 表达式体的类型，来共同推导出 lambda 表达式的返回类型。</p>
<ul>
<li>
<p><code>=&gt;</code> 右侧的内容与普通函数体的规则一样，返回类型为 <code>Int64</code>:</p>
<!-- compile -->
<pre><code class="language-cangjie">let sum1 = { a: Int64, b: Int64 =&gt; a + b }
</code></pre>
</li>
<li>
<p><code>=&gt;</code> 的右侧为空，返回类型为 <code>Unit</code>:</p>
<!-- compile -->
<pre><code class="language-cangjie">let f = { =&gt; }
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="lambda-表达式调用"><a class="header" href="#lambda-表达式调用">Lambda 表达式调用</a></h2>
<p>Lambda 表达式支持立即调用，例如：</p>
<!-- compile -->
<pre><code class="language-cangjie">let r1 = { a: Int64, b: Int64 =&gt; a + b }(1, 2) // r1 = 3
let r2 = { =&gt; 123 }()                          // r2 = 123
</code></pre>
<p>Lambda 表达式也可以赋值给一个变量，使用变量名进行调用，例如：</p>
<!-- compile -->
<pre><code class="language-cangjie">func f() {
    var g = { x: Int64 =&gt; println(&quot;x = ${x}&quot;) }
    g(2)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="闭包"><a class="header" href="#闭包">闭包</a></h1>
<p>一个函数或 lambda 从定义它的静态作用域中捕获了变量，函数或 lambda 和捕获的变量一起被称为一个闭包，这样即使脱离了闭包定义所在的作用域，闭包也能正常运行。</p>
<p>函数或 lambda 的定义中对于以下几种变量的访问，称为变量捕获：</p>
<ul>
<li>
<p>函数的参数缺省值中访问了本函数之外定义的局部变量；</p>
</li>
<li>
<p>函数或 lambda 内访问了本函数或本 lambda 之外定义的局部变量;</p>
</li>
<li>
<p><code>class</code>/<code>struct</code> 内定义的不是成员函数的函数或 lambda 访问了实例成员变量或 <code>this</code>。</p>
</li>
</ul>
<p>以下情形的变量访问不是变量捕获：</p>
<ul>
<li>
<p>对定义在本函数或本 lambda 内的局部变量的访问；</p>
</li>
<li>
<p>对本函数或本 lambda 的形参的访问；</p>
</li>
<li>
<p>对全局变量和静态成员变量的访问；</p>
</li>
<li>
<p>对实例成员变量在实例成员函数或属性中的访问。由于实例成员函数或属性将 <code>this</code> 作为参数传入，在实例成员函数或属性内通过 <code>this</code> 访问所有实例成员变量。</p>
</li>
</ul>
<p>变量的捕获发生在闭包定义时，因此变量捕获有以下规则：</p>
<ul>
<li>
<p>被捕获的变量必须在闭包定义时可见，否则编译报错；</p>
</li>
<li>
<p>被捕获的变量必须在闭包定义时已经完成初始化，否则编译报错。</p>
</li>
</ul>
<p>示例 1：闭包 <code>add</code>，捕获了 <code>let</code> 声明的局部变量 <code>num</code>，之后通过返回值返回到 <code>num</code> 定义的作用域之外，调用 <code>add</code> 时仍可正常访问 <code>num</code>。</p>
<!-- verify -->
<pre><code class="language-cangjie">func returnAddNum(): (Int64) -&gt; Int64 {
    let num: Int64 = 10

    func add(a: Int64) {
        return a + num
    }
    add
}

main() {
    let f = returnAddNum()
    println(f(10))
}
</code></pre>
<p>程序输出的结果为：</p>
<pre><code class="language-text">20
</code></pre>
<p>示例 2：捕获的变量必须在闭包定义时可见。</p>
<pre><code class="language-cangjie">func f() {
    let x = 99
    func f1() {
        println(x)
    }
    let f2 = { =&gt;
        println(y)      // Error, cannot capture 'y' which is not defined yet
    }
    let y = 88
    f1()          // Print 99.
    f2()
}
</code></pre>
<p>示例 3：捕获的变量必须在闭包定义前完成初始化。</p>
<pre><code class="language-cangjie">func f() {
    let x: Int64
    func f1() {
        println(x)    // Error, x is not initialized yet.
    }
    x = 99
    f1()
}
</code></pre>
<p>如果捕获的变量是引用类型，可修改其可变实例成员变量的值。</p>
<!-- run -->
<pre><code class="language-cangjie">class C {
    public var num: Int64 = 0
}

func returnIncrementer(): () -&gt; Unit {
    let c: C = C()

    func incrementer() {
        c.num++
    }

    incrementer
}

main() {
    let f = returnIncrementer()
    f() // c.num increases by 1
}
</code></pre>
<p>为了防止捕获了 <code>var</code> 声明变量的闭包逃逸，这类闭包只能被调用，不能作为一等公民使用，包括不能赋值给变量，不能作为实参或返回值使用，不能直接将闭包的名字作为表达式使用。</p>
<pre><code class="language-cangjie">func f() {
    var x = 1
    let y = 2

    func g() {
        println(x)  // OK, captured a mutable variable.
    }
    let b = g  // Error, g cannot be assigned to a variable

    g  // Error, g cannot be used as an expression
    g()  // OK, g can be invoked

    g  // Error, g cannot be used as a return value.
}
</code></pre>
<p>需要注意的是，捕获具有传递性，如果一个函数 <code>f</code> 调用了捕获 <code>var</code> 变量的函数 <code>g</code>，且存在 <code>g</code> 捕获的 <code>var</code> 变量不在函数 <code>f</code> 内定义，那么函数 <code>f</code> 同样捕获了 <code>var</code> 变量，此时，<code>f</code> 也不能作为一等公民使用。</p>
<p>以下示例中，<code>g</code> 捕获了 <code>var</code> 声明的变量 <code>x</code>，<code>f</code> 调用了 <code>g</code>，且 <code>g</code> 捕获的 <code>x</code> 不在 <code>f</code> 内定义，<code>f</code> 同样不能作为一等公民使用：</p>
<pre><code class="language-cangjie">func h(){
    var x = 1

    func g() {  x }   // captured a mutable variable

    func f() {
        g()      // invoked g
    }
    return f // Error
}
</code></pre>
<p>以下示例中，<code>g</code> 捕获了 <code>var</code> 声明的变量 <code>x</code>，<code>f</code> 调用了 <code>g</code>。但 <code>g</code> 捕获的 <code>x</code> 在 <code>f</code> 内定义，<code>f</code> 没有捕获其它 <code>var</code> 声明的变量。因此，<code>f</code> 仍作为一等公民使用：</p>
<!-- compile -->
<pre><code class="language-cangjie">func h(){
    func f() {
        var x = 1
        func g() { x }   // captured a mutable variable

        g()
    }
    return f // Ok
}
</code></pre>
<p>静态成员变量和全局变量的访问，不属于变量捕获，因此访问了 <code>var</code> 修饰的全局变量、静态成员变量的函数或 lambda 仍可作为一等公民使用。</p>
<!-- compile -->
<pre><code class="language-cangjie">class C {
    static public var a: Int32 = 0
    static public func foo() {
        a++       // OK
        return a
    }
}

var globalV1 = 0

func countGlobalV1() {
    globalV1++
    C.a = 99
    let g = C.foo  // OK
}

func g(){
    let f = countGlobalV1 // OK
    f()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数调用语法糖"><a class="header" href="#函数调用语法糖">函数调用语法糖</a></h1>
<h2 id="尾随-lambda"><a class="header" href="#尾随-lambda">尾随 lambda</a></h2>
<p>尾随 lambda 可以使函数的调用看起来像是语言内置的语法一样，增加语言的可扩展性。</p>
<p>当函数最后一个形参是函数类型，并且函数调用对应的实参是 lambda 时，我们可以使用尾随 lambda 语法，将 lambda 放在函数调用的尾部，圆括号外面。</p>
<p>例如，下例中我们定义了一个 <code>myIf</code> 函数，它的第一个参数是 <code>Bool</code> 类型，第二个参数是函数类型。当第一个参数的值为 <code>true</code> 时，返回第二个参数调用后的值，否则返回 <code>0</code>。调用 <code>myIf</code> 时可以像普通函数一样调用，也可以使用尾随 lambda 的方式调用。</p>
<!-- compile -->
<pre><code class="language-cangjie">func myIf(a: Bool, fn: () -&gt; Int64) {
    if(a) {
        fn()
    } else {
        0
    }
}

func test() {
    myIf(true, { =&gt; 100 }) // General function call

    myIf(true) {        // Trailing closure call
        100
    }
}
</code></pre>
<p>当函数调用有且只有一个 lambda 实参时，我们还可以省略 <code>()</code>，只写 lambda。</p>
<p>示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">func f(fn: (Int64) -&gt; Int64) { fn(1) }

func test() {
    f { i =&gt; i * i }
}
</code></pre>
<h2 id="flow-表达式"><a class="header" href="#flow-表达式">Flow 表达式</a></h2>
<p>流操作符包括两种：表示数据流向的中缀操作符 <code>|&gt;</code> （称为 <code>pipeline</code>）和表示函数组合的中缀操作符 <code>~&gt;</code> （称为 <code>composition</code>）。</p>
<h3 id="pipeline-表达式"><a class="header" href="#pipeline-表达式">Pipeline 表达式</a></h3>
<p>当需要对输入数据做一系列的处理时，可以使用 <code>pipeline</code> 表达式来简化描述。<code>pipeline</code> 表达式的语法形式如下：<code>e1 |&gt; e2</code>。等价于如下形式的语法糖：<code>let v = e1; e2(v)</code> 。</p>
<p>其中 <code>e2</code> 是函数类型的表达式，<code>e1</code> 的类型是 <code>e2</code> 的参数类型的子类型。</p>
<p>示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">func inc(x: Array&lt;Int64&gt;): Array&lt;Int64&gt; { // Increasing the value of each element in the array by '1'
    let s = x.size
    var i = 0
    for (e in x where i &lt; s) {
        x[i] = e + 1
        i++
    }
    x
}

func sum(y: Array&lt;Int64&gt;): Int64 { // Get the sum of elements in the array.
    var s = 0
    for (j in y) {
        s += j
    }
    s
}

let arr: Array&lt;Int64&gt; = Array&lt;Int64&gt;([1, 3, 5])
let res = arr |&gt; inc |&gt; sum // res = 12
</code></pre>
<h3 id="composition-表达式"><a class="header" href="#composition-表达式">Composition 表达式</a></h3>
<p><code>composition</code> 表达式表示两个单参函数的组合。<code>composition</code> 表达式语法如下： <code>f ~&gt; g</code>。等价于如下形式： <code>{ x =&gt; g(f(x)) }</code>。</p>
<p>其中 <code>f</code>，<code>g</code> 均为只有一个参数的函数类型的表达式。</p>
<p><code>f</code> 和 <code>g</code> 组合，则要求 <code>f(x)</code> 的返回类型是 <code>g(...)</code> 的参数类型的子类型。</p>
<p>示例 1：</p>
<!-- compile -->
<pre><code class="language-cangjie">func f(x: Int64): Float64 {
    Float64(x)
}
func g(x: Float64): Float64 {
    x
}

var fg = f ~&gt; g // The same as { x: Int64 =&gt; g(f(x)) }
</code></pre>
<p>示例 2：</p>
<!-- compile -->
<pre><code class="language-cangjie">func f(x: Int64): Float64 {
    Float64(x)
}

let lambdaComp = ({x: Int64 =&gt; x}) ~&gt; f // The same as { x: Int64 =&gt; f({x: Int64 =&gt; x}(x)) }
</code></pre>
<p>示例 3：</p>
<!-- compile -->
<pre><code class="language-cangjie">func h1&lt;T&gt;(x: T): T { x }
func h2&lt;T&gt;(x: T): T { x }
var hh = h1&lt;Int64&gt; ~&gt; h2&lt;Int64&gt; // The same as { x: Int64 =&gt; h2&lt;Int64&gt;(h1&lt;Int64&gt;(x)) }
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p>表达式 f ~&gt; g 中，会先对 f 求值，然后对 g 求值，最后才会进行函数的组合。</p>
</blockquote>
<p>另外，流操作符不能与无默认值的命名形参函数直接一同使用，这是因为无默认值的命名形参函数必须给出命名实参才可以调用。例如：</p>
<pre><code class="language-cangjie">func f(a!: Int64): Unit {}

var a = 1 |&gt; f  // Error
</code></pre>
<p>如果需要使用，用户可以通过 lambda 表达式传入 <code>f</code> 函数的命名实参：</p>
<!-- compile -->
<pre><code class="language-cangjie">func f(a!: Int64): Unit {}

var x = 1 |&gt;  { x: Int64 =&gt; f(a: x) } // Ok
</code></pre>
<p>由于相同的原因，当 <code>f</code> 的参数有默认值时，直接与流运算符一起使用也是错误的，例如：</p>
<pre><code class="language-cangjie">func f(a!: Int64 = 2): Unit {}

var a = 1 |&gt; f // Error
</code></pre>
<p>但是当命名形参都存在默认值时，不需要给出命名实参也可以调用该函数，函数仅需要传入非命名形参，那么这种函数是可以同流运算符一起使用的，例如：</p>
<!-- compile -->
<pre><code class="language-cangjie">func f(a: Int64, b!: Int64 = 2): Unit {}

var a = 1 |&gt; f  // Ok
</code></pre>
<p>当然，如果想要在调用<code>f</code>时，为参数 <code>b</code> 传入其他参数，那么也需要借助 lambda 表达式：</p>
<!-- compile -->
<pre><code class="language-cangjie">func f(a: Int64, b!: Int64 = 2): Unit {}

var a = 1 |&gt; {x: Int64 =&gt; f(x,  b: 3)}  // Ok
</code></pre>
<h2 id="变长参数"><a class="header" href="#变长参数">变长参数</a></h2>
<p>变长参数是一种特殊的函数调用语法糖。当形参最后一个非命名参数是 <code>Array</code> 类型时，实参中对应位置可以直接传入参数序列代替 <code>Array</code> 字面量（参数个数可以是 0 个或多个）。示例如下：</p>
<!-- verify -->
<pre><code class="language-cangjie">func sum(arr: Array&lt;Int64&gt;) {
    var total = 0
    for (x in arr) {
        total += x
    }
    return total
}

main() {
    println(sum())
    println(sum(1, 2, 3))
}
</code></pre>
<p>程序输出：</p>
<pre><code class="language-text">0
6
</code></pre>
<p>需要注意，只有最后一个非命名参数可以作为变长参数，命名参数不能使用这个语法糖。</p>
<pre><code class="language-cangjie">func length(arr!: Array&lt;Int64&gt;) {
    return arr.size
}

main() {
    println(length())        // Error, expected 1 argument, found 0
    println(length(1, 2, 3)) // Error, expected 1 argument, found 3
}
</code></pre>
<p>变长参数可以出现在全局函数、静态成员函数、实例成员函数、局部函数、构造函数、函数变量、lambda、函数调用操作符重载、索引操作符重载的调用处。不支持其他操作符重载、compose、pipeline 这几种调用方式。示例如下：</p>
<!-- verify -->
<pre><code class="language-cangjie">class Counter {
    var total = 0
    init(data: Array&lt;Int64&gt;) { total = data.size }
    operator func ()(data: Array&lt;Int64&gt;) { total += data.size }
}

main() {
    let counter = Counter(1, 2)
    println(counter.total)
    counter(3, 4, 5)
    println(counter.total)
}
</code></pre>
<p>程序输出：</p>
<pre><code class="language-text">2
5
</code></pre>
<p>函数重载决议总是会优先考虑不使用变长参数就能匹配的函数，只有在所有函数都不能匹配，才尝试使用变长参数解析。示例如下：</p>
<!-- verify -->
<pre><code class="language-cangjie">func f&lt;T&gt;(x: T) where T &lt;: ToString {
    println(&quot;item: ${x}&quot;)
}

func f(arr: Array&lt;Int64&gt;) {
    println(&quot;array: ${arr}&quot;)
}

main() {
    f()
    f(1)
    f(1, 2)
}
</code></pre>
<p>程序输出：</p>
<pre><code class="language-text">array: []
item: 1
array: [1, 2]
</code></pre>
<p>当编译器无法决议时会报错：</p>
<pre><code class="language-cangjie">func f(arr: Array&lt;Int64&gt;) { arr.size }
func f(first: Int64, arr: Array&lt;Int64&gt;) { first + arr.size }

main() {
    println(f(1, 2, 3)) // Error
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数重载"><a class="header" href="#函数重载">函数重载</a></h1>
<h2 id="函数重载定义"><a class="header" href="#函数重载定义">函数重载定义</a></h2>
<p>在仓颉编程语言中，如果一个作用域中，一个函数名对应多个函数定义，这种现象称为函数重载。</p>
<ul>
<li>
<p>函数名相同，函数参数不同（是指参数个数不同，或者参数个数相同但参数类型不同）的两个函数构成重载。示例如下：</p>
<!-- compile -->
<pre><code class="language-cangjie">// Scenario 1
func f(a: Int64): Unit {
}

func f(a: Float64): Unit {
}

func f(a: Int64, b: Float64): Unit {
}
</code></pre>
</li>
<li>
<p>对于两个同名泛型函数，如果重命名一个函数的泛型形参后，其非泛型部分与另一个函数的非泛型部分函数参数不同，则两个函数构成重载，否则这两个泛型函数构成重复定义错误（类型变元的约束不参与判断）。示例如下：</p>
<pre><code class="language-cangjie">interface I1{}
interface I2{}

func f1&lt;X, Y&gt;(a: X, b: Y) {}
func f1&lt;Y, X&gt;(a: X, b: Y) {} // Ok: after rename generic type parameter, it will be 'func f1&lt;X, Y&gt;(a: Y, b: X)'

func f2&lt;T&gt;(a: T) where T &lt;: I1 {}
func f2&lt;T&gt;(a: T) where T &lt;: I2 {} // Error, not overloading
</code></pre>
</li>
<li>
<p>同一个类内的两个构造函数参数不同，构成重载。示例如下：</p>
<!-- compile -->
<pre><code class="language-cangjie">// Scenario 2
class C {
    var a: Int64
    var b: Float64

    public init(a: Int64, b: Float64) {
        this.a = a
        this.b = b
    }

    public init(a: Int64) {
        b = 0.0
        this.a = a
    }
}
</code></pre>
</li>
<li>
<p>同一个类内的主构造函数和 <code>init</code> 构造函数参数不同，构成重载（认为主构造函数和 <code>init</code> 函数具有相同的名字）。示例如下：</p>
<!-- compile -->
<pre><code class="language-cangjie">// Scenario 3
class C {
    C(var a!: Int64, var b!: Float64) {
        this.a = a
        this.b = b
    }

    public init(a: Int64) {
        b = 0.0
        this.a = a
    }
}
</code></pre>
</li>
<li>
<p>两个函数定义在不同的作用域，在两个函数可见的作用域中构成重载。示例如下：</p>
<!-- compile -->
<pre><code class="language-cangjie">// Scenario 4
func f(a: Int64): Unit {
}

func g() {
    func f(a: Float64): Unit {
    }
}
</code></pre>
</li>
<li>
<p>两个函数分别定义在父类和子类中，在两个函数可见的作用域中构成重载。示例如下：</p>
<!-- compile -->
<pre><code class="language-cangjie">// Scenario 5
open class Base {
    public func f(a: Int64): Unit {
    }
}

class Sub &lt;: Base {
    public func f(a: Float64): Unit {
    }
}
</code></pre>
</li>
</ul>
<p>只允许函数声明引入的函数重载，但是以下情形不构成重载，不构成重载的两个名字不能定义或声明在同一个作用域内：</p>
<ul>
<li>class、interface、struct 类型的静态成员函数和实例成员函数之间不能重载</li>
<li>enum 类型的 constructor、静态成员函数和实例成员函数之间不能重载</li>
</ul>
<p>如下示例，两个变量均为函数类型且函数参数类型不同，但由于它们不是函数声明所以不能重载，如下示例将编译报错（重定义错）：</p>
<pre><code class="language-cangjie">main() {
    var f: (Int64) -&gt; Unit
    var f: (Float64) -&gt; Unit
}
</code></pre>
<p>如下示例，虽然变量 <code>f</code> 为函数类型，但由于变量和函数之间不能同名，如下示例将编译报错（重定义错）：</p>
<pre><code class="language-cangjie">main() {
    var f: (Int64) -&gt; Unit

    func f(a: Float64): Unit {   // Error, functions and variables cannot have the same name.
    }
}
</code></pre>
<p>如下示例，静态成员函数 <code>f</code> 与实例成员函数 <code>f</code> 的参数类型不同，但由于类内静态成员函数和实例成员函数之间不能重载，如下示例将编译报错：</p>
<pre><code class="language-cangjie">class C {
    public static func f(a: Int64): Unit {
    }
    public func f(a: Float64): Unit {
    }
}
</code></pre>
<h2 id="函数重载决议"><a class="header" href="#函数重载决议">函数重载决议</a></h2>
<p>函数调用时，所有可被调用的函数（是指当前作用域可见且能通过类型检查的函数）构成候选集，候选集中有多个函数，究竟选择候选集中哪个函数，需要进行函数重载决议，有如下规则：</p>
<ul>
<li>
<p>优先选择作用域级别高的作用域内的函数。在嵌套的表达式或函数中，越是内层作用域级别越高。</p>
<p>如下示例中在 <code>inner</code> 函数体内调用 <code>g(Sub())</code> 时，候选集包括 <code>inner</code> 函数内定义的函数 <code>g</code> 和 <code>inner</code> 函数外定义的函数 <code>g</code>，函数决议选择作用域级别更高的 <code>inner</code> 函数内定义的函数 <code>g</code>。</p>
<!-- compile -->
<pre><code class="language-cangjie">open class Base {}
class Sub &lt;: Base {}

func outer() {
    func g(a: Sub) {
        print(&quot;1&quot;)
    }

    func inner() {
        func g(a: Base) {
            print(&quot;2&quot;)
        }

        g(Sub())   // Output: 2
    }
}
</code></pre>
</li>
<li>
<p>如果作用域级别相对最高的仍有多个函数，则需要选择最匹配的函数（对于函数 f 和 g 以及给定的实参，如果 f 可以被调用时 g 也总是可以被调用的，但反之不然，则我们称 f 比 g 更匹配）。如果不存在唯一最匹配的函数，则报错。</p>
<p>如下示例中，两个函数 <code>g</code> 定义在同一作用域，选择更匹配的函数 <code>g(a: Sub): Unit</code>。</p>
<!-- compile -->
<pre><code class="language-cangjie">open class Base {}
class Sub &lt;: Base {}

func outer() {
    func g(a: Sub) {
        print(&quot;1&quot;)
    }
    func g(a: Base) {
        print(&quot;2&quot;)
    }

    g(Sub())   // Output: 1

}
</code></pre>
</li>
<li>
<p>子类和父类认为是同一作用域。如下示例中，一个函数 <code>g</code> 定义在父类中，另一个函数 <code>g</code> 定义在子类中，在调用 <code>s.g(Sub())</code> 时，两个函数 <code>g</code> 当成同一作用域级别决议，则选择更匹配的父类中定义的函数 <code>g(a: Sub): Unit</code>。</p>
<!-- compile -->
<pre><code class="language-cangjie">open class Base {
    public func g(a: Sub) { print(&quot;1&quot;) }
}

class Sub &lt;: Base {
    public func g(a: Base) {
        print(&quot;2&quot;)
    }
}

func outer() {
    let s: Sub = Sub()
    s.g(Sub())   // Output: 1
}
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="操作符重载"><a class="header" href="#操作符重载">操作符重载</a></h1>
<p>如果希望在某个类型上支持此类型默认不支持的操作符，可以使用操作符重载实现。</p>
<p>如果需要在某个类型上重载某个操作符，可以通过为类型定义一个函数名为此操作符的函数的方式实现，这样，在该类型的实例使用该操作符时，就会自动调用此操作符函数。</p>
<p>操作符函数定义与普通函数定义相似，区别如下：</p>
<ul>
<li>定义操作符函数时需要在 <code>func</code> 关键字前面添加 <code>operator</code> 修饰符；</li>
<li>操作符函数的参数个数需要匹配对应操作符的要求（详见附录<a href="source_zh_cn/function/../Appendix/operator.html">操作符</a>）；</li>
<li>操作符函数只能定义在 class、interface、struct、enum 和 extend 中；</li>
<li>操作符函数具有实例成员函数的语义，所以禁止使用 <code>static</code> 修饰符；</li>
<li>操作符函数不能为泛型函数。</li>
</ul>
<p>另外，需要注意的是，被重载后的操作符不改变它们固有的优先级和结合性（详见附录<a href="source_zh_cn/function/../Appendix/operator.html">操作符</a>）。</p>
<h2 id="操作符重载函数定义和使用"><a class="header" href="#操作符重载函数定义和使用">操作符重载函数定义和使用</a></h2>
<p>定义操作符函数有两种方式：</p>
<ol>
<li>对于可以直接包含函数定义的类型 (包括 <code>struct</code>、<code>enum</code>、<code>class</code> 和 <code>interface</code> )，可以直接在其内部定义操作符函数的方式实现操作符的重载。</li>
<li>使用 <code>extend</code> 的方式为其添加操作符函数，从而实现操作符在这些类型上的重载。对于无法直接包含函数定义的类型（是指除 <code>struct</code>、<code>class</code>、<code>enum</code> 和 <code>interface</code> 之外其他的类型）或无法改变其实现的类型，比如第三方定义的 <code>struct</code>、<code>class</code>、<code>enum</code> 和 <code>interface</code>，只能采用这种方式（参见<a href="source_zh_cn/function/../extension/extend_overview.html">扩展</a>）；</li>
</ol>
<p>操作符函数对参数类型的约定如下：</p>
<ol>
<li>
<p>对于一元操作符，操作符函数没有参数，对返回值的类型没有要求。</p>
</li>
<li>
<p>对于二元操作符，操作符函数只有一个参数，对返回值的类型没有要求。</p>
<p>如下示例中介绍了一元操作符和二元操作符的定义和使用：</p>
<p><code>-</code> 实现对一个 <code>Point</code> 实例中两个成员变量 <code>x</code> 和 <code>y</code> 取负值，然后返回一个新的 <code>Point</code> 对象，<code>+</code> 实现对两个 <code>Point</code> 实例中两个成员变量 <code>x</code> 和 <code>y</code> 分别求和，然后返回一个新的 <code>Point</code> 对象。</p>
<!-- run -overloadOperater -->
<pre><code class="language-cangjie">open class Point {
    var x: Int64 = 0
    var y: Int64 = 0
    public init (a: Int64, b: Int64) {
        x = a
        y = b
    }

    public operator func -(): Point {
        Point(-x, -y)
    }
    public operator func +(right: Point): Point {
        Point(this.x + right.x, this.y + right.y)
    }
}
</code></pre>
<p>接下来，就可以在 <code>Point</code> 的实例上直接使用一元 <code>-</code> 操作符和二元 <code>+</code> 操作符：</p>
<!-- run -overloadOperater -->
<pre><code class="language-cangjie">main() {
    let p1 = Point(8, 24)
    let p2 = -p1      // p2 = Point(-8, -24)
    let p3 = p1 + p2  // p3 = Point(0, 0)
}
</code></pre>
</li>
<li>
<p>索引操作符（<code>[]</code>）分为取值 <code>let a = arr[i]</code> 和赋值 <code>arr[i] = a</code> 两种形式，它们通过是否存在特殊的命名参数 value 来区分不同的重载。索引操作符重载不要求同时重载两种形式，可以只重载赋值不重载取值，反之亦可。</p>
<p>索引操作符取值形式 <code>[]</code> 内的参数序列对应操作符重载的非命名参数，可以是 1 个或多个，可以是任意类型。不可以有其它命名参数。返回类型可以是任意类型。</p>
<!-- compile -->
<pre><code class="language-cangjie">class A {
    operator func [](arg1: Int64, arg2: String): Int64 {
        return 0
    }
}

func f() {
    let a = A()
    let b: Int64 = a[1, &quot;2&quot;]
    // b == 0
}
</code></pre>
<p>索引操作符赋值形式 <code>[]</code> 内的参数序列对应操作符重载的非命名参数，可以是 1 个或多个，可以是任意类型。<code>=</code> 右侧的表达式对应操作符重载的命名参数，有且只能有一个命名参数，该命名参数的名称必须是 value, 不能有默认值，value 可以是任意类型。返回类型必须是 Unit 类型。</p>
<p>需要注意的是，value 只是一种特殊的标记，在索引操作符赋值时并不需要使用命名参数的形式调用。</p>
<!-- compile -->
<pre><code class="language-cangjie">class A {
    operator func [](arg1: Int64, arg2: String, value!: Int64): Unit {
        return
    }
}

func f() {
    let a = A()
    a[1, &quot;2&quot;] = 0
}
</code></pre>
<p>特别的，除 <code>enum</code> 外的不可变类型不支持重载索引操作符赋值形式。</p>
</li>
<li>
<p>函数调用操作符（<code>()</code>）重载函数，输入参数和返回值类型可以是任意类型。示例如下：</p>
<!-- compile -->
<pre><code class="language-cangjie">open class A {
    public init() {}

    public operator func ()(): Unit {}
}

func test1() {
    let a = A() // Ok, A() is call the constructor of A.
    a() // Ok, a() is to call the operator () overloading function.
}
</code></pre>
<p>不能使用 <code>this</code> 或 <code>super</code> 调用 <code>()</code> 操作符重载函数。示例如下：</p>
<pre><code class="language-cangjie">open class A {
    public init() {}
    public init(x: Int64) {
        this() // Ok, this() calls the constructor of A.
    }

    public operator func ()(): Unit {}

    public func foo() {
        this()  // Error, this() calls the constructor of A.
        super() // Error
    }
}

class B &lt;: A {
    public init() {
        super() // Ok, super()  calls the constuctor of the super class.
    }

    public func goo() {
        super() // Error
    }
}
</code></pre>
<p>对于枚举类型，当构造器形式和 <code>()</code> 操作符重载函数形式都满足时，优先匹配构造器形式。示例如下：</p>
<!-- compile -->
<pre><code class="language-cangjie">enum E {
    Y | X | X(Int64)

    public operator func ()(p: Int64) {}
    public operator func ()(p: Float64) {}
}

main() {
    let e = X(1) // Ok, X(1) is to call the constructor X(Int64).
    X(1.0) // Ok, X(1.0) is to call the operator () overloading function.
    let e1 = X
    e1(1) // Ok, e1(1) is to call the operator () overloading function.
    Y(1) // oK, Y(1) is to call the operator () overloading function.
}
</code></pre>
</li>
</ol>
<h2 id="可以被重载的操作符"><a class="header" href="#可以被重载的操作符">可以被重载的操作符</a></h2>
<p>下表列出了所有可以被重载的操作符（优先级从高到低）：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Operator</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>()</code></td><td style="text-align: left">Function call</td></tr>
<tr><td style="text-align: left"><code>[]</code></td><td style="text-align: left">Indexing</td></tr>
<tr><td style="text-align: left"><code>!</code></td><td style="text-align: left">NOT</td></tr>
<tr><td style="text-align: left"><code>-</code></td><td style="text-align: left">Negative</td></tr>
<tr><td style="text-align: left"><code>**</code></td><td style="text-align: left">Power</td></tr>
<tr><td style="text-align: left"><code>*</code></td><td style="text-align: left">Multiply</td></tr>
<tr><td style="text-align: left"><code>/</code></td><td style="text-align: left">Divide</td></tr>
<tr><td style="text-align: left"><code>%</code></td><td style="text-align: left">Remainder</td></tr>
<tr><td style="text-align: left"><code>+</code></td><td style="text-align: left">Add</td></tr>
<tr><td style="text-align: left"><code>-</code></td><td style="text-align: left">Subtract</td></tr>
<tr><td style="text-align: left"><code>&lt;&lt;</code></td><td style="text-align: left">Bitwise left shift</td></tr>
<tr><td style="text-align: left"><code>&gt;&gt;</code></td><td style="text-align: left">Bitwise right shift</td></tr>
<tr><td style="text-align: left"><code>&lt;</code></td><td style="text-align: left">Less than</td></tr>
<tr><td style="text-align: left"><code>&lt;=</code></td><td style="text-align: left">Less than or equal</td></tr>
<tr><td style="text-align: left"><code>&gt;</code></td><td style="text-align: left">Greater than</td></tr>
<tr><td style="text-align: left"><code>&gt;=</code></td><td style="text-align: left">Greater than or equal</td></tr>
<tr><td style="text-align: left"><code>==</code></td><td style="text-align: left">Equal</td></tr>
<tr><td style="text-align: left"><code>!=</code></td><td style="text-align: left">Not equal</td></tr>
<tr><td style="text-align: left"><code>&amp;</code></td><td style="text-align: left">Bitwise AND</td></tr>
<tr><td style="text-align: left"><code>^</code></td><td style="text-align: left">Bitwise XOR</td></tr>
<tr><td style="text-align: left"><code>|</code></td><td style="text-align: left">Bitwise OR</td></tr>
</tbody></table>
</div>
<p>需要注意的是：</p>
<ol>
<li>一旦在某个类型上重载了除关系操作符（<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>==</code>和<code>!=</code>）之外的其他二元操作符，并且操作符函数的返回类型与左操作数的类型一致或是其子类型，那么此类型支持对应的复合赋值操作符。当操作符函数的返回类型与左操作数的类型不一致且不是其子类型时，在使用对应的复合赋值符号时将报类型不匹配错误。</li>
<li>仓颉编程语言不支持自定义操作符，即不允许定义除上表中所列 <code>operator</code> 之外的其他操作符函数。</li>
<li>对于类型 <code>T</code>, 如果 <code>T</code> 已经默认支持了上述若干可重载操作符，那么通过扩展的方式再次为其实现同签名的操作符函数时将报重定义错误。例如，为数值类型重载其已支持的同签名算术操作符、位操作符或关系操作符等操作符时，为 <code>Rune</code> 重载同签名的关系操作符时，为 <code>Bool</code> 类型重载同签名的逻辑操作符、判等或不等操作符时，等等这些情况，均会报重定义错误。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="const-函数和常量求值"><a class="header" href="#const-函数和常量求值">const 函数和常量求值</a></h1>
<p>常量求值允许某些特定形式的表达式在编译时求值，可以减少程序运行时需要的计算。本章主要介绍常量求值的使用方法与规则。</p>
<h2 id="const-变量"><a class="header" href="#const-变量"><code>const</code> 变量</a></h2>
<p><code>const</code> 变量是一种特殊的变量，它以关键字 <code>const</code> 修饰，定义在编译时完成求值，并且在运行时不可改变的变量。例如，下面的例子定义了万有引力常数 <code>G</code>：</p>
<!-- verify -const -->
<pre><code class="language-cangjie">const G = 6.674e-11
</code></pre>
<p><code>const</code> 变量可以省略类型标注，但是不可省略初始化表达式。<code>const</code> 变量可以是全局变量，局部变量，静态成员变量。但是 <code>const</code> 变量不能在扩展中定义。<code>const</code> 变量可以访问对应类型的所有实例成员，也可以调用对应类型的所有非 <code>mut</code> 实例成员函数。</p>
<p>下例定义了一个 <code>struct</code>，记录行星的质量和半径，同时定义了一个 <code>const</code> 成员函数 <code>gravity</code> 用来计算该行星对距离为 <code>r</code> 质量为 <code>m</code> 的物体的万有引力：</p>
<!-- verify -const -->
<pre><code class="language-cangjie">struct Planet {
    const Planet(let mass: Float64, let radius: Float64) {}

    const func gravity(m: Float64, r: Float64) {
        G * mass * m / r**2
    }
}

main() {
    const myMass = 71.0
    const earth = Planet(5.972e24, 6.378e6)
    println(earth.gravity(myMass, earth.radius))
}
</code></pre>
<p>编译执行得到地球对地面上一个质量为 71 kg 的成年人的万有引力：</p>
<!-- verify -const -->
<pre><code class="language-text">695.657257
</code></pre>
<p><code>const</code> 变量初始化后该类型实例的所有成员都是 <code>const</code> 的（深度 <code>const</code>，包含成员的成员），因此不能被用于左值。</p>
<pre><code class="language-cangjie">main() {
    const myMass = 71.0
    myMass = 70.0 // Error, cannot assign to immutable value
}
</code></pre>
<h2 id="const-上下文与-const-表达式"><a class="header" href="#const-上下文与-const-表达式"><code>const</code> 上下文与 <code>const</code> 表达式</a></h2>
<p><code>const</code> 上下文是指 <code>const</code> 变量初始化表达式，这些表达式始终在编译时求值。因此需要对 <code>const</code> 上下文中允许的表达式加以限制，避免修改全局状态、I/O 等副作用，确保其可以在编译时求值。</p>
<p><code>const</code> 表达式具备了可以在编译时求值的能力。满足如下规则的表达式是 <code>const</code> 表达式：</p>
<ol>
<li>数值类型、<code>Bool</code>、<code>Unit</code>、<code>Rune</code>、<code>String</code> 类型的字面量（不包含插值字符串）。</li>
<li>所有元素都是 <code>const</code> 表达式的 <code>Array</code> 字面量（不能是 <code>Array</code> 类型，可以使用 <code>VArray</code> 类型），<code>tuple</code> 字面量。</li>
<li><code>const</code> 变量，<code>const</code> 函数形参，<code>const</code> 函数中的局部变量。</li>
<li><code>const</code> 函数，包含使用 <code>const</code> 声明的函数名、符合 <code>const</code> 函数要求的 <code>lambda</code>、以及这些函数返回的函数表达式。</li>
<li><code>const</code> 函数调用（包含 <code>const</code> 构造函数），该函数的表达式必须是 <code>const</code> 表达式，所有实参必须都是 <code>const</code> 表达式。</li>
<li>所有参数都是 <code>const</code> 表达式的 <code>enum</code> 构造器调用，和无参数的 <code>enum</code> 构造器。</li>
<li>数值类型、<code>Bool</code>、<code>Unit</code>、<code>Rune</code>、<code>String</code> 类型的算术表达式、关系表达式、位运算表达式，所有操作数都必须是 <code>const</code> 表达式。</li>
<li><code>if</code>、<code>match</code>、<code>try</code>、控制转移表达式（包含 <code>return</code>、<code>break</code>、<code>continue</code>、<code>throw</code>）、<code>is</code>、<code>as</code>。这些表达式内的表达式必须都是 <code>const</code> 表达式。</li>
<li><code>const</code> 表达式的成员访问（不包含属性的访问），<code>tuple</code> 的索引访问。</li>
<li><code>const init</code> 和 <code>const</code> 函数中的 <code>this</code> 和 <code>super</code> 表达式。</li>
<li><code>const</code> 表达式的 <code>const</code> 实例成员函数调用，且所有实参必须都是 <code>const</code> 表达式。</li>
</ol>
<h2 id="const-函数"><a class="header" href="#const-函数"><code>const</code> 函数</a></h2>
<p><code>const</code> 函数是一类特殊的函数，这些函数具备了可以在编译时求值的能力。在 <code>const</code> 上下文中调用这种函数时，这些函数会在编译时执行计算。而在其它非 <code>const</code> 上下文，<code>const</code> 函数会和普通函数一样在运行时执行。</p>
<p>下例是一个计算平面上两点距离的 <code>const</code> 函数，<code>distance</code> 中使用 <code>let</code> 定义了两个局部变量 <code>dx</code> 和 <code>dy</code>：</p>
<!-- verify -->
<pre><code class="language-cangjie">struct Point {
    const Point(let x: Float64, let y: Float64) {}
}

const func distance(a: Point, b: Point) {
    let dx = a.x - b.x
    let dy = a.y - b.y
    (dx**2 + dy**2)**0.5
}

main() {
    const a = Point(3.0, 0.0)
    const b = Point(0.0, 4.0)
    const d = distance(a, b)
    println(d)
}
</code></pre>
<p>编译运行输出：</p>
<pre><code class="language-text">5.000000
</code></pre>
<p>需要注意：</p>
<ol>
<li><code>const</code> 函数声明必须使用 <code>const</code> 修饰。</li>
<li>全局 <code>const</code> 函数和 <code>static const</code> 函数中只能访问 <code>const</code> 声明的外部变量，包含 <code>const</code> 全局变量、<code>const</code> 静态成员变量，其它外部变量都不可访问。<code>const init</code> 函数和 <code>const</code> 实例成员函数除了能访问 <code>const</code> 声明的外部变量，还可以访问当前类型的实例成员变量。</li>
<li><code>const</code> 函数中的表达式都必须是 <code>const</code> 表达式，<code>const init</code> 函数除外。</li>
<li><code>const</code> 函数中可以使用 <code>let</code>、<code>const</code> 声明新的局部变量。但不支持 <code>var</code>。</li>
<li><code>const</code> 函数中的参数类型和返回类型没有特殊规定。如果该函数调用的实参不符合 <code>const</code> 表达式要求，那这个函数调用不能作为 <code>const</code> 表达式使用，但仍然可以作为普通表达式使用。</li>
<li><code>const</code> 函数不一定都会在编译时执行，例如可以在非 <code>const</code> 函数中运行时调用。</li>
<li><code>const</code> 函数与非 <code>const</code> 函数重载规则一致。</li>
<li>数值类型、<code>Bool</code>、<code>Unit</code>、<code>Rune</code>、<code>String</code> 类型 和 <code>enum</code> 支持定义 <code>const</code> 实例成员函数。</li>
<li>对于 <code>struct</code> 和 <code>class</code>，只有定义了 <code>const init</code> 才能定义 <code>const</code> 实例成员函数。<code>class</code> 中的 <code>const</code> 实例成员函数不能是 <code>open</code> 的。<code>struct</code> 中的 <code>const</code> 实例成员函数不能是 <code>mut</code> 的。</li>
</ol>
<p>另外，接口中也可以定义 <code>const</code> 函数，但会受到以下规则限制：</p>
<ol>
<li>接口中的 <code>const</code> 函数，实现类型必须也用 <code>const</code> 函数才算实现接口。</li>
<li>接口中的非 <code>const</code> 函数，实现类型使用 <code>const</code> 或非 <code>const</code> 函数都算实现接口。</li>
<li>接口中的 <code>const</code> 函数与接口的 <code>static</code> 函数一样，只有在该接口作为泛型约束的时候，受约束的泛型变元或变量才能使用这些 <code>const</code> 函数。</li>
</ol>
<p>在下面的例子中，在接口 <code>I</code> 里定义了两个 <code>const</code> 函数，类 <code>A</code> 实现了接口 <code>I</code>，泛型函数 <code>g</code> 的形参类型上界是 <code>I</code>。</p>
<!-- verify -->
<pre><code class="language-cangjie">interface I {
    const func f(): Int64
    const static func f2(): Int64
}

class A &lt;: I {
    public const func f() { 0 }
    public const static func f2() { 1 }
    const init() {}
}

const func g&lt;T&gt;(i: T) where T &lt;: I {
    return i.f() + T.f2()
}

main() {
    println(g(A()))
}
</code></pre>
<p>编译执行上述代码，输出结果为：</p>
<pre><code class="language-text">1
</code></pre>
<h2 id="const-init"><a class="header" href="#const-init"><code>const init</code></a></h2>
<p>如果一个 <code>struct</code> 或 <code>class</code> 定义了 <code>const</code> 构造器，那么这个 <code>struct</code>/<code>class</code> 实例可以用在 <code>const</code> 表达式中。</p>
<ol>
<li>如果当前类型是 <code>class</code>，则不能具有 <code>var</code> 声明的实例成员变量，否则不允许定义 <code>const init</code> 。如果当前类型具有父类，当前的 <code>const init</code> 必须调用父类的 <code>const init</code>（可以显式调用或者隐式调用无参<code>const init</code>），如果父类没有 <code>const init</code> 则报错。</li>
<li>当前类型的实例成员变量如果有初始值，初始值必须要是 <code>const</code> 表达式，否则不允许定义 <code>const init</code>。</li>
<li><code>const init</code> 内可以使用赋值表达式对实例成员变量赋值，除此以外不能有其它赋值表达式。</li>
</ol>
<p><code>const init</code> 与 <code>const</code> 函数的区别是 <code>const init</code> 内允许对实例成员变量进行赋值（需要使用赋值表达式）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="定义-struct-类型"><a class="header" href="#定义-struct-类型">定义 struct 类型</a></h1>
<p><code>struct</code> 类型的定义以关键字 <code>struct</code> 开头，后跟 <code>struct</code> 的名字，接着是定义在一对花括号中的 <code>struct</code> 定义体。<code>struct</code> 定义体中可以定义一系列的成员变量、成员属性（参见<a href="source_zh_cn/struct/../class_and_interface/prop.html">属性</a>）、静态初始化器、构造函数和成员函数。</p>
<!-- compile -->
<pre><code class="language-cangjie">struct Rectangle {
    let width: Int64
    let height: Int64

    public init(width: Int64, height: Int64) {
        this.width = width
        this.height = height
    }

    public func area() {
        width * height
    }
}
</code></pre>
<p>上例中定义了名为 <code>Rectangle</code> 的 <code>struct</code> 类型，它有两个 <code>Int64</code> 类型的成员变量 <code>width</code> 和 <code>height</code>，一个有两个 <code>Int64</code> 类型参数的构造函数（使用关键字 <code>init</code> 定义，函数体中通常是对成员变量的初始化），以及一个成员函数 <code>area</code>（返回 <code>width</code> 和 <code>height</code> 的乘积）。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p><code>struct</code> 只能定义在源文件顶层。</p>
</blockquote>
<h2 id="struct-成员变量"><a class="header" href="#struct-成员变量">struct 成员变量</a></h2>
<p><code>struct</code> 成员变量分为实例成员变量和静态成员变量（使用 <code>static</code> 修饰符修饰，且必须有初值），二者的区别在于实例成员变量只能通过 <code>struct</code> 实例（我们说 <code>a</code> 是 <code>T</code> 类型的实例，指的是 <code>a</code> 是一个 <code>T</code> 类型的值）访问，静态成员变量只能通过 <code>struct</code> 类型名访问。</p>
<p>实例成员变量定义时可以不设置初值（但必须标注类型，如上例中的 <code>width</code> 和 <code>height</code>），也可以设置初值，例如：</p>
<!-- compile -->
<pre><code class="language-cangjie">struct Rectangle {
    let width = 10
    let height = 20
}
</code></pre>
<h2 id="struct-静态初始化器"><a class="header" href="#struct-静态初始化器">struct 静态初始化器</a></h2>
<p><code>struct</code> 支持定义静态初始化器，并在静态初始化器中通过赋值表达式来对静态成员变量进行初始化。</p>
<p>静态初始化器以关键字组合 <code>static init</code> 开头，后跟无参参数列表和函数体，且不能被访问修饰符修饰。函数体中必须完成对所有未初始化的静态成员变量的初始化，否则编译报错。</p>
<!-- compile -->
<pre><code class="language-cangjie">struct Rectangle {
    static let degree: Int64
    static init() {
        degree = 180
    }
}
</code></pre>
<p>一个 <code>struct</code> 中最多允许定义一个静态初始化器，否则报重定义错误。</p>
<pre><code class="language-cangjie">struct Rectangle {
    static let degree: Int64
    static init() {
        degree = 180
    }
    static init() { // Error, redefinition with the previous static init function
        degree = 180
    }
}
</code></pre>
<h2 id="struct-构造函数"><a class="header" href="#struct-构造函数">struct 构造函数</a></h2>
<p><code>struct</code> 支持两类构造函数：普通构造函数和主构造函数。</p>
<p>普通构造函数以关键字 <code>init</code> 开头，后跟参数列表和函数体，函数体中必须完成对所有未初始化的实例成员变量的初始化（如果参数名和成员变量名无法区分，可以在成员变量前使用 <code>this</code> 加以区分，<code>this</code> 表示 <code>struct</code> 的当前实例），否则编译报错。</p>
<pre><code class="language-cangjie">struct Rectangle {
    let width: Int64
    let height: Int64

    public init(width: Int64, height: Int64) { // Error, 'height' is not initialized in the constructor
        this.width = width
    }
}
</code></pre>
<p>一个 <code>struct</code> 中可以定义多个普通构造函数，但它们必须构成重载（参见<a href="source_zh_cn/struct/../function/function_overloading.html">函数重载</a>），否则报重定义错误。</p>
<pre><code class="language-cangjie">struct Rectangle {
    let width: Int64
    let height: Int64

    public init(width: Int64) {
        this.width = width
        this.height = width
    }

    public init(width: Int64, height: Int64) { // Ok: overloading with the first init function
        this.width = width
        this.height = height
    }

    public init(height: Int64) { // Error, redefinition with the first init function
        this.width = height
        this.height = height
    }
}
</code></pre>
<p>除了可以定义若干普通的以 <code>init</code> 为名字的构造函数外，<code>struct</code> 内还可以定义（最多）一个主构造函数。主构造函数的名字和 <code>struct</code> 类型名相同，它的参数列表中可以有两种形式的形参：普通形参和成员变量形参（需要在参数名前加上 <code>let</code> 或 <code>var</code>），成员变量形参同时扮演定义成员变量和构造函数参数的功能。</p>
<p>使用主构造函数通常可以简化 <code>struct</code> 的定义，例如，上述包含一个 <code>init</code> 构造函数的 <code>Rectangle</code> 可以简化为如下定义：</p>
<!-- compile -->
<pre><code class="language-cangjie">struct Rectangle {
    public Rectangle(let width: Int64, let height: Int64) {}
}
</code></pre>
<p>主构造函数的参数列表中也可以定义普通形参，例如：</p>
<!-- compile -->
<pre><code class="language-cangjie">struct Rectangle {
    public Rectangle(name: String, let width: Int64, let height: Int64) {}
}
</code></pre>
<p>如果 <code>struct</code> 定义中不存在自定义构造函数（包括主构造函数），并且所有实例成员变量都有初始值，则会自动为其生成一个无参构造函数（调用此无参构造函数会创建一个所有实例成员变量的值均等于其初值的对象）；否则，不会自动生成此无参构造函数。例如，对于如下 <code>struct</code> 定义，注释中给出了自动生成的无参构造函数：</p>
<!-- compile -->
<pre><code class="language-cangjie">struct Rectangle {
    let width: Int64 = 10
    let height: Int64 = 10
    /* Auto-generated memberwise constructor:
    public init() {
    }
    */
}
</code></pre>
<h2 id="struct-成员函数"><a class="header" href="#struct-成员函数">struct 成员函数</a></h2>
<p><code>struct</code> 成员函数分为实例成员函数和静态成员函数（使用 <code>static</code> 修饰符修饰），二者的区别在于：实例成员函数只能通过 <code>struct</code> 实例访问，静态成员函数只能通过 <code>struct</code> 类型名访问；静态成员函数中不能访问实例成员变量，也不能调用实例成员函数，但在实例成员函数中可以访问静态成员变量以及静态成员函数。</p>
<p>下例中，<code>area</code> 是实例成员函数，<code>typeName</code> 是静态成员函数。</p>
<!-- compile -->
<pre><code class="language-cangjie">struct Rectangle {
    let width: Int64 = 10
    let height: Int64 = 20

    public func area() {
        this.width * this.height
    }

    public static func typeName(): String {
        &quot;Rectangle&quot;
    }
}
</code></pre>
<p>实例成员函数中可以通过 <code>this</code> 访问实例成员变量，例如：</p>
<!-- compile -->
<pre><code class="language-cangjie">struct Rectangle {
    let width: Int64 = 1
    let height: Int64 = 1

    public func area() {
        this.width * this.height
    }
}
</code></pre>
<h2 id="struct-成员的访问修饰符"><a class="header" href="#struct-成员的访问修饰符">struct 成员的访问修饰符</a></h2>
<p><code>struct</code> 的成员（包括成员变量、成员属性、构造函数、成员函数、操作符函数（详见<a href="source_zh_cn/struct/../function/operator_overloading.html">操作符重载</a>章节））用 4 种访问修饰符修饰：<code>private</code>、<code>internal</code>、<code>protected</code> 和 <code>public</code>，缺省的含义是 <code>internal</code>。</p>
<ul>
<li><code>private</code> 表示在 <code>struct</code> 定义内可见。</li>
<li><code>internal</code> 表示仅当前包及子包（包括子包的子包，详见<a href="source_zh_cn/struct/../package/toplevel_access.html">包</a>章节）内可见。</li>
<li><code>protected</code> 表示当前模块（详见<a href="source_zh_cn/struct/../package/toplevel_access.html">包</a>章节）可见。</li>
<li><code>public</code> 表示模块内外均可见。</li>
</ul>
<p>下面的例子中，<code>width</code> 是 <code>public</code> 修饰的成员，在类外可以访问，<code>height</code> 是缺省访问修饰符的成员，仅在当前包及子包可见，其他包无法访问。</p>
<pre><code class="language-cangjie">package a
public struct Rectangle {
    public var width: Int64
    var height: Int64
    private var area: Int64
    ...
}

func samePkgFunc() {
    var r = Rectangle(10, 20)
    r.width = 8               // Ok: public 'width' can be accessed here
    r.height = 24             // Ok: 'height' has no modifier and can be accessed here
    r.area = 30               // Error, private 'area' can't be accessed here
}
</code></pre>
<pre><code class="language-cangjie">package b
import a.*
main() {
    var r = Rectangle(10, 20)
    r.width = 8               // Ok: public 'width' can be accessed here
    r.height = 24             // Error, no modifier 'height' can't be accessed here
    r.area = 30               // Error, private 'area' can't be accessed here
}
</code></pre>
<h2 id="禁止递归-struct"><a class="header" href="#禁止递归-struct">禁止递归 struct</a></h2>
<p>递归和互递归定义的 <code>struct</code> 均是非法的。例如：</p>
<pre><code class="language-cangjie">struct R1 { // Error, 'R1' recursively references itself
    let other: R1
}
struct R2 { // Error, 'R2' and 'R3' are mutually recursive
    let other: R3
}
struct R3 { // Error, 'R2' and 'R3' are mutually recursive
    let other: R2
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="创建-struct-实例"><a class="header" href="#创建-struct-实例">创建 struct 实例</a></h1>
<p>定义了 <code>struct</code> 类型后，即可通过调用 <code>struct</code> 的构造函数来创建 <code>struct</code> 实例。在 <code>struct</code> 定义之外，通过 <code>struct</code> 类型名调用构造函数。例如，下例中定义了一个 <code>Rectangle</code> 类型的变量 <code>r</code>。</p>
<pre><code class="language-cangjie">let r = Rectangle(10, 20)
</code></pre>
<p>创建了 <code>struct</code> 实例之后，可以通过实例访问它的（<code>public</code> 修饰的）实例成员变量和实例成员函数。例如，下例中通过 <code>r.width</code> 和 <code>r.height</code> 可分别访问 <code>r</code> 中 <code>width</code> 和 <code>height</code> 的值，通过 <code>r.area()</code> 可以调用 <code>r</code> 的成员函数 <code>area</code>。</p>
<pre><code class="language-cangjie">let r = Rectangle(10, 20)
let width = r.width   // width = 10
let height = r.height // height = 20
let a = r.area()      // a = 200
</code></pre>
<p>如果希望通过 <code>struct</code> 实例去修改成员变量的值，需要将 <code>struct</code> 类型的变量定义为可变变量，并且被修改的成员变量也必须是可变成员变量（使用 <code>var</code> 定义）。举例如下：</p>
<!-- run -->
<pre><code class="language-cangjie">struct Rectangle {
    public var width: Int64
    public var height: Int64

    public init(width: Int64, height: Int64) {
        this.width = width
        this.height = height
    }

    public func area() {
        width * height
    }
}

main() {
    var r = Rectangle(10, 20) // r.width = 10, r.height = 20
    r.width = 8               // r.width = 8
    r.height = 24             // r.height = 24
    let a = r.area()          // a = 192
}
</code></pre>
<p>在赋值或传参时，会对 <code>struct</code> 实例进行复制，生成新的实例，对其中一个实例的修改并不会影响另外一个实例。以赋值为例，下面的例子中，将 <code>r1</code> 赋值给 <code>r2</code> 之后，修改 <code>r1</code> 的 <code>width</code> 和 <code>height</code> 的值，并不会影响 <code>r2</code> 的 <code>width</code> 和 <code>height</code> 值。</p>
<!-- run -->
<pre><code class="language-cangjie">struct Rectangle {
    public var width: Int64
    public var height: Int64

    public init(width: Int64, height: Int64) {
        this.width = width
        this.height = height
    }

    public func area() {
        width * height
    }
}

main() {
    var r1 = Rectangle(10, 20) // r1.width = 10, r1.height = 20
    var r2 = r1                // r2.width = 10, r2.height = 20
    r1.width = 8               // r1.width = 8
    r1.height = 24             // r1.height = 24
    let a1 = r1.area()         // a1 = 192
    let a2 = r2.area()         // a2 = 200
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mut-函数"><a class="header" href="#mut-函数">mut 函数</a></h1>
<p>struct 类型是值类型，其实例成员函数无法修改实例本身。例如，下例中，成员函数 <code>g</code> 中不能修改成员变量 <code>i</code> 的值。</p>
<pre><code class="language-cangjie">struct Foo {
    var i = 0

    public func g() {
        i += 1  // Error, the value of a instance member variable cannot be modified in an instance member function
    }
}
</code></pre>
<p>mut 函数是一种可以修改 <code>struct</code> 实例本身的特殊的实例成员函数。在 <code>mut</code> 函数内部，<code>this</code> 的语义是特殊的，这种 <code>this</code> 拥有原地修改字段的能力。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>只允许在 interface、struct 和 struct 的扩展内定义 <code>mut</code> 函数（class 是引用类型，实例成员函数不需要加 <code>mut</code> 也可以修改实例成员变量，所以禁止在 class 中定义 <code>mut</code> 函数）。</p>
</blockquote>
<h2 id="mut-函数定义"><a class="header" href="#mut-函数定义">mut 函数定义</a></h2>
<p>mut 函数与普通的实例成员函数相比，多一个 <code>mut</code> 关键字来修饰。</p>
<p>例如，下例中在函数 <code>g</code> 之前增加 <code>mut</code> 修饰符之后，即可在函数体内修改成员变量 <code>i</code> 的值。</p>
<pre><code class="language-cangjie">struct Foo {
    var i = 0

    public mut func g() {
        i += 1  // Ok
    }
}
</code></pre>
<p><code>mut</code> 只能修饰实例成员函数，不能修饰静态成员函数。</p>
<pre><code class="language-cangjie">struct A {
    public mut func f(): Unit {} // Ok
    public mut operator func +(rhs: A): A { // Ok
        A()
    }
    public mut static func g(): Unit {} // Error, static member functions cannot be modified with 'mut'
}
</code></pre>
<p>mut 函数中的 <code>this</code> 不能被捕获，也不能作为表达式。不能在 <code>mut</code> 函数中对 struct 的实例成员变量进行捕获。</p>
<p>示例：</p>
<pre><code class="language-cangjie">struct Foo {
    var i = 0

    public mut func f(): Foo {
        let f1 = { =&gt; this } // Error, 'this' in mut functions cannot be captured
        let f2 = { =&gt; this.i = 2 } // Error, instance member variables in mut functions cannot be captured
        let f3 = { =&gt; this.i } // Error, instance member variables in mut functions cannot be captured
        let f4 = { =&gt; i } // Error, instance member variables in mut functions cannot be captured
        this // Error, 'this' in mut functions cannot be used as expressions
    }
}
</code></pre>
<h2 id="接口中的-mut-函数"><a class="header" href="#接口中的-mut-函数">接口中的 mut 函数</a></h2>
<p>接口中的实例成员函数，也可以使用 <code>mut</code> 修饰。</p>
<p><code>struct</code> 类型在实现 <code>interface</code> 的函数时必须保持一样的 <code>mut</code> 修饰。<code>struct</code> 以外的类型实现 <code>interface</code> 的函数时不能使用 <code>mut</code> 修饰。</p>
<p>示例：</p>
<pre><code class="language-cangjie">interface I {
    mut func f1(): Unit
    func f2(): Unit
}

struct A &lt;: I {
    public mut func f1(): Unit {} // Ok: as in the interface, the 'mut' modifier is used
    public func f2(): Unit {} // Ok: as in the interface, the 'mut' modifier is not used
}

struct B &lt;: I {
    public func f1(): Unit {} // Error, 'f1' is modified with 'mut' in interface, but not in struct
    public mut func f2(): Unit {} // Error, 'f2' is not modified with 'mut' in interface, but did in struct
}

class C &lt;: I {
    public func f1(): Unit {} // Ok
    public func f2(): Unit {} // Ok
}
</code></pre>
<p>当 <code>struct</code> 的实例赋值给 <code>interface</code> 类型时是拷贝语义，因此 <code>interface</code> 的 <code>mut</code> 函数并不能修改 <code>struct</code> 实例的值。</p>
<p>示例：</p>
<pre><code class="language-cangjie">interface I {
    mut func f(): Unit
}
struct Foo &lt;: I {
    public var v = 0
    public mut func f(): Unit {
        v += 1
    }
}
main() {
    var a = Foo()
    var b: I = a  
    b.f()  // Calling 'f' via 'b' cannot modify the value of 'a'
    println(a.v) // 0
}
</code></pre>
<p>程序输出结果为：</p>
<pre><code class="language-text">0
</code></pre>
<h2 id="mut-函数的使用限制"><a class="header" href="#mut-函数的使用限制">mut 函数的使用限制</a></h2>
<p>因为 <code>struct</code> 是值类型，所以如果一个变量是 <code>struct</code> 类型且使用 <code>let</code> 声明，那么不能通过这个变量访问该类型的 <code>mut</code> 函数。</p>
<p>示例：</p>
<pre><code class="language-cangjie">interface I {
    mut func f(): Unit
}
struct Foo &lt;: I {
    public var i = 0
    public mut func f(): Unit {
        i += 1
    }
}
main() {
    let a = Foo()
    a.f() // Error, 'a' is of type struct and is declared with 'let', the 'mut' function cannot be accessed via 'a'
    var b = Foo()
    b.f() // Ok
    let c: I = Foo()
    c.f() // Ok
}
</code></pre>
<p>为避免逃逸，如果一个变量的类型是 <code>struct</code> 类型，那么这个变量不能将该类型使用 <code>mut</code> 修饰的函数作为一等公民来使用，只能调用这些 <code>mut</code> 函数。</p>
<p>示例：</p>
<pre><code class="language-cangjie">interface I {
    mut func f(): Unit
}

struct Foo &lt;: I {
    var i = 0

    public mut func f(): Unit {
        i += 1
    }
}

main() {
    var a = Foo()
    var fn = a.f // Error, mut function 'f' of 'a' cannot be used as a first class citizen.
    var b: I = Foo()
    fn = b.f // Ok
}
</code></pre>
<p>为避免逃逸，非 <code>mut</code> 的实例成员函数（包括 <code>lambda</code> 表达式）不能直接访问所在类型的 <code>mut</code> 函数，反之可以。</p>
<p>示例：</p>
<pre><code class="language-cangjie">struct Foo {
    var i = 0

    public mut func f(): Unit {
        i += 1
        g() // Ok
    }

    public func g(): Unit {
        f() // Error, mut functions cannot be invoked in non-mut functions
    }
}

interface I {
    mut func f(): Unit {
        g() // Ok
    }

    func g(): Unit {
        f() // Error, mut functions cannot be invoked in non-mut functions
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚举类型"><a class="header" href="#枚举类型">枚举类型</a></h1>
<p>本节介绍仓颉中的 <code>enum</code> 类型。<code>enum</code> 类型提供了通过列举一个类型的所有可能取值来定义此类型的方式。</p>
<p>在很多语言中都有 <code>enum</code> 类型（或者称枚举类型），但是不同语言中的 <code>enum</code> 类型的使用方式和表达能力均有所差异，仓颉中的 <code>enum</code> 类型可以理解为函数式编程语言中的代数数据类型（Algebraic Data Types）。</p>
<p>接下来，首先介绍如何定义和使用 <code>enum</code>，然后介绍如何使用模式匹配使得 <code>enum</code> 取不同值时执行不同的操作，最后介绍一个名为 <code>Option</code> 的常用 <code>enum</code> 类型，用于表示某个类型的实例要么有值要么没值。</p>
<h2 id="enum-的定义"><a class="header" href="#enum-的定义">enum 的定义</a></h2>
<p>定义 <code>enum</code> 时需要把它所有可能的取值一一列出，我们称这些值为 <code>enum</code> 的构造器（或者 <code>constructor</code>）。</p>
<pre><code class="language-cangjie">enum RGBColor {
    | Red | Green | Blue
}
</code></pre>
<p><code>enum</code> 类型的定义以关键字 <code>enum</code> 开头，接着是 <code>enum</code> 的名字，之后是定义在一对花括号中的 <code>enum</code> 体，<code>enum</code> 体中定义了若干构造器，多个构造器之间使用 <code>|</code> 进行分隔（第一个构造器之前的 <code>|</code> 是可选的）。上例中定义了一个名为 <code>RGBColor</code> 的 <code>enum</code> 类型，它有 3 个构造器：<code>Red</code>、<code>Green</code> 和 <code>Blue</code>，分别表示 RGB 色彩模式中的红色、绿色和蓝色。</p>
<p>上述 <code>enum</code> 中的构造器还可以携带若干（至少一个）参数，称为有参构造器。例如，可以为 <code>Red</code>、<code>Green</code> 和 <code>Blue</code> 设置一个 <code>UInt8</code> 的类型的参数，用来表示每个颜色的亮度级别：</p>
<pre><code class="language-cangjie">enum RGBColor {
    | Red(UInt8) | Green(UInt8) | Blue(UInt8)
}
</code></pre>
<p>仓颉支持同一个 <code>enum</code> 中定义多个同名构造器，但是要求这些构造器的参数个数不同（认为没有参数的构造器的参数个数等于 <code>0</code>），例如：</p>
<pre><code class="language-cangjie">enum RGBColor {
    | Red | Green | Blue
    | Red(UInt8) | Green(UInt8) | Blue(UInt8)
}
</code></pre>
<p><code>enum</code> 支持递归定义，例如，下面的例子中使用 <code>enum</code> 定义了一种表达式（即 <code>Expr</code>），此表达式只能有 3 种形式：单独的一个数字 <code>Num</code>（携带一个 <code>Int64</code> 类型的参数）、加法表达式 <code>Add</code>（携带两个 <code>Expr</code> 类型的参数）、减法表达式 <code>Sub</code>（携带两个 <code>Expr</code> 类型的参数）。对于 <code>Add</code> 和 <code>Sub</code> 这两个构造器，其参数中递归地使用到了 <code>Expr</code> 自身。</p>
<pre><code class="language-cangjie">enum Expr {
    | Num(Int64)
    | Add(Expr, Expr)
    | Sub(Expr, Expr)
}
</code></pre>
<p>另外，在 <code>enum</code> 体中还可以定义一系列成员函数、操作符函数（详见<a href="source_zh_cn/enum_and_pattern_match/../function/operator_overloading.html">操作符重载</a>章节）和成员属性（详见<a href="source_zh_cn/enum_and_pattern_match/../class_and_interface/prop.html">属性</a>章节），但是要求构造器、成员函数、成员属性之间不能重名。例如，下面的例子在 <code>RGBColor</code> 中定义了一个名为 <code>printType</code> 的函数，它会输出字符串 <code>RGBColor</code>：</p>
<pre><code class="language-cangjie">enum RGBColor {
    | Red | Green | Blue

    public static func printType() {
        print(&quot;RGBColor&quot;)
    }
}
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li><code>enum</code> 只能定义在源文件顶层。</li>
<li>当 <code>enum</code> 和 <code>struct</code> 类型存在互递归关系时，且 <code>enum</code> 类型作为 <code>Option</code> 的类型参数，可能存在编译错误。</li>
</ul>
</blockquote>
<h2 id="enum-的使用"><a class="header" href="#enum-的使用">enum 的使用</a></h2>
<p>定义了 <code>enum</code> 类型之后，就可以创建此类型的实例（即 <code>enum</code> 值），<code>enum</code> 值只能取 <code>enum</code> 类型定义中的一个构造器。<code>enum</code> 没有构造函数，可以通过 <code>类型名.构造器</code>，或者直接使用构造器的方式来构造一个 <code>enum</code> 值（对于有参构造器，需要传实参）。</p>
<p>下例中，<code>RGBColor</code> 中定义了三个构造器，其中有两个无参构造器（<code>Red</code> 和 <code>Green</code>）和一个有参构造器（<code>Blue(UInt8)</code>），<code>main</code> 中定义了三个 <code>RGBColor</code> 类型的变量 <code>r</code>，<code>g</code> 和 <code>b</code>，其中，<code>r</code> 的值使用 <code>RGBColor.Red</code> 进行初始化，<code>g</code> 的值直接使用 <code>Green</code> 进行初始化，<code>b</code> 的值使用 <code>Blue(100)</code> 进行初始化：</p>
<!-- compile -->
<pre><code class="language-cangjie">enum RGBColor {
    | Red | Green | Blue(UInt8)
}

main() {
    let r = RGBColor.Red
    let g = Green
    let b = Blue(100)
}
</code></pre>
<p>当省略类型名时，<code>enum</code> 构造器的名字可能和类型名、变量名、函数名发生冲突。此时必须加上 <code>enum</code> 类型名来使用 <code>enum</code> 构造器，否则只会选择同名的类型、变量、函数定义。</p>
<p>下面的例子中，只有构造器 <code>Blue(UInt8)</code> 可以不带类型名使用，<code>Red</code> 和 <code>Green(UInt8)</code> 皆会因为名字冲突而不能直接使用，必须加上类型名 <code>RGBColor</code>。</p>
<pre><code class="language-cangjie">let Red = 1

func Green(g: UInt8) {
    return g
}

enum RGBColor {
    | Red | Green(UInt8) | Blue(UInt8)
}

let r1 = Red                 // Will choose 'let Red'
let r2 = RGBColor.Red        // Ok: constructed by enum type name

let g1 = Green(100)          // Will choose 'func Green'
let g2 = RGBColor.Green(100) // Ok: constructed by enum type name

let b = Blue(100)            // Ok: can be uniquely identified as an enum constructor
</code></pre>
<p>如下的例子中，只有构造器 <code>Blue</code> 会因为名称冲突而不能直接使用，必须加上类型名 <code>RGBColor</code>。</p>
<pre><code>class Blue {}

enum RGBColor {
    | Red | Green(UInt8) | Blue(UInt8)
}

let r = Red                 // Ok: constructed by enum type name

let g = Green(100)          // Ok: constructed by enum type name

let b = Blue(100)           // Will choose constructor of 'class Blue' and report an error
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option-类型"><a class="header" href="#option-类型">Option 类型</a></h1>
<p><code>Option</code> 类型使用 <code>enum</code> 定义，它包含两个构造器：<code>Some</code> 和 <code>None</code>。其中，<code>Some</code> 会携带一个参数，表示有值，<code>None</code> 不带参数，表示无值。当需要表示某个类型可能有值，也可能没有值的时候，可选择使用 <code>Option</code> 类型。</p>
<p><code>Option</code> 类型被定义为一个泛型 <code>enum</code> 类型，定义如下（这里我们仅需要知道尖括号中的 <code>T</code> 是一个类型形参，当 <code>T</code> 为不同类型时会得到不同的 <code>Option</code> 类型即可。关于泛型的详细介绍，可参见<a href="source_zh_cn/enum_and_pattern_match/../generic/generic_overview.html">泛型</a>）：</p>
<pre><code class="language-cangjie">enum Option&lt;T&gt; {
    | Some(T)
    | None
}
</code></pre>
<p>其中，<code>Some</code> 构造器的参数类型就是类型形参 <code>T</code>，当 <code>T</code> 被实例化为不同的类型时，会得到不同的 <code>Option</code> 类型，例如：<code>Option&lt;Int64&gt;</code>、<code>Option&lt;String&gt;</code>等。</p>
<p><code>Option</code> 类型还有一种简单的写法：在类型名前加 <code>?</code>。也就是说，对于任意类型 <code>Ty</code>，<code>?Ty</code> 等价于 <code>Option&lt;Ty&gt;</code>。例如，<code>?Int64</code> 等价于 <code>Option&lt;Int64&gt;</code>，<code>?String</code> 等价于 <code>Option&lt;String&gt;</code> 等等。</p>
<p>下面的例子展示了如何定义 <code>Option</code> 类型的变量：</p>
<!-- compile -->
<pre><code class="language-cangjie">let a: Option&lt;Int64&gt; = Some(100)
let b: ?Int64 = Some(100)
let c: Option&lt;String&gt; = Some(&quot;Hello&quot;)
let d: ?String = None
</code></pre>
<p>另外，虽然 <code>T</code> 和 <code>Option&lt;T&gt;</code> 是不同的类型，但是当明确知道某个位置需要的是 <code>Option&lt;T&gt;</code> 类型的值时，可以直接传一个 <code>T</code> 类型的值，编译器会用 <code>Option&lt;T&gt;</code> 类型的 <code>Some</code> 构造器将 <code>T</code> 类型的值封装成 <code>Option&lt;T&gt;</code> 类型的值（注意：这里并不是类型转换）。例如，下面的定义是合法的（等价于上例中变量 <code>a</code>，<code>b</code> 和 <code>c</code> 的定义）：</p>
<!-- compile -->
<pre><code class="language-cangjie">let a: Option&lt;Int64&gt; = 100
let b: ?Int64 = 100
let c: Option&lt;String&gt; = &quot;100&quot;
</code></pre>
<p>在上下文没有明确的类型要求时，无法使用 <code>None</code> 直接构造出想要的类型，此时应使用 <code>None&lt;T&gt;</code> 这样的语法来构造 <code>Option&lt;T&gt;</code> 类型的数据，例如</p>
<!-- compile -->
<pre><code class="language-cangjie">let a = None&lt;Int64&gt; // a: Option&lt;Int64&gt;
let b = None&lt;Bool&gt; // b: Option&lt;Bool&gt;
</code></pre>
<p>最后，关于 <code>Option</code> 的使用，请参见<a href="source_zh_cn/enum_and_pattern_match/../error_handle/use_option.html">使用 Option</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模式概述"><a class="header" href="#模式概述">模式概述</a></h1>
<p>对于包含匹配值的 <code>match</code> 表达式，<code>case</code> 之后支持哪些模式决定了 <code>match</code> 表达式的表达能力，本节中我们将依次介绍仓颉支持的模式，包括：常量模式、通配符模式、绑定模式、tuple 模式、类型模式和 enum 模式。</p>
<h2 id="常量模式"><a class="header" href="#常量模式">常量模式</a></h2>
<p>常量模式可以是整数字面量、浮点数字面量、字符字面量、布尔字面量、字符串字面量（不支持字符串插值）、Unit 字面量。</p>
<p>在包含匹配值的 <code>match</code> 表达式中使用常量模式时，要求常量模式表示的值的类型与待匹配值的类型相同，匹配成功的条件是待匹配的值与常量模式表示的值相等。</p>
<p>下面的例子中，根据 <code>score</code> 的值（假设 <code>score</code> 只能取 <code>0</code> 到 <code>100</code> 间被 <code>10</code> 整除的值），输出考试成绩的等级：</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    let score = 90
    let level = match (score) {
        case 0 | 10 | 20 | 30 | 40 | 50 =&gt; &quot;D&quot;
        case 60 =&gt; &quot;C&quot;
        case 70 | 80 =&gt; &quot;B&quot;
        case 90 | 100 =&gt; &quot;A&quot; // Matched.
        case _ =&gt; &quot;Not a valid score&quot;
    }
    println(level)
}
</code></pre>
<p>编译执行上述代码，输出结果为：</p>
<pre><code class="language-text">A
</code></pre>
<ul>
<li>
<p>在模式匹配的目标是静态类型为 <code>Rune</code> 的值时，<code>Rune</code> 字面量和单字符字符串字面量都可用于表示 <code>Rune</code> 类型字面量的常量 pattern。</p>
<!-- verify -->
<pre><code class="language-cangjie">func translate(n: Rune) {
    match (n) {
        case &quot;一&quot; =&gt; 1
        case &quot;二&quot; =&gt; 2
        case &quot;三&quot; =&gt; 3
        case _ =&gt; -1
    }
}

main() {
    println(translate(r&quot;三&quot;))
}
</code></pre>
<p>编译执行上述代码，输出结果为：</p>
<pre><code class="language-text">3
</code></pre>
</li>
<li>
<p>在模式匹配的目标是静态类型为 <code>Byte</code> 的值时，一个表示 ASCII 字符的字符串字面量可用于表示 <code>Byte</code> 类型字面量的常量 pattern。</p>
<!-- verify -->
<pre><code class="language-cangjie">func translate(n: Byte) {
    match (n) {
        case &quot;1&quot; =&gt; 1
        case &quot;2&quot; =&gt; 2
        case &quot;3&quot; =&gt; 3
        case _ =&gt; -1
    }
}

main() {
    println(translate(51)) // UInt32(r'3') == 51
}
</code></pre>
<p>编译执行上述代码，输出结果为：</p>
<pre><code class="language-text">3
</code></pre>
</li>
</ul>
<h2 id="通配符模式"><a class="header" href="#通配符模式">通配符模式</a></h2>
<p>通配符模式使用下划线 <code>_</code> 表示，可以匹配任意值。通配符模式通常作为最后一个 <code>case</code> 中的模式，用来匹配其他 <code>case</code> 未覆盖到的情况，如<a href="source_zh_cn/enum_and_pattern_match/./pattern_overview.html#%E5%B8%B8%E9%87%8F%E6%A8%A1%E5%BC%8F">常量模式</a>中匹配 <code>score</code> 值的示例中，最后一个 <code>case</code> 中使用 <code>_</code> 来匹配无效的 <code>score</code> 值。</p>
<h2 id="绑定模式"><a class="header" href="#绑定模式">绑定模式</a></h2>
<p>绑定模式使用 <code>id</code> 表示，<code>id</code> 是一个合法的标识符。与通配符模式相比，绑定模式同样可以匹配任意值，但绑定模式会将匹配到的值与 <code>id</code> 进行绑定，在 <code>=&gt;</code> 之后可以通过 <code>id</code> 访问其绑定的值。</p>
<p>下面的例子中，最后一个 <code>case</code> 中使用了绑定模式，用于绑定非 <code>0</code> 值：</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    let x = -10
    let y = match (x) {
        case 0 =&gt; &quot;zero&quot;
        case n =&gt; &quot;x is not zero and x = ${n}&quot; // Matched.
    }
    println(y)
}
</code></pre>
<p>编译执行上述代码，输出结果为：</p>
<pre><code class="language-text">x is not zero and x = -10
</code></pre>
<p>使用 <code>|</code> 连接多个模式时不能使用绑定模式，也不可嵌套出现在其它模式中，否则会报错：</p>
<pre><code class="language-cangjie">main() {
    let opt = Some(0)
    match (opt) {
        case x | x =&gt; {} // Error, variable cannot be introduced in patterns connected by '|'
        case Some(x) | Some(x) =&gt; {} // Error, variable cannot be introduced in patterns connected by '|'
        case x: Int64 | x: String =&gt; {} // Error, variable cannot be introduced in patterns connected by '|'
    }
}
</code></pre>
<p>绑定模式 <code>id</code> 相当于新定义了一个名为 <code>id</code> 的不可变变量（其作用域从引入处开始到该 <code>case</code> 结尾处），因此在 <code>=&gt;</code> 之后无法对 <code>id</code> 进行修改。例如，下例中最后一个 <code>case</code> 中对 <code>n</code> 的修改是不允许的。</p>
<pre><code class="language-cangjie">main() {
    let x = -10
    let y = match (x) {
        case 0 =&gt; &quot;zero&quot;
        case n =&gt; n = n + 0 // Error, 'n' cannot be modified.
                  &quot;x is not zero&quot;
    }
    println(y)
}
</code></pre>
<p>对于每个 <code>case</code> 分支，<code>=&gt;</code> 之后变量作用域级别与 <code>case</code> 后 <code>=&gt;</code> 前引入的变量作用域级别相同，在 <code>=&gt;</code> 之后再次引入相同名字会触发重定义错误。例如：</p>
<pre><code class="language-cangjie">main() {
    let x = -10
    let y = match (x) {
        case 0 =&gt; &quot;zero&quot;
        case n =&gt; let n = 0 // Error, redefinition
                  println(n)
                  &quot;x is not zero&quot;
    }
    println(y)
}
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p>当模式的 identifier 为 enum 构造器时，该模式会被当成 enum 模式进行匹配，而不是绑定模式（关于 enum 模式，详见 <a href="source_zh_cn/enum_and_pattern_match/pattern_overview.html#enum-%E6%A8%A1%E5%BC%8F">enum 模式</a>章节）。</p>
</blockquote>
<!-- verify -->
<pre><code class="language-cangjie">enum RGBColor {
    | Red | Green | Blue
}

main() {
    let x = Red
    let y = match (x) {
        case Red =&gt; &quot;red&quot; // The 'Red' is enum mode here.
        case _ =&gt; &quot;not red&quot;
    }
    println(y)
}
</code></pre>
<p>编译执行上述代码，输出结果为：</p>
<pre><code class="language-text">red
</code></pre>
<h2 id="tuple-模式"><a class="header" href="#tuple-模式">Tuple 模式</a></h2>
<p>Tuple 模式用于 tuple 值的匹配，它的定义和 tuple 字面量类似：<code>(p_1, p_2, ..., p_n)</code>，区别在于这里的 <code>p_1</code> 到 <code>p_n</code>（<code>n</code> 大于等于 <code>2</code>）是模式（可以是本章节中介绍的任何模式，多个模式间使用逗号分隔）而不是表达式。</p>
<p>例如，<code>(1, 2, 3)</code> 是一个包含三个常量模式的 tuple 模式，<code>(x, y, _)</code> 是一个包含两个绑定模式，一个通配符模式的 tuple 模式。</p>
<p>给定一个 tuple 值 <code>tv</code> 和一个 tuple 模式 <code>tp</code>，当且仅当 <code>tv</code> 每个位置处的值均能与 <code>tp</code> 中对应位置处的模式相匹配，才称 <code>tp</code> 能匹配 <code>tv</code>。例如，<code>(1, 2, 3)</code> 仅可以匹配 tuple 值 <code>(1, 2, 3)</code>，<code>(x, y, _)</code> 可以匹配任何三元 tuple 值。</p>
<p>下面的例子中，展示了 tuple 模式的使用：</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    let tv = (&quot;Alice&quot;, 24)
    let s = match (tv) {
        case (&quot;Bob&quot;, age) =&gt; &quot;Bob is ${age} years old&quot;
        case (&quot;Alice&quot;, age) =&gt; &quot;Alice is ${age} years old&quot; // Matched, &quot;Alice&quot; is a constant pattern, and 'age' is a variable pattern.
        case (name, 100) =&gt; &quot;${name} is 100 years old&quot;
        case (_, _) =&gt; &quot;someone&quot;
    }
    println(s)
}
</code></pre>
<p>编译执行上述代码，输出结果为：</p>
<pre><code class="language-text">Alice is 24 years old
</code></pre>
<p>同一个 tuple 模式中不允许引入多个名字相同的绑定模式。例如，下例中最后一个 <code>case</code> 中的 <code>case (x, x)</code> 是不合法的。</p>
<pre><code class="language-cangjie">main() {
    let tv = (&quot;Alice&quot;, 24)
    let s = match (tv) {
        case (&quot;Bob&quot;, age) =&gt; &quot;Bob is ${age} years old&quot;
        case (&quot;Alice&quot;, age) =&gt; &quot;Alice is ${age} years old&quot;
        case (name, 100) =&gt; &quot;${name} is 100 years old&quot;
        case (x, x) =&gt; &quot;someone&quot; // Error, Cannot introduce a variable pattern with the same name, which will be a redefinition error.
    }
    println(s)
}
</code></pre>
<h2 id="类型模式"><a class="header" href="#类型模式">类型模式</a></h2>
<p>类型模式用于判断一个值的运行时类型是否是某个类型的子类型。类型模式有两种形式：<code>_: Type</code>（嵌套一个通配符模式 <code>_</code>）和 <code>id: Type</code>（嵌套一个绑定模式 <code>id</code>），它们的差别是后者会发生变量绑定，而前者并不会。</p>
<p>对于待匹配值 <code>v</code> 和类型模式 <code>id: Type</code>（或 <code>_: Type</code>），首先判断 <code>v</code> 的运行时类型是否是 <code>Type</code> 的子类型，若成立则视为匹配成功，否则视为匹配失败；如匹配成功，则将 <code>v</code> 的类型转换为 <code>Type</code> 并与 <code>id</code> 进行绑定（对于 <code>_: Type</code>，不存在绑定这一操作）。</p>
<p>假设有如下两个类，<code>Base</code> 和 <code>Derived</code>，并且 <code>Derived</code> 是 <code>Base</code> 的子类，<code>Base</code> 的无参构造函数中将 <code>a</code> 的值设置为 <code>10</code>，<code>Derived</code> 的无参构造函数中将 <code>a</code> 的值设置为 <code>20</code>：</p>
<!-- verify -extend -->
<pre><code class="language-cangjie">open class Base {
    var a: Int64
    public init() {
        a = 10
    }
}

class Derived &lt;: Base {
    public init() {
        a = 20
    }
}
</code></pre>
<p>下面的代码展示了使用类型模式并匹配成功的例子：</p>
<!-- verify -extend -->
<pre><code class="language-cangjie">main() {
    var d = Derived()
    var r = match (d) {
        case b: Base =&gt; b.a // Matched.
        case _ =&gt; 0
    }
    println(&quot;r = ${r}&quot;)
}
</code></pre>
<p>编译执行上述代码，输出结果为：</p>
<!-- verify -extend -->
<pre><code class="language-text">r = 20
</code></pre>
<p>下面的代码展示了使用类型模式但类型模式匹配失败的例子：</p>
<!-- verify -->
<pre><code class="language-cangjie">open class Base {
    var a: Int64
    public init() {
        a = 10
    }
}

class Derived &lt;: Base {
    public init() {
        a = 20
    }
}

main() {
    var b = Base()
    var r = match (b) {
        case d: Derived =&gt; d.a // Type pattern match failed.
        case _ =&gt; 0 // Matched.
    }
    println(&quot;r = ${r}&quot;)
}
</code></pre>
<p>编译执行上述代码，输出结果为：</p>
<pre><code class="language-text">r = 0
</code></pre>
<h2 id="enum-模式"><a class="header" href="#enum-模式">enum 模式</a></h2>
<p>enum 模式用于匹配 <code>enum</code> 类型的实例，它的定义和 <code>enum</code> 的构造器类似：无参构造器 <code>C</code> 或有参构造器 <code>C(p_1, p_2, ..., p_n)</code>，构造器的类型前缀可以省略，区别在于这里的 <code>p_1</code> 到 <code>p_n</code>（<code>n</code> 大于等于 <code>1</code>）是模式。例如，<code>Some(1)</code> 是一个包含一个常量模式的 enum 模式，<code>Some(x)</code> 是一个包含一个绑定模式的 enum 模式。</p>
<p>给定一个 enum 实例 <code>ev</code> 和一个 enum 模式 <code>ep</code>，当且仅当 <code>ev</code> 的构造器名字和 <code>ep</code> 的构造器名字相同，且 <code>ev</code> 参数列表中每个位置处的值均能与 <code>ep</code> 中对应位置处的模式相匹配，才称 <code>ep</code> 能匹配 <code>ev</code>。例如，<code>Some(&quot;one&quot;)</code> 仅可以匹配 <code>Option&lt;String&gt;</code> 类型的<code>Some</code> 构造器 <code>Option&lt;String&gt;.Some(&quot;one&quot;)</code>，<code>Some(x)</code> 可以匹配任何 Option 类型的 <code>Some</code> 构造器。</p>
<p>下面的例子中，展示了 enum 模式的使用，因为 <code>x</code> 的构造器是 <code>Year</code>，所以会和第一个 <code>case</code> 匹配：</p>
<!-- verify -->
<pre><code class="language-cangjie">enum TimeUnit {
    | Year(UInt64)
    | Month(UInt64)
}

main() {
    let x = Year(2)
    let s = match (x) {
        case Year(n) =&gt; &quot;x has ${n * 12} months&quot; // Matched.
        case TimeUnit.Month(n) =&gt; &quot;x has ${n} months&quot;
    }
    println(s)
}
</code></pre>
<p>编译执行上述代码，输出结果为：</p>
<pre><code class="language-text">x has 24 months
</code></pre>
<p>使用 <code>|</code> 连接多个 enum 模式：</p>
<pre><code class="language-cangjie">enum TimeUnit {
    | Year(UInt64)
    | Month(UInt64)
}

main() {
    let x = Year(2)
    let s = match (x) {
        case Year(0) | Year(1) | Month(_) =&gt; &quot;Ok&quot; // Ok
        case Year(2) | Month(m) =&gt; &quot;invalid&quot; // Error, Variable cannot be introduced in patterns connected by '|'
        case Year(n: UInt64) | Month(n: UInt64) =&gt; &quot;invalid&quot; // Error, Variable cannot be introduced in patterns connected by '|'
    }
    println(s)
}
</code></pre>
<p>使用 <code>match</code> 表达式匹配 <code>enum</code> 值时，要求 <code>case</code> 之后的模式要覆盖待匹配 <code>enum</code> 类型中的所有构造器，如果未做到完全覆盖，编译器将报错：</p>
<pre><code class="language-cangjie">enum RGBColor {
    | Red | Green | Blue
}

main() {
    let c = Green
    let cs = match (c) { // Error, Not all constructors of RGBColor are covered.
        case Red =&gt; &quot;Red&quot;
        case Green =&gt; &quot;Green&quot;
    }
    println(cs)
}
</code></pre>
<p>我们可以通过加上 <code>case Blue</code> 来实现完全覆盖，也可以在 <code>match</code> 表达式的最后通过使用 <code>case _</code> 来覆盖其他 <code>case</code> 未覆盖的到的情况，如：</p>
<!-- verify -->
<pre><code class="language-cangjie">enum RGBColor {
    | Red | Green | Blue
}

main() {
    let c = Blue
    let cs = match (c) {
        case Red =&gt; &quot;Red&quot;
        case Green =&gt; &quot;Green&quot;
        case _ =&gt; &quot;Other&quot; // Matched.
    }
    println(cs)
}
</code></pre>
<p>上述代码的执行结果为：</p>
<pre><code class="language-text">Other
</code></pre>
<h2 id="模式的嵌套组合"><a class="header" href="#模式的嵌套组合">模式的嵌套组合</a></h2>
<p>Tuple 模式和 enum 模式可以嵌套任意模式。下面的代码展示了不同模式嵌套组合使用：</p>
<!-- verify -->
<pre><code class="language-cangjie">enum TimeUnit {
    | Year(UInt64)
    | Month(UInt64)
}

enum Command {
    | SetTimeUnit(TimeUnit)
    | GetTimeUnit
    | Quit
}

main() {
    let command = SetTimeUnit(Year(2022))
    match (command) {
        case SetTimeUnit(Year(year)) =&gt; println(&quot;Set year ${year}&quot;)
        case SetTimeUnit(Month(month)) =&gt; println(&quot;Set month ${month}&quot;)
        case _ =&gt; ()
    }
}
</code></pre>
<p>编译执行上述代码，输出结果为：</p>
<pre><code class="language-text">Set year 2022
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模式的-refutability"><a class="header" href="#模式的-refutability">模式的 Refutability</a></h1>
<p>模式可以分为两类：<code>refutable</code> 模式和 <code>irrefutable</code> 模式。在类型匹配的前提下，当一个模式有可能和待匹配值不匹配时，称此模式为 <code>refutable</code> 模式；反之，当一个模式总是可以和待匹配值匹配时，称此模式为 <code>irrefutable</code> 模式。</p>
<p>对于上述介绍的各种模式，规定如下：</p>
<p>常量模式是 <code>refutable</code> 模式。例如，下例中第一个 case 中的 <code>1</code> 和第二个 case 中的 <code>2</code> 都有可能和 <code>x</code> 的值不相等。</p>
<pre><code class="language-cangjie">func constPat(x: Int64) {
    match (x) {
        case 1 =&gt; &quot;one&quot;
        case 2 =&gt; &quot;two&quot;
        case _ =&gt; &quot;_&quot;
    }
}
</code></pre>
<p>通配符模式是 <code>irrefutable</code> 模式。例如，下例中无论 <code>x</code> 的值是多少，<code>_</code> 总能和其匹配。</p>
<pre><code class="language-cangjie">func wildcardPat(x: Int64) {
    match (x) {
        case _ =&gt; &quot;_&quot;
    }
}
</code></pre>
<p>绑定模式是 <code>irrefutable</code> 模式。例如，下例中无论 <code>x</code> 的值是多少，绑定模式 <code>a</code> 总能和其匹配。</p>
<pre><code class="language-cangjie">func varPat(x: Int64) {
    match (x) {
        case a =&gt; &quot;x = ${a}&quot;
    }
}
</code></pre>
<p>Tuple 模式是 <code>irrefutable</code> 模式，当且仅当其包含的每个模式都是 <code>irrefutable</code> 模式。例如，下例中 <code>(1, 2)</code> 和 <code>(a, 2)</code> 都有可能和 <code>x</code> 的值不匹配，所以它们是 <code>refutable</code> 模式，而 <code>(a, b)</code> 可以匹配任何 <code>x</code> 的值，所以它是 <code>irrefutable</code> 模式。</p>
<pre><code class="language-cangjie">func tuplePat(x: (Int64, Int64)) {
    match (x) {
        case (1, 2) =&gt; &quot;(1, 2)&quot;
        case (a, 2) =&gt; &quot;(${a}, 2)&quot;
        case (a, b) =&gt; &quot;(${a}, ${b})&quot;
    }
}
</code></pre>
<p>类型模式是 <code>refutable</code> 模式。例如，下例中（假设 <code>Base</code> 是 <code>Derived</code> 的父类，并且 <code>Base</code> 实现了接口 <code>I</code>），<code>x</code> 的运行时类型有可能既不是 <code>Base</code> 也不是 <code>Derived</code>，所以 <code>a: Derived</code> 和 <code>b: Base</code> 均是 <code>refutable</code> 模式。</p>
<pre><code class="language-cangjie">interface I {}
open class Base &lt;: I {}
class Derived &lt;: Base {}

func typePat(x: I) {
    match (x) {
        case a: Derived =&gt; &quot;Derived&quot;
        case b: Base =&gt; &quot;Base&quot;
        case _ =&gt; &quot;Other&quot;
    }
}
</code></pre>
<p>enum 模式是 <code>irrefutable</code> 模式，当且仅当它对应的 <code>enum</code> 类型中只有一个有参构造器，且 enum 模式中包含的其他模式也是 <code>irrefutable</code> 模式。例如，对于下例中的 <code>E1</code> 和 <code>E2</code> 定义，函数 <code>enumPat1</code> 中的 <code>A(1)</code> 是 <code>refutable</code> 模式，<code>A(a)</code> 是 <code>irrefutable</code> 模式；而函数 <code>enumPat2</code> 中的 <code>B(b)</code> 和 <code>C(c)</code> 均是 <code>refutable</code> 模式。</p>
<pre><code class="language-cangjie">enum E1 {
    A(Int64)
}

enum E2 {
    B(Int64) | C(Int64)
}

func enumPat1(x: E1) {
    match (x) {
        case A(1) =&gt; &quot;A(1)&quot;
        case A(a) =&gt; &quot;A(${a})&quot;
    }
}

func enumPat2(x: E2) {
    match (x) {
        case B(b) =&gt; &quot;B(${b})&quot;
        case C(c) =&gt; &quot;C(${c})&quot;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match-表达式"><a class="header" href="#match-表达式">match 表达式</a></h1>
<h2 id="match-表达式的定义"><a class="header" href="#match-表达式的定义">match 表达式的定义</a></h2>
<p>仓颉支持两种 <code>match</code> 表达式，第一种是包含待匹配值的 <code>match</code> 表达式，第二种是不含待匹配值的 <code>match</code> 表达式。</p>
<p><strong>含匹配值的 match 表达式</strong>：</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    let x = 0
    match (x) {
        case 1 =&gt; let r1 = &quot;x = 1&quot;
                  print(r1)
        case 0 =&gt; let r2 = &quot;x = 0&quot; // Matched.
                  print(r2)
        case _ =&gt; let r3 = &quot;x != 1 and x != 0&quot;
                  print(r3)
    }
}
</code></pre>
<p><code>match</code> 表达式以关键字 <code>match</code> 开头，后跟要匹配的值（如上例中的 <code>x</code>，<code>x</code> 可以是任意表达式），接着是定义在一对花括号内的若干 <code>case</code> 分支。</p>
<p>每个 <code>case</code> 分支以关键字 <code>case</code> 开头，<code>case</code> 之后是一个模式或多个由 <code>|</code> 连接的相同种类的模式（如上例中的 <code>1</code>、<code>0</code>、<code>_</code> 都是模式，详见<a href="source_zh_cn/enum_and_pattern_match/../enum_and_pattern_match/pattern_overview.html">模式概述</a>章节）；模式之后可以接一个可选的 <code>pattern guard</code>，表示本条 <code>case</code> 匹配成功后额外需要满足的条件；接着是一个 <code>=&gt;</code>，<code>=&gt;</code> 之后即本条 <code>case</code> 分支匹配成功后需要执行的操作，可以是一系列表达式、变量和函数定义（新定义的变量或函数的作用域从其定义处开始到下一个 <code>case</code> 之前结束），如上例中的变量定义和 <code>print</code> 函数调用。</p>
<p><code>match</code> 表达式执行时依次将 <code>match</code> 之后的表达式与每个 <code>case</code> 中的模式进行匹配，一旦匹配成功（如果有 <code>pattern guard</code>，也需要 <code>where</code> 之后的表达式的值为 <code>true</code>；如果 <code>case</code> 中有多个由 <code>|</code> 连接的模式，只要待匹配值和其中一个模式匹配则认为匹配成功）则执行 <code>=&gt;</code> 之后的代码然后退出 <code>match</code> 表达式的执行（意味着不会再去匹配它之后的 <code>case</code>），如果匹配不成功则继续与它之后的 <code>case</code> 中的模式进行匹配，直到匹配成功（<code>match</code> 表达式可以保证一定存在匹配的 <code>case</code> 分支）。</p>
<p>上例中，因为 <code>x</code> 的值等于 <code>0</code>，所以会和第二条 <code>case</code> 分支匹配（此处使用的是常量模式，匹配的是值是否相等，详见<a href="source_zh_cn/enum_and_pattern_match/../enum_and_pattern_match/pattern_overview.html#%E5%B8%B8%E9%87%8F%E6%A8%A1%E5%BC%8F">常量模式</a>章节），最后输出 <code>x = 0</code>。</p>
<p>编译并执行上述代码，输出结果为：</p>
<pre><code class="language-text">x = 0
</code></pre>
<p><code>match</code> 表达式要求所有匹配必须是穷尽（exhaustive）的，意味着待匹配表达式的所有可能取值都应该被考虑到。当 <code>match</code> 表达式非穷尽，或者编译器判断不出是否穷尽时，均会编译报错，换言之，所有 <code>case</code> 分支（包含 pattern guard）所覆盖的取值范围的并集，应该包含待匹配表达式的所有可能取值。常用的确保 <code>match</code> 表达式穷尽的方式是在最后一个 <code>case</code> 分支中使用通配符模式 <code>_</code>，因为 <code>_</code> 可以匹配任何值。</p>
<p><code>match</code> 表达式的穷尽性保证了一定存在和待匹配值相匹配的 <code>case</code> 分支。下面的例子将编译报错，因为所有的 <code>case</code> 并没有覆盖 <code>x</code> 的所有可能取值：</p>
<pre><code class="language-cangjie">func nonExhaustive(x: Int64) {
    match (x) {
        case 0 =&gt; print(&quot;x = 0&quot;)
        case 1 =&gt; print(&quot;x = 1&quot;)
        case 2 =&gt; print(&quot;x = 2&quot;)
    }
}
</code></pre>
<p>在 <code>case</code> 分支的模式之后，可以使用 <code>pattern guard</code> 进一步对匹配出来的结果进行判断。<code>pattern guard</code> 使用 <code>where cond</code> 表示，要求表达式 <code>cond</code> 的类型为 <code>Bool</code>。</p>
<p>在下面的例子中（使用到了 <code>enum</code> 模式，详见 <a href="source_zh_cn/enum_and_pattern_match/../enum_and_pattern_match/pattern_overview.html#enum-%E6%A8%A1%E5%BC%8F">enum 模式</a>章节），当 <code>RGBColor</code> 的构造器的参数值大于等于 <code>0</code> 时，输出它们的值，当参数值小于 <code>0</code> 时，认为它们的值等于 <code>0</code>：</p>
<!-- verify -->
<pre><code class="language-cangjie">enum RGBColor {
    | Red(Int16) | Green(Int16) | Blue(Int16)
}
main() {
    let c = RGBColor.Green(-100)
    let cs = match (c) {
        case Red(r) where r &lt; 0 =&gt; &quot;Red = 0&quot;
        case Red(r) =&gt; &quot;Red = ${r}&quot;
        case Green(g) where g &lt; 0 =&gt; &quot;Green = 0&quot; // Matched.
        case Green(g) =&gt; &quot;Green = ${g}&quot;
        case Blue(b) where b &lt; 0 =&gt; &quot;Blue = 0&quot;
        case Blue(b) =&gt; &quot;Blue = ${b}&quot;
    }
    print(cs)
}
</code></pre>
<p>编译执行上述代码，输出结果为：</p>
<pre><code class="language-text">Green = 0
</code></pre>
<p><strong>没有匹配值的 match 表达式</strong>：</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    let x = -1
    match {
        case x &gt; 0 =&gt; print(&quot;x &gt; 0&quot;)
        case x &lt; 0 =&gt; print(&quot;x &lt; 0&quot;) // Matched.
        case _ =&gt; print(&quot;x = 0&quot;)
    }
}
</code></pre>
<p>与包含待匹配值的 <code>match</code> 表达式相比，关键字 <code>match</code> 之后并没有待匹配的表达式，并且 <code>case</code> 之后不再是 <code>pattern</code>，而是类型为 <code>Bool</code> 的表达式（上述代码中的 <code>x &gt; 0</code> 和 <code>x &lt; 0</code>）或者 <code>_</code>（表示 <code>true</code>），当然，<code>case</code> 中也不再有 <code>pattern guard</code>。</p>
<p>无匹配值的 <code>match</code> 表达式执行时依次判断 <code>case</code> 之后的表达式的值，直到遇到值为 <code>true</code> 的 <code>case</code> 分支；一旦某个 <code>case</code> 之后的表达式值等于 <code>true</code>，则执行此 <code>case</code> 中 <code>=&gt;</code> 之后的代码，然后退出 <code>match</code> 表达式的执行（意味着不会再去判断该 <code>case</code> 之后的其他 <code>case</code>）。</p>
<p>上例中，因为 <code>x</code> 的值等于 <code>-1</code>，所以第二条 <code>case</code> 分支中的表达式（即 <code>x &lt; 0</code>）的值等于 <code>true</code>，执行 <code>print(&quot;x &lt; 0&quot;)</code>。</p>
<p>编译并执行上述代码，输出结果为：</p>
<pre><code class="language-text">x &lt; 0
</code></pre>
<h2 id="match-表达式的类型"><a class="header" href="#match-表达式的类型">match 表达式的类型</a></h2>
<p>对于 <code>match</code> 表达式（无论是否有匹配值），</p>
<ul>
<li>
<p>在上下文有明确的类型要求时，要求每个 <code>case</code> 分支中 <code>=&gt;</code> 之后的代码块的类型是上下文所要求的类型的子类型；</p>
</li>
<li>
<p>在上下文没有明确的类型要求时，<code>match</code> 表达式的类型是每个 <code>case</code> 分支中 <code>=&gt;</code> 之后的代码块的类型的最小公共父类型；</p>
</li>
<li>
<p>当 <code>match</code> 表达式的值没有被使用时，其类型为 <code>Unit</code>，不要求各分支的类型有最小公共父类型。</p>
</li>
</ul>
<p>下面分别举例说明。</p>
<!-- compile -->
<pre><code class="language-cangjie">let x = 2
let s: String = match (x) {
    case 0 =&gt; &quot;x = 0&quot;
    case 1 =&gt; &quot;x = 1&quot;
    case _ =&gt; &quot;x != 0 and x != 1&quot; // Matched.
}
</code></pre>
<p>上面的例子中，定义变量 <code>s</code> 时，显式地标注了其类型为 <code>String</code>，属于上下文类型信息明确的情况，因此要求每个 <code>case</code> 的 <code>=&gt;</code> 之后的代码块的类型均是 <code>String</code> 的子类型，显然上例中 <code>=&gt;</code> 之后的字符串类型的字面量均满足要求。</p>
<p>再来看一个没有上下文类型信息的例子：</p>
<!-- compile -->
<pre><code class="language-cangjie">let x = 2
let s = match (x) {
    case 0 =&gt; &quot;x = 0&quot;
    case 1 =&gt; &quot;x = 1&quot;
    case _ =&gt; &quot;x != 0 and x != 1&quot; // Matched.
}
</code></pre>
<p>上例中，定义变量 <code>s</code> 时，未显式标注其类型，因为每个 <code>case</code> 的 <code>=&gt;</code> 之后的代码块的类型均是 <code>String</code>，所以 <code>match</code> 表达式的类型是 <code>String</code>，进而可确定 <code>s</code> 的类型也是 <code>String</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-let-表达式"><a class="header" href="#if-let-表达式">if-let 表达式</a></h1>
<p><code>if-let</code> 表达式首先对条件中 <code>&lt;-</code> 右侧的表达式进行求值，如果此值能匹配 <code>&lt;-</code> 左侧的模式，则执行 <code>if</code> 分支，否则执行 <code>else</code> 分支（可省略）。例如：</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    let result = Option&lt;Int64&gt;.Some(2023)

    if (let Some(value) &lt;- result) {
        println(&quot;操作成功，返回值为：${value}&quot;)
    } else {
        println(&quot;操作失败&quot;)
    }
}
</code></pre>
<p>运行以上程序，将输出：</p>
<pre><code class="language-text">操作成功，返回值为：2023
</code></pre>
<p>对于以上程序，如果将 <code>result</code> 的初始值修改为 <code>Option&lt;Int64&gt;.None</code>，则 <code>if-let</code> 的模式匹配会失败，将执行 <code>else</code> 分支：</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    let result = Option&lt;Int64&gt;.None

    if (let Some(value) &lt;- result) {
        println(&quot;操作成功，返回值为：${value}&quot;)
    } else {
        println(&quot;操作失败&quot;)
    }
}
</code></pre>
<p>运行以上程序，将输出：</p>
<pre><code class="language-text">操作失败
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="while-let-表达式"><a class="header" href="#while-let-表达式">while-let 表达式</a></h1>
<p><code>while-let</code> 表达式首先对条件中 <code>&lt;-</code> 右侧的表达式进行求值，如果此值能匹配 <code>&lt;-</code> 左侧的模式，则执行循环体，然后重复执行此过程。如果模式匹配失败，则结束循环，继续执行 <code>while-let</code> 表达式之后的代码。例如：</p>
<pre><code class="language-cangjie">import std.random.*

// 此函数模拟在通信中接收数据，获取数据可能失败
func recv(): Option&lt;UInt8&gt; {
    let number = Random().nextUInt8()
    if (number &lt; 128) {
        return Some(number)
    }
    return None
}

main() {
    // 模拟循环接收通信数据，如果失败就结束循环
    while (let Some(data) &lt;- recv()) {
        println(data)
    }
    println(&quot;receive failed&quot;)
}
</code></pre>
<p>运行以上程序，可能的输出为：</p>
<pre><code class="language-text">73
94
receive failed
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="其他使用模式的地方"><a class="header" href="#其他使用模式的地方">其他使用模式的地方</a></h1>
<p>模式除了可以在 <code>match</code> 表达式中使用外，还可以使用在变量定义（等号左侧是个模式）和 for in 表达式（<code>for</code> 关键字和 <code>in</code> 关键字之间是个模式）中。</p>
<p>但是，并不是所有的模式都能使用在变量定义和 <code>for in</code> 表达式中，只有 <code>irrefutable</code> 的模式才能在这两处被使用，所以只有通配符模式、绑定模式、<code>irrefutable</code> tuple 模式和 <code>irrefutable</code> enum 模式是允许的。</p>
<ol>
<li>
<p>变量定义和 <code>for in</code> 表达式中使用通配符模式的例子如下：</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    let _ = 100
    for (_ in 1..5) {
        println(&quot;0&quot;)
    }
}
</code></pre>
<p>上例中，变量定义时使用了通配符模式，表示定义了一个没有名字的变量（当然此后也就没办法对其进行访问），<code>for in</code> 表达式中使用了通配符模式，表示不会将 <code>1..5</code> 中的元素与某个变量绑定（当然循环体中就无法访问 <code>1..5</code> 中元素值）。编译执行上述代码，输出结果为：</p>
<pre><code class="language-text">0
0
0
0
</code></pre>
</li>
<li>
<p>变量定义和 <code>for in</code> 表达式中使用绑定模式的例子如下：</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    let x = 100
    println(&quot;x = ${x}&quot;)
    for (i in 1..5) {
        println(i)
    }
}
</code></pre>
<p>上例中，变量定义中的 <code>x</code> 以及 <code>for in</code> 表达式中的 <code>i</code> 都是绑定模式。编译执行上述代码，输出结果为：</p>
<pre><code class="language-text">x = 100
1
2
3
4
</code></pre>
</li>
<li>
<p>变量定义和 <code>for in</code> 表达式中使用 <code>irrefutable</code> tuple 模式的例子如下：</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    let (x, y) = (100, 200)
    println(&quot;x = ${x}&quot;)
    println(&quot;y = ${y}&quot;)
    for ((i, j) in [(1, 2), (3, 4), (5, 6)]) {
        println(&quot;Sum = ${i + j}&quot;)
    }
}

</code></pre>
<p>上例中，变量定义时使用了 tuple 模式，表示对 <code>(100, 200)</code> 进行解构并分别和 <code>x</code> 与 <code>y</code> 进行绑定，效果上相当于定义了两个变量 <code>x</code> 和 <code>y</code>。<code>for in</code> 表达式中使用了 tuple 模式，表示依次将 <code>[(1, 2), (3, 4), (5, 6)]</code> 中的 tuple 类型的元素取出，然后解构并分别和 <code>i</code> 与 <code>j</code> 进行绑定，循环体中输出 <code>i + j</code> 的值。编译执行上述代码，输出结果为：</p>
<pre><code class="language-text">x = 100
y = 200
Sum = 3
Sum = 7
Sum = 11
</code></pre>
</li>
<li>
<p>变量定义和 <code>for in</code> 表达式中使用 <code>irrefutable</code> enum 模式的例子如下：</p>
<!-- verify -->
<pre><code class="language-cangjie">enum RedColor {
    Red(Int64)
}
main() {
    let Red(red) = Red(0)
    println(&quot;red = ${red}&quot;)
    for (Red(r) in [Red(10), Red(20), Red(30)]) {
        println(&quot;r = ${r}&quot;)
    }
}
</code></pre>
<p>上例中，变量定义时使用了 enum 模式，表示对 <code>Red(0)</code> 进行解构并将构造器的参数值（即 <code>0</code>）与 <code>red</code> 进行绑定。<code>for in</code> 表达式中使用了 enum 模式，表示依次将 <code>[Red(10), Red(20), Red(30)]</code> 中的元素取出，然后解构并将构造器的参数值与 <code>r</code> 进行绑定，循环体中输出 <code>r</code> 的值。编译执行上述代码，输出结果为：</p>
<pre><code class="language-text">red = 0
r = 10
r = 20
r = 30
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类"><a class="header" href="#类">类</a></h1>
<p><code>class</code> 类型是面向对象编程中的经典概念，仓颉中同样支持使用 <code>class</code> 来实现面向对象编程。<code>class</code> 与 <code>struct</code> 的主要区别在于：<code>class</code> 是引用类型，<code>struct</code> 是值类型，它们在赋值或传参时行为是不同的；<code>class</code> 之间可以继承，但 <code>struct</code> 之间不能继承。</p>
<p>本节依次介绍如何定义 <code>class</code> 类型，如何创建对象，以及 <code>class</code> 的继承。</p>
<h2 id="class-定义"><a class="header" href="#class-定义">class 定义</a></h2>
<p><code>class</code> 类型的定义以关键字 <code>class</code> 开头，后跟 <code>class</code> 的名字，接着是定义在一对花括号中的 <code>class</code> 定义体。<code>class</code> 定义体中可以定义一系列的成员变量、成员属性（参见<a href="source_zh_cn/class_and_interface/prop.html">属性</a>）、静态初始化器、构造函数、成员函数和操作符函数（详见<a href="source_zh_cn/class_and_interface/../function/operator_overloading.html">操作符重载</a>章节））。</p>
<pre><code class="language-cangjie">class Rectangle {
    let width: Int64
    let height: Int64

    public init(width: Int64, height: Int64) {
        this.width = width
        this.height = height
    }

    public func area() {
        width * height
    }
}
</code></pre>
<p>上例中定义了名为 <code>Rectangle</code> 的 <code>class</code> 类型，它有两个 <code>Int64</code> 类型的成员变量 <code>width</code> 和 <code>height</code>，一个有两个 <code>Int64</code> 类型参数的构造函数，以及一个成员函数 <code>area</code>（返回 <code>width</code> 和 <code>height</code> 的乘积）。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p><code>class</code> 只能定义在源文件顶层。</p>
</blockquote>
<h3 id="class-成员变量"><a class="header" href="#class-成员变量">class 成员变量</a></h3>
<p><code>class</code> 成员变量分为实例成员变量和静态成员变量，静态成员变量使用 <code>static</code> 修饰符修饰，必须有初值，只能通过类型名访问，参考如下示例：</p>
<pre><code class="language-cangjie">class Rectangle {
    let width = 10
    static let height = 20
}

let l = Rectangle.height // l = 20
</code></pre>
<p>实例成员变量定义时可以不设置初值（但必须标注类型），也可以设置初值，只能通过对象（即类的实例）访问，参考如下示例：</p>
<pre><code class="language-cangjie">class Rectangle {
    let width = 10
    let height: Int64
    init(h: Int64){
        height = h
    }
}
let rec = Rectangle(20)
let l = rec.height // l = 20
</code></pre>
<h3 id="class-静态初始化器"><a class="header" href="#class-静态初始化器">class 静态初始化器</a></h3>
<p><code>class</code> 支持定义静态初始化器，并在静态初始化器中通过赋值表达式来对静态成员变量进行初始化。</p>
<p>静态初始化器以关键字组合 <code>static init</code> 开头，后跟无参参数列表和函数体，且不能被访问修饰符修饰。函数体中必须完成对所有未初始化的静态成员变量的初始化，否则编译报错。</p>
<pre><code class="language-cangjie">class Rectangle {
    static let degree: Int64
    static init() {
        degree = 180
    }
}
</code></pre>
<p>一个 <code>class</code> 中最多允许定义一个静态初始化器，否则报重定义错误。</p>
<pre><code class="language-cangjie">class Rectangle {
    static let degree: Int64
    static init() {
        degree = 180
    }
    static init() { // Error, redefinition with the previous static init function
        degree = 180
    }
}
</code></pre>
<h3 id="class-构造函数"><a class="header" href="#class-构造函数">class 构造函数</a></h3>
<p>和 <code>struct</code> 一样，<code>class</code> 中也支持定义普通构造函数和主构造函数。</p>
<p>普通构造函数以关键字 <code>init</code> 开头，后跟参数列表和函数体，函数体中必须完成所有未初始化实例成员变量的初始化，否则编译报错。</p>
<pre><code class="language-cangjie">class Rectangle {
    let width: Int64
    let height: Int64

    public init(width: Int64, height: Int64) { // Error, 'height' is not initialized in the constructor
        this.width = width
    }
}
</code></pre>
<p>一个类中可以定义多个普通构造函数，但它们必须构成重载（参见<a href="source_zh_cn/class_and_interface/../function/function_overloading.html">函数重载</a>），否则报重定义错误。</p>
<pre><code class="language-cangjie">class Rectangle {
    let width: Int64
    let height: Int64

    public init(width: Int64) {
        this.width = width
        this.height = width
    }

    public init(width: Int64, height: Int64) { // Ok: overloading with the first init function
        this.width = width
        this.height = height
    }

    public init(height: Int64) { // Error, redefinition with the first init function
        this.width = height
        this.height = height
    }
}
</code></pre>
<p>除了可以定义若干普通的以 <code>init</code> 为名字的构造函数外，<code>class</code> 内还可以定义（最多）一个主构造函数。主构造函数的名字和 <code>class</code> 类型名相同，它的参数列表中可以有两种形式的形参：普通形参和成员变量形参（需要在参数名前加上 <code>let</code> 或 <code>var</code>），成员变量形参同时具有定义成员变量和构造函数参数的功能。</p>
<p>使用主构造函数通常可以简化 <code>class</code> 的定义，例如，上述包含一个 <code>init</code> 构造函数的 <code>Rectangle</code> 可以简化为如下定义：</p>
<pre><code class="language-cangjie">class Rectangle {
    public Rectangle(let width: Int64, let height: Int64) {}
}
</code></pre>
<p>主构造函数的参数列表中也可以定义普通形参，例如：</p>
<pre><code class="language-cangjie">class Rectangle {
    public Rectangle(name: String, let width: Int64, let height: Int64) {}
}
</code></pre>
<p>如果 <code>class</code> 定义中不存在自定义构造函数（包括主构造函数），并且所有实例成员变量都有初值，则会自动为其生成一个无参构造函数（调用此无参构造函数会创建一个所有实例成员变量的值均等于其初值的对象）；否则，不会自动生成此无参构造函数。例如，对于如下 <code>class</code> 定义，编译器会为其自动生成一个无参构造函数：</p>
<pre><code class="language-cangjie">class Rectangle {
    let width = 10
    let height = 20

    /* Auto-generated parameterless constructor:
    public init() {

    }
    */
}

// Invoke the auto-generated parameterless constructor
let r = Rectangle() // r.width = 10，r.height = 20
</code></pre>
<h3 id="class-终结器"><a class="header" href="#class-终结器">class 终结器</a></h3>
<p><code>class</code> 支持定义终结器，这个函数在类的实例被垃圾回收的时候被调用。终结器的函数名固定为 <code>~init</code>。终结器一般被用于释放系统资源：</p>
<pre><code class="language-cangjie">class C {
    var p: CString

    init(s: String) {
        p = unsafe { LibC.mallocCString(s) }
        println(s)
    }
    ~init() {
        unsafe { LibC.free(p) }
    }
}
</code></pre>
<p>使用终结器有些限制条件，需要开发者注意：</p>
<ol>
<li>终结器没有参数，没有返回类型，没有泛型类型参数，没有任何修饰符，也不可以被显式调用。</li>
<li>带有终结器的类不可被 <code>open</code> 修饰，只有非 <code>open</code> 的类可以拥有终结器。</li>
<li>一个类最多只能定义一个终结器。</li>
<li>终结器不可以定义在扩展中。</li>
<li>终结器被触发的时机是不确定的。</li>
<li>终结器可能在任意一个线程上执行。</li>
<li>多个终结器的执行顺序是不确定的。</li>
<li>终结器向外抛出未捕获异常属于未定义行为。</li>
<li>终结器中创建线程或者使用线程同步功能属于未定义行为。</li>
<li>终结器执行结束之后，如果这个对象还可以被继续访问，则属于未定义行为。</li>
</ol>
<h3 id="class-成员函数"><a class="header" href="#class-成员函数">class 成员函数</a></h3>
<p><code>class</code> 成员函数同样分为实例成员函数和静态成员函数（使用 <code>static</code> 修饰符修饰），实例成员函数只能通过对象访问，静态成员函数只能通过 <code>class</code> 类型名访问；静态成员函数中不能访问实例成员变量，也不能调用实例成员函数，但在实例成员函数中可以访问静态成员变量以及静态成员函数。</p>
<p>下例中，<code>area</code> 是实例成员函数，<code>typeName</code> 是静态成员函数。</p>
<pre><code class="language-cangjie">class Rectangle {
    let width: Int64 = 10
    let height: Int64 = 20

    public func area() {
        this.width * this.height
    }

    public static func typeName(): String {
        &quot;Rectangle&quot;
    }
}
</code></pre>
<p>根据有没有函数体，实例成员函数又可以分为抽象成员函数和非抽象成员函数。抽象成员函数没有函数体，只能定义在抽象类或接口（详见<a href="source_zh_cn/class_and_interface/interface.html">接口</a>章节）中。例如，下例中在抽象类 <code>AbRectangle</code>（使用关键字 <code>abstract</code> 修饰）中定义了抽象函数 <code>foo</code>。</p>
<pre><code class="language-cangjie">abstract class AbRectangle {
    public func foo(): Unit
}
</code></pre>
<p>需要注意的是，抽象实例成员函数默认具有 <code>open</code> 的语义，<code>open</code> 修饰符是可选的，且必须使用 <code>public</code> 或 <code>protected</code> 进行修饰。</p>
<p>非抽象函数必须有函数体，在函数体中可以通过 <code>this</code> 访问实例成员变量，例如：</p>
<pre><code class="language-cangjie">class Rectangle {
    let width: Int64 = 10
    let height: Int64 = 20

    public func area() {
        this.width * this.height
    }
}
</code></pre>
<h3 id="class-成员的访问修饰符"><a class="header" href="#class-成员的访问修饰符">class 成员的访问修饰符</a></h3>
<p>对于 <code>class</code> 的成员（包括成员变量、成员属性、构造函数、成员函数），可以使用的访问修饰符有 4 种访问修饰符修饰：<code>private</code>、<code>internal</code>、<code>protected</code> 和 <code>public</code>，缺省的含义是 <code>internal</code>。</p>
<ul>
<li><code>private</code> 表示在 <code>class</code> 定义内可见。</li>
<li><code>internal</code> 表示仅当前包及子包（包括子包的子包，详见<a href="source_zh_cn/class_and_interface/../package/toplevel_access.html">包</a>章节）内可见。</li>
<li><code>protected</code> 表示当前模块（详见<a href="source_zh_cn/class_and_interface/../package/toplevel_access.html">包</a>章节）及当前类的子类可见。</li>
<li><code>public</code> 表示模块内外均可见。</li>
</ul>
<pre><code class="language-cangjie">package a
public open class Rectangle {
    public var width: Int64
    protected var height: Int64
    private var area: Int64
    public init(width: Int64, height: Int64) {
        this.width = width
        this.height = height
        this.area = this.width * this.height
    }
    init(width: Int64, height: Int64, multiple: Int64) {
        this.width = width
        this.height = height
        this.area = width * height * multiple
    }
}

func samePkgFunc() {
    var r = Rectangle(10, 20) // Ok: constructor 'Rectangle' can be accessed here
    r.width = 8               // Ok: public 'width' can be accessed here
    r.height = 24             // Ok: protected 'height' can be accessed here
    r.area = 30               // Error, private 'area' cannot be accessed here
}
</code></pre>
<pre><code class="language-cangjie">package b
import a.*
public class Cuboid &lt;: Rectangle {
    private var length: Int64
    public init(width: Int64, height: Int64, length: Int64) {
        super(width, height)
        this.length = length
    }
    public func volume() {
        this.width * this.height * this.length // Ok: protected 'height' can be accessed here
    }
}

main() {
    var r = Rectangle(10, 20, 2) // Error, Rectangle has no `public` constructor with three parameters
    var c = Cuboid(20, 20, 20)
    c.width = 8               // Ok: public 'width' can be accessed here
    c.height = 24             // Error, protected 'height' cannot be accessed here
    c.area = 30               // Error, private 'area' cannot be accessed here
}
</code></pre>
<h2 id="this-类型"><a class="header" href="#this-类型">This 类型</a></h2>
<p>在类内部，我们支持 <code>This</code> 类型占位符，代指当前类的类型。它只能被作为实例成员函数的返回类型来使用，当使用子类对象调用在父类中定义的返回 <code>This</code> 类型的函数时，该函数调用的类型会被识别为子类类型，而非定义所在的父类类型。</p>
<p>如果实例成员函数没有声明返回类型，并且只存在返回 <code>This</code> 类型表达式时，当前函数的返回类型会推断为 <code>This</code>。示例如下：</p>
<pre><code class="language-cangjie">open class C1 {
    func f(): This {  // its type is `() -&gt; C1`
        return this
    }

    func f2() { // its type is `() -&gt; C1`
        return this
    }

    public open func f3(): C1 {
        return this
    }
}
class C2 &lt;: C1 {
    // member function f is inherited from C1, and its type is `() -&gt; C2` now
    public override func f3(): This { // Ok
        return this
    }
}

var obj1: C2 = C2()
var obj2: C1 = C2()

var x = obj1.f()    // During compilation, the type of x is C2
var y = obj2.f()    // During compilation, the type of y is C1
</code></pre>
<h2 id="创建对象"><a class="header" href="#创建对象">创建对象</a></h2>
<p>定义了 <code>class</code> 类型后，即可通过调用其构造函数来创建对象（通过 <code>class</code> 类型名调用构造函数）。例如，下例中通过 <code>Rectangle(10, 20)</code> 创建 <code>Rectangle</code> 类型的对象并赋值给变量 <code>r</code>。</p>
<pre><code class="language-cangjie">let r = Rectangle(10, 20)
</code></pre>
<p>创建对象之后，可以通过对象访问（<code>public</code> 修饰的）实例成员变量和实例成员函数。例如，下例中通过 <code>r.width</code> 和 <code>r.height</code> 可分别访问 <code>r</code> 中 <code>width</code> 和 <code>height</code> 的值，通过 <code>r.area()</code> 可以调用成员函数 <code>area</code>。</p>
<pre><code class="language-cangjie">let r = Rectangle(10, 20) // r.width = 10, r.height = 20
let width = r.width       // width = 10
let height = r.height     // height = 20
let a = r.area()          // a = 200
</code></pre>
<p>如果希望通过对象去修改成员变量的值（不鼓励这种方式，最好还是通过成员函数去修改），需要将 <code>class</code> 类型中的成员变量定义为可变成员变量（即使用 <code>var</code> 定义）。举例如下：</p>
<pre><code class="language-cangjie">class Rectangle {
    public var width: Int64
    public var height: Int64

    ...
}

main() {
    let r = Rectangle(10, 20) // r.width = 10, r.height = 20
    r.width = 8               // r.width = 8
    r.height = 24             // r.height = 24
    let a = r.area()          // a = 192
}
</code></pre>
<p>不同于 <code>struct</code>，对象在赋值或传参时，不会将对象进行复制，多个变量指向的是同一个对象，通过一个变量去修改对象中成员的值，其他变量中对应的成员变量也会被修改。以赋值为例，下面的例子中，将 <code>r1</code> 赋值给 <code>r2</code> 之后，修改 <code>r1</code> 的 <code>width</code> 和 <code>height</code> 的值，<code>r2</code> 的 <code>width</code> 和 <code>height</code> 值也同样会被修改。</p>
<pre><code class="language-cangjie">main() {
    var r1 = Rectangle(10, 20) // r1.width = 10, r1.height = 20
    var r2 = r1                // r2.width = 10, r2.height = 20
    r1.width = 8               // r1.width = 8
    r1.height = 24             // r1.height = 24
    let a1 = r1.area()         // a1 = 192
    let a2 = r2.area()         // a2 = 192
}
</code></pre>
<h2 id="class-的继承"><a class="header" href="#class-的继承">class 的继承</a></h2>
<p>像大多数支持 <code>class</code> 的编程语言一样，仓颉中的 <code>class</code> 同样支持继承。如果类 B 继承类 A，则我们称 A 为父类，B 为子类。子类将继承父类中除 <code>private</code> 成员和构造函数以外的所有成员。</p>
<p>抽象类总是可被继承的，故抽象类定义时的 <code>open</code> 修饰符是可选的，也可以使用 <code>sealed</code> 修饰符修饰抽象类，表示该抽象类只能在本包被继承。但非抽象的类可被继承是有条件的：定义时必须使用修饰符 <code>open</code> 修饰。当带 <code>open</code> 修饰的实例成员被 class 继承时，该 <code>open</code> 的修饰符也会被继承。当非 <code>open</code> 修饰的类中存在 <code>open</code> 修饰的成员时，编译器会给出告警。</p>
<p>可以在子类定义处通过 <code>&lt;:</code> 指定其继承的父类，但要求父类必须是可继承的。例如，下面的例子中，<code>class</code> A 使用 <code>open</code> 修饰，是可以被类 B 继承的，但是因为类 B 是不可继承的，所以 C 在继承 B 的时候会报错。</p>
<pre><code class="language-cangjie">open class A {
    let a: Int64 = 10
}

class B &lt;: A { // Ok: 'B' Inheritance 'A'
    let b: Int64 = 20
}

class C &lt;: B { // Error, 'B' is not inheritable
    let c: Int64 = 30
}
</code></pre>
<p><code>class</code> 仅支持单继承，因此下面这样一个类继承两个类的代码是不合法的（<code>&amp;</code> 是类实现多个接口时的语法，详见<a href="source_zh_cn/class_and_interface/interface.html">接口</a>章节）。</p>
<pre><code class="language-cangjie">open class A {
    let a: Int64 = 10
}

open class B {
    let b: Int64 = 20
}

class C &lt;: A &amp; B { // Error, 'C' can only inherit one class
    let c: Int64 = 30
}
</code></pre>
<p>因为类是单继承的，所以任何类都最多只能有一个直接父类。对于定义时指定了父类的 <code>class</code>，它的直接父类就是定义时指定的类，对于定义时未指定父类的 <code>class</code>，它的直接父类是 <code>Object</code> 类型。<code>Object</code> 是所有类的父类（注意，<code>Object</code> 没有直接父类，并且 <code>Object</code> 中不包含任何成员）。</p>
<p>因为子类是继承自父类的，所以子类的对象天然可以当做父类的对象使用，但是反之不然。例如，下例中 B 是 A 的子类，那么 B 类型的对象可以赋值给 A 类型的变量，但是 A 类型的对象不能赋值给 B 类型的变量。</p>
<pre><code class="language-cangjie">open class A {
    let a: Int64 = 10
}

class B &lt;: A {
    let b: Int64 = 20
}

let a: A = B() // Ok: subclass objects can be assigned to superclass variables
</code></pre>
<pre><code class="language-cangjie">open class A {
    let a: Int64 = 10
}

class B &lt;: A {
    let b: Int64 = 20
}

let b: B = A() // Error, superclass objects can not be assigned to subclass variables
</code></pre>
<p><code>class</code> 定义的类型不允许继承类型本身。</p>
<pre><code class="language-cangjie">class A &lt;: A {}  // Error, 'A' inherits itself.
</code></pre>
<p><code>sealed</code> 修饰符只能修饰抽象类，表示被修饰的类定义只能在本定义所在的包内被其他类继承。<code>sealed</code> 已经蕴含了 <code>public</code>/<code>open</code> 的语义，因此定义 sealed abstract class 时若提供 <code>public</code>/<code>open</code> 修饰符，编译器将会告警。<code>sealed</code> 的子类可以不是 <code>sealed</code> 类，仍可被 <code>open</code>/<code>sealed</code> 修饰，或不使用任何继承性修饰符。若 <code>sealed</code> 类的子类被 <code>open</code> 修饰，则其子类可在包外被继承。<code>sealed</code> 的子类可以不被 <code>public</code> 修饰。</p>
<pre><code class="language-cangjie">package A
public sealed abstract class C1 {}   // Warning, redundant modifier, 'sealed' implies 'public'
sealed open abstract class C2 {}     // Warning, redundant modifier, 'sealed' implies 'open'
sealed abstract class C3 {}          // OK, 'public' is optional when 'sealed' is used

class S1 &lt;: C1 {}  // OK
public open class S2 &lt;: C1 {}   // OK
public sealed abstract class S3 &lt;: C1 {}  // OK
open class S4 &lt;: C1 {}   // OK
</code></pre>
<pre><code class="language-cangjie">package B
import A.*

class SS1 &lt;: S2 {}  // OK
class SS2 &lt;: S3 {}  // Error, S3 is sealed class, cannot be inherited here.
sealed class SS3 {} // Error, 'sealed' cannot be used on non-abstract class.
</code></pre>
<h3 id="父类构造函数调用"><a class="header" href="#父类构造函数调用">父类构造函数调用</a></h3>
<p>子类的 <code>init</code> 构造函数可以使用 <code>super(args)</code> 的形式调用父类构造函数，或使用 <code>this(args)</code> 的形式调用本类其它构造函数，但两者之间只能调用一个。如果调用，必须在构造函数体内的第一个表达式处，在此之前不能有任何表达式或声明。</p>
<pre><code class="language-cangjie">open class A {
    A(let a: Int64) {}
}

class B &lt;: A {
    let b: Int64
    init(b: Int64) {
        super(30)
        this.b = b
    }

    init() {
        this(20)
    }
}
</code></pre>
<p>子类的主构造函数中，可以使用 <code>super(args)</code> 的形式调用父类构造函数，但不能使用 <code>this(args)</code> 的形式调用本类其它构造函数。</p>
<p>如果子类的构造函数没有显式调用父类构造函数，也没有显式调用其他构造函数，编译器会在该构造函数体的开始处插入直接父类的无参构造函数的调用。如果此时父类没有无参构造函数，则会编译报错；</p>
<pre><code class="language-cangjie">open class A {
    let a: Int64
    init() {
        a = 100
    }
}

open class B &lt;: A {
    let b: Int64
    init(b: Int64) {
        // OK, `super()` added by compiler
        this.b = b
    }
}

open class C &lt;: B {
    let c: Int64
    init(c: Int64) {  // Error, there is no non-parameter constructor in super class
        this.c = c
    }
}
</code></pre>
<h3 id="覆盖和重定义"><a class="header" href="#覆盖和重定义">覆盖和重定义</a></h3>
<p>子类中可以覆盖（override）父类中的同名非抽象实例成员函数，即在子类中为父类中的某个实例成员函数定义新的实现。覆盖时，要求父类中的成员函数使用 <code>open</code> 修饰，子类中的同名函数使用 <code>override</code> 修饰，其中 <code>override</code> 是可选的。例如，下面的例子中，子类 B 中的函数 <code>f</code> 覆盖了父类 A 中的函数 <code>f</code>。</p>
<!-- verify -->
<pre><code class="language-cangjie">open class A {
    public open func f(): Unit {
        println(&quot;I am superclass&quot;)
    }
}

class B &lt;: A {
    public override func f(): Unit {
        println(&quot;I am subclass&quot;)
    }
}

main() {
    let a: A = A()
    let b: A = B()
    a.f()
    b.f()
}
</code></pre>
<p>对于被覆盖的函数，调用时将根据变量的运行时类型（由实际赋给该变量的对象决定）确定调用的版本（即所谓的动态派发）。例如，上例中 <code>a</code> 的运行时类型是 A，因此 <code>a.f()</code> 调用的是父类 A 中的函数 <code>f</code>；<code>b</code> 的运行时类型是 B（编译时类型是 A），因此 <code>b.f()</code> 调用的是子类 B 中的函数 <code>f</code>。所以程序会输出：</p>
<pre><code class="language-text">I am superclass
I am subclass
</code></pre>
<p>对于静态函数，子类中可以重定义父类中的同名非抽象静态函数，即在子类中为父类中的某个静态函数定义新的实现。重定义时，要求子类中的同名静态函数使用 <code>redef</code> 修饰，其中 <code>redef</code> 是可选的。例如，下面的例子中，子类 D 中的函数 <code>foo</code> 重定义了父类 C 中的函数 <code>foo</code>。</p>
<!-- verify -->
<pre><code class="language-cangjie">open class C {
    public static func foo(): Unit {
        println(&quot;I am class C&quot;)
    }
}

class D &lt;: C {
    public redef static func foo(): Unit {
        println(&quot;I am class D&quot;)
    }
}

main() {
    C.foo()
    D.foo()
}
</code></pre>
<p>对于被重定义的函数，调用时将根据 <code>class</code> 的类型决定调用的版本。例如，上例中 <code>C.foo()</code> 调用的是父类 C 中的函数 <code>foo</code>，<code>D.foo()</code> 调用的是子类 D 中的函数 <code>foo</code>。</p>
<pre><code class="language-text">I am class C
I am class D
</code></pre>
<p>如果抽象函数或 <code>open</code> 修饰的函数有命名形参，那么实现函数或 <code>override</code> 修饰的函数也需要保持同样的命名形参。</p>
<pre><code class="language-cangjie">open class A {
    public open func f(a!: Int32): Int32 {
        a + 1
    }
}

class B &lt;: A {
    public override func f(a!: Int32): Int32 { // Ok
        a + 2
    }
}

class C &lt;: A {
    public override func f(b!: Int32): Int32 { // Error
        b + 3
    }
}

main() {
    B().f(a: 0)
    C().f(b: 0)
}
</code></pre>
<p>还需要注意的是，当实现或重定义的函数为泛型函数时，子类型函数的类型变元约束需要比父类型中对应函数更宽松或相同。</p>
<pre><code class="language-cangjie">open class A {}
open class B &lt;: A {}
open class C &lt;: B {}

open class Base {
    static func f&lt;T&gt;(a: T): Unit where T &lt;: B {}
    static func g&lt;T&gt;(): Unit where T &lt;: B {}
}

class D &lt;: Base {
    redef static func f&lt;T&gt;(a: T): Unit where T &lt;: C {} // Error, stricter constraint
    redef static func g&lt;T&gt;(): Unit where T &lt;: C {} // Error, stricter constraint
}

class E &lt;: Base {
    redef static func f&lt;T&gt;(a: T): Unit where T &lt;: A {} // OK: looser constraint
    redef static func g&lt;T&gt;(): Unit where T &lt;: A {} // OK: looser constraint
}

class F &lt;: Base {
    redef static func f&lt;T&gt;(a: T): Unit where T &lt;: B {} // OK: same constraint
    redef static func g&lt;T&gt;(): Unit where T &lt;: B {} // OK: same constraint
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="接口"><a class="header" href="#接口">接口</a></h1>
<p>接口用来定义一个抽象类型，它不包含数据，但可以定义类型的行为。一个类型如果声明实现某接口，并且实现了该接口中所有的成员，就被称为实现了该接口。</p>
<p>接口的成员可以包含：</p>
<ul>
<li>成员函数</li>
<li>操作符重载函数</li>
<li>成员属性</li>
</ul>
<p>这些成员都是抽象的，要求实现类型必须拥有对应的成员实现。</p>
<h2 id="接口定义"><a class="header" href="#接口定义">接口定义</a></h2>
<p>一个简单的接口定义如下：</p>
<!-- verify -interface -->
<pre><code class="language-cangjie">interface I { // 'open' modifier is optional.
    func f(): Unit
}
</code></pre>
<p>接口使用关键字 <code>interface</code> 声明，其后是接口的标识符 <code>I</code> 和接口的成员。接口成员可被 <code>open</code> 修饰符修饰，并且 <code>open</code> 修饰符是可选的。</p>
<p>当接口 <code>I</code> 声明了一个成员函数 <code>f</code> 之后，要为一个类型实现 <code>I</code> 时，就必须在该类型中实现一个对应的 <code>f</code> 函数。</p>
<p>因为 <code>interface</code> 默认具有 <code>open</code> 语义，所以 <code>interface</code> 定义时的 <code>open</code> 修饰符是可选的。</p>
<p>如下面的代码所示，定义了一个 <code>class Foo</code>，使用 <code>Foo &lt;: I</code> 的形式声明了 <code>Foo</code> 实现 <code>I</code> 接口。</p>
<p>在 <code>Foo</code> 中必须包含 <code>I</code> 声明的所有成员的实现，即需要定义一个相同类型的 <code>f</code>，否则会由于没有实现接口而编译报错。</p>
<!-- verify -interface -->
<pre><code class="language-cangjie">class Foo &lt;: I {
    public func f(): Unit {
        println(&quot;Foo&quot;)
    }
}

main() {
    let a = Foo()
    let b: I = a
    b.f() // &quot;Foo&quot;
}
</code></pre>
<p>当某个类型实现了某个接口之后，该类型就会成为该接口的子类型。</p>
<p>对于上面的例子，<code>Foo</code> 是 <code>I</code> 的子类型，因此任何一个 <code>Foo</code> 类型的实例，都可以当作 <code>I</code> 类型的实例使用。</p>
<p>在 <code>main</code> 中我们将一个 <code>Foo</code> 类型的变量 <code>a</code>，赋值给一个 <code>I</code> 类型的变量 <code>b</code>。然后我们再调用 <code>b</code> 中的函数 <code>f</code>，就会打印出 <code>Foo</code> 实现的 <code>f</code> 版本。程序的输出结果为：</p>
<!-- verify -interface -->
<pre><code class="language-text">Foo
</code></pre>
<p><code>interface</code> 也可以使用 <code>sealed</code> 修饰符表示只能在 <code>interface</code> 定义所在的包内继承、实现或扩展该 <code>interface</code>。<code>sealed</code> 已经蕴含了 <code>public</code>/<code>open</code> 的语义，因此定义 <code>sealed interface</code> 时若提供 <code>public</code>/<code>open</code> 修饰符，编译器将会告警。继承 <code>sealed</code> 接口的子接口或实现 <code>sealed</code> 接口的类仍可被 <code>sealed</code> 修饰或不使用 <code>sealed</code> 修饰。若 <code>sealed</code> 接口的子接口被 <code>public</code> 修饰，且不被 <code>sealed</code> 修饰，则其子接口可在包外被继承、实现或扩展。继承、实现 sealed 接口的类型可以不被 <code>public</code> 修饰。</p>
<pre><code class="language-cangjie">package A
public interface I1 {}
sealed interface I2 {}         // OK
public sealed interface I3 {}  // Warning, redundant modifier, 'sealed' implies 'public'
sealed open interface I4 {}    // Warning, redundant modifier, 'sealed' implies 'open'

class C1 &lt;: I1 {}
public open class C2 &lt;: I1 {}
sealed class C3 &lt;: I2 {}
extend Int64 &lt;: I2 {}
</code></pre>
<pre><code class="language-cangjie">package B
import A.*

class S1 &lt;: I1 {}  // OK
class S2 &lt;: I2 {}  // Error, I2 is sealed interface, cannot be inherited here.
</code></pre>
<p>通过接口的这种约束能力，我们可以对一系列的类型约定共同的功能，达到对功能进行抽象的目的。</p>
<p>例如下面的代码，我们可以定义一个 Flyable 接口，并且让其他具有 Flyable 属性的类实现它。</p>
<!-- verify -->
<pre><code class="language-cangjie">interface Flyable {
    func fly(): Unit
}

class Bird &lt;: Flyable {
    public func fly(): Unit {
        println(&quot;Bird flying&quot;)
    }
}

class Bat &lt;: Flyable {
    public func fly(): Unit {
        println(&quot;Bat flying&quot;)
    }
}

class Airplane &lt;: Flyable {
    public func fly(): Unit {
        println(&quot;Airplane flying&quot;)
    }
}

func fly(item: Flyable): Unit {
    item.fly()
}

main() {
    let bird = Bird()
    let bat = Bat()
    let airplane = Airplane()
    fly(bird)
    fly(bat)
    fly(airplane)
}
</code></pre>
<p>编译并执行上面的代码，我们会看到如下输出：</p>
<pre><code class="language-text">Bird flying
Bat flying
Airplane flying
</code></pre>
<p>接口的成员可以是实例的或者静态的，以上的例子已经展示过实例成员函数的作用，接下来我们来看看静态成员函数的作用。</p>
<p>静态成员函数和实例成员函数类似，都要求实现类型提供实现。</p>
<p>例如下面的例子，我们定义了一个 <code>NamedType</code> 接口，这个接口含有一个静态成员函数 <code>typename</code> 用来获得每个类型的字符串名称。</p>
<p>这样其它类型在实现 <code>NamedType</code> 接口时就必须实现 <code>typename</code> 函数，之后我们就可以安全地在 <code>NamedType</code> 的子类型上获得类型的名称。</p>
<!-- verify -->
<pre><code class="language-cangjie">interface NamedType {
    static func typename(): String
}

class A &lt;: NamedType {
    public static func typename(): String {
        &quot;A&quot;
    }
}

class B &lt;: NamedType {
    public static func typename(): String {
        &quot;B&quot;
    }
}

main() {
    println(&quot;the type is ${ A.typename() }&quot;)
    println(&quot;the type is ${ B.typename() }&quot;)
}
</code></pre>
<p>程序输出结果为：</p>
<pre><code class="language-text">the type is A
the type is B
</code></pre>
<p>接口中的静态成员函数（或属性）可以没有默认实现，也可以拥有默认实现。</p>
<p>当其没有默认实现时，将无法通过接口类型名对其进行访问。例如下面的代码，直接访问 <code>NamedType</code> 的 <code>typename</code> 函数会发生编译报错，因为 <code>NamedType</code> 不具有 <code>typename</code> 函数的实现。</p>
<pre><code class="language-cangjie">main() {
    NamedType.typename() // Error
}
</code></pre>
<p>接口中的静态成员函数（或属性）也可以拥有默认实现，当另一个类型继承拥有默认静态函数（或属性）实现的接口时，该类型可以不再实现这个静态成员函数（或属性），该函数（或属性）可以通过接口名和该类型名直接访问。如下用例，<code>NamedType</code> 的成员函数 <code>typename</code> 拥有默认实现，且在 <code>A</code> 中都可以不用再重新实现它，同时，也可以通过接口名和该类型名对其进行直接访问。</p>
<!-- verify -->
<pre><code class="language-cangjie">interface NamedType {
    static func typename(): String {
        &quot;interface NamedType&quot;
    }
}

class A &lt;: NamedType {}

main() {
    println(NamedType.typename())
    println(A.typename())
    0
}
</code></pre>
<p>程序输出结果为：</p>
<pre><code class="language-text">interface NamedType
interface NamedType
</code></pre>
<p>通常我们会通过泛型约束，在泛型函数中使用这类静态成员。</p>
<p>例如下面的 <code>printTypeName</code> 函数，当我们约束泛型变元 <code>T</code> 是 <code>NamedType</code> 的子类型时，我们需要保证 <code>T</code> 的实例化类型中所有的静态成员函数（或属性）都必须拥有实现，以保证可以使用 <code>T.typename</code> 的方式访问泛型变元的实现，达到了我们对静态成员抽象的目的。详见<a href="source_zh_cn/class_and_interface/../generic/generic_overview.html">泛型</a>章节。</p>
<pre><code class="language-cangjie">interface NamedType {
    static func typename(): String
}

interface I &lt;: NamedType {
    static func typename(): String {
        f()
    }
    static func f(): String
}

class A &lt;: NamedType {
    public static func typename(): String {
        &quot;A&quot;
    }
}

class B &lt;: NamedType {
    public static func typename(): String {
        &quot;B&quot;
    }
}

func printTypeName&lt;T&gt;() where T &lt;: NamedType {
    println(&quot;the type is ${ T.typename() }&quot;)
}

main() {
    printTypeName&lt;A&gt;() // Ok
    printTypeName&lt;B&gt;() // Ok
    printTypeName&lt;I&gt;() // Error, 'I' must implement all static function. Otherwise, an unimplemented 'f' is called, causing problems.
}
</code></pre>
<p>需要注意的是，接口的成员默认就被 <code>public</code> 修饰，不可以声明额外的访问控制修饰符，同时也要求实现类型必须使用 <code>public</code> 实现。</p>
<pre><code class="language-cangjie">interface I {
    func f(): Unit
}

open class C &lt;: I {
    protected func f() {} // Compiler Error, f needs to be public semantics
}
</code></pre>
<h2 id="接口继承"><a class="header" href="#接口继承">接口继承</a></h2>
<p>当我们想为一个类型实现多个接口，可以在声明处使用 <code>&amp;</code> 分隔多个接口，实现的接口之间没有顺序要求。</p>
<p>例如下面的例子，我们可以让 MyInt 同时实现 Addable 和 Subtractable 两个接口。</p>
<pre><code class="language-cangjie">interface Addable {
    func add(other: Int64): Int64
}

interface Subtractable {
    func sub(other: Int64): Int64
}

class MyInt &lt;: Addable &amp; Subtractable {
    var value = 0
    public func add(other: Int64): Int64 {
        value + other
    }
    public func sub(other: Int64): Int64 {
        value - other
    }
}
</code></pre>
<p>接口可以继承一个或多个接口，但不能继承类。与此同时，接口继承的时候可以添加新的接口成员。</p>
<p>例如下面的例子，Calculable 接口继承了 Addable 和 Subtractable 两个接口，并且增加了乘除两种运算符重载。</p>
<!-- compile -myInt -->
<pre><code class="language-cangjie">interface Addable {
    func add(other: Int64): Int64
}

interface Subtractable {
    func sub(other: Int64): Int64
}

interface Calculable &lt;: Addable &amp; Subtractable {
    func mul(other: Int64): Int64
    func div(other: Int64): Int64
}
</code></pre>
<p>这样实现类型实现 Calculable 接口时就必须同时实现加减乘除四种运算符重载，不能缺少任何一个成员。</p>
<!-- compile -myInt -->
<pre><code class="language-cangjie">class MyInt &lt;: Calculable {
    var value = 0
    public func add(other: Int64): Int64 {
        value + other
    }
    public func sub(other: Int64): Int64 {
        value - other
    }
    public func mul(other: Int64): Int64 {
        value * other
    }
    public func div(other: Int64): Int64 {
        value / other
    }
}
</code></pre>
<p>MyInt 实现 Calculable 的同时，也同时实现了 Calculable 继承的所有接口，因此 MyInt 也实现了 Addable 和 Subtractable，即同时是它们的子类型。</p>
<!-- compile -myInt -->
<pre><code class="language-cangjie">main() {
    let myInt = MyInt()
    let add: Addable = myInt
    let sub: Subtractable = myInt
    let calc: Calculable = myInt
}
</code></pre>
<p>对于 <code>interface</code> 的继承，子接口如果继承了父接口中有默认实现的函数或属性，则在子接口中不允许仅写此函数或属性的声明（即没有默认实现），而是必须要给出新的默认实现，并且函数定义前的 <code>override</code> 修饰符（或 <code>redef</code> 修饰符）是可选的；子接口如果继承了父接口中没有默认实现的函数或属性，则在子接口中允许仅写此函数或属性的声明（当然也允许定义默认实现），并且函数声明或定义前的 override 修饰符（或 <code>redef</code> 修饰符）是可选的。</p>
<pre><code class="language-cangjie">interface I1 {
   func f(a: Int64) {
        a
   }
   static func g(a: Int64) {
        a
   }
   func f1(a: Int64): Unit
   static func g1(a: Int64): Unit
}

interface I2 &lt;: I1 {
    /*'override' is optional*/ func f(a: Int64) {
       a + 1
    }
    override func f(a: Int32) {} // Error, override function 'f' does not have an overridden function from its supertypes
    static /*'redef' is optional*/ func g(a: Int64) {
       a + 1
    }
    /*'override' is optional*/ func f1(a: Int64): Unit {}
    static /*'redef' is optional*/ func g1(a: Int64): Unit {}
}
</code></pre>
<h2 id="接口实现"><a class="header" href="#接口实现">接口实现</a></h2>
<p>仓颉所有的类型都可以实现接口，包括数值类型、Rune、String、struct、class、enum、Tuple、函数以及其它类型。</p>
<p>一个类型实现接口有三种途径：</p>
<ol>
<li>在定义类型时就声明实现接口，在以上的内容中我们已经见过相关例子。</li>
<li>通过扩展实现接口，这种方式详见<a href="source_zh_cn/class_and_interface/../extension/interface_extension.html">扩展</a>章节。</li>
<li>由语言内置实现，具体详见《仓颉编程语言库 API》相关文档。</li>
</ol>
<p>实现类型声明实现接口时，需要实现接口中要求的所有成员，为此需要满足下面一些规则。</p>
<ol>
<li>对于成员函数和操作符重载函数，要求实现类型提供的函数实现与接口对应的函数名称相同、参数列表相同、返回类型相同。</li>
<li>对于成员属性，要求是否被 <code>mut</code> 修饰保持一致，并且属性的类型相同。</li>
</ol>
<p>所以大部分情况都如同上面的例子，我们需要让实现类型中包含与接口要求的一样的成员的实现。</p>
<p>但有个地方是个例外，如果接口中的成员函数或操作符重载函数的返回值类型是 class 类型，那么允许实现函数的返回类型是其子类型。</p>
<p>例如下面这个例子，<code>I</code> 中的 <code>f</code> 返回类型是一个 <code>class</code> 类型 <code>Base</code>，因此 <code>C</code> 中实现的 <code>f</code> 返回类型可以是 <code>Base</code> 的子类型 <code>Sub</code>。</p>
<pre><code class="language-cangjie">open class Base {}
class Sub &lt;: Base {}

interface I {
    func f(): Base
}

class C &lt;: I {
    public func f(): Sub {
        Sub()
    }
}
</code></pre>
<p>除此以外，接口的成员还可以为 class 类型提供默认实现。拥有默认实现的接口成员，当实现类型是 class 的时候，class 可以不提供自己的实现而继承接口的实现。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>默认实现只对类型是 class 的实现类型有效，对其它类型无效。</p>
</blockquote>
<p>例如下面的代码中，<code>SayHi</code> 中的 <code>say</code> 拥有默认实现，因此 <code>A</code> 实现 <code>SayHi</code> 时可以继承 <code>say</code> 的实现，而 <code>B</code> 也可以选择提供自己的 <code>say</code> 实现。</p>
<pre><code class="language-cangjie">interface SayHi {
    func say() {
        &quot;hi&quot;
    }
}

class A &lt;: SayHi {}

class B &lt;: SayHi {
    public func say() {
        &quot;hi, B&quot;
    }
}
</code></pre>
<p>特别地，如果一个类型在实现多个接口时，多个接口中包含同一个成员的默认实现，这时会发生多重继承的冲突，语言无法选择最适合的实现，因此这时接口中的默认实现也会失效，需要实现类型提供自己的实现。</p>
<p>例如下面的例子，<code>SayHi</code> 和 <code>SayHello</code> 中都包含了 <code>say</code> 的实现，<code>Foo</code> 在实现这两个接口时就必须提供自己的实现，否则会出现编译错误。</p>
<pre><code class="language-cangjie">interface SayHi {
    func say() {
        &quot;hi&quot;
    }
}

interface SayHello {
    func say() {
        &quot;hello&quot;
    }
}

class Foo &lt;: SayHi &amp; SayHello {
    public func say() {
        &quot;Foo&quot;
    }
}
</code></pre>
<p>struct、enum 和 class 在实现接口时，函数或属性定义前的 <code>override</code> 修饰符（或 <code>redef</code> 修饰符）是可选的，无论接口中的函数或属性是否存在默认实现。</p>
<pre><code class="language-cangjie">interface I {
    func foo(): Int64 {
        return 0
    }
}
enum E &lt;: I{
    elem
    public override func foo(): Int64 {
        return 1
    }
}
struct S &lt;: I {
    public override func foo(): Int64 {
        return 1
    }
}
</code></pre>
<h2 id="any-类型"><a class="header" href="#any-类型">Any 类型</a></h2>
<p>Any 类型是一个内置的接口，它的定义如下面。</p>
<pre><code class="language-cangjie">interface Any {}
</code></pre>
<p>仓颉中所有接口都默认继承它，所有非接口类型都默认实现它，因此所有类型都可以作为 Any 类型的子类型使用。</p>
<p>如下面的代码，我们可以将一系列不同类型的变量赋值给 Any 类型的变量。</p>
<!-- compile -->
<pre><code class="language-cangjie">main() {
    var any: Any = 1
    any = 2.0
    any = &quot;hello, world!&quot;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="属性"><a class="header" href="#属性">属性</a></h1>
<p>属性（Properties）提供了一个 getter 和一个可选的 setter 来间接获取和设置值。</p>
<p>使用属性的时候与普通变量无异，我们只需要对数据操作，对内部的实现无感知，可以更便利地实现访问控制、数据监控、跟踪调试、数据绑定等机制。</p>
<p>属性在使用时可以作为表达式或被赋值。此处以类和接口为例进行说明，但属性不仅限于类和接口。</p>
<p>以下是一个简单的例子，b 是一个典型的属性，封装了外部对 a 的访问：</p>
<!-- verify -->
<pre><code class="language-cangjie">class Foo {
    private var a = 0

    public mut prop b: Int64 {
        get() {
            println(&quot;get&quot;)
            a
        }
        set(value) {
            println(&quot;set&quot;)
            a = value
        }
    }
}

main() {
    var x = Foo()
    let y = x.b + 1 // get
    x.b = y // set
}
</code></pre>
<p>此处 Foo 提供了一个名为 b 的属性，针对 getter/setter 这两个功能，仓颉提供了 get 和 set 两种语法来定义。当一个类型为 Foo 的变量 x 在访问 b 时，会调用 b 的 get 操作返回类型为 Int64 的值，因此可以用来与 1 相加；而当 x 在对 b 进行赋值时，会调用 b 的 set 操作，将 y 的值传给 set 的 value，最终将 value 的值赋值给 a。</p>
<p>通过属性 b，外部对 Foo 的成员变量 a 完全不感知，但却可以通过 b 做到同样地访问和修改操作，实现了有效的封装性。所以程序的输出如下：</p>
<pre><code class="language-text">get
set
</code></pre>
<h2 id="属性定义"><a class="header" href="#属性定义">属性定义</a></h2>
<p>属性可以在 interface、class、struct、enum、extend 中定义。</p>
<p>一个典型的属性语法结构如下：</p>
<pre><code class="language-cangjie">class Foo {
    public prop a: Int64 {
        get() { 0 }
    }
    public mut prop b: Int64 {
        get() { 0 }
        set(v) {}
    }
}
</code></pre>
<p>其中使用 prop 声明的 a 和 b 都是属性，a 和 b 的类型都是 <code>Int64</code>。a 是无 <code>mut</code> 修饰符的属性，这类属性有且仅有定义 getter（对应取值）实现。b 是使用 <code>mut</code> 修饰的属性，这类属性必须分别定义 getter（对应取值）和 setter（对应赋值）的实现。</p>
<p>属性的 getter 和 setter 分别对应两个不同的函数。</p>
<ol>
<li>getter 函数类型是 <code>() -&gt; T</code>，T 是该属性的类型，当使用该属性作为表达式时会执行 getter 函数。</li>
<li>setter 函数类型是 <code>(T) -&gt; Unit</code>，T 是该属性的类型，形参名需要显式指定，当对该属性赋值时会执行 setter 函数。</li>
</ol>
<p>getter 和 setter 的实现中可以和函数体一样包含声明和表达式，与函数体的规则一样，详见<a href="source_zh_cn/class_and_interface/../function/define_functions.html#%E5%87%BD%E6%95%B0%E4%BD%93">函数体</a>章节。</p>
<p>setter 中的参数对应的是赋值时传入的值。</p>
<pre><code class="language-cangjie">class Foo {
    private var j = 0
    public mut prop i: Int64 {
        get() {
            j
        }
        set(v) {
            j = v
        }
    }
}
</code></pre>
<p>需要注意的是，在属性的 getter 和 setter 中访问属性自身属于递归调用，与函数调用一样可能会出现死循环的情况。</p>
<h3 id="修饰符"><a class="header" href="#修饰符">修饰符</a></h3>
<p>我们可以在 prop 前面声明需要的修饰符。</p>
<pre><code class="language-cangjie">class Foo {
    public prop a: Int64 {
        get() {
            0
        }
    }
    private prop b: Int64 {
        get() {
            0
        }
    }
}
</code></pre>
<p>和成员函数一样，成员属性也支持 <code>open</code>、<code>override</code>、<code>redef</code> 修饰，所以我们也可以在子类型中覆盖/重定义父类型属性的实现。</p>
<p>子类型覆盖父类型的属性时，如果父类型属性带有 <code>mut</code> 修饰符，则子类型属性也需要带有 <code>mut</code> 修饰符，同时也必须保持一样的类型。</p>
<p>如下代码所示，A 中定义了 x 和 y 两个属性，B 中可以分别对 x 和 y 进行 <code>override</code>/<code>redef</code>：</p>
<pre><code class="language-cangjie">open class A {
    private var valueX = 0
    private static var valueY = 0

    public open prop x: Int64 {
        get() { valueX }
    }

    public static mut prop y: Int64 {
        get() { valueY }
        set(v) {
            valueY = v
        }
    }
}
class B &lt;: A {
    private var valueX2 = 0
    private static var valueY2 = 0

    public override prop x: Int64 {
        get() { valueX2 }
    }

    public redef static mut prop y: Int64 {
        get() { valueY2 }
        set(v) {
            valueY2 = v
        }
    }
}
</code></pre>
<h3 id="抽象属性"><a class="header" href="#抽象属性">抽象属性</a></h3>
<p>类似于抽象函数，我们在 interface 和抽象类中也可以声明抽象属性，这些抽象属性没有实现。</p>
<pre><code class="language-cangjie">interface I {
    prop a: Int64
}

abstract class C {
    public prop a: Int64
}
</code></pre>
<p>当实现类型实现 interface 或者非抽象子类继承抽象类时，必须要实现这些抽象属性。</p>
<p>与覆盖的规则一样，实现类型或子类在实现这些属性时，如果父类型属性带有 <code>mut</code> 修饰符，则子类型属性也需要带有 <code>mut</code> 修饰符，同时也必须保持一样的类型。</p>
<pre><code class="language-cangjie">interface I {
    prop a: Int64
    mut prop b: Int64
}
class C &lt;: I {
    private var value = 0

    public prop a: Int64 {
        get() { value }
    }

    public mut prop b: Int64 {
        get() { value }
        set(v) {
            value = v
        }
    }
}
</code></pre>
<p>通过抽象属性，我们可以让接口和抽象类对一些数据操作能以更加易用的方式进行约定，相比函数的方式要更加直观。</p>
<p>如下代码所示，如果我们要对一个 size 值的获取和设置进行约定，使用属性的方式 (I1) 相比使用函数的方式 (I2) 代码更少，也更加符合对数据操作的意图。</p>
<!-- verify -->
<pre><code class="language-cangjie">interface I1 {
    mut prop size: Int64
}

interface I2 {
    func getSize(): Int64
    func setSize(value: Int64): Unit
}

class C &lt;: I1 &amp; I2 {
    private var mySize = 0

    public mut prop size: Int64 {
        get() {
            mySize
        }
        set(value) {
            mySize = value
        }
    }

    public func getSize() {
        mySize
    }

    public func setSize(value: Int64) {
        mySize = value
    }
}

main() {
    let a: I1 = C()
    a.size = 5
    println(a.size)

    let b: I2 = C()
    b.setSize(5)
    println(b.getSize())
}
</code></pre>
<pre><code class="language-text">5
5
</code></pre>
<h2 id="属性使用"><a class="header" href="#属性使用">属性使用</a></h2>
<p>属性分为实例成员属性和静态成员属性。成员属性的使用和成员变量的使用方式一样，详见<a href="source_zh_cn/class_and_interface/./class.html#class-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">成员变量</a>章节。</p>
<!-- verify -->
<pre><code class="language-cangjie">class A {
    public prop x: Int64 {
        get() {
            123
        }
    }
    public static prop y: Int64 {
        get() {
            321
        }
    }
}

main() {
    var a = A()
    println(a.x) // 123
    println(A.y) // 321
}
</code></pre>
<p>结果为：</p>
<pre><code class="language-text">123
321
</code></pre>
<p>无 <code>mut</code> 修饰符的属性类似 let 声明的变量，不可以被赋值。</p>
<pre><code class="language-cangjie_runnable">class A {
    private let value = 0
    public prop i: Int64 {
        get() {
            value
        }
    }
}

main() {
    var x = A()
    println(x.i) // OK
    x.i = 1 // Error
}
</code></pre>
<p>带有 <code>mut</code> 修饰符的属性类似 var 声明的变量，可以取值也可以被赋值。</p>
<!-- verify -->
<pre><code class="language-cangjie">class A {
    private var value: Int64 = 0
    public mut prop i: Int64 {
        get() {
            value
        }
        set(v) {
            value = v
        }
    }
}

main() {
    var x = A()
    println(x.i) // OK
    x.i = 1 // OK
}
</code></pre>
<pre><code class="language-text">0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="子类型关系"><a class="header" href="#子类型关系">子类型关系</a></h1>
<p>与其他面向对象语言一样，仓颉语言提供子类型关系和子类型多态。举例说明（不限于下述用例）：</p>
<ul>
<li>假设函数的形参是类型 <code>T</code>，则函数调用时传入的参数的实际类型既可以是 <code>T</code> 也可以是 <code>T</code> 的子类型（严格地说，<code>T</code> 的子类型已经包括 <code>T</code> 自身，下同）。</li>
<li>假设赋值表达式 <code>=</code> 左侧的变量的类型是 <code>T</code>，则 <code>=</code> 右侧的表达式的实际类型既可以是 <code>T</code> 也可以是 <code>T</code> 的子类型。</li>
<li>假设函数定义中用户标注的返回类型是 <code>T</code>，则函数体的类型（以及函数体内所有 <code>return</code> 表达式的类型）既可以是 <code>T</code> 也可以是 <code>T</code> 的子类型。</li>
</ul>
<p>那么如何判定两个类型是否存在子类型关系呢？下面我们对此展开说明。</p>
<h2 id="继承-class-带来的子类型关系"><a class="header" href="#继承-class-带来的子类型关系">继承 class 带来的子类型关系</a></h2>
<p>继承 class 后，子类即为父类的子类型。如下代码中， <code>Sub</code> 即为 <code>Super</code> 的子类型。</p>
<pre><code class="language-cangjie">open class Super { }
class Sub &lt;: Super { }
</code></pre>
<h2 id="实现接口带来的子类型关系"><a class="header" href="#实现接口带来的子类型关系">实现接口带来的子类型关系</a></h2>
<p>实现接口（含扩展实现）后，实现接口的类型即为接口的子类型。如下代码中，<code>I3</code> 是 <code>I1</code> 和 <code>I2</code> 的子类型， <code>C</code> 是 <code>I1</code> 的子类型， <code>Int64</code> 是 <code>I2</code> 的子类型：</p>
<pre><code class="language-cangjie">interface I1 { }
interface I2 { }

interface I3 &lt;: I1 &amp; I2 { }

class C &lt;: I1 { }

extend Int64 &lt;: I2 { }
</code></pre>
<p>需要注意的是，部分跨扩展类型赋值后的类型向下转换场景（<code>is</code> 或 <code>as</code>）暂不支持，可能出现判断失败，见如下示例：</p>
<pre><code class="language-cangjie">// file1.cj
package p1

public class A{}

public func get(): Any {
    return A()
}

// =====================
// file2.cj
import p1.*

interface I0 {}

extend A &lt;: I0 {}

main() {
    let v: Any = get()
    println(v is I0) // 无法正确判断类型，打印内容不确定
}
</code></pre>
<h2 id="元组类型的子类型关系"><a class="header" href="#元组类型的子类型关系">元组类型的子类型关系</a></h2>
<p>仓颉语言中的元组类型也有子类型关系。直观的，如果一个元组 <code>t1</code> 的每个元素的类型都是另一个元组 <code>t2</code> 的对应位置元素类型的子类型，那么元组 <code>t1</code> 的类型也是元组 <code>t2</code> 的类型的子类型。例如下面的代码中，由于 <code>C2 &lt;: C1</code> 和 <code>C4 &lt;: C3</code>，因此也有 <code>(C2, C4) &lt;: (C1, C3)</code> 以及 <code>(C4, C2) &lt;: (C3, C1)</code>。</p>
<pre><code class="language-cangjie">open class C1 { }
class C2 &lt;: C1 { }

open class C3 { }
class C4 &lt;: C3 { }

let t1: (C1, C3) = (C2(), C4()) // OK
let t2: (C3, C1) = (C4(), C2()) // OK
</code></pre>
<h2 id="函数类型的子类型关系"><a class="header" href="#函数类型的子类型关系">函数类型的子类型关系</a></h2>
<p>仓颉语言中，函数是一等公民，而函数类型亦有子类型关系：给定两个函数类型 <code>(U1) -&gt; S2</code> 和 <code>(U2) -&gt; S1</code>，<code>(U1) -&gt; S2 &lt;: (U2) -&gt; S1</code> 当且仅当 <code>U2 &lt;: U1</code> 且 <code>S2 &lt;: S1</code>（注意顺序）。例如下面的代码定义了两个函数 <code>f : (U1) -&gt; S2</code> 和 <code>g : (U2) -&gt; S1</code>，且 <code>f</code> 的类型是 <code>g</code> 的类型的子类型。由于 <code>f</code> 的类型是 <code>g</code> 的子类型，所以代码中使用到 <code>g</code> 的地方都可以换为 <code>f</code>。</p>
<pre><code class="language-cangjie">open class U1 { }
class U2 &lt;: U1 { }

open class S1 { }
class S2 &lt;: S1 { }


func f(a: U1): S2 { S2() }
func g(a: U2): S1 { S1() }

func call1() {
    g(U2()) // Ok.
    f(U2()) // Ok.
}

func h(lam: (U2) -&gt; S1): S1 {
    lam(U2())
}

func call2() {
    h(g) // Ok.
    h(f) // Ok.
}
</code></pre>
<p>对于上面的规则，<code>S2 &lt;: S1</code> 部分很好理解：函数调用产生的结果数据会被后续程序使用，函数 <code>g</code> 可以产生 <code>S1</code> 类型的结果数据，函数 <code>f</code> 可以产生 <code>S2</code> 类型的结果，而 <code>g</code> 产生的结果数据应当能被 <code>f</code> 产生的结果数据替代，因此要求 <code>S2 &lt;: S1</code>。</p>
<p>对于 <code>U2 &lt;: U1</code> 的部分，可以这样理解：在函数调用产生结果前，它本身应当能够被调用，函数调用的实参类型固定不变，同时形参类型要求更宽松时，依然可以被调用，而形参类型要求更严格时可能无法被调用——例如给定上述代码中的定义 <code>g(U2())</code> 可以被换为 <code>f(U2())</code>，正是因为实参类型 <code>U2</code> 的要求更严格于形参类型 <code>U1</code> 。</p>
<h2 id="永远成立的子类型关系"><a class="header" href="#永远成立的子类型关系">永远成立的子类型关系</a></h2>
<p>仓颉语言中，有些预设的子类型关系是永远成立的：</p>
<ul>
<li>一个类型 <code>T</code> 永远是自身的子类型，即 <code>T &lt;: T</code>。</li>
<li><code>Nothing</code> 类型永远是其他任意类型 <code>T</code> 的子类型，即 <code>Nothing &lt;: T</code>。</li>
<li>任意类型 <code>T</code> 都是 <code>Any</code> 类型的子类型，即 <code>T &lt;: Any</code>。</li>
<li>任意 <code>class</code> 定义的类型都是 <code>Object</code> 的子类型，即如果有 <code>class C {}</code>，则 <code>C &lt;: Object</code>。</li>
</ul>
<h2 id="传递性带来的子类型关系"><a class="header" href="#传递性带来的子类型关系">传递性带来的子类型关系</a></h2>
<p>子类型关系具有传递性。如下代码中，虽然只描述了 <code>I2 &lt;: I1</code>，<code>C &lt;: I2</code>，以及 <code>Bool &lt;: I2</code>，但根据子类型的传递性，也隐式存在 <code>C &lt;: I1</code> 以及 <code>Bool &lt;: I1</code> 这两个子类型关系。</p>
<pre><code class="language-cangjie">interface I1 { }
interface I2 &lt;: I1 { }

class C &lt;: I2 { }

extend Bool &lt;: I2 { }
</code></pre>
<h2 id="泛型类型的子类型关系"><a class="header" href="#泛型类型的子类型关系">泛型类型的子类型关系</a></h2>
<p>泛型类型间也有子类型关系，详见<a href="source_zh_cn/class_and_interface/../generic/generic_subtype.html">泛型类型的子类型关系</a>章节。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型转换"><a class="header" href="#类型转换">类型转换</a></h1>
<p>仓颉不支持不同类型之间的隐式转换（子类型天然是父类型，所以子类型到父类型的转换不是隐式类型转换），类型转换必须显式地进行。下面将依次介绍数值类型之间的转换，<code>Rune</code> 到 <code>UInt32</code> 和整数类型到 <code>Rune</code> 的转换，以及 <code>is</code> 和 <code>as</code> 操作符。</p>
<h2 id="数值类型之间的转换"><a class="header" href="#数值类型之间的转换">数值类型之间的转换</a></h2>
<p>对于数值类型（包括：<code>Int8</code>，<code>Int16</code>，<code>Int32</code>，<code>Int64</code>，<code>IntNative</code>，<code>UInt8</code>，<code>UInt16</code>，<code>UInt32</code>，<code>UInt64</code>，<code>UIntNative</code>，<code>Float16</code>，<code>Float32</code>，<code>Float64</code>），仓颉支持使用 <code>T(e)</code> 的方式得到一个值等于 <code>e</code>，类型为 <code>T</code> 的值。其中，表达式 <code>e</code> 的类型和 <code>T</code> 可以是上述任意数值类型。</p>
<p>下面的例子展示了数值类型之间的类型转换：</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    let a: Int8 = 10
    let b: Int16 = 20
    let r1 = Int16(a)
    println(&quot;The type of r1 is 'Int16', and r1 = ${r1}&quot;)
    let r2 = Int8(b)
    println(&quot;The type of r2 is 'Int8', and r2 = ${r2}&quot;)

    let c: Float32 = 1.0
    let d: Float64 = 1.123456789
    let r3 = Float64(c)
    println(&quot;The type of r3 is 'Float64', and r3 = ${r3}&quot;)
    let r4 = Float32(d)
    println(&quot;The type of r4 is 'Float32', and r4 = ${r4}&quot;)

    let e: Int64 = 1024
    let f: Float64 = 1024.1024
    let r5 = Float64(e)
    println(&quot;The type of r5 is 'Float64', and r5 = ${r5}&quot;)
    let r6 = Int64(f)
    println(&quot;The type of r6 is 'Int64', and r6 = ${r6}&quot;)
}
</code></pre>
<p>上述代码的执行结果为：</p>
<pre><code class="language-text">The type of r1 is 'Int16', and r1 = 10
The type of r2 is 'Int8', and r2 = 20
The type of r3 is 'Float64', and r3 = 1.000000
The type of r4 is 'Float32', and r4 = 1.123457
The type of r5 is 'Float64', and r5 = 1024.000000
The type of r6 is 'Int64', and r6 = 1024
</code></pre>
<h2 id="rune-到-uint32-和整数类型到-rune-的转换"><a class="header" href="#rune-到-uint32-和整数类型到-rune-的转换"><code>Rune</code> 到 <code>UInt32</code> 和整数类型到 <code>Rune</code> 的转换</a></h2>
<p><code>Rune</code> 到 <code>UInt32</code> 的转换使用 <code>UInt32(e)</code> 的方式，其中 <code>e</code> 是一个 <code>Rune</code> 类型的表达式，<code>UInt32(e)</code> 的结果是 <code>e</code> 的 Unicode scalar value 对应的 <code>UInt32</code> 类型的整数值。</p>
<p>整数类型到 <code>Rune</code> 的转换使用 <code>Rune(num)</code> 的方式，其中 <code>num</code> 的类型可以是任意的整数类型，且仅当 <code>num</code> 的值落在 <code>[0x0000, 0xD7FF]</code> 或 <code>[0xE000, 0x10FFFF]</code> （即 Unicode scalar value）中时，返回对应的 Unicode scalar value 表示的字符，否则，编译报错（编译时可确定 <code>num</code> 的值）或运行时抛异常。</p>
<p>下面的例子展示了 <code>Rune</code> 和 <code>UInt32</code> 之间的类型转换：</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    let x: Rune = 'a'
    let y: UInt32 = 65
    let r1 = UInt32(x)
    let r2 = Rune(y)
    println(&quot;The type of r1 is 'UInt32', and r1 = ${r1}&quot;)
    println(&quot;The type of r2 is 'Rune', and r2 = ${r2}&quot;)
}
</code></pre>
<p>上述代码的执行结果为：</p>
<pre><code class="language-text">The type of r1 is 'UInt32', and r1 = 97
The type of r2 is 'Rune', and r2 = A
</code></pre>
<h2 id="is-和-as-操作符"><a class="header" href="#is-和-as-操作符"><code>is</code> 和 <code>as</code> 操作符</a></h2>
<p>仓颉支持使用 <code>is</code> 操作符来判断某个表达式的类型是否是指定的类型（或其子类型）。具体而言，对于表达式 <code>e is T</code>（<code>e</code> 可以是任意表达式，<code>T</code> 可以是任何类型），当 <code>e</code> 的运行时类型是 <code>T</code> 的子类型时，<code>e is T</code> 的值为 <code>true</code>，否则 <code>e is T</code> 的值为 <code>false</code>。</p>
<p>下面的例子展示了 <code>is</code> 操作符的使用：</p>
<!-- verify -->
<pre><code class="language-cangjie">open class Base {
    var name: String = &quot;Alice&quot;
}
class Derived &lt;: Base {
    var age: UInt8 = 18
}

main() {
    let a = 1 is Int64
    println(&quot;Is the type of 1 'Int64'? ${a}&quot;)
    let b = 1 is String
    println(&quot;Is the type of 1 'String'? ${b}&quot;)

    let b1: Base = Base()
    let b2: Base = Derived()
    var x = b1 is Base
    println(&quot;Is the type of b1 'Base'? ${x}&quot;)
    x = b1 is Derived
    println(&quot;Is the type of b1 'Derived'? ${x}&quot;)
    x = b2 is Base
    println(&quot;Is the type of b2 'Base'? ${x}&quot;)
    x = b2 is Derived
    println(&quot;Is the type of b2 'Derived'? ${x}&quot;)
}
</code></pre>
<p>上述代码的执行结果为：</p>
<pre><code class="language-text">Is the type of 1 'Int64'? true
Is the type of 1 'String'? false
Is the type of b1 'Base'? true
Is the type of b1 'Derived'? false
Is the type of b2 'Base'? true
Is the type of b2 'Derived'? true
</code></pre>
<p><code>as</code> 操作符可以用于将某个表达式的类型转换为指定的类型。因为类型转换有可能会失败，所以 <code>as</code> 操作返回的是一个 <code>Option</code> 类型。具体而言，对于表达式 <code>e as T</code>（<code>e</code> 可以是任意表达式，<code>T</code> 可以是任何类型），当 <code>e</code> 的运行时类型是 <code>T</code> 的子类型时，<code>e as T</code> 的值为 <code>Option&lt;T&gt;.Some(e)</code>，否则 <code>e as T</code> 的值为 <code>Option&lt;T&gt;.None</code>。</p>
<p>下面的例子展示了 <code>as</code> 操作符的使用（注释中标明了 <code>as</code> 操作的结果）：</p>
<pre><code class="language-cangjie">open class Base {
    var name: String = &quot;Alice&quot;
}
class Derived &lt;: Base {
    var age: UInt8 = 18
}

let a = 1 as Int64     // a = Option&lt;Int64&gt;.Some(1)
let b = 1 as String    // b = Option&lt;String&gt;.None

let b1: Base = Base()
let b2: Base = Derived()
let d: Derived = Derived()
let r1 = b1 as Base    // r1 = Option&lt;Base&gt;.Some(b1)
let r2 = b1 as Derived // r2 = Option&lt;Derived&gt;.None
let r3 = b2 as Base    // r3 = Option&lt;Base&gt;.Some(b2)
let r4 = b2 as Derived // r4 = Option&lt;Derived&gt;.Some(b2)
let r5 = d as Base     // r5 = Option&lt;Base&gt;.Some(d)
let r6 = d as Derived  // r6 = Option&lt;Derived&gt;.Some(d)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="泛型概述"><a class="header" href="#泛型概述">泛型概述</a></h1>
<p>在仓颉编程语言中，泛型指的是参数化类型，参数化类型是一个在声明时未知并且需要在使用时指定的类型。类型声明与函数声明可以是泛型的。最为常见的例子就是 <code>Array&lt;T&gt;</code>、<code>Set&lt;T&gt;</code> 等容器类型。以数组类型为例，当使用数组类型  <code>Array</code> 时，会需要其中存放的是不同的类型，我们不可能定义所有类型的数组，通过在类型声明中声明类型形参，在应用数组时再指定其中的类型，这样就可以减少在代码上的重复。</p>
<p>在仓颉中，class、interface、struct 与 enum 的声明都可以声明类型形参，也就是说它们都可以是泛型的。</p>
<p>为了方便讨论我们先定义以下几个常用的术语：</p>
<ul>
<li>类型形参：一个类型或者函数声明可能有一个或者多个需要在使用处被指定的类型，这些类型就被称为类型形参。在声明形参时，需要给定一个标识符，以便在声明体中引用。</li>
<li>类型变元：在声明类型形参后，当我们通过标识符来引用这些类型时，这些标识符被称为类型变元。</li>
<li>类型实参：当我们在使用泛型声明的类型或函数时指定了泛型参数，这些参数被称为类型实参。</li>
<li>类型构造器：一个需要零个、一个或者多个类型作为实参的类型称为类型构造器。</li>
</ul>
<p>类型形参在声明时一般在类型名称的声明或者函数名称的声明后，使用尖括号 <code>&lt;...&gt;</code> 括起来。例如泛型列表可声明为：</p>
<!-- compile -->
<pre><code class="language-cangjie">class List&lt;T&gt; {
    var elem: Option&lt;T&gt; = None
    var tail: Option&lt;List&lt;T&gt;&gt; = None
}

func sumInt(a: List&lt;Int64&gt;) {  }
</code></pre>
<p>其中 <code>List&lt;T&gt;</code> 中的 <code>T</code> 被称为类型形参。对于 <code>elem: Option&lt;T&gt;</code> 中对 <code>T</code> 的引用称为类型变元，同理 <code>tail: Option&lt;List&lt;T&gt;&gt;</code> 中的 <code>T</code> 也称为类型变元。函数 <code>sumInt</code> 的参数中 <code>List&lt;Int64&gt;</code> 的 <code>Int64</code> 被称为 <code>List</code> 的类型实参。 <code>List</code> 就是类型构造器，<code>List&lt;Int64&gt;</code> 通过 <code>Int64</code> 类型实参构造出了一个类型 <code>Int64</code> 的列表类型。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="泛型函数"><a class="header" href="#泛型函数">泛型函数</a></h1>
<p>如果一个函数声明了一个或多个类型形参，则将其称为泛型函数。语法上，类型形参紧跟在函数名后，并用 <code>&lt;&gt;</code> 括起，如果有多个类型形参，则用“,”分离。</p>
<h2 id="全局泛型函数"><a class="header" href="#全局泛型函数">全局泛型函数</a></h2>
<p>在声明全局泛型函数时，只需要在函数名后使用尖括号声明类型形参，然后就可以在函数形参、返回类型及函数体中对这一类型形参进行引用。例如 <code>id</code> 函数定义为：</p>
<!-- compile -->
<pre><code class="language-cangjie">func id&lt;T&gt;(a: T): T {
    return a
}
</code></pre>
<p>其中 <code>(a: T)</code> 是函数声明的形参，其中使用到了 <code>id</code> 函数声明的类型形参 <code>T</code>，并且在 <code>id</code> 函数的返回类型使用。</p>
<p>再比如另一个复杂的例子，定义如下一个泛型函数 <code>composition</code>，该函数声明了 3 个类型形参，分别是 <code>T1, T2, T3</code>，其功能是把两个函数 <code>f: (T1) -&gt; T2, g: (T2) -&gt; T3</code> 复合成类型为 <code>(T1) -&gt; T3</code> 的函数。</p>
<!-- verify -composition -->
<pre><code class="language-cangjie">func composition&lt;T1, T2, T3&gt;(f: (T1) -&gt; T2, g: (T2) -&gt; T3): (T1) -&gt; T3 {
    return {x: T1 =&gt; g(f(x))}
}
</code></pre>
<p>因为被用来复合的函数可以是任意类型，例如可以是 <code>(Int32) -&gt; Bool, (Bool) -&gt; Int64</code> 的复合，也可以是 <code>(Int64) -&gt; Rune, (Rune) -&gt; Int8</code> 的复合，所以才需要使用泛型函数。</p>
<!-- verify -composition -->
<pre><code class="language-cangjie">func times2(a: Int64): Int64 {
    return a * 2
}

func plus10(a: Int64): Int64 {
    return a + 10
}

func times2plus10(a: Int64) {
    return composition&lt;Int64, Int64, Int64&gt;(times2, plus10)(a)
}

main() {
  println(times2plus10(9))
  return 0
}
</code></pre>
<p>这里，我们复合两个 <code>(Int64) -&gt; Int64</code> 的函数，将 9 先乘以 2，再加 10，结果会是 28。</p>
<!-- verify -composition -->
<pre><code class="language-text">28
</code></pre>
<h2 id="局部泛型函数"><a class="header" href="#局部泛型函数">局部泛型函数</a></h2>
<p>局部函数也可以是泛型函数。例如泛型函数 <code>id</code> 可以嵌套定义在其它函数中：</p>
<!-- verify -->
<pre><code class="language-cangjie">func foo(a: Int64) {
    func id&lt;T&gt;(a: T): T { a }

    func double(a: Int64): Int64 { a + a }

    return (id&lt;Int64&gt; ~&gt; double)(a) == (double ~&gt; id&lt;Int64&gt;)(a)
}

main() {
    println(foo(1))
    return 0
}
</code></pre>
<p>这里由于 <code>id</code> 的单位元性质，函数 <code>id&lt;Int64&gt; ~&gt; double</code> 和 <code>double ~&gt; id&lt;Int64&gt;</code> 是等价的，结果是 <code>true</code>。</p>
<pre><code class="language-text">true
</code></pre>
<h2 id="泛型成员函数"><a class="header" href="#泛型成员函数">泛型成员函数</a></h2>
<p>class、struct 与 enum 的成员函数可以是泛型的。例如：</p>
<!-- verify -->
<pre><code class="language-cangjie">class A {
    func foo&lt;T&gt;(a: T): Unit where T &lt;: ToString {
        println(&quot;${a}&quot;)
    }
}

struct B {
    func bar&lt;T&gt;(a: T): Unit where T &lt;: ToString {
        println(&quot;${a}&quot;)
    }
}

enum C {
    | X | Y

    func coo&lt;T&gt;(a: T): Unit where T &lt;: ToString {
        println(&quot;${a}&quot;)
    }
}

main() {
    var a = A()
    var b = B()
    var c = C.X
    a.foo&lt;Int64&gt;(10)
    b.bar&lt;String&gt;(&quot;abc&quot;)
    c.coo&lt;Bool&gt;(false)
    return 0
}
</code></pre>
<p>程序输出的结果为：</p>
<pre><code class="language-text">10
abc
false
</code></pre>
<p>这里需要注意的是，class 中声明的泛型成员函数不能被 open 修饰，如果被 open 修饰则会报错，例如：</p>
<pre><code class="language-cangjie">class A {
    public open func foo&lt;T&gt;(a: T): Unit where T &lt;: ToString { // Error, open generic function is not allowed
        println(&quot;${a}&quot;)
    }
}
</code></pre>
<p>在为类型使用 extend 声明进行扩展时，扩展中的函数也可以是泛型的，例如我们可以为 <code>Int64</code> 类型增加一个泛型成员函数：</p>
<!-- verify -->
<pre><code class="language-cangjie">extend Int64 {
    func printIntAndArg&lt;T&gt;(a: T) where T &lt;: ToString {
        println(this)
        println(&quot;${a}&quot;)
    }
}

main() {
    var a: Int64 = 12
    a.printIntAndArg&lt;String&gt;(&quot;twelve&quot;)
}
</code></pre>
<p>程序输出的结果将为：</p>
<pre><code class="language-text">12
twelve
</code></pre>
<h2 id="静态泛型函数"><a class="header" href="#静态泛型函数">静态泛型函数</a></h2>
<p>interface、class、struct、enum 与 extend 中可以定义静态泛型函数，例如下例 <code>ToPair</code> class 中从 <code>ArrayList</code> 中返回一个元组：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.collection.*

class ToPair {
    public static func fromArray&lt;T&gt;(l: ArrayList&lt;T&gt;): (T, T) {
        return (l[0], l[1])
    }
}

main() {
    var res: ArrayList&lt;Int64&gt; = ArrayList([1,2,3,4])
    var a: (Int64, Int64) = ToPair.fromArray&lt;Int64&gt;(res)
    return 0
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="泛型接口"><a class="header" href="#泛型接口">泛型接口</a></h1>
<p>泛型可以用来定义泛型接口，以标准库中定义的 <code>Iterable</code> 为例，它需要返回一个 <code>Iterator</code> 类型，这一类型是一个容器的遍历器。 <code>Iterator</code> 是一个泛型接口，<code>Iterator</code> 内部有一个从容器类型中返回下一个元素的 <code>next</code> 成员函数，<code>next</code> 成员函数返回的类型是一个需要在使用时指定的类型，所以 <code>Iterator</code> 需要声明泛型参数。</p>
<!-- compile -->
<pre><code class="language-cangjie">public interface Iterable&lt;E&gt; {
    func iterator(): Iterator&lt;E&gt;
}

public interface Iterator&lt;E&gt; &lt;: Iterable&lt;E&gt; {
    func next(): Option&lt;E&gt;
}

public interface Collection&lt;T&gt; &lt;: Iterable&lt;T&gt; {
     prop size: Int64
     func isEmpty(): Bool
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="泛型类"><a class="header" href="#泛型类">泛型类</a></h1>
<p><a href="source_zh_cn/generic/./generic_interface.html">泛型接口</a>中介绍了泛型接口的定义和使用，本节我们介绍泛型类的定义和使用。如 <code>Map</code> 的键值对就是使用泛型类来定义的。</p>
<p>可以看一下 <code>Map</code> 类型中的键值对 <code>Node</code> 类型就可以使用泛型类来定义：</p>
<!-- compile -->
<pre><code class="language-cangjie">public open class Node&lt;K, V&gt; where K &lt;: Hashable &amp; Equatable&lt;K&gt; {
    public var key: Option&lt;K&gt; = Option&lt;K&gt;.None
    public var value: Option&lt;V&gt; = Option&lt;V&gt;.None

    public init() {}

    public init(key: K, value: V) {
        this.key = Option&lt;K&gt;.Some(key)
        this.value = Option&lt;V&gt;.Some(value)
    }
}
</code></pre>
<p>由于键与值的类型有可能不相同，且可以为任意满足条件的类型，所以 <code>Node</code> 需要两个类型形参 <code>K</code> 与 <code>V</code> ，<code>K &lt;: Hashable, K &lt;: Equatable&lt;K&gt;</code> 是对于键类型的约束，意为 <code>K</code> 要实现 <code>Hashable</code> 与 <code>Equatable&lt;K&gt;</code> 接口，也就是 <code>K</code> 需要满足的条件。对于泛型约束，详见<a href="source_zh_cn/generic/./generic_constraint.html">泛型约束</a>章节。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="泛型结构体"><a class="header" href="#泛型结构体">泛型结构体</a></h1>
<p>struct 类型的泛型与 class 是类似的，下面我们可以使用 struct 定义一个类似于二元元组的类型：</p>
<!-- verify -->
<pre><code class="language-cangjie">struct Pair&lt;T, U&gt; {
    let x: T
    let y: U
    public init(a: T, b: U) {
        x = a
        y = b
    }
    public func first(): T {
        return x
    }
    public func second(): U {
        return y
    }
}

main() {
    var a: Pair&lt;String, Int64&gt; = Pair&lt;String, Int64&gt;(&quot;hello&quot;, 0)
    println(a.first())
    println(a.second())
}
</code></pre>
<p>程序输出的结果为：</p>
<pre><code class="language-text">hello
0
</code></pre>
<p>在 <code>Pair</code> 中我们提供了 <code>first</code> 与 <code>second</code> 两个函数来取得元组的第一个与第二个元素。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="泛型枚举"><a class="header" href="#泛型枚举">泛型枚举</a></h1>
<p>在仓颉编程语言中，泛型 enum 声明的类型里被使用得最广泛的例子之一就是 <code>Option</code> 类型了，关于 <code>Option</code> 详细描述可以详见 <a href="source_zh_cn/generic/../enum_and_pattern_match/option_type.html">Option 类型</a>章节。 <code>Option</code> 类型是用来表示在某一类型上的值可能是个空的值。这样，<code>Option</code> 就可以用来表示在某种类型上计算的失败。这里是何种类型上的失败是不确定的，所以很明显，<code>Option</code> 是一个泛型类型，需要声明类型形参。</p>
<pre><code class="language-cangjie">package core // `Option` is defined in core.

public enum Option&lt;T&gt; {
      Some(T)
    | None

    public func getOrThrow(): T {
        match (this) {
            case Some(v) =&gt; v
            case None =&gt; throw NoneValueException()
        }
    }
    ...
}
</code></pre>
<p>可以看到，<code>Option&lt;T&gt;</code> 分成两种情况，一种是 <code>Some(T)</code>，用来表示一个正常的返回结果，另一种是 <code>None</code> 用来表示一个空的结果。其中的 <code>getOrThrow</code> 函数会是将 <code>Some(T)</code> 内部的值返回出来的函数，返回的结果就是 <code>T</code> 类型，而如果参数是 None，那么直接抛出异常。</p>
<p>例如：如果我们想定义一个安全的除法，因为在除法上的计算是可能失败的。如果除数为 0，那么返回 <code>None</code> ，否则返回一个用 <code>Some</code> 包装过的结果：</p>
<!-- compile -->
<pre><code class="language-cangjie">func safeDiv(a: Int64, b: Int64): Option&lt;Int64&gt; {
    var res: Option&lt;Int64&gt; = match (b) {
                case 0 =&gt; None
                case _ =&gt; Some(a/b)
            }
    return res
}
</code></pre>
<p>这样，在除数为 0 时，程序运行的过程中不会因除以 0 而抛出算术运算异常。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="泛型类型的子类型关系-1"><a class="header" href="#泛型类型的子类型关系-1">泛型类型的子类型关系</a></h1>
<p>实例化后的泛型类型间也有子类型关系。例如当我们写出下列代码时，</p>
<!-- compile -->
<pre><code class="language-cangjie">interface I&lt;X, Y&gt; { }

class C&lt;Z&gt; &lt;: I&lt;Z, Z&gt; { }
</code></pre>
<p>根据第 3 行，便知 <code>C&lt;Bool&gt; &lt;: I&lt;Bool, Bool&gt;</code> 以及 <code>C&lt;D&gt; &lt;: I&lt;D, D&gt;</code> 等。这里的第 3 行可以解读为“于所有的（不含类型变元的） <code>Z</code> 类型，都有 <code>C&lt;Z&gt; &lt;: I&lt;Z, Z&gt;</code> 成立”。</p>
<p>但是对于下列代码</p>
<!-- compile -->
<pre><code class="language-cangjie">open class C { }
class D &lt;: C { }

interface I&lt;X&gt; { }
</code></pre>
<p><code>I&lt;D&gt; &lt;: I&lt;C&gt;</code> 是不成立的（即使 <code>D &lt;: C</code> 成立），这是因为在仓颉语言中，用户定义的类型构造器在其类型参数处是<strong>不型变</strong>的。</p>
<p>型变的具体定义为：如果 <code>A</code> 和 <code>B</code> 是（实例化后的）类型，<code>T</code> 是类型构造器，设有一个类型参数 <code>X</code>（例如 <code>interface T&lt;X&gt;</code>），那么</p>
<ul>
<li>如果 <code>T(A) &lt;: T(B)</code> 当且仅当 <code>A = B</code>，则 <code>T</code> 是<strong>不型变</strong>的。</li>
<li>如果 <code>T(A) &lt;: T(B)</code> 当且仅当  <code>A &lt;: B</code> ，则 <code>T</code> 在 <code>X</code> 处是<strong>协变</strong>的。</li>
<li>如果 <code>T(A) &lt;: T(B)</code> 当且仅当 <code>B &lt;: A</code> ，则 <code>T</code> 在 <code>X</code> 处是<strong>逆变</strong>的。</li>
</ul>
<p>因为现阶段的仓颉中，所有用户自定义的泛型类型在其所有的类型变元处都是不变的，所以给定 <code>interface I&lt;X&gt;</code> 和类型 <code>A</code>、<code>B</code>，只有 <code>A = B</code>，我们才能得到 <code>I&lt;A&gt; &lt;: I&lt;B&gt;</code>；反过来，如果知道了 <code>I&lt;A&gt; &lt;: I&lt;B&gt;</code>，也可推出 <code>A = B</code>（内建类型除外：内建的元组类型对其每个元素类型来说，都是协变的；内建的函数类型在其入参类型处是逆变的，在其返回类型处是协变的。）</p>
<p>不型变限制了一些语言的表达能力，但也避免了一些安全问题，例如“协变数组运行时抛异常”的问题（Java 便有这个问题）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型别名"><a class="header" href="#类型别名">类型别名</a></h1>
<p>当某个类型的名字比较复杂或者在特定场景中不够直观时，可以选择使用类型别名的方式为此类型设置一个别名。</p>
<pre><code class="language-cangjie">type I64 = Int64
</code></pre>
<p>类型别名的定义以关键字 <code>type</code> 开头，接着是类型的别名（如上例中的 <code>I64</code>），然后是等号 <code>=</code>，最后是原类型（即被取别名的类型，如上例中的 <code>Int64</code>）。</p>
<p>只能在源文件顶层定义类型别名，并且原类型必须在别名定义处可见。例如，下例中 <code>Int64</code> 的别名定义在 <code>main</code> 中将报错，<code>LongNameClassB</code> 类型在为其定义别名时不可见，同样报错。</p>
<pre><code class="language-cangjie">main() {
    type I64 = Int64 // Error, type aliases can only be defined at the top level of the source file
}

class LongNameClassA { }
type B = LongNameClassB // Error, type 'LongNameClassB' is not defined
</code></pre>
<p>一个（或多个）类型别名定义中禁止出现（直接或间接的）循环引用。</p>
<pre><code class="language-cangjie">type A = (Int64, A) // Error, 'A' refered itself

type B = (Int64, C) // Error, 'B' and 'C' are circularly refered
type C = (B, Int64)
</code></pre>
<p>类型别名并不会定义一个新的类型，它仅仅是为原类型定义了另外一个名字，它有如下几种使用场景：</p>
<ol>
<li>
<p>作为类型使用，例如：</p>
<!-- compile -->
<pre><code class="language-cangjie">type A = B
class B {}
var a: A = B() // Use typealias A as type B
</code></pre>
</li>
<li>
<p>当类型别名实际指向的类型为 class、struct 时，可以作为构造器名称使用：</p>
<!-- compile -->
<pre><code class="language-cangjie">type A = B
class B {}
func foo() { A() }  // Use type alias A as constructor of B
</code></pre>
</li>
<li>
<p>当类型别名实际指向的类型为 class、interface、struct 时，可以作为访问内部静态成员变量或函数的类型名：</p>
<!-- compile -->
<pre><code class="language-cangjie">type A = B
class B {
    static var b : Int32 = 0;
    static func foo() {}
}
func foo() {
    A.foo() // Use A to access static method in class B
    A.b
}
</code></pre>
</li>
<li>
<p>当类型别名实际指向的类型为 enum 时，可以作为 enum 声明的构造器的类型名：</p>
<!-- compile -->
<pre><code class="language-cangjie">enum TimeUnit {
    Day | Month | Year
}
type Time = TimeUnit
var a = Time.Day  
var b = Time.Month   // Use type alias Time to access constructors in TimeUnit
</code></pre>
</li>
</ol>
<p>需要注意的是，当前用户自定义的类型别名暂不支持在类型转换表达式中使用，参考如下示例：</p>
<pre><code class="language-cangjie">type MyInt = Int32
MyInt(0)  // Error, no matching function for operator '()' function call
</code></pre>
<h2 id="泛型别名"><a class="header" href="#泛型别名">泛型别名</a></h2>
<p>类型别名也是可以声明类型形参的，但是不能对其形参使用 <code>where</code> 声明约束，对于泛型变元的约束我们会在后面给出解释。</p>
<p>当一个泛型类型的名称过长时，我们就可以使用类型别名来为其声明一个更短的别名。例如，有一个类型为 <code>RecordData</code> ，我们可以把他用类型别名简写为 <code>RD</code> ：</p>
<!-- run -->
<pre><code class="language-cangjie">struct RecordData&lt;T&gt; {
    var a: T
    public init(x: T){
        a = x
    }
}

type RD&lt;T&gt; = RecordData&lt;T&gt;

main(): Int64 {
    var struct1: RD&lt;Int32&gt; = RecordData&lt;Int32&gt;(2)
    return 1
}
</code></pre>
<p>在使用时就可以用 <code>RD&lt;Int32&gt;</code> 来代指 <code>RecordData&lt;Int32&gt;</code> 类型。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="泛型约束"><a class="header" href="#泛型约束">泛型约束</a></h1>
<p>泛型约束的作用是在函数、class、enum、struct 声明时明确泛型形参所具备的操作与能力。只有声明了这些约束才能调用相应的成员函数。在很多场景下泛型形参是需要加以约束的。以 <code>id</code> 函数为例：</p>
<!-- compile -->
<pre><code class="language-cangjie">func id&lt;T&gt;(a: T) {
    return a
}
</code></pre>
<p>我们唯一能做的事情就是将函数形参 <code>a</code> 这个值返回，而不能进行 <code>a + 1</code>，<code>println(&quot;${a}&quot;)</code> 等操作，因为它可能是一个任意的类型，比如 <code>(Bool) -&gt; Bool</code>，这样就无法与整数相加，同样因为是函数类型，也不能通过 <code>println</code> 函数来输出在命令行上。而如果这一泛型形参上有了约束，那么就可以做更多操作了。</p>
<p>约束大致分为接口约束与子类型约束。语法为在函数、类型的声明体之前使用 <code>where</code> 关键字来声明，对于声明的泛型形参 <code>T1, T2</code>，可以使用 <code>where T1 &lt;: Interface, T2 &lt;: Type</code> 这样的方式来声明泛型约束，同一个类型变元的多个约束可以使用 <code>&amp;</code> 连接。例如：<code>where T1 &lt;: Interface1 &amp; Interface2</code>。</p>
<p>例如，仓颉中的 <code>println</code> 函数能接受类型为字符串的参数，如果我们需要把一个泛型类型的变量转为字符串后打印在命令行上，可以对这个泛型类型变元加以约束，这个约束是 <code>core</code> 中定义的 <code>ToString</code> 接口，显然它是一个接口约束：</p>
<pre><code class="language-cangjie">package core // `ToString` is defined in core.

public interface ToString {
    func toString(): String
}
</code></pre>
<p>这样我们就可以利用这个约束，定义一个名为 <code>genericPrint</code> 的函数：</p>
<!-- verify -->
<pre><code class="language-cangjie">func genericPrint&lt;T&gt;(a: T) where T &lt;: ToString {
    println(a)
}

main() {
    genericPrint&lt;Int64&gt;(10)
    return 0
}
</code></pre>
<p>结果为：</p>
<pre><code class="language-text">10
</code></pre>
<p>如果 genericPrint 函数的类型实参没有实现 ToString 接口，那么编译器会报错。例如我们传入一个函数做为参数时：</p>
<pre><code class="language-cangjie">func genericPrint&lt;T&gt;(a: T) where T &lt;: ToString {
    println(a)
}

main() {
    genericPrint&lt;(Int64) -&gt; Int64&gt;({ i =&gt; 0 })
    return 0
}
</code></pre>
<p>如果我们对上面的文件进行编译，那么编译器会抛出泛型类型参数与满足约束的错误。因为 <code>genericPrint</code> 函数的泛型的类型实参不满足约束 <code>(Int64) -&gt; Int64 &lt;: ToString</code>。</p>
<p>除了上述通过接口来表示约束，还可以使用子类型来约束一个泛型类型变元。例如：当我们要声明一个动物园类型 <code>Zoo&lt;T&gt;</code>，但是我们需要这里声明的类型形参 <code>T</code> 受到约束，这个约束就是 <code>T</code> 需要是动物类型 <code>Animal</code> 的子类型， <code>Animal</code> 类型中声明了 <code>run</code> 成员函数。这里我们声明两个子类型 <code>Dog</code> 与 <code>Fox</code> 都实现了 <code>run</code> 成员函数，这样在 <code>Zoo&lt;T&gt;</code> 的类型中，我们就可以对于 <code>animals</code> 数组列表中存放的动物实例调用 <code>run</code> 成员函数：</p>
<!-- verify -->
<pre><code class="language-cangjie">import std.collection.*

abstract class Animal {
    public func run(): String
}

class Dog &lt;: Animal {
    public func run(): String {
        return &quot;dog run&quot;
    }
}

class Fox &lt;: Animal {
    public func run(): String {
        return &quot;fox run&quot;
    }
}

class Zoo&lt;T&gt; where T &lt;: Animal {
    var animals: ArrayList&lt;Animal&gt; = ArrayList&lt;Animal&gt;()
    public func addAnimal(a: T) {
        animals.append(a)
    }

    public func allAnimalRuns() {
        for(a in animals) {
            println(a.run())
        }
    }
}

main() {
    var zoo: Zoo&lt;Animal&gt; = Zoo&lt;Animal&gt;()
    zoo.addAnimal(Dog())
    zoo.addAnimal(Fox())
    zoo.allAnimalRuns()
    return 0
}
</code></pre>
<p>程序的输出为：</p>
<pre><code class="language-text">dog run
fox run
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="扩展概述"><a class="header" href="#扩展概述">扩展概述</a></h1>
<p>扩展可以为在当前 <code>package</code> 可见的类型（除函数、元组、接口）添加新功能。</p>
<p>当我们不能破坏原有类型的封装性，但希望添加额外的功能时，可以使用扩展。</p>
<p>可以添加的功能包括：</p>
<ul>
<li>添加成员函数</li>
<li>添加操作符重载函数</li>
<li>添加成员属性</li>
<li>实现接口</li>
</ul>
<p>扩展虽然可以添加额外的功能，但不能变更原有类型的封装性，因此扩展不支持以下功能：</p>
<ol>
<li>扩展不能增加成员变量。</li>
<li>扩展的函数和属性必须拥有实现。</li>
<li>扩展的函数和属性不能使用 <code>open</code>、<code>override</code>、 <code>redef</code>修饰。</li>
<li>扩展不能访问原类型 <code>private</code> 的成员。</li>
</ol>
<p>根据扩展有没有实现新的接口，扩展可以分为 <strong>直接扩展</strong> 和 <strong>接口扩展</strong> 两种用法，直接扩展即不包含额外接口的扩展；接口扩展即包含接口的扩展，接口扩展可以用来为现有的类型添加新功能并实现接口，增强抽象灵活性。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="直接扩展"><a class="header" href="#直接扩展">直接扩展</a></h1>
<p>一个简单的扩展语法结构示例如下：</p>
<!-- verify -printSize -->
<pre><code class="language-cangjie">extend String {
    public func printSize() {
        println(&quot;the size is ${this.size}&quot;)
    }
}
</code></pre>
<p>如上例所示，扩展使用 <code>extend</code> 关键字声明，其后跟着被扩展的类型 <code>String</code> 和扩展的功能。</p>
<p>当为 <code>String</code> 扩展了 <code>printSize</code> 函数之后，我们就能在当前 <code>package</code> 内对 <code>String</code> 的实例访问该函数，就像是 <code>String</code> 本身具备该函数。</p>
<!-- verify -printSize -->
<pre><code class="language-cangjie">main() {
    let a = &quot;123&quot;
    a.printSize() // the size is 3
}
</code></pre>
<p>编译执行上述代码，输出结果为：</p>
<!-- verify -printSize -->
<pre><code class="language-text">the size is 3
</code></pre>
<p>被扩展类型是泛型类型时，有两种扩展语法可以对泛型类型扩展功能。</p>
<p>一种是针对特定泛型实例化类型进行扩展，关键字 <code>extend</code> 后允许带一个任意实例化完全的泛型类型。为这些类型增加的功能只有在类型完全匹配时才能使用，且泛型类型的类型实参必须符合泛型类型定义处的约束要求。</p>
<p>例如下面所示的 <code>Foo&lt;T&gt;</code>。</p>
<pre><code class="language-cangjie">class Foo&lt;T&gt; where T &lt;: ToString {}

extend Foo&lt;Int64&gt; {} // Ok

class Bar {}
extend Foo&lt;Bar&gt; {} // Error
</code></pre>
<p>另一种是在 <code>extend</code> 后面引入泛型形参的泛型扩展。泛型扩展可以用来扩展未实例化或未完全实例化的泛型类型。在 <code>extend</code> 后声明的泛型形参必须被直接或间接使用在被扩展的泛型类型上。为这些类型增加的功能只有在类型和约束完全匹配时才能使用。</p>
<p>例如下面所示的 <code>MyList&lt;T&gt;</code>。</p>
<pre><code class="language-cangjie">class MyList&lt;T&gt; {
    public let data: Array&lt;T&gt; = Array&lt;T&gt;()
}

extend&lt;T&gt; MyList&lt;T&gt; {} // OK
extend&lt;R&gt; MyList&lt;R&gt; {} // OK
extend&lt;T, R&gt; MyList&lt;(T, R)&gt; {} // OK
extend MyList {} // Error
extend&lt;T, R&gt; MyList&lt;T&gt; {} // Error
extend&lt;T, R&gt; MyList&lt;T, R&gt; {} // Error
</code></pre>
<p>对于泛型类型的扩展，我们可以在其中声明额外的泛型约束，来实现一些有限情况下才能使用的函数。</p>
<p>例如我们可以定义一个叫 Pair 的类型，这个类型可以让我们方便的存储两个元素（类似于 Tuple）。</p>
<p>我们希望 Pair 类型可以容纳任何类型，因此两个泛型变元不应该有任何约束，这样才能保证 Pair 能容纳所有类型。</p>
<p>但同时我们又希望当两个元素可以判等的时候，让 Pair 也可以判等，这时就可以用扩展来实现这个功能。</p>
<p>如下面的代码所示，我们使用扩展语法，约束了 T1 和 T2 在支持 equals 的情况下，Pair 也可以实现 equals 函数。</p>
<!-- verify -->
<pre><code class="language-cangjie">class Pair&lt;T1, T2&gt; {
    var first: T1
    var second: T2
    public init(a: T1, b: T2) {
        first = a
        second = b
    }
}

interface Eq&lt;T&gt; {
    func equals(other: T): Bool
}

extend&lt;T1, T2&gt; Pair&lt;T1, T2&gt; where T1 &lt;: Eq&lt;T1&gt;, T2 &lt;: Eq&lt;T2&gt; {
    public func equals(other: Pair&lt;T1, T2&gt;) {
        first.equals(other.first) &amp;&amp; second.equals(other.second)
    }
}

class Foo &lt;: Eq&lt;Foo&gt; {
    public func equals(other: Foo): Bool {
        true
    }
}

main() {
    let a = Pair(Foo(), Foo())
    let b = Pair(Foo(), Foo())
    println(a.equals(b)) // true
}
</code></pre>
<p>编译执行上述代码，输出结果为：</p>
<pre><code class="language-text">true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="接口扩展"><a class="header" href="#接口扩展">接口扩展</a></h1>
<p>例如下面的例子，类型 <code>Array</code> 本身没有实现接口 <code>PrintSizeable</code>，但我们可以通过扩展的方式为 <code>Array</code> 增加额外的成员函数 <code>printSize</code>，并实现 <code>PrintSizeable</code>。</p>
<!-- verify -PrintSizeable -->
<pre><code class="language-cangjie">interface PrintSizeable {
    func printSize(): Unit
}

extend&lt;T&gt; Array&lt;T&gt; &lt;: PrintSizeable {
    public func printSize() {
        println(&quot;The size is ${this.size}&quot;)
    }
}
</code></pre>
<p>当使用扩展为 <code>Array</code> 实现 <code>PrintSizeable</code> 之后，就相当于在 <code>Array</code> 定义时实现接口 <code>PrintSizeable</code>。</p>
<p>因此我们可以将 <code>Array</code> 作为 <code>PrintSizeable</code> 的实现类型来使用了，如以下代码所示。</p>
<!-- verify -PrintSizeable -->
<pre><code class="language-cangjie">main() {
    let a: PrintSizeable = Array&lt;Int64&gt;()
    a.printSize() // 0
}
</code></pre>
<p>编译执行上述代码，输出结果为：</p>
<!-- verify -PrintSizeable -->
<pre><code class="language-text">The size is 0
</code></pre>
<p>我们可以在同一个扩展内同时实现多个接口，多个接口之间使用 <code>&amp;</code> 分开，接口的顺序没有先后关系。</p>
<p>如下面代码所示，我们可以在扩展中为 <code>Foo</code> 同时实现 <code>I1</code>、<code>I2</code>、<code>I3</code>。</p>
<pre><code class="language-cangjie">interface I1 {
    func f1(): Unit
}

interface I2 {
    func f2(): Unit
}

interface I3 {
    func f3(): Unit
}

class Foo {}

extend Foo &lt;: I1 &amp; I2 &amp; I3 {
    public func f1(): Unit {}
    public func f2(): Unit {}
    public func f3(): Unit {}
}
</code></pre>
<p>我们也可以在接口扩展中声明额外的泛型约束，来实现一些特定约束下才能满足的接口。</p>
<p>例如我们可以让上面的 <code>Pair</code> 类型实现 <code>Eq</code> 接口，这样 <code>Pair</code> 自己也能成为一个符合 <code>Eq</code> 约束的类型，如下代码所示。</p>
<!-- verify -->
<pre><code class="language-cangjie">class Pair&lt;T1, T2&gt; {
    var first: T1
    var second: T2
    public init(a: T1, b: T2) {
        first = a
        second = b
    }
}

interface Eq&lt;T&gt; {
    func equals(other: T): Bool
}

extend&lt;T1, T2&gt; Pair&lt;T1, T2&gt; &lt;: Eq&lt;Pair&lt;T1, T2&gt;&gt; where T1 &lt;: Eq&lt;T1&gt;, T2 &lt;: Eq&lt;T2&gt; {
    public func equals(other: Pair&lt;T1, T2&gt;) {
        first.equals(other.first) &amp;&amp; second.equals(other.second)
    }
}

class Foo &lt;: Eq&lt;Foo&gt; {
    public func equals(other: Foo): Bool {
        true
    }
}

main() {
    let a = Pair(Foo(), Foo())
    let b = Pair(Foo(), Foo())
    println(a.equals(b)) // true
}
</code></pre>
<p>编译执行上述代码，输出结果为：</p>
<pre><code class="language-text">true
</code></pre>
<p>如果被扩展的类型已经包含接口要求的函数或属性，那么我们在扩展中不需要并且也不能重新实现这些函数或属性。</p>
<p>例如下面的例子，我们定义了一个新接口 <code>Sizeable</code>，目的是获得某个类型的 <code>size</code>，而我们已经知道 <code>Array</code> 中包含了这个函数，因此我们就可以通过扩展让 <code>Array</code> 实现 <code>Sizeable</code>，而不需要添加额外的函数。</p>
<!-- verify -->
<pre><code class="language-cangjie">interface Sizeable {
    prop size: Int64
}

extend&lt;T&gt; Array&lt;T&gt; &lt;: Sizeable {}

main() {
    let a: Sizeable = Array&lt;Int64&gt;()
    println(a.size)
}
</code></pre>
<p>编译执行上述代码，输出结果为：</p>
<pre><code class="language-text">0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="访问规则"><a class="header" href="#访问规则">访问规则</a></h1>
<h2 id="扩展的修饰符"><a class="header" href="#扩展的修饰符">扩展的修饰符</a></h2>
<p>扩展本身不能使用修饰符修饰。</p>
<p>例如，下面的例子中对 A 的直接扩展前使用了 <code>public</code> 修饰，将编译报错。</p>
<pre><code class="language-cangjie">public class A {}

public extend A {}  // Error, expected no modifier before extend
</code></pre>
<p>扩展成员可使用的修饰符有：<code>static</code>、<code>public</code>、<code>protected</code>（仅限于被扩展类型是 <code>class</code> 类型）、<code>private</code>、<code>mut</code>。</p>
<ul>
<li>使用 <code>private</code> 修饰的成员只能在本扩展内使用，外部不可见。</li>
<li>使用 <code>protected</code> 修饰的成员除了能在本包内被访问，对包外的当前 class 子类也可以访问。</li>
<li>没有使用 <code>private</code>，<code>protected</code> 或 <code>public</code> 修饰的成员只能在本包内使用。</li>
<li>使用 <code>static</code> 修饰的成员，只能通过类型名访问，不能通过实例对象访问。</li>
<li>对 <code>struct</code> 类型的扩展可以定义 <code>mut</code> 函数。</li>
</ul>
<!-- compile -->
<pre><code class="language-cangjie">package p1

public open class A {}

extend A {
    public func f1() {}
    protected func f2() {}
    private func f3() {}
    static func f4() {}
}

main() {
    A.f4()
    var a = A()
    a.f1()
    a.f2()
}
</code></pre>
<p>扩展内的成员定义不支持使用 <code>open</code>、<code>override</code>、<code>redef</code> 修饰。</p>
<pre><code class="language-cangjie">class Foo {
    public open func f() {}
    static func h() {}
}

extend Foo {
    public override func f() {} // Error
    public open func g() {} // Error
    redef static func h() {} // Error
}
</code></pre>
<h2 id="扩展的孤儿规则"><a class="header" href="#扩展的孤儿规则">扩展的孤儿规则</a></h2>
<p>为一个其它 <code>package</code> 的类型实现另一个 <code>package</code> 的接口，可能造成理解上的困扰。</p>
<p>为了防止一个类型被意外实现不合适的接口，仓颉不允许定义孤儿扩展，指的是既不与接口（包含接口继承链上的所有接口）定义在同一个包中，也不与被扩展类型定义在同一个包中的接口扩展。</p>
<p>如下代码所示，我们不能在 <code>package c</code> 中，为 <code>package a</code> 里的 <code>Foo</code> 实现 <code>package b</code> 里的 <code>Bar</code>。</p>
<p>我们只能在 <code>package a</code> 或者在 <code>package b</code> 中为 <code>Foo</code> 实现 <code>Bar</code>。</p>
<pre><code class="language-cangjie">// package a
public class Foo {}

// package b
public interface Bar {}

// package c
import a.Foo
import b.Bar

extend Foo &lt;: Bar {} // Error
</code></pre>
<h2 id="扩展的访问和遮盖"><a class="header" href="#扩展的访问和遮盖">扩展的访问和遮盖</a></h2>
<p>扩展的实例成员与类型定义处一样可以使用 <code>this</code>，<code>this</code> 的功能保持一致。同样也可以省略 <code>this</code> 访问成员。扩展的实例成员不能使用 <code>super</code>。</p>
<pre><code class="language-cangjie">class A {
    var v = 0
}

extend A {
    func f() {
        print(this.v) // Ok
        print(v) // Ok
    }
}
</code></pre>
<p>扩展不能访问被扩展类型的 <code>private</code> 修饰的成员（意味着非 <code>private</code> 修饰的成员均能被访问）。</p>
<pre><code class="language-cangjie">class A {
    private var v1 = 0
    protected var v2 = 0
}

extend A {
    func f() {
        print(v1) // Error
        print(v2) // Ok
    }
}
</code></pre>
<p>扩展不能遮盖被扩展类型的任何成员。</p>
<pre><code class="language-cangjie">class A {
    func f() {}
}

extend A {
    func f() {} // Error
}
</code></pre>
<p>扩展也不允许遮盖其它扩展增加的任何成员。</p>
<pre><code class="language-cangjie">class A {}

extend A {
    func f() {}
}

extend A {
    func f() {} // Error
}
</code></pre>
<p>在同一个 <code>package</code> 内对同一类型可以扩展多次。</p>
<p>在扩展中可以直接调用（不加任何前缀修饰）其它对同一类型的扩展中的非 <code>private</code> 修饰的函数。</p>
<pre><code class="language-cangjie">class Foo {}

extend Foo { // OK
    private func f() {}
    func g() {}
}

extend Foo { // OK
    func h() {
        g() // OK
        f() // Error
    }
}
</code></pre>
<p>扩展泛型类型时，可以使用额外的泛型约束。泛型类型的任意两个扩展之间的可见性规则如下：</p>
<ul>
<li>如果两个扩展的约束相同，则两个扩展相互可见，即两个扩展内可以直接使用对方内的函数或属性；</li>
<li>如果两个扩展的约束不同，且两个扩展的约束有包含关系，约束更宽松的扩展对约束更严格的扩展可见，反之，不可见；</li>
<li>当两个扩展的约束不同时，且两个约束不存在包含关系，则两个扩展均互相不可见。</li>
</ul>
<p>示例：假设对同一个类型 <code>E&lt;X&gt;</code> 的两个扩展分别为扩展 <code>1</code> 和扩展 <code>2</code> ，<code>X</code> 的约束在扩展 <code>1</code> 中比扩展 <code>2</code> 中更严格，那么扩展 <code>1</code> 中的函数和属性对扩展 <code>2</code> 均不可见，反之，扩展 <code>2</code> 中的函数和属性对扩展 <code>1</code> 可见。</p>
<pre><code class="language-cangjie">open class A {}
class B &lt;: A {}
class E&lt;X&gt; {}

interface I1 {
    func f1(): Unit
}
interface I2 {
    func f2(): Unit
}

extend&lt;X&gt; E&lt;X&gt; &lt;: I1 where X &lt;: B {  // extension 1
    public func f1(): Unit {
        f2() // OK
    }
}

extend&lt;X&gt; E&lt;X&gt; &lt;: I2 where X &lt;: A   { // extension 2
    public func f2(): Unit {
        f1() // Error
    }
}
</code></pre>
<h2 id="扩展的导入导出"><a class="header" href="#扩展的导入导出">扩展的导入导出</a></h2>
<p>扩展也是可以被导入和导出的，但是扩展本身不能使用 <code>public</code> 修饰，扩展的导出有一套特殊的规则。</p>
<p>对于直接扩展，只有当扩展与被扩展的类型在同一个 <code>package</code>，并且被扩展的类型和扩展中添加的成员都使用 <code>public</code> 或 <code>protected</code> 修饰时，扩展的功能才会被导出。</p>
<p>除此以外的直接扩展均不能被导出，只能在当前 <code>package</code> 使用。</p>
<p>如以下代码所示，<code>Foo</code> 是使用 <code>public</code> 修饰的类型，并且 <code>f</code> 与 <code>Foo</code> 在同一个 <code>package</code> 内，因此 <code>f</code> 会跟随 <code>Foo</code> 一起被导出。而 <code>g</code> 和 <code>Foo</code> 不在同一个 <code>package</code>，因此 <code>g</code> 不会被导出。</p>
<pre><code class="language-cangjie">// package a

public class Foo {}

extend Foo {
    public func f() {}
}

// package b
import a.*

extend Foo {
    public func g() {}
}

// package c
import a.*
import b.*

main() {
    let a = Foo()
    a.f() // OK
    a.g() // Error
}
</code></pre>
<p>对于接口扩展则分为两种情况：</p>
<ol>
<li>如果接口扩展和被扩展类型在同一个 <code>package</code>，但接口是来自导入的，只有当被扩展类型使用 <code>public</code> 修饰时，扩展的功能才会被导出。</li>
<li>如果接口扩展与接口在同一个 <code>package</code>，则只有当接口是使用 <code>public</code> 修饰时，扩展的功能才会被导出。</li>
</ol>
<p>如下代码所示，<code>Foo</code> 和 <code>I</code> 都使用了 <code>public</code> 修饰，因此对 <code>Foo</code> 的扩展就可以被导出。</p>
<pre><code class="language-cangjie">// package a

public class Foo {}

public interface I {
    func g(): Unit
}

extend Foo &lt;: I {
    public func g(): Unit {}
}

// package b
import a.*

main() {
    let a: I = Foo()
    a.g()
}
</code></pre>
<p>与扩展的导出类似，扩展的导入也不需要显式地用 <code>import</code> 导入，扩展的导入只需要导入被扩展的类型和接口，就可以导入可访问的所有扩展。</p>
<p>如下面的代码所示，在 <code>package b</code> 中，只需要导入 <code>Foo</code> 就可以使用 <code>Foo</code> 对应的扩展中的函数 <code>f</code>。</p>
<p>而对于接口扩展，需要同时导入被扩展的类型和扩展的接口才能使用，因此在 <code>package c</code> 中，需要同时导入 <code>Foo</code> 和 <code>I</code> 才能使用对应扩展中的函数 <code>g</code>。</p>
<pre><code class="language-cangjie">// package a
public class Foo {}
extend Foo {
    public func f() {}
}

// package b
import a.Foo

public interface I {
    func g(): Unit
}
extend Foo &lt;: I {
    public func g() {
        this.f() // OK
    }
}

// package c
import a.Foo
import b.I

func test() {
    let a = Foo()
    a.f() // OK
    a.g() // OK
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基础-collection-类型概述"><a class="header" href="#基础-collection-类型概述">基础 Collection 类型概述</a></h1>
<p>本章我们来看看仓颉中常用的几种基础 Collection 类型，包含 Array、ArrayList、HashSet、HashMap。</p>
<p>我们可以在不同的场景中选择适合我们业务的类型：</p>
<ul>
<li>Array：如果我们不需要增加和删除元素，但需要修改元素，就应该使用它。</li>
<li>ArrayList：如果我们需要频繁对元素增删查改，就应该使用它。</li>
<li>HashSet：如果我们希望每个元素都是唯一的，就应该使用它。</li>
<li>HashMap：如果我们希望存储一系列的映射关系，就应该使用它。</li>
</ul>
<p>下表是这些类型的基础特性：</p>
<div class="table-wrapper"><table><thead><tr><th>类型名称</th><th>元素可变</th><th>增删元素</th><th>元素唯一性</th><th>有序序列</th></tr></thead><tbody>
<tr><td><code>Array&lt;T&gt;</code></td><td>Y</td><td>N</td><td>N</td><td>Y</td></tr>
<tr><td><code>ArrayList&lt;T&gt;</code></td><td>Y</td><td>Y</td><td>N</td><td>Y</td></tr>
<tr><td><code>HashSet&lt;T&gt;</code></td><td>N</td><td>Y</td><td>Y</td><td>N</td></tr>
<tr><td><code>HashMap&lt;K, V&gt;</code></td><td>K: N, V: Y</td><td>Y</td><td>K: Y, V: N</td><td>N</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="arraylist"><a class="header" href="#arraylist">ArrayList</a></h1>
<p>使用 ArrayList 类型需要导入 collection 包：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.collection.*
</code></pre>
<p>仓颉使用 <code>ArrayList&lt;T&gt;</code> 表示 ArrayList 类型，T 表示 ArrayList 的元素类型，T 可以是任意类型。</p>
<p>ArrayList 具备非常好的扩容能力，适合于需要频繁增加和删除元素的场景。</p>
<p>相比 Array，ArrayList 既可以原地修改元素，也可以原地增加和删除元素。</p>
<p>ArrayList 的可变性是一个非常有用的特征，我们可以让同一个 ArrayList 实例的所有引用都共享同样的元素，并且对它们统一进行修改。</p>
<pre><code class="language-cangjie">var a: ArrayList&lt;Int64&gt; = ... // ArrayList whose element type is Int64
var b: ArrayList&lt;String&gt; = ... // ArrayList whose element type is String
</code></pre>
<p>元素类型不相同的 ArrayList 是不相同的类型，所以它们之间不可以互相赋值。</p>
<p>因此以下例子是不合法的。</p>
<pre><code class="language-cangjie">b = a // Type mismatch
</code></pre>
<p>仓颉中可以使用构造函数的方式构造一个指定的 ArrayList。</p>
<!-- run -->
<pre><code class="language-cangjie">let a = ArrayList&lt;String&gt;() // Created an empty ArrayList whose element type is String
let b = ArrayList&lt;String&gt;(100) // Created an ArrayList whose element type is String, and allocate a space of 100
let c = ArrayList&lt;Int64&gt;([0, 1, 2]) // Created an ArrayList whose element type is Int64, containing elements 0, 1, 2
let d = ArrayList&lt;Int64&gt;(c) // Use another Collection to initialize an ArrayList
let e = ArrayList&lt;String&gt;(2, {x: Int64 =&gt; x.toString()}) // Created an ArrayList whose element type is String and size is 2. All elements are initialized by specified rule function
</code></pre>
<h2 id="访问-arraylist-成员"><a class="header" href="#访问-arraylist-成员">访问 ArrayList 成员</a></h2>
<p>当我们需要对 ArrayList 的所有元素进行访问时，可以使用 for-in 循环遍历 ArrayList 的所有元素。</p>
<!-- verify -->
<pre><code class="language-cangjie">import std.collection.*

main() {
    let list = ArrayList&lt;Int64&gt;([0, 1, 2])
    for (i in list) {
        println(&quot;The element is ${i}&quot;)
    }
}
</code></pre>
<p>编译并执行上面的代码，会输出：</p>
<pre><code class="language-text">The element is 0
The element is 1
The element is 2
</code></pre>
<p>当我们需要知道某个 ArrayList 包含的元素个数时，可以使用 size 属性获得对应信息。</p>
<!-- verify -->
<pre><code class="language-cangjie">import std.collection.*

main() {
    let list = ArrayList&lt;Int64&gt;([0, 1, 2])
    if (list.size == 0) {
        println(&quot;This is an empty arraylist&quot;)
    } else {
        println(&quot;The size of arraylist is ${list.size}&quot;)
    }
}
</code></pre>
<p>编译并执行上面的代码，会输出：</p>
<pre><code class="language-text">The size of arraylist is 3
</code></pre>
<p>当我们想访问单个指定位置的元素时，可以使用下标语法访问（下标的类型必须是 Int64）。非空 ArrayList 的第一个元素总是从位置 0 开始的。我们可以从 0 开始访问 ArrayList 的任意一个元素，直到最后一个位置（ArrayList 的 size - 1）。使用负数或大于等于 size 的索引会触发运行时异常。</p>
<pre><code class="language-cangjie">let a = list[0] // a == 0
let b = list[1] // b == 1
let c = list[-1] // Runtime exceptions
</code></pre>
<p>ArrayList 也支持下标中使用 Range 的语法，详见 <a href="source_zh_cn/Collections/../basic_data_type/array.html#array">Array</a> 章节。</p>
<h2 id="修改-arraylist"><a class="header" href="#修改-arraylist">修改 ArrayList</a></h2>
<p>我们可以使用下标语法对某个位置的元素进行修改。</p>
<!-- run -->
<pre><code class="language-cangjie">let list = ArrayList&lt;Int64&gt;([0, 1, 2])
list[0] = 3
</code></pre>
<p>ArrayList 是引用类型，ArrayList 在作为表达式使用时不会拷贝副本，同一个 ArrayList 实例的所有引用都会共享同样的数据。</p>
<p>因此对 ArrayList 元素的修改会影响到该实例的所有引用。</p>
<!-- run -->
<pre><code class="language-cangjie">let list1 = ArrayList&lt;Int64&gt;([0, 1, 2])
let list2 = list1
list2[0] = 3
// list1 contains elements 3, 1, 2
// list2 contains elements 3, 1, 2
</code></pre>
<p>如果需要将单个元素添加到 ArrayList 的末尾，请使用 append 函数。如果希望同时添加多个元素到末尾，可以使用 appendAll 函数，这个函数可以接受其它相同元素类型的 Collection 类型（例如 Array）。</p>
<!-- run -->
<pre><code class="language-cangjie">import std.collection.*

main() {
    let list = ArrayList&lt;Int64&gt;()
    list.append(0) // list contains element 0
    list.append(1) // list contains elements 0, 1
    let li = [2, 3]
    list.appendAll(li) // list contains elements 0, 1, 2, 3
}
</code></pre>
<p>我们可以通过 insert 和 insertAll 函数将指定的单个元素或相同元素类型的 Collection 值插入到我们指定索引的位置。该索引处的元素和后面的元素会被挪后以腾出空间。</p>
<!-- run -->
<pre><code class="language-cangjie">let list = ArrayList&lt;Int64&gt;([0, 1, 2]) // list contains elements 0, 1, 2
list.insert(1, 4) // list contains elements 0, 4, 1, 2
</code></pre>
<p>从 ArrayList 中删除元素，可以使用 remove 函数，需要指定删除的索引。该索引处后面的元素会挪前以填充空间。</p>
<!-- run -->
<pre><code class="language-cangjie">let list = ArrayList&lt;String&gt;([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]) // list contains the elements &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;
list.remove(1) // Delete the element at subscript 1, now the list contains elements &quot;a&quot;, &quot;c&quot;, &quot;d&quot;
</code></pre>
<h2 id="增加-arraylist-的大小"><a class="header" href="#增加-arraylist-的大小">增加 ArrayList 的大小</a></h2>
<p>每个 ArrayList 都需要特定数量的内存来保存其内容。当我们向 ArrayList 添加元素并且该 ArrayList 开始超出其保留容量时，该 ArrayList 会分配更大的内存区域并将其所有元素复制到新内存中。这种增长策略意味着触发重新分配内存的添加操作具有性能成本，但随着 ArrayList 的保留内存变大，它们发生的频率会越来越低。</p>
<p>如果我们知道大约需要添加多少个元素，可以在添加之前预备足够的内存以避免中间重新分配，这样可以提升性能表现。</p>
<!-- run -->
<pre><code class="language-cangjie">import std.collection.*

main() {
    let list = ArrayList&lt;Int64&gt;(100) // Allocate space at once
    for (i in 0..100) {
        list.append(i) // Does not trigger reallocation of space
    }
    list.reserve(100) // Prepare more space
    for (i in 0..100) {
        list.append(i) // Does not trigger reallocation of space
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashset"><a class="header" href="#hashset">HashSet</a></h1>
<p>使用 HashSet 类型需要导入 collection 包：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.collection.*
</code></pre>
<p>我们可以使用 HashSet 类型来构造只拥有不重复元素的 Collection。</p>
<p>仓颉使用 <code>HashSet&lt;T&gt;</code> 表示 HashSet 类型，T 表示 HashSet 的元素类型，T 必须是实现了 Hashable 和 <code>Equatable&lt;T&gt;</code> 接口的类型，例如数值或 String。</p>
<pre><code class="language-cangjie">var a: HashSet&lt;Int64&gt; = ... // HashSet whose element type is Int64
var b: HashSet&lt;String&gt; = ... // HashSet whose element type is String
</code></pre>
<p>元素类型不相同的 HashSet 是不相同的类型，所以它们之间不可以互相赋值。</p>
<p>因此以下例子是不合法的。</p>
<pre><code class="language-cangjie">b = a // Type mismatch
</code></pre>
<p>仓颉中可以使用构造函数的方式构造一个指定的 HashSet。</p>
<!-- run -->
<pre><code class="language-cangjie">let a = HashSet&lt;String&gt;() // Created an empty HashSet whose element type is String
let b = HashSet&lt;String&gt;(100) // Created a HashSet whose capacity is 100
let c = HashSet&lt;Int64&gt;([0, 1, 2]) // Created a HashSet whose element type is Int64, containing elements 0, 1, 2
let d = HashSet&lt;Int64&gt;(c) // Use another Collection to initialize a HashSet
let e = HashSet&lt;Int64&gt;(10, {x: Int64 =&gt; (x * x)}) // Created a HashSet whose element type is Int64 and size is 10. All elements are initialized by specified rule function
</code></pre>
<h2 id="访问-hashset-成员"><a class="header" href="#访问-hashset-成员">访问 HashSet 成员</a></h2>
<p>当我们需要对 HashSet 的所有元素进行访问时，可以使用 for-in 循环遍历 HashSet 的所有元素。</p>
<p>需要注意的是，HashSet 并不保证按插入元素的顺序排列，因此遍历的顺序和插入的顺序可能不同。</p>
<!-- verify -->
<pre><code class="language-cangjie">import std.collection.*

main() {
    let mySet = HashSet&lt;Int64&gt;([0, 1, 2])
    for (i in mySet) {
        println(&quot;The element is ${i}&quot;)
    }
}
</code></pre>
<p>编译并执行上面的代码，有可能会输出：</p>
<pre><code class="language-text">The element is 0
The element is 1
The element is 2
</code></pre>
<p>当我们需要知道某个 HashSet 包含的元素个数时，可以使用 size 属性获得对应信息。</p>
<!-- verify -->
<pre><code class="language-cangjie">import std.collection.*

main() {
    let mySet = HashSet&lt;Int64&gt;([0, 1, 2])
    if (mySet.size == 0) {
        println(&quot;This is an empty hashset&quot;)
    } else {
        println(&quot;The size of hashset is ${mySet.size}&quot;)
    }
}
</code></pre>
<p>编译并执行上面的代码，会输出：</p>
<pre><code class="language-text">The size of hashset is 3
</code></pre>
<p>当我们想判断某个元素是否被包含在某个 HashSet 中时，可以使用 contains 函数。如果该元素存在会返回 true，否则返回 false。</p>
<!-- run -->
<pre><code class="language-cangjie">let mySet = HashSet&lt;Int64&gt;([0, 1, 2])
let a = mySet.contains(0) // a == true
let b = mySet.contains(-1) // b == false
</code></pre>
<h2 id="修改-hashset"><a class="header" href="#修改-hashset">修改 HashSet</a></h2>
<p>HashSet 是一种可变的引用类型，HashSet 类型提供了添加元素、删除元素的功能。</p>
<p>HashSet 的可变性是一个非常有用的特征，我们可以让同一个 HashSet 实例的所有引用都共享同样的元素，并且对它们统一进行修改。</p>
<p>如果需要将单个元素添加到 HashSet 的末尾，请使用 put 函数。如果希望同时添加多个元素，可以使用 putAll 函数，这个函数可以接受另一个相同元素类型的 Collection 类型（例如 Array）。当元素不存在时，put 函数会执行添加的操作，当 HashSet 中存在相同元素时，put 函数将不会有效果。</p>
<!-- run -->
<pre><code class="language-cangjie">let mySet = HashSet&lt;Int64&gt;()
mySet.put(0) // mySet contains elements 0
mySet.put(0) // mySet contains elements 0
mySet.put(1) // mySet contains elements 0, 1
let li = [2, 3]
mySet.putAll(li) // mySet contains elements 0, 1, 2, 3
</code></pre>
<p>HashSet 是引用类型，HashSet 在作为表达式使用时不会拷贝副本，同一个 HashSet 实例的所有引用都会共享同样的数据。</p>
<p>因此对 HashSet 元素的修改会影响到该实例的所有引用。</p>
<!-- run -->
<pre><code class="language-cangjie">let set1 = HashSet&lt;Int64&gt;([0, 1, 2])
let set2 = set1
set2.put(3)
// set1 contains elements 0, 1, 2, 3
// set2 contains elements 0, 1, 2, 3
</code></pre>
<p>从 HashSet 中删除元素，可以使用 remove 函数，需要指定删除的元素。</p>
<!-- run -->
<pre><code class="language-cangjie">let mySet = HashSet&lt;Int64&gt;([0, 1, 2, 3])
mySet.remove(1) // mySet contains elements 0, 2, 3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashmap"><a class="header" href="#hashmap">HashMap</a></h1>
<p>使用 HashMap 类型需要导入 collection 包：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.collection.*
</code></pre>
<p>我们可以使用 HashMap 类型来构造元素为键值对的 Collection。</p>
<p>HashMap 是一种哈希表，提供对其包含的元素的快速访问。表中的每个元素都使用其键作为标识，我们可以使用键来访问相应的值。</p>
<p>仓颉使用 <code>HashMap&lt;K, V&gt;</code> 表示 HashMap 类型，K 表示 HashMap 的键类型，K 必须是实现了 Hashable 和 <code>Equatable&lt;K&gt;</code> 接口的类型，例如数值或 String。V 表示 HashMap 的值类型，V 可以是任意类型。</p>
<pre><code class="language-cangjie">var a: HashMap&lt;Int64, Int64&gt; = ... // HashMap whose key type is Int64 and value type is Int64
var b: HashMap&lt;String, Int64&gt; = ... // HashMap whose key type is String and value type is Int64
</code></pre>
<p>元素类型不相同的 HashMap 是不相同的类型，所以它们之间不可以互相赋值。</p>
<p>因此以下例子是不合法的。</p>
<pre><code class="language-cangjie">b = a // Type mismatch
</code></pre>
<p>仓颉中可以使用构造函数的方式构造一个指定的 HashMap。</p>
<!-- run -->
<pre><code class="language-cangjie">let a = HashMap&lt;String, Int64&gt;() // Created an empty HashMap whose key type is String and value type is Int64
let b = HashMap&lt;String, Int64&gt;([(&quot;a&quot;, 0), (&quot;b&quot;, 1), (&quot;c&quot;, 2)]) // whose key type is String and value type is Int64, containing elements (&quot;a&quot;, 0), (&quot;b&quot;, 1), (&quot;c&quot;, 2)
let c = HashMap&lt;String, Int64&gt;(b) // Use another Collection to initialize a HashMap
let d = HashMap&lt;String, Int64&gt;(10) // Created a HashMap whose key type is String and value type is Int64 and capacity is 10
let e = HashMap&lt;Int64, Int64&gt;(10, {x: Int64 =&gt; (x, x * x)}) // Created a HashMap whose key and value type is Int64 and size is 10. All elements are initialized by specified rule function
</code></pre>
<h2 id="访问-hashmap-成员"><a class="header" href="#访问-hashmap-成员">访问 HashMap 成员</a></h2>
<p>当我们需要对 HashMap 的所有元素进行访问时，可以使用 for-in 循环遍历 HashMap 的所有元素。</p>
<p>需要注意的是，HashMap 并不保证按插入元素的顺序排列，因此遍历的顺序和插入的顺序可能不同。</p>
<!-- verify -->
<pre><code class="language-cangjie">import std.collection.*

main() {
    let map = HashMap&lt;String, Int64&gt;([(&quot;a&quot;, 0), (&quot;b&quot;, 1), (&quot;c&quot;, 2)])
    for ((k, v) in map) {
        println(&quot;The key is ${k}, the value is ${v}&quot;)
    }
}
</code></pre>
<p>编译并执行上面的代码，有可能会输出：</p>
<pre><code class="language-text">The key is a, the value is 0
The key is b, the value is 1
The key is c, the value is 2
</code></pre>
<p>当我们需要知道某个 HashMap 包含的元素个数时，可以使用 size 属性获得对应信息。</p>
<!-- verify -->
<pre><code class="language-cangjie">import std.collection.*

main() {
    let map = HashMap&lt;String, Int64&gt;([(&quot;a&quot;, 0), (&quot;b&quot;, 1), (&quot;c&quot;, 2)])
    if (map.size == 0) {
        println(&quot;This is an empty hashmap&quot;)
    } else {
        println(&quot;The size of hashmap is ${map.size}&quot;)
    }
}
</code></pre>
<p>编译并执行上面的代码，会输出：</p>
<pre><code class="language-text">The size of hashmap is 3
</code></pre>
<p>当我们想判断某个键是否被包含 HashMap 中时，可以使用 contains 函数。如果该键存在会返回 true，否则返回 false。</p>
<!-- run -->
<pre><code class="language-cangjie">let map = HashMap&lt;String, Int64&gt;([(&quot;a&quot;, 0), (&quot;b&quot;, 1), (&quot;c&quot;, 2)])
let a = map.contains(&quot;a&quot;) // a == true
let b = map.contains(&quot;d&quot;) // b == false
</code></pre>
<p>当我们想访问指定键对应的元素时，可以使用下标语法访问（下标的类型必须是键类型）。使用不存在的键作为索引会触发运行时异常。</p>
<pre><code class="language-cangjie">let map = HashMap&lt;String, Int64&gt;([(&quot;a&quot;, 0), (&quot;b&quot;, 1), (&quot;c&quot;, 2)])
let a = map[&quot;a&quot;] // a == 0
let b = map[&quot;b&quot;] // b == 1
let c = map[&quot;d&quot;] // Runtime exceptions
</code></pre>
<h2 id="修改-hashmap"><a class="header" href="#修改-hashmap">修改 HashMap</a></h2>
<p>HashMap 是一种可变的引用类型，HashMap 类型提供了修改元素、添加元素、删除元素的功能。</p>
<p>HashMap 的可变性是一个非常有用的特征，我们可以让同一个 HashMap 实例的所有引用都共享同样的元素，并且对它们统一进行修改。</p>
<p>我们可以使用下标语法对某个键对应的值进行修改。</p>
<!-- run -->
<pre><code class="language-cangjie">let map = HashMap&lt;String, Int64&gt;([(&quot;a&quot;, 0), (&quot;b&quot;, 1), (&quot;c&quot;, 2)])
map[&quot;a&quot;] = 3
</code></pre>
<p>HashMap 是引用类型，HashMap 在作为表达式使用时不会拷贝副本，同一个 HashMap 实例的所有引用都会共享同样的数据。</p>
<p>因此对 HashMap 元素的修改会影响到该实例的所有引用。</p>
<!-- run -->
<pre><code class="language-cangjie">let map1 = HashMap&lt;String, Int64&gt;([(&quot;a&quot;, 0), (&quot;b&quot;, 1), (&quot;c&quot;, 2)])
let map2 = map1
map2[&quot;a&quot;] = 3
// map1 contains the elements (&quot;a&quot;, 3), (&quot;b&quot;, 1), (&quot;c&quot;, 2)
// map2 contains the elements (&quot;a&quot;, 3), (&quot;b&quot;, 1), (&quot;c&quot;, 2)
</code></pre>
<p>如果需要将单个键值对添加到 HashMap 的末尾，请使用 put 函数。如果希望同时添加多个键值对，可以使用 putAll 函数。当键不存在时，put 函数会执行添加的操作，当键存在时，put 函数会将新的值覆盖旧的值。</p>
<!-- run -->
<pre><code class="language-cangjie">let map = HashMap&lt;String, Int64&gt;()
map.put(&quot;a&quot;, 0) // map contains the element (&quot;a&quot;, 0)
map.put(&quot;b&quot;, 1) // map contains the elements (&quot;a&quot;, 0), (&quot;b&quot;, 1)
let map2 = HashMap&lt;String, Int64&gt;([(&quot;c&quot;, 2), (&quot;d&quot;, 3)])
map.putAll(map2) // map contains the elements (&quot;a&quot;, 0), (&quot;b&quot;, 1), (&quot;c&quot;, 2), (&quot;d&quot;, 3)
</code></pre>
<p>除了使用 put 函数以外，我们也可以使用赋值的方式直接将新的键值对添加到 HashMap。</p>
<!-- run -->
<pre><code class="language-cangjie">let map = HashMap&lt;String, Int64&gt;([(&quot;a&quot;, 0), (&quot;b&quot;, 1), (&quot;c&quot;, 2)])
map[&quot;d&quot;] = 3 // map contains the elements (&quot;a&quot;, 0), (&quot;b&quot;, 1), (&quot;c&quot;, 2), (&quot;d&quot;, 3)
</code></pre>
<p>从 HashMap 中删除元素，可以使用 remove 函数，需要指定删除的键。</p>
<!-- run -->
<pre><code class="language-cangjie">let map = HashMap&lt;String, Int64&gt;([(&quot;a&quot;, 0), (&quot;b&quot;, 1), (&quot;c&quot;, 2), (&quot;d&quot;, 3)])
map.remove(&quot;d&quot;) // map contains the elements (&quot;a&quot;, 0), (&quot;b&quot;, 1), (&quot;c&quot;, 2)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterable-和-collections"><a class="header" href="#iterable-和-collections">Iterable 和 Collections</a></h1>
<p>前面我们已经了解过 Range、Array、ArrayList，它们都可以使用 for-in 进行遍历操作，那么对一个用户自定义类型，能不能实现类似的遍历操作呢？答案是可以的。</p>
<p>Range、Array、ArrayList 其实都是通过 Iterable 来支持 for-in 语法的。</p>
<p>Iterable 是如下形式（只展示了核心代码）的一个内置 interface。</p>
<pre><code class="language-cangjie">interface Iterable&lt;T&gt; {
    func iterator(): Iterator&lt;T&gt;
    ...
}
</code></pre>
<p>iterator 函数要求返回的 Iterator 类型是如下形式（只展示了核心代码）的另一个内置 interface。</p>
<pre><code class="language-cangjie">interface Iterator&lt;T&gt; &lt;: Iterable&lt;T&gt; {
    mut func next(): Option&lt;T&gt;
    ...
}
</code></pre>
<p>我们可以使用 for-in 语法来遍历任何一个实现了 Iterable 接口类型的实例。</p>
<p>假设有这样一个 for-in 代码。</p>
<!-- run -->
<pre><code class="language-cangjie">let list = [1, 2, 3]
for (i in list) {
    println(i)
}
</code></pre>
<p>那么它等价于如下形式的 while 代码。</p>
<!-- run -->
<pre><code class="language-cangjie">let list = [1, 2, 3]
var it = list.iterator()
while (true) {
    match (it.next()) {
        case Some(i) =&gt; println(i)
        case None =&gt; break
    }
}
</code></pre>
<p>另外一种常见的遍历 Iterable 类型的方法是使用 while-let，比如上面 while 代码的另一种等价写法是：</p>
<!-- run -->
<pre><code class="language-cangjie">let list = [1, 2, 3]
var it = list.iterator()
while (let Some(i) &lt;- it.next()) {
    println(i)
}
</code></pre>
<p>Array、ArrayList、HashSet、HashMap 类型都实现了 Iterable，因此我们都可以将其用在 for-in 或者 while-let 中。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包的概述"><a class="header" href="#包的概述">包的概述</a></h1>
<p>随着项目规模的不断扩大，仅在一个超大文件中管理源代码会变得十分困难。这时可以将源代码根据功能进行分组，并将不同功能的代码分开管理，每组独立管理的代码会生成一个输出文件。在使用时，通过导入对应的输出文件使用相应的功能，或者通过不同功能的交互与组合实现更加复杂的特性，使得项目管理更加高效。</p>
<p>在仓颉编程语言中，包是<strong>编译的最小单元</strong>，每个包可以单独输出 AST 文件、静态库文件、动态库文件等产物。每个包有自己的名字空间，在同一个包内不允许有同名的顶层定义或声明（函数重载除外）。一个包中可以包含多个源文件。</p>
<p>模块是若干包的集合，是第三方开发者<strong>发布的最小单元</strong>。一个模块的程序入口只能在其根目录下，它的顶层最多只能有一个作为程序入口的 <code>main</code> ，该 <code>main</code> 没有参数或参数类型为 <code>Array&lt;String&gt;</code>，返回类型为整数类型或 <code>Unit</code> 类型。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包的声明"><a class="header" href="#包的声明">包的声明</a></h1>
<p>在仓颉编程语言中，包声明以关键字 <code>package</code> 开头，后接 root 包至当前包由 <code>.</code> 分隔路径上所有包的包名。包名必须是合法的普通标识符（不含原始标识符）。例如：</p>
<pre><code class="language-cangjie">package pkg1      // root 包 pkg1
package pkg1.sub1 // root 包 pkg1 的子包 sub1
</code></pre>
<p>包声明必须在源文件的非空非注释的首行，且同一个包中的不同源文件的包声明必须保持一致。</p>
<pre><code class="language-cangjie">// file 1
// Comments are accepted
package test
// declarations...

// file 2
let a = 1 // Error, package declaration must appear first in a file
package test
// declarations...
</code></pre>
<p>仓颉的包名需反映当前源文件相对于项目源码根目录 <code>src</code> 的路径，并将其中的路径分隔符替换为小数点。例如包的源代码位于 <code>src/directory_0/directory_1</code> 下，root 包名为 <code>pkg</code> 则其源代码中的包声明应为 <code>package pkg.directory_0.directory_1</code>。</p>
<p>需要注意的是：</p>
<ul>
<li>包所在的文件夹名必须与包名一致。</li>
<li>源码根目录默认名为 <code>src</code>。</li>
<li>源码根目录下的包可以没有包声明，此时编译器将默认为其指定包名 <code>default</code>。</li>
</ul>
<p>假设源代码目录结构如下：</p>
<pre><code class="language-text">// The directory structure is as follows:
src
`-- directory_0
    |-- directory_1
    |    |-- a.cj
    |    `-- b.cj
    `-- c.cj
`-- main.cj
</code></pre>
<p>则 <code>a.cj</code>、<code>b.cj</code>、<code>c.cj</code>、<code>main.cj</code> 中的包声明可以为:</p>
<pre><code class="language-cangjie">// a.cj
// in file a.cj, the declared package name must correspond to relative path directory_0/directory_1.

package default.directory_0.directory_1
</code></pre>
<pre><code class="language-cangjie">// b.cj
// in file b.cj, the declared package name must correspond to relative path directory_0/directory_1.

package default.directory_0.directory_1
</code></pre>
<pre><code class="language-cangjie">// c.cj
// in file c.cj, the declared package name must correspond to relative path directory_0.

package default.directory_0
</code></pre>
<pre><code class="language-cangjie_runnable">// main.cj
// file main.cj is in the module root directory and may omit package declaration.

main() {
    return 0
}
</code></pre>
<p>另外，包声明不能引起命名冲突：子包不能和当前包的顶层声明同名。</p>
<p>以下是一些错误示例：</p>
<pre><code class="language-cangjie">// a.cj
package a
public class B { // Error, 'B' is conflicted with sub-package 'a.B'
    public static func f() {}
}

// b.cj
package a.B
public func f {}

// main.cj
import a.B // ambiguous use of 'a.B'

main() {
    a.B.f()
    return 0
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="顶层声明的可见性"><a class="header" href="#顶层声明的可见性">顶层声明的可见性</a></h1>
<p>仓颉中，可以使用访问修饰符来控制对类型、变量、函数等顶层声明的可见性。仓颉有 4 种访问修饰符：<code>private</code>、<code>internal</code>、<code>protected</code>、<code>public</code>，在修饰顶层元素时不同访问修饰符的语义如下。</p>
<ul>
<li><code>private</code> 表示仅当前文件内可见。不同的文件无法访问这类成员。</li>
<li><code>internal</code> 表示仅当前包及子包（包括子包的子包）内可见。同一个包内可以不导入就访问这类成员，当前包的子包（包括子包的子包）内可以通过导入来访问这类成员。</li>
<li><code>protected</code> 表示仅当前模块内可见。同一个包的文件可以不导入就访问这类成员，不同包但是在同一个模块内的其它包可以通过导入访问这些成员，不同模块的包无法访问这些成员。</li>
<li><code>public</code> 表示模块内外均可见。同一个包的文件可以不导入就访问这类成员，其它包可以通过导入访问这些成员。</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>修饰符</th><th>文件</th><th>包及子包</th><th>模块</th><th>所有包</th></tr></thead><tbody>
<tr><td><code>private</code></td><td>Y</td><td>N</td><td>N</td><td>N</td></tr>
<tr><td><code>internal</code></td><td>Y</td><td>Y</td><td>N</td><td>N</td></tr>
<tr><td><code>protected</code></td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr>
<tr><td><code>public</code></td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr>
</tbody></table>
</div>
<p>不同顶层声明支持的访问修饰符和默认修饰符（默认修饰符是指在省略情况下的修饰符语义，这些默认修饰符也允许显式写出）规定如下：</p>
<ul>
<li><code>pacakge</code> 支持使用 <code>internal</code>、<code>protected</code>、<code>public</code>，默认修饰符为 <code>public</code>。</li>
<li><code>import</code> 支持使用全部访问修饰符，默认修饰符为 <code>private</code>。</li>
<li>其他顶层声明支持使用全部访问修饰符，默认修饰符为 <code>internal</code>。</li>
</ul>
<!-- compile -->
<pre><code class="language-cangjie">package a

private func f1() { 1 }   // f1 仅在当前文件内可见
func f2() { 2 }           // f2 仅当前包及子包内可见
protected func f3() { 3 } // f3 仅当前模块内可见
public func f4() { 4 }    // f4 当前模块内外均可见
</code></pre>
<p>仓颉的访问级别排序为 <code>public &gt; protected &gt; internal &gt; private</code>。一个声明的访问修饰符不得高于该声明中用到的类型的访问修饰符的级别，参考如下示例：</p>
<ul>
<li>
<p>函数声明中的参数与返回值</p>
<pre><code class="language-cangjie">// a.cj
package a
class C {}
public func f1(a1: C) // Error, public declaration f1 cannot use internal type C.
{
    return 0
}
public func f2(a1: Int8): C // Error, public declaration f2 cannot use internal type C.
{
    return C()
}
public func f3 (a1: Int8) // Error, public declaration f3 cannot use internal type C.
{
    return C()
}
</code></pre>
</li>
<li>
<p>变量声明</p>
<pre><code class="language-cangjie">// a.cj
package a
class C {}
public let v1: C = C() // Error, public declaration v1 cannot use internal type C.
public let v2 = C() // Error, public declaration v2 cannot use internal type C.
</code></pre>
</li>
<li>
<p>类声明中继承的类</p>
<pre><code class="language-cangjie">// a.cj
package a
open class C1 {}
public class C2 &lt;: C1 {} // Error, public declaration C2 cannot use internal type C1.
</code></pre>
</li>
<li>
<p>类型实现的接口</p>
<pre><code class="language-cangjie">// a.cj
package a
interface I {}
public enum E &lt;: I { A } // Error, public declaration uses internal types.
</code></pre>
</li>
<li>
<p>泛型类型的类型实参</p>
<pre><code class="language-cangjie">// a.cj
package a
public class C1&lt;T&gt; {}
class C2 {}
public let v1 = C1&lt;C2&gt;() // Error, public declaration v1 cannot use internal type C2.
</code></pre>
</li>
<li>
<p><code>where</code> 约束中的类型上界</p>
<pre><code class="language-cangjie">// a.cj
package a
interface I {}
public class B&lt;T&gt; where T &lt;: I {}  // Error, public declaration B cannot use internal type I.
</code></pre>
</li>
</ul>
<p>值得注意的是：</p>
<ul>
<li>
<p><code>public</code> 修饰的声明在其初始化表达式或者函数体里面可以使用本包可见的任意类型，包括 <code>public</code> 修饰的类型和没有 <code>public</code> 修饰的类型。</p>
<!-- compile -->
<pre><code class="language-cangjie">// a.cj
package a
class C1 {}
func f1(a1: C1)
{
  return 0
}
public func f2(a1: Int8) // Ok.
{
  var v1 = C1()
  return 0
}
public let v1 = f1(C1()) // Ok.
public class C2 // Ok.
{
  var v2 = C1()
}
</code></pre>
</li>
<li>
<p><code>public</code> 修饰的顶层声明能使用匿名函数，或者任意顶层函数，包括 <code>public</code> 修饰的类型和没有 <code>public</code> 修饰的顶层函数。</p>
<!-- compile -toplevel-->
<pre><code class="language-cangjie">public var t1: () -&gt; Unit = { =&gt; } // Ok.
func f1(): Unit {}
public let t2 = f1 // Ok.

public func f2() // Ok.
{
  return f1
}
</code></pre>
</li>
<li>
<p>内置类型诸如 <code>Rune</code>、<code>Int64</code> 等也都默认是 <code>public</code> 的。</p>
<!-- compile -toplevel-->
<pre><code class="language-cangjie">var num = 5
public var t3 = num // Ok.
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包的导入"><a class="header" href="#包的导入">包的导入</a></h1>
<h2 id="使用-import-语句导入其它包中的声明或定义"><a class="header" href="#使用-import-语句导入其它包中的声明或定义">使用 <code>import</code> 语句导入其它包中的声明或定义</a></h2>
<p>在仓颉编程语言中，可以通过 <code>import fullPackageName.itemName</code> 的语法导入其他包中的一个顶层声明或定义，<code>fullPackageName</code> 为完整路径包名，<code>itemName</code> 为声明的名字。导入语句在源文件中的位置必须在包声明之后，其他声明或定义之前。例如：</p>
<pre><code class="language-cangjie">package a
import std.math.*
import package1.foo
import {package1.foo, package2.bar}
</code></pre>
<p>如果要导入的多个 <code>itemName</code> 同属于一个 <code>fullPackageName</code>，可以使用 <code>import fullPackageName.{itemName[, itemName]*}</code> 语法，例如：</p>
<pre><code class="language-cangjie">import package1.{foo, bar, fuzz}
</code></pre>
<p>这等价于：</p>
<pre><code class="language-cangjie">import package1.foo
import package1.bar
import package1.fuzz
</code></pre>
<p>除了通过 <code>import fullPackagename.itemName</code> 语法导入一个特定的顶层声明或定义外，还可以使用 <code>import packageName.*</code> 语法将 <code>packageName</code> 包中所有可见的顶层声明或定义全部导入。例如：</p>
<pre><code class="language-cangjie">import package1.*
import {package1.*, package2.*}
</code></pre>
<p>需要注意：</p>
<ul>
<li><code>import</code> 可以被 <code>private</code>、<code>internal</code>、<code>protected</code>、<code>public</code> 访问修饰符修饰。不写访问修饰符的 <code>import</code> 等价于 <code>private import</code>。</li>
<li>导入的成员的作用域级别低于当前包声明的成员。</li>
<li>当已导出的包的模块名或者包名被篡改，使其与导出时指定的模块名或包名不一致，在导入时会报错。</li>
<li>只允许导入当前文件可见的顶层声明或定义，导入不可见的声明或定义将会在导入处报错。</li>
<li>禁止通过 <code>import</code> 导入当前源文件所在包的声明或定义。</li>
<li>禁止包间的循环依赖导入，如果包之间存在循环依赖，编译器会报错。</li>
</ul>
<p>示例如下：</p>
<pre><code class="language-cangjie">// pkga/a.cj
package pkga    // Error, packages pkga pkgb are in circular dependencies.
import pkgb.*

class C {}
public struct R {}

// pkgb/b.cj
package pkgb

import pkga.*

// pkgc/c1.cj
package pkgc

import pkga.C // Error, 'C' is not accessible in package 'pkga'.
import pkga.R // OK, R is an external top-level declaration of package pkga.
import pkgc.f1 // Error, package 'pkgc' should not import itself.

public func f1() {}

// pkgc/c2.cj
package pkgc

func f2() {
    /* OK, the imported declaration is visible to all source files of the same package
     * and accessing import declaration by its name is supported.
     */
    R()

    // OK, accessing imported declaration by fully qualified name is supported.
    pkga.R()

    // OK, the declaration of current package can be accessed directly.
    f1()

    // OK, accessing declaration of current package by fully qualified name is supported.
    pkgc.f1()
}
</code></pre>
<p>在仓颉编程语言中，导入的声明或定义如果和当前包中的顶层声明或定义重名且不构成函数重载，则导入的声明和定义会被遮盖；导入的声明或定义如果和当前包中的顶层声明或定义重名且构成函数重载，函数调用时将会根据函数重载的规则进行函数决议。</p>
<pre><code class="language-cangjie">// pkga/a.cj
package pkga

public struct R {}            // R1
public func f(a: Int32) {}    // f1
public func f(a: Bool) {} // f2

// pkgb/b.cj
package pkgb
import pkga.*

func f(a: Int32) {}         // f3
struct R {}                 // R2

func bar() {
    R()     // OK, R2 shadows R1.
    f(1)    // OK, invoke f3 in current package.
    f(true) // OK, invoke f2 in the imported package
}
</code></pre>
<h2 id="隐式导入-core-包"><a class="header" href="#隐式导入-core-包">隐式导入 core 包</a></h2>
<p>诸如 <code>String</code>、<code>Range</code> 等类型能直接使用，并不是因为这些类型是内置类型，而是因为编译器会自动为源码隐式的导入 <code>core</code> 包中所有的 <code>public</code> 修饰的声明。</p>
<h2 id="使用-import-as-对导入的名字重命名"><a class="header" href="#使用-import-as-对导入的名字重命名">使用 <code>import as</code> 对导入的名字重命名</a></h2>
<p>不同包的名字空间是分隔的，因此在不同的包之间可能存在同名的顶层声明。在导入不同包的同名顶层声明时，我们支持使用 <code>import packageName.name as newName</code> 的方式进行重命名来避免冲突。没有名字冲突的情况下仍然可以通过 <code>import as</code> 来重命名导入的内容。<code>import as</code> 具有如下规则：</p>
<ul>
<li>
<p>使用 <code>import as</code> 对导入的声明进行重命名后，当前包只能使用重命名后的新名字，原名无法使用。</p>
</li>
<li>
<p>如果重命名后的名字与当前包顶层作用域的其它名字存在冲突，且这些名字对应的声明均为函数类型，则参与函数重载，否则报重定义的错误。</p>
</li>
<li>
<p>支持 <code>import pkg as newPkgName</code> 的形式对包名进行重命名，以解决不同模块中同名包的命名冲突问题。</p>
<pre><code class="language-cangjie">// a.cj
package p1
public func f1() {}

// d.cj
package p2
public func f3() {}

// b.cj
package p1
public func f2() {}

// c.cj
package pkgc
public func f1() {}

// main.cj
import p1 as A
import p1 as B
import p2.f3 as f  // OK
import pkgc.f1 as a
import pkgc.f1 as b // OK

func f(a: Int32) {}

main() {
    A.f1()  // OK, package name conflict is resolved by renaming package name.
    B.f2()  // OK, package name conflict is resolved by renaming package name.
    p1.f1() // Error, the original package name cannot be used.
    a()     // Ok.
    b()     // Ok.
    pkgc.f1()    // Error, the original name cannot be used.
}
</code></pre>
</li>
<li>
<p>如果没有对导入的存在冲突的名字进行重命名，在 <code>import</code> 语句处不报错；在使用处，会因为无法导入唯一的名字而报错。这种情况可以通过 <code>import as</code> 定义别名或者 <code>import fullPackageName</code> 导入包作为命名空间。</p>
<pre><code class="language-cangjie">// a.cj
package p1
public class C {}

// b.cj
package p2
public class C {}

// main1.cj
package pkga
import p1.C
import p2.C

main() {
    let _ = C() // Error
}

// main2.cj
package pkgb
import p1.C as C1
import p2.C as C2

main() {
    let _ = C1() // Ok
    let _ = C2() // Ok
}

// main3.cj
package pkgc
import p1
import p2

main() {
    let _ = p1.C() // Ok
    let _ = p2.C() // Ok
}
</code></pre>
</li>
</ul>
<h2 id="重导出一个导入的名字"><a class="header" href="#重导出一个导入的名字">重导出一个导入的名字</a></h2>
<p>在功能繁多的大型项目的开发过程中，这样的场景是非常常见的：包 <code>p2</code> 大量地使用从包 <code>p1</code> 中导入的声明，当包 <code>p3</code> 导入包 <code>p2</code> 并使用其中的功能时，<code>p1</code> 中的声明同样需要对包 <code>p3</code> 可见。如果要求包 <code>p3</code> 自行导入 <code>p2</code> 中使用到的 <code>p1</code> 中的声明，这个过程将过于繁琐。因此希望能够在 <code>p2</code> 被导入时一并导入 <code>p2</code> 使用到的 <code>p1</code> 中的声明。</p>
<p>在仓颉编程语言中，<code>import</code> 可以被 <code>private</code>、<code>internal</code>、<code>protected</code>、<code>public</code> 访问修饰符修饰。其中，被 <code>public</code>、<code>protected</code> 或者 <code>internal</code> 修饰的 <code>import</code> 可以把导入的成员重导出（如果这些导入的成员没有因为名称冲突或者被遮盖导致在本包中不可用）。其它包可以根据可见性直接导入并使用本包中用重导出的内容，无需从原包中导入这些内容。</p>
<ul>
<li><code>private import</code> 表示导入的内容仅当前文件内可访问，<code>private</code> 是 <code>import</code> 的默认修饰符，不写访问修饰符的 <code>import</code> 等价于 <code>private import</code>。</li>
<li><code>internal import</code> 表示导入的内容在当前包及其子包（包括子包的子包）均可访问。非当前包访问需要显式 <code>import</code>。</li>
<li><code>protected import</code> 表示导入的内容在当前 module 内都可访问。非当前包访问需要显式 <code>import</code>。</li>
<li><code>public import</code> 表示导入的内容外部都可访问。非当前包访问需要显式 <code>import</code>。</li>
</ul>
<p>在下面的例子中，<code>b</code> 是 <code>a</code> 的子包，在 <code>a</code> 中通过 <code>public import</code> 重导出了 <code>b</code> 中定义的函数 <code>f</code>。</p>
<pre><code class="language-cangjie">package a

public let x = 0
public import a.b.f
</code></pre>
<pre><code class="language-cangjie">internal package a.b

public func f() { 0 }
</code></pre>
<pre><code class="language-cangjie">import a.f  // Ok
let _ = f() // Ok
</code></pre>
<p>需要注意的是，包不可以被重导出：如果被 <code>import</code> 导入的是包，那么该 <code>import</code> 不允许被 <code>public</code>、<code>protected</code> 或者 <code>internal</code> 修饰。</p>
<pre><code class="language-cangjie">public import a.b // Error, cannot re-export package
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="程序入口"><a class="header" href="#程序入口">程序入口</a></h1>
<p>仓颉程序入口为 <code>main</code>，源文件根目录下的包的顶层最多只能有一个 <code>main</code>。</p>
<p>如果模块采用生成可执行文件的编译方式，编译器只在源文件根目录下的顶层查找 <code>main</code>。如果没有找到，编译器将会报错；如果找到 <code>main</code>，编译器会进一步对其参数和返回值类型进行检查。需要注意的是，<code>main</code> 不可被访问修饰符修饰，当一个包被导入时，包中定义的 <code>main</code> 不会被导入。</p>
<p>作为程序入口的 <code>main</code> 可以没有参数或参数类型为 <code>Array&lt;String&gt;</code>，返回值类型为 <code>Unit</code> 或整数类型。</p>
<p>没有参数的 <code>main</code>：</p>
<!-- run -->
<pre><code class="language-cangjie">// main.cj
main(): Int64 { // Ok.
    return 0
}
</code></pre>
<p>参数类型为 <code>Array&lt;String&gt;</code> 的 <code>main</code>：</p>
<pre><code class="language-cangjie">// main.cj
main(args: Array&lt;String&gt;): Unit { // Ok.
    for (arg in args) {
        println(arg)
    }
}
</code></pre>
<p>使用 <code>cjc main.cj</code> 编译完成后，通过命令行执行：<code>./main Hello, World</code>，将会得到如下输出：</p>
<pre><code class="language-text">Hello,
World
</code></pre>
<p>以下是一些错误示例：</p>
<pre><code class="language-cangjie">// main.cj
main(): String { // Error, return type of 'main' is not 'Integer' or 'Unit'.
    return &quot;&quot;
}
</code></pre>
<pre><code class="language-cangjie">// main.cj
main(args: Array&lt;Int8&gt;): Int64 { // Error, 'main' cannot be defined with parameter whose type is not Array&lt;String&gt;.
    return 0
}
</code></pre>
<pre><code class="language-cangjie">// main.cj
// Error, multiple 'main's are found in source files.
main(args: Array&lt;String&gt;): Int32 {
    return 0
}

main(): Int8 {
    return 0
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="定义异常"><a class="header" href="#定义异常">定义异常</a></h1>
<p>异常是一类特殊的可以被程序员捕获并处理的错误，是程序执行时出现的一系列不正常行为的统称，例如，数组越界、除零错误、计算溢出、非法输入等。为了保证系统的正确性和健壮性，很多软件系统中都包含大量的代码用于错误检测和错误处理。</p>
<p>异常不属于程序的正常功能，一旦发生异常，要求程序必须立即处理，即将程序的控制权从正常功能的执行处转移至处理异常的部分。仓颉编程语言提供异常处理机制用于处理程序运行时可能出现的各种异常情况。</p>
<p>在仓颉中，异常类有 <code>Error</code> 和 <code>Exception</code> ：</p>
<ul>
<li><code>Error</code> 类描述仓颉语言运行时，系统内部错误和资源耗尽错误，应用程序不应该抛出这种类型错误，如果出现内部错误，只能通知给用户，尽量安全终止程序。</li>
<li><code>Exception</code> 类描述的是程序运行时的逻辑错误或者 IO 错误导致的异常，例如数组越界或者试图打开一个不存在的文件等，这类异常需要在程序中捕获处理。</li>
</ul>
<p>用户不可以通过继承仓颉语言内置的 Error 或其子类类来自定义异常，但是可以继承内置的 Exception 或其子类来自定义异常，例如</p>
<pre><code class="language-cangjie">open class FatherException &lt;: Exception {
    public open func printException() {
        print(&quot;I am a FatherException&quot;)
    }
}

class ChildException &lt;: FatherException {
    public override func printException() {
        print(&quot;I am a ChildException&quot;)
    }
}
</code></pre>
<p>下面列表展示了 <code>Exception</code> 的主要函数及其说明</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">函数种类</th><th style="text-align: left">函数及说明</th></tr></thead><tbody>
<tr><td style="text-align: left">构造函数</td><td style="text-align: left"><code>init()</code> 默认构造函数。</td></tr>
<tr><td style="text-align: left">构造函数</td><td style="text-align: left"><code>init(message: String)</code>  可以设置异常消息的构造函数。</td></tr>
<tr><td style="text-align: left">成员属性</td><td style="text-align: left"><code>open prop message: String</code>  返回发生异常的详细信息。该消息在异常类构造函数中初始化，默认空字符串。</td></tr>
<tr><td style="text-align: left">成员函数</td><td style="text-align: left"><code>open func toString(): String</code>  返回异常类型名以及异常的详细信息，其中，异常的详细信息会默认调用 message。</td></tr>
<tr><td style="text-align: left">成员函数</td><td style="text-align: left"><code>func printStackTrace(): Unit</code> 打印堆栈信息至标准错误流。</td></tr>
</tbody></table>
</div>
<p>下面列表展示了 <code>Error</code> 的主要函数及其说明</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">函数种类</th><th style="text-align: left">函数及说明</th></tr></thead><tbody>
<tr><td style="text-align: left">成员属性</td><td style="text-align: left"><code>open prop message: String</code>  返回发生错误的详细信息。该消息在错误发生时，内部初始化，默认空字符串。</td></tr>
<tr><td style="text-align: left">成员函数</td><td style="text-align: left"><code>open func toString(): String</code>  返回错误类型名以及错误的详细信息，其中，错误的详细信息会默认调用 message。</td></tr>
<tr><td style="text-align: left">成员函数</td><td style="text-align: left"><code>func printStackTrace(): Unit</code> 打印堆栈信息至标准错误流。</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="throw-和处理异常"><a class="header" href="#throw-和处理异常">throw 和处理异常</a></h1>
<p>上文介绍了如何自定义异常，接下来我们学习如何抛出和处理异常。</p>
<ul>
<li>由于异常是 <code>class</code> 类型，只需要按 class 对象的构建方式去创建异常即可。如表达式 <code>FatherException()</code> 即创建了一个类型为 <code>FatherException</code> 的异常。</li>
<li>仓颉语言提供 <code>throw</code> 关键字，用于抛出异常。用 <code>throw</code> 来抛出异常时，<code>throw</code> 之后的表达式必须是 <code>Exception</code> 的子类型（同为异常的 <code>Error</code> 不可以手动 <code>throw</code> ），如 <code>throw ArithmeticException(&quot;I am an Exception!&quot;)</code> （被执行到时）会抛出一个算术运算异常。</li>
<li><code>throw</code> 关键字抛出的异常需要被捕获处理。若异常没有被捕获，则由系统调用默认的异常处理函数。</li>
</ul>
<p>异常处理由 <code>try</code> 表达式完成，可分为：</p>
<ul>
<li>不涉及资源自动管理的普通 try 表达式；</li>
<li>会进行资源自动管理 try-with-resources 表达式。</li>
</ul>
<h2 id="普通-try-表达式"><a class="header" href="#普通-try-表达式">普通 try 表达式</a></h2>
<p>普通 try 表达式包括三个部分：try 块，catch 块和 finally 块。</p>
<ul>
<li>
<p>try 块，以关键字 <code>try</code> 开始，后面紧跟一个由表达式与声明组成的块（用一对花括号括起来，定义了新的局部作用域，可以包含任意表达式和声明，后简称“块”），try 后面的块内可以抛出异常，并被紧随的 catch 块所捕获并处理（如果不存在 catch 块或未被捕获，则在执行完 finally 块后，该异常继续被抛出）。</p>
</li>
<li>
<p>catch 块，一个普通 try 表达式可以包含零个或多个 catch 块（当没有 catch 块时必须有 finally 块）。每个 catch 块以关键字 <code>catch</code> 开头，后跟一条 <code>catchPattern</code> 和一个块，<code>catchPattern</code> 通过模式匹配的方式匹配待捕获的异常。一旦匹配成功，则交由其后跟随的块进行处理，并且忽略它后面的其他 catch 块。当某个 catch 块可捕获的异常类型均可被定义在它前面的某个 catch 块所捕获时，会在此 catch 块处报“catch 块不可达”的 warning。</p>
</li>
<li>
<p>finally 块，以关键字 <code>finally</code> 开始，后面紧跟一个块。原则上，finally 块中主要实现一些“善后”的工作，如释放资源等，且要尽量避免在 finally 块中再抛异常。并且无论异常是否发生（即无论 try 块中是否抛出异常），finally 块内的内容都会被执行（若异常未被处理，执行完 finally 块后，继续向外抛出异常）。一个 try 表达式在包含 catch 块时可以不包含 finally 块，否则必须包含 finally 块。</p>
</li>
</ul>
<p><code>try</code> 后面紧跟的块以及每个 <code>catch</code> 块的的作用域互相独立。</p>
<p>下面是一个只有 try 块和 catch 块的简单示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    try {
        throw NegativeArraySizeException(&quot;I am an Exception!&quot;)
    } catch (e: NegativeArraySizeException) {
        println(e)
        println(&quot;NegativeArraySizeException is caught!&quot;)
    }
    println(&quot;This will also be printed!&quot;)
}
</code></pre>
<p>执行结果为</p>
<pre><code class="language-text">NegativeArraySizeException: I am an Exception!
NegativeArraySizeException is caught!
This will also be printed!
</code></pre>
<p><code>catchPattern</code> 中引入的变量作用域级别与 <code>catch</code> 后面的块中变量作用域级别相同，在 catch 块中再次引入相同名字会触发重定义错误。例如：</p>
<pre><code class="language-cangjie">main() {
    try {
        throw NegativeArraySizeException(&quot;I am an Exception!&quot;)
    } catch (e: NegativeArraySizeException) {
        println(e)
        let e = 0 // Error, redefinition
        println(e)
        println(&quot;NegativeArraySizeException is caught!&quot;)
    }
    println(&quot;This will also be printed!&quot;)
}
</code></pre>
<p>下面是带有 finally 块的 try 表达式的简单示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    try {
        throw NegativeArraySizeException(&quot;NegativeArraySizeException&quot;)
    } catch (e: NegativeArraySizeException) {
        println(&quot;Exception info: ${e}.&quot;)
    } finally {
        println(&quot;The finally block is executed.&quot;)
    }
}
</code></pre>
<p>执行结果为</p>
<pre><code class="language-text">Exception info: NegativeArraySizeException: NegativeArraySizeException.
The finally block is executed.
</code></pre>
<p>try 表达式可以出现在任何允许使用表达式的地方。try 表达式的类型的确定方式，与 <code>if</code>、<code>match</code> 表达式等多分支语法结构的类型的确定方式相似，为 finally 分支除外的所有分支的类型的最小公共父类型。例如下面代码中的 try 表达式和变量 <code>x</code> 的类型均为 E 和 D 的最小公共父类型 D；finally 分支中的 <code>C()</code> 并不参与公共父类型的计算（若参与，则最小公共父类型会变为 <code>C</code>）。</p>
<p>另外，当 <code>try</code> 表达式的值没有被使用时，其类型为 <code>Unit</code>，不要求各分支的类型有最小公共父类型。</p>
<!-- compile -->
<pre><code class="language-cangjie">open class C { }
open class D &lt;: C { }
class E &lt;: D { }
main () {
    let x = try {
        E()
    } catch (e: Exception) {
        D()
    } finally {
        C()
    }
    0
}
</code></pre>
<h2 id="try-with-resources-表达式"><a class="header" href="#try-with-resources-表达式">Try-with-resources 表达式</a></h2>
<p>Try-with-resources 表达式主要是为了自动释放非内存资源。不同于普通 try 表达式，try-with-resources 表达式中的 catch 块和 finally 块均是可选的，并且 try 关键字其后的块之间可以插入一个或者多个 <code>ResourceSpecification</code> 用来申请一系列的资源（<code>ResourceSpecification</code> 并不会影响整个 try 表达式的类型）。这里所讲的资源对应到语言层面即指对象，因此 <code>ResourceSpecification</code> 其实就是实例化一系列的对象（多个实例化之间使用“,”分隔）。使用 try-with-resources 表达式的例子如下所示：</p>
<!-- verify -->
<pre><code class="language-cangjie">class R &lt;: Resource {
    public func isClosed(): Bool {
        true
    }
    public func close(): Unit {
        print(&quot;R is closed&quot;)
    }
}

main() {
    try (r = R()) {
        println(&quot;Get the resource&quot;)
    }
}
</code></pre>
<p>程序输出结果为：</p>
<pre><code class="language-text">Get the resource
</code></pre>
<p><code>try</code> 关键字和 <code>{}</code> 之间引入的名字，其作用域与 <code>{}</code> 中引入的变量作用域级别相同，在 <code>{}</code> 中再次引入相同名字会触发重定义错误。</p>
<pre><code class="language-cangjie">class R &lt;: Resource {
    public func isClosed(): Bool {
        true
    }
    public func close(): Unit {
        print(&quot;R is closed&quot;)
    }
}

main() {
    try (r = R()) {
        println(&quot;Get the resource&quot;)
        let r = 0 // Error, redefinition
        println(r)
    }
}
</code></pre>
<p>Try-with-resources 表达式中的 <code>ResourceSpecification</code> 的类型必须实现 Resource 接口，并且尽量保证其中的 <code>isClosed</code> 函数不要再抛异常：</p>
<pre><code class="language-cangjie">interface Resource {
    func isClosed(): Bool
    func close(): Unit
}
</code></pre>
<p>需要说明的是，try-with-resources 表达式中一般没有必要再包含 catch 块和 finally 块，也不建议用户再手动释放资源。因为 try 块执行的过程中无论是否发生异常，所有申请的资源都会被自动释放，并且执行过程中产生的异常均会被向外抛出。但是，如果需要显式地捕获 try 块或资源申请和释放过程中可能抛出的异常并处理，仍可在 try-with-resources 表达式中包含 catch 块和 finally 块：</p>
<!-- verify -->
<pre><code class="language-cangjie">class R &lt;: Resource {
    public func isClosed(): Bool {
        true
    }
    public func close(): Unit {
        print(&quot;R is closed&quot;)
    }
}

main() {
    try (r = R()) {
        println(&quot;Get the resource&quot;)
    } catch (e: Exception) {
        println(&quot;Exception happened when executing the try-with-resources expression&quot;)
    } finally {
        println(&quot;End of the try-with-resources expression&quot;)
    }
}
</code></pre>
<p>程序输出结果如下：</p>
<pre><code class="language-text">Get the resource
End of the try-with-resources expression
</code></pre>
<p>Try-with-resources 表达式的类型是 <code>Unit</code>。</p>
<h2 id="catchpattern-进阶介绍"><a class="header" href="#catchpattern-进阶介绍">CatchPattern 进阶介绍</a></h2>
<p>大多数时候，我们只想捕获某一类型和其子类型的异常，这时候我们使用 CatchPattern 的<strong>类型模式</strong>来处理；但有时也需要所有异常做统一处理（如此处不该出现异常，出现了就统一报错），这时可以使用 CatchPattern 的<strong>通配符模式</strong>来处理。</p>
<p>类型模式在语法上有两种格式：</p>
<ul>
<li><code>Identifier: ExceptionClass</code>。此格式可以捕获类型为 <code>ExceptionClass</code> 及其子类的异常，并将捕获到的异常实例转换成 <code>ExceptionClass</code>，然后与 <code>Identifier</code> 定义的变量进行绑定，接着就可以在 catch 块中通过 Identifier 定义的变量访问捕获到的异常实例。</li>
<li><code>Identifier: ExceptionClass_1 | ExceptionClass_2 | ... | ExceptionClass_n</code>。此格式可以通过连接符 <code>|</code> 将多个异常类进行拼接，连接符 <code>|</code> 表示“或”的关系：可以捕获类型为 <code>ExceptionClass_1</code> 及其子类的异常，或者捕获类型为 <code>ExceptionClass_2</code> 及其子类的异常，依次类推，或捕获类型为 <code>ExceptionClass_n</code> 及其子类的异常（假设 n 大于 1）。当待捕获异常的类型属于上述“或”关系中的任一类型或其子类型时，此异常将被捕获。但是由于无法静态地确定被捕获异常的类型，所以被捕获异常的类型会被转换成由 <code>|</code> 连接的所有类型的最小公共父类，并将异常实例与 <code>Identifier</code> 定义的变量进行绑定。因此在此类模式下，catch 块内只能通过 <code>Identifier</code> 定义的变量访问 <code>ExceptionClass_i（1 &lt;= i &lt;= n）</code> 的最小公共父类中的成员变量和成员函数。当然，也可以使用通配符代替类型模式中的 <code>Identifier</code>，差别仅在于通配符不会进行绑定操作。</li>
</ul>
<p>示例如下：</p>
<!-- verify -->
<pre><code class="language-cangjie">main(): Int64 {
    try {
        throw IllegalArgumentException(&quot;This is an Exception!&quot;)
    } catch (e: OverflowException) {
        println(e.message)
        println(&quot;OverflowException is caught!&quot;)
    } catch (e: IllegalArgumentException | NegativeArraySizeException) {
        println(e.message)
        println(&quot;IllegalArgumentException or NegativeArraySizeException is caught!&quot;)
    } finally {
        println(&quot;finally is executed!&quot;)
    }
    return 0
}
</code></pre>
<p>执行结果：</p>
<pre><code class="language-text">This is an Exception!
IllegalArgumentException or NegativeArraySizeException is caught!
finally is executed!
</code></pre>
<p>关于“被捕获异常的类型是由 <code>|</code> 连接的所有类型的最小公共父类”的示例：</p>
<!-- run -->
<pre><code class="language-cangjie">open class Father &lt;: Exception {
    var father: Int32 = 0
}

class ChildOne &lt;: Father {
    var childOne: Int32 = 1
}

class ChildTwo &lt;: Father {
    var childTwo: Int32 = 2
}

main() {
    try {
        throw ChildOne()
    } catch (e: ChildTwo | ChildOne) {
        println(&quot;ChildTwo or ChildOne?&quot;)
    }
}
</code></pre>
<p>执行结果：</p>
<pre><code class="language-text">ChildTwo or ChildOne?
</code></pre>
<p><strong>通配符模式</strong>的语法是 <code>_</code>，它可以捕获同级 try 块内抛出的任意类型的异常，等价于类型模式中的 <code>e: Exception</code>，即捕获 Exception 子类所定义的异常。示例：</p>
<pre><code class="language-cangjie">// Catch with wildcardPattern.
try {
    throw OverflowException()
} catch (_) {
    println(&quot;catch an exception!&quot;)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常见运行时异常"><a class="header" href="#常见运行时异常">常见运行时异常</a></h1>
<p>在仓颉语言中内置了最常见的异常类，开发人员可以直接使用。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">异常</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>ConcurrentModificationException</code></td><td style="text-align: left">并发修改产生的异常</td></tr>
<tr><td style="text-align: left"><code>IllegalArgumentException</code></td><td style="text-align: left">传递不合法或不正确参数时抛出的异常</td></tr>
<tr><td style="text-align: left"><code>NegativeArraySizeException</code></td><td style="text-align: left">创建大小为负的数组时抛出的异常</td></tr>
<tr><td style="text-align: left"><code>NoneValueException</code></td><td style="text-align: left">值不存在时产生的异常，如 Map 中不存在要查找的 key</td></tr>
<tr><td style="text-align: left"><code>OverflowException</code></td><td style="text-align: left">算术运算溢出异常</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="使用-option"><a class="header" href="#使用-option">使用 Option</a></h1>
<p>在<a href="source_zh_cn/error_handle/../enum_and_pattern_match/option_type.html">Option 类型</a>中我们介绍了 Option 类型的定义，因为 Option 类型可以同时表示有值和无值两种状态，而无值在某些情况下也可以理解为一种错误，所以 Option 类型也可以用作错误处理。</p>
<p>例如，在下例中，如果函数 <code>getOrThrow</code> 的参数值等于 <code>Some(v)</code> 则将 <code>v</code> 的值返回，如果参数值等于 <code>None</code> 则抛出异常。</p>
<pre><code class="language-cangjie">func getOrThrow(a: ?Int64) {
    match (a) {
        case Some(v) =&gt; v
        case None =&gt; throw NoneValueException()
    }
}
</code></pre>
<p>因为 <code>Option</code> 是一种非常常用的类型，所以仓颉为其提供了多种解构方式，以方便 <code>Option</code> 类型的使用，具体包括：模式匹配、<code>getOrThrow</code> 函数、<code>coalescing</code> 操作符（<code>??</code>），以及问号操作符（<code>?</code>）。下面将对这些方式逐一介绍。</p>
<ul>
<li>
<p>模式匹配：因为 Option 类型是一种 enum 类型，所以可以使用上文提到的 enum 的模式匹配来实现对 <code>Option</code> 值的解构。例如，下例中函数 <code>getString</code> 接受一个 <code>?Int64</code> 类型的参数，当参数是 <code>Some</code> 值时，返回其中数值的字符串表示，当参数是 <code>None</code> 值时，返回字符串 <code>&quot;none&quot;</code>。</p>
<!-- verify -->
<pre><code class="language-cangjie">func getString(p: ?Int64): String{
    match (p) {
        case Some(x) =&gt; &quot;${x}&quot;
        case None =&gt; &quot;none&quot;
    }
}
main() {
    let a = Some(1)
    let b: ?Int64 = None
    let r1 = getString(a)
    let r2 = getString(b)
    println(r1)
    println(r2)
}
</code></pre>
<p>上述代码的执行结果为：</p>
<pre><code class="language-text">1
none
</code></pre>
</li>
<li>
<p><code>coalescing</code> 操作符（<code>??</code>）：对于 <code>?T</code> 类型的表达式 <code>e1</code>，如果希望 <code>e1</code> 的值等于 <code>None</code> 时同样返回一个 <code>T</code> 类型的值 <code>e2</code>，可以使用 <code>??</code> 操作符。对于表达式 <code>e1 ?? e2</code>，当 <code>e1</code> 的值等于 <code>Some(v)</code> 时返回 <code>v</code> 的值，否则返回 <code>e2</code> 的值。举例如下：</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    let a = Some(1)
    let b: ?Int64 = None
    let r1: Int64 = a ?? 0
    let r2: Int64 = b ?? 0
    println(r1)
    println(r2)
}
</code></pre>
<p>上述代码的执行结果为：</p>
<pre><code class="language-text">1
0
</code></pre>
</li>
<li>
<p>问号操作符（<code>?</code>）：<code>?</code> 需要和 <code>.</code> 或 <code>()</code> 或 <code>[]</code> 或 <code>{}</code>（特指尾随 lambda 调用的场景）一起使用，用以实现 <code>Option</code> 类型对 <code>.</code>，<code>()</code>，<code>[]</code> 和 <code>{}</code> 的支持。以 <code>.</code> 为例（<code>()</code>，<code>[]</code> 和 <code>{}</code>同理），对于 <code>?T1</code> 类型的表达式 <code>e</code>，当 <code>e</code> 的值等于 <code>Some(v)</code> 时，<code>e?.b</code> 的值等于 <code>Option&lt;T2&gt;.Some(v.b)</code>，否则 <code>e?.b</code> 的值等于 <code>Option&lt;T2&gt;.None</code>，其中 <code>T2</code> 是 <code>v.b</code> 的类型。举例如下：</p>
<pre><code class="language-cangjie">struct R {
    public var a: Int64
    public init(a: Int64) {
        this.a = a
    }
}

let r = R(100)
let x = Some(r)
let y = Option&lt;R&gt;.None
let r1 = x?.a   // r1 = Option&lt;Int64&gt;.Some(100)
let r2 = y?.a   // r2 = Option&lt;Int64&gt;.None
</code></pre>
<p>问号操作符（<code>?</code>）支持多层访问，以 <code>a?.b.c?.d</code> 为例（<code>()</code>，<code>[]</code> 和 <code>{}</code>同理）。表达式 <code>a</code> 的类型需要是某个 <code>Option&lt;T1&gt;</code> 且 <code>T1</code> 包含实例成员 <code>b</code>，<code>b</code> 的类型中包含实例成员变量 <code>c</code> 且 <code>c</code> 的类型是某个 <code>Option&lt;T2&gt;</code>，<code>T2</code> 包含实例成员 <code>d</code>；表达式 <code>a?.b.c?.d</code> 的类型为 <code>Option&lt;T3&gt;</code>，其中 <code>T3</code> 是 <code>T2</code> 的实例成员 <code>d</code> 的类型；当 <code>a</code> 的值等于 <code>Some(va)</code> 且 <code>va.b.c</code> 的值等于 <code>Some(vc)</code> 时，<code>a?.b.c?.d</code> 的值等于 <code>Option&lt;T3&gt;.Some(vc.d)</code>；当 <code>a</code> 的值等于 <code>Some(va)</code> 且 <code>va.b.c</code> 的值等于 <code>None</code> 时，<code>a?.b.c?.d</code> 的值等于 <code>Option&lt;T3&gt;.None</code>（<code>d</code> 不会被求值）；当 <code>a</code> 的值等于 <code>None</code> 时，<code>a?.b.c?.d</code> 的值等于 <code>Option&lt;T3&gt;.None</code>（<code>b</code>，<code>c</code> 和 <code>d</code> 都不会被求值）。</p>
<pre><code class="language-cangjie">struct A {
    let b: B = B()
}

struct B {
    let c: Option&lt;C&gt; = C()
    let c1: Option&lt;C&gt; = Option&lt;C&gt;.None
}

struct C {
    let d: Int64 = 100
}

let a = Some(A())
let a1 = a?.b.c?.d // a1 = Option&lt;Int64&gt;.Some(100)
let a2 = a?.b.c1?.d // a2 = Option&lt;Int64&gt;.None
</code></pre>
</li>
<li>
<p><code>getOrThrow</code> 函数：对于 <code>?T</code> 类型的表达式 <code>e</code>，可以通过调用 <code>getOrThrow</code> 函数实现解构。当 <code>e</code> 的值等于 <code>Some(v)</code> 时，<code>getOrThrow()</code> 返回 <code>v</code> 的值，否则抛出异常。举例如下：</p>
<!-- verify -->
<pre><code class="language-cangjie">main() {
    let a = Some(1)
    let b: ?Int64 = None
    let r1 = a.getOrThrow()
    println(r1)
    try {
        let r2 = b.getOrThrow()
    } catch (e: NoneValueException) {
        println(&quot;b is None&quot;)
    }
}
</code></pre>
<p>上述代码的执行结果为：</p>
<pre><code class="language-text">1
b is None
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="并发概述"><a class="header" href="#并发概述">并发概述</a></h1>
<p>并发编程是现代编程语言中不可或缺的特性，仓颉编程语言提供<em>抢占式的线程模型</em>作为并发编程机制。在谈及编程语言和线程时，线程其实可以细化为两种不同概念，<strong>语言线程</strong>和 <strong>native 线程</strong>。</p>
<ul>
<li>前者是编程语言中并发模型的基本执行单位，语言线程的目的是屏蔽底层实现细节。例如，仓颉编程语言希望给开发者提供一个友好、高效、统一的并发编程界面，让开发者无需关心操作系统线程、用户态线程等差异，因此提供<strong>仓颉线程</strong>的概念。开发者在大多数情况下只需面向仓颉线程编写并发代码。</li>
<li>后者指语言实现中所使用到的线程（一般是操作系统线程），他们作为语言线程的具体实现载体。不同编程语言会以不同的方式实现语言线程。例如，一些编程语言直接通过操作系统调用来创建线程，这意味着每个语言线程对应一个 native 线程，这种实现方案一般被称之为 <code>1:1</code> 线程模型。此外，另有一些编程语言提供特殊的线程实现，他们允许多个语言线程在多个 native 线程上切换执行，这种也被称为 <code>M:N</code> 线程模型，即 M 个语言线程在 N 个 native 线程上调度执行，其中 M 和 N 不一定相等。当前，仓颉语言的实现同样采用 <code>M:N</code> 线程模型；因此，仓颉线程本质上是一种用户态的轻量级线程，支持抢占且相比操作系统线程更轻量化。</li>
</ul>
<p>仓颉线程本质上是用户态的轻量级线程，每个仓颉线程都受到底层 native 线程的调度执行，并且多个仓颉线程可以由一个 native 线程执行。每个 native 线程会不断地选择一个就绪的仓颉线程完成执行，如果仓颉线程在执行过程中发生阻塞（例如等待互斥锁的释放），那么 native 线程会将当前的仓颉线程挂起，并继续选择下一个就绪的仓颉线程。发生阻塞的仓颉线程在重新就绪后会继续被 native 线程调度执行。</p>
<p>在大多数情况下，开发者只需要面向仓颉线程进行并发编程而不需要考虑这些细节。但在进行跨语言编程时，开发者需要谨慎调用可能发生阻塞的 foreign 函数，例如 IO 相关的操作系统调用等。例如，下列示例代码中的新线程会调用 foreign 函数 <code>socket_read</code>。在程序运行过程中，某一 native 线程将调度并执行该仓颉线程，在进入到 foreign 函数中后，系统调用会直接阻塞当前 native 线程直到函数执行完成。native 线程在阻塞期间将无法调度其他仓颉线程来执行，这会降低程序执行的吞吐量。</p>
<pre><code class="language-cangjie">foreign socket_read(sock: Int64): CPointer&lt;Int8&gt;

let fut = spawn {
    let sock: Int64 = ...
    let ptr = socket_read(sock)
}
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p>本文档在没有歧义的情况下将直接以<em>线程</em>简化对<em>仓颉线程</em>的指代。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="创建线程"><a class="header" href="#创建线程">创建线程</a></h1>
<p>当开发者希望并发执行某一段代码时，只需创建一个仓颉线程即可。要创建一个新的仓颉线程，可以使用关键字 <code>spawn</code> 并传递一个无形参的 <code>lambda</code> 表达式，该 <code>lambda</code> 表达式即为在新线程中执行的代码。</p>
<p>下方示例代码中，主线程和新线程均会尝试打印一些文本：</p>
<pre><code class="language-cangjie">import std.sync.*
import std.time.*

main(): Int64 {
    spawn { =&gt;
        println(&quot;New thread before sleeping&quot;)
        sleep(100 * Duration.millisecond) // sleep for 100ms.
        println(&quot;New thread after sleeping&quot;)
    }

    println(&quot;Main thread&quot;)

    return 0
}
</code></pre>
<p>在上面的例子中，新线程会在主线程结束时一起停止，无论这个新线程是否已完成运行。上方示例的输出每次可能略有不同，有可能会输出类似如下的内容：</p>
<pre><code class="language-text">New thread before sleeping
Main thread
</code></pre>
<p><code>sleep()</code> 函数会让当前线程睡眠指定的时长，之后再恢复执行，其时间由指定的 Duration 类型决定，详细介绍请参考<a href="source_zh_cn/concurrency/./sleep.html">线程睡眠指定时长</a>章节。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="访问线程"><a class="header" href="#访问线程">访问线程</a></h1>
<h2 id="使用-futuret-等待线程结束并获取返回值"><a class="header" href="#使用-futuret-等待线程结束并获取返回值">使用 <code>Future&lt;T&gt;</code> 等待线程结束并获取返回值</a></h2>
<p>在上面的例子中，新创建的线程会由于主线程结束而提前结束，在缺乏顺序保证的情况下，甚至可能会出现新创建的线程还来不及得到执行就退出了。我们可以通过 <code>spawn</code> 表达式的返回值，来等待线程执行结束。</p>
<p><code>spawn</code> 表达式的返回类型是 <code>Future&lt;T&gt;</code>，其中 <code>T</code> 是类型变元，其类型与 lambda 表达式的返回类型一致。当我们调用 <code>Future&lt;T&gt;</code> 的 <code>get()</code> 成员函数时，它将等待它的线程执行完成。</p>
<p><code>Future&lt;T&gt;</code> 的原型声明如下：</p>
<pre><code class="language-cangjie">public class Future&lt;T&gt; {
    // Blocking the current thread, waiting for the result of the thread corresponding to the current Future object.
    // If an exception occurs in the corresponding thread, the method will throw the exception.
    public func get(): T

    // Blocking the current thread, waiting for the result of the thread corresponding to the current Future object.
    // If the corresponding thread has not completed execution within ns nanoseconds, the method will return a Option&lt;T&gt;.None.
    // If `ns` &lt;= 0, its behavior is the same as `get()`.
    public func get(ns: Int64): Option&lt;T&gt;

    // Non-blocking method that immediately returns Option&lt;T&gt;.None if thread has not finished execution.
    // Returns the computed result otherwise.
    // If an exception occurs in the corresponding thread, the method will throw the exception.
    public func tryGet(): Option&lt;T&gt;
}
</code></pre>
<p>下方示例代码演示了如何使用 <code>Future&lt;T&gt;</code> 在 <code>main</code> 中等待新创建的线程执行完成：</p>
<pre><code class="language-cangjie">import std.sync.*
import std.time.*

main(): Int64 {
    let fut: Future&lt;Unit&gt; = spawn { =&gt;
        println(&quot;New thread before sleeping&quot;)
        sleep(100 * Duration.millisecond) // sleep for 100ms.
        println(&quot;New thread after sleeping&quot;)
    }

    println(&quot;Main thread&quot;)

    fut.get() // wait for the thread to finish.
    return 0
}
</code></pre>
<p>调用 <code>Future&lt;T&gt;</code> 实例的 <code>get()</code> 会阻塞当前运行的线程，直到 <code>Future&lt;T&gt;</code> 实例所代表的线程运行结束。因此，上方示例有可能会输出类似如下内容：</p>
<pre><code class="language-text">New thread before sleeping
Main thread
New thread after sleeping
</code></pre>
<p>主线程在完成打印后会因为调用 <code>get()</code> 而等待新创建的线程执行结束。但主线程和新线程的打印顺序具有不确定性。</p>
<p>但是，如果我们将 <code>fut.get()</code> 移动到主线程的打印之前，会出现什么结果呢？就像下方这样：</p>
<!-- verify -->
<pre><code class="language-cangjie">import std.sync.*
import std.time.*

main(): Int64 {
    let fut: Future&lt;Unit&gt; = spawn { =&gt;
        println(&quot;New thread before sleeping&quot;)
        sleep(100 * Duration.millisecond) // sleep for 100ms.
        println(&quot;New thread after sleeping&quot;)
    }

    fut.get() // wait for the thread to finish.

    println(&quot;Main thread&quot;)
    return 0
}
</code></pre>
<p>主线程将等待新创建的线程执行完成，然后再执行打印，因此程序的输出将变得确定，如下所示：</p>
<pre><code class="language-text">New thread before sleeping
New thread after sleeping
Main thread
</code></pre>
<p>可见，<code>get()</code> 的调用位置会影响线程是否能同时运行。</p>
<p><code>Future&lt;T&gt;</code> 除了可以用于阻塞等待线程执行结束以外，还可以获取线程执行的结果。现在，我们来看一下它提供的具体成员函数：</p>
<ul>
<li>
<p><code>get(): T</code>：阻塞等待线程执行结束，并返回执行结果，如果该线程已经结束，则直接返回执行结果。</p>
<p>示例代码如下：</p>
<!-- verify -->
<pre><code class="language-cangjie">import std.sync.*
import std.time.*

main(): Int64 {
    let fut: Future&lt;Int64&gt; = spawn {
        sleep(Duration.second) // sleep for 1s.
        return 1
    }

    try {
        // wait for the thread to finish, and get the result.
        let res: Int64 = fut.get()
        println(&quot;result = ${res}&quot;)
    } catch (_) {
        println(&quot;oops&quot;)
    }
    return 0
}
</code></pre>
<p>输出结果如下：</p>
<pre><code class="language-text">result = 1
</code></pre>
</li>
<li>
<p><code>get(ns: Int64): Option&lt;T&gt;</code>：阻塞等待该 <code>Future&lt;T&gt;</code> 所代表的线程执行结束，并返回执行结果，当到达超时时间 <code>ns</code> 时，如果该线程还没有执行结束，将会返回 <code>Option&lt;T&gt;.None</code>。如果 <code>ns &lt;= 0</code>,其行为与 <code>get()</code> 相同。</p>
<p>示例代码如下：</p>
<!-- verify -->
<pre><code class="language-cangjie">import std.sync.*
import std.time.*

main(): Int64 {
    let fut = spawn {
        sleep(Duration.second) // sleep for 1s.
        return 1
    }

    // wait for the thread to finish, but only for 1ms.
    let res: Option&lt;Int64&gt; = fut.get(1000 * 1000)
    match (res) {
        case Some(val) =&gt; println(&quot;result = ${val}&quot;)
        case None =&gt; println(&quot;oops&quot;)
    }
    return 0
}
</code></pre>
<p>输出结果如下：</p>
<pre><code class="language-text">oops
</code></pre>
</li>
</ul>
<h2 id="访问线程属性"><a class="header" href="#访问线程属性">访问线程属性</a></h2>
<p>每个 <code>Future&lt;T&gt;</code> 对象都有一个对应的仓颉线程，以 <code>Thread</code> 对象为表示。<code>Thread</code> 类主要被用于访问线程的属性信息，例如线程标识等。需要注意的是，<code>Thread</code> 无法直接被实例化构造对象，仅能从 <code>Future&lt;T&gt;</code> 的 <code>thread</code> 成员属性获取对应的 <code>Thread</code> 对象，或是通过 <code>Thread</code> 的静态成员属性 <code>currentThread</code> 得到当前正在执行线程对应的 <code>Thread</code> 对象。</p>
<p><code>Thread</code> 类的部分方法定义如下（完整的方法描述可参考《仓颉编程语言库 API》）。</p>
<pre><code class="language-cangjie">class Thread {
    ... ...
    // Get the currently running thread
    static prop currentThread: Thread

    // Get the unique identifier (represented as an integer) of the thread object
    prop id: Int64

    // Check whether the thread has any cancellation request
    prop hasPendingCancellation: Bool
}
</code></pre>
<p>下列示例代码在创建新线程后分别通过两种方式获取线程标识。由于主线程和新线程获取的是同一个 <code>Thread</code> 对象，所以他们能够打印出相同的线程标识。</p>
<pre><code class="language-cangjie">main(): Unit {
    let fut = spawn {
        println(&quot;Current thread id: ${Thread.currentThread.id}&quot;)
    }
    println(&quot;New thread id: ${fut.thread.id}&quot;)
    fut.get()
}
</code></pre>
<p>输出结果如下：</p>
<pre><code class="language-text">New thread id: 1
Current thread id: 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="终止线程"><a class="header" href="#终止线程">终止线程</a></h1>
<p>可以通过 <code>Future&lt;T&gt;</code> 的 <code>cancel()</code> 方法向对应的线程发送终止请求，该方法不会停止线程执行。开发者需要使用 <code>Thread</code> 的 <code>hasPendingCancellation</code> 属性来检查线程是否存在终止请求。</p>
<p>一般而言，如果线程存在终止请求，那么开发者可以实施相应的线程终止逻辑。因此，如何终止线程都交由开发者自行处理，如果开发者忽略终止请求，那么线程继续执行直到正常结束。</p>
<p>示例代码如下：</p>
<!-- verify -->
<pre><code class="language-cangjie">import std.sync.SyncCounter

main(): Unit {
    let syncCounter = SyncCounter(1)
    let fut = spawn {
        syncCounter.waitUntilZero()
        // Check cancellation request
        if (Thread.currentThread.hasPendingCancellation) {
            println(&quot;cancelled&quot;)
            return
        }
        println(&quot;hello&quot;)
    }
    fut.cancel()    // Send cancellation request
    syncCounter.dec()
    fut.get() // Join thread
}
</code></pre>
<p>输出结果如下：</p>
<pre><code class="language-text">cancelled
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="同步机制"><a class="header" href="#同步机制">同步机制</a></h1>
<p>在并发编程中，如果缺少同步机制来保护多个线程共享的变量，很容易会出现数据竞争问题（data race）。</p>
<p>仓颉编程语言提供三种常见的同步机制来确保数据的线程安全：原子操作，互斥锁以及条件变量。</p>
<h2 id="原子操作-atomic"><a class="header" href="#原子操作-atomic">原子操作 Atomic</a></h2>
<p>仓颉提供整数类型、<code>Bool</code> 类型和引用类型的原子操作。</p>
<p>其中整数类型包括： <code>Int8</code>、<code>Int16</code>、<code>Int32</code>、<code>Int64</code>、<code>UInt8</code>、<code>UInt16</code>、<code>UInt32</code>、<code>UInt64</code>。</p>
<p>整数类型的原子操作支持基本的读写、交换以及算术运算操作：</p>
<div class="table-wrapper"><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody>
<tr><td><code>load</code></td><td>读取</td></tr>
<tr><td><code>store</code></td><td>写入</td></tr>
<tr><td><code>swap</code></td><td>交换，返回交换前的值</td></tr>
<tr><td><code>compareAndSwap</code></td><td>比较再交换，交换成功返回 <code>true</code>，否则返回 <code>false</code></td></tr>
<tr><td><code>fetchAdd</code></td><td>加法，返回执行加操作之前的值</td></tr>
<tr><td><code>fetchSub</code></td><td>减法，返回执行减操作之前的值</td></tr>
<tr><td><code>fetchAnd</code></td><td>与，返回执行与操作之前的值</td></tr>
<tr><td><code>fetchOr</code></td><td>或，返回执行或操作之前的值</td></tr>
<tr><td><code>fetchXor</code></td><td>异或，返回执行异或操作之前的值</td></tr>
</tbody></table>
</div>
<p>需要注意的是：</p>
<ol>
<li>交换操作和算术操作的返回值是修改前的值。</li>
<li>compareAndSwap 是判断当前原子变量的值是否等于 old 值，如果等于，则使用 new 值替换；否则不替换。</li>
</ol>
<p>以 <code>Int8</code> 类型为例，对应的原子操作类型声明如下：</p>
<pre><code class="language-cangjie">class AtomicInt8 {
    public func load(): Int8
    public func store(val: Int8): Unit
    public func swap(val: Int8): Int8
    public func compareAndSwap(old: Int8, new: Int8): Bool
    public func fetchAdd(val: Int8): Int8
    public func fetchSub(val: Int8): Int8
    public func fetchAnd(val: Int8): Int8
    public func fetchOr(val: Int8): Int8
    public func fetchXor(val: Int8): Int8
}
</code></pre>
<p>上述每一种原子类型的方法都有一个对应的方法可以接收内存排序参数，目前内存排序参数仅支持顺序一致性。</p>
<p>类似的，其他整数类型对应的原子操作类型有：</p>
<pre><code class="language-cangjie">class AtomicInt16 {...}
class AtomicInt32 {...}
class AtomicInt64 {...}
class AtomicUInt8 {...}
class AtomicUInt16 {...}
class AtomicUInt32 {...}
class AtomicUInt64 {...}
</code></pre>
<p>下方示例演示了如何在多线程程序中，使用原子操作实现计数：</p>
<!-- verify -->
<pre><code class="language-cangjie">import std.sync.*
import std.time.*
import std.collection.*

let count = AtomicInt64(0)

main(): Int64 {
    let list = ArrayList&lt;Future&lt;Int64&gt;&gt;()

    // create 1000 threads.
    for (i in 0..1000) {
        let fut = spawn {
            sleep(Duration.millisecond) // sleep for 1ms.
            count.fetchAdd(1)
        }
        list.append(fut)
    }

    // Wait for all threads finished.
    for (f in list) {
        f.get()
    }

    let val = count.load()
    println(&quot;count = ${val}&quot;)
    return 0
}

</code></pre>
<p>输出结果应为：</p>
<pre><code class="language-text">count = 1000
</code></pre>
<p>以下是使用整数类型原子操作的一些其他正确示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">var obj: AtomicInt32 = AtomicInt32(1)
var x = obj.load() // x: 1, the type is Int32
x = obj.swap(2) // x: 1
x = obj.load() // x: 2
var y = obj.compareAndSwap(2, 3) // y: true, the type is Bool.
y = obj.compareAndSwap(2, 3) // y: false, the value in obj is no longer 2 but 3. Therefore, the CAS operation fails.
x = obj.fetchAdd(1) // x: 3
x = obj.load() // x: 4
</code></pre>
<p><code>Bool</code> 类型和引用类型的原子操作只提供读写和交换操作：</p>
<div class="table-wrapper"><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody>
<tr><td><code>load</code></td><td>读取</td></tr>
<tr><td><code>store</code></td><td>写入</td></tr>
<tr><td><code>swap</code></td><td>交换，返回交换前的值</td></tr>
<tr><td><code>compareAndSwap</code></td><td>比较再交换，交换成功返回 <code>true</code>，否则返回 <code>false</code></td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>注意：</strong></p>
<p>引用类型原子操作只对引用类型有效。</p>
</blockquote>
<p>原子引用类型是 <code>AtomicReference</code>，以下是使用 <code>Bool</code> 类型、引用类型原子操作的一些正确示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import std.sync.*

class A {}

main() {
    var obj = AtomicBool(true)
    var x1 = obj.load() // x1: true, the type is Bool
    println(x1)
    var t1 = A()
    var obj2 = AtomicReference(t1)
    var x2 = obj2.load() // x2 and t1 are the same object
    var y1 = obj2.compareAndSwap(x2, t1) // x2 and t1 are the same object, y1: true
    println(y1)
    var t2 = A()
    var y2 = obj2.compareAndSwap(t2, A()) // x and t1 are not the same object, CAS fails, y2: false
    println(y2)
    y2 = obj2.compareAndSwap(t1, A()) // CAS successes, y2: true
    println(y2)
}
</code></pre>
<p>编译执行上述代码，输出结果为：</p>
<pre><code class="language-text">true
true
false
true
</code></pre>
<h2 id="可重入互斥锁-reentrantmutex"><a class="header" href="#可重入互斥锁-reentrantmutex">可重入互斥锁 ReentrantMutex</a></h2>
<p>可重入互斥锁的作用是对临界区加以保护，使得任意时刻最多只有一个线程能够执行临界区的代码。当一个线程试图获取一个已被其他线程持有的锁时，该线程会被阻塞，直到锁被释放，该线程才会被唤醒，可重入是指线程获取该锁后可再次获得该锁。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>ReentrantMutex 是内置的互斥锁，开发者需要保证不继承它。</p>
</blockquote>
<p>使用可重入互斥锁时，必须牢记两条规则：</p>
<ol>
<li>在访问共享数据之前，必须尝试获取锁；</li>
<li>处理完共享数据后，必须进行解锁，以便其他线程可以获得锁。</li>
</ol>
<p><code>ReentrantMutex</code> 提供的主要成员函数如下：</p>
<pre><code class="language-cangjie">public open class ReentrantMutex {
    // Create a ReentrantMutex.
    public init()

    // Locks the mutex, blocks if the mutex is not available.
    public func lock(): Unit

    // Unlocks the mutex. If there are other threads blocking on this
    // lock, then wake up one of them.
    public func unlock(): Unit

    // Tries to lock the mutex, returns false if the mutex is not
    // available, otherwise returns true.
    public func tryLock(): Bool
}
</code></pre>
<p>下方示例演示了如何使用 <code>ReentrantMutex</code> 来保护对全局共享变量 <code>count</code> 的访问，对 <code>count</code> 的操作即属于临界区：</p>
<!-- verify -->
<pre><code class="language-cangjie">import std.sync.*
import std.time.*
import std.collection.*

var count: Int64 = 0
let mtx = ReentrantMutex()

main(): Int64 {
    let list = ArrayList&lt;Future&lt;Unit&gt;&gt;()

    // creat 1000 threads.
    for (i in 0..1000) {
        let fut = spawn {
            sleep(Duration.millisecond) // sleep for 1ms.
            mtx.lock()
            count++
            mtx.unlock()
        }
        list.append(fut)
    }

    // Wait for all threads finished.
    for (f in list) {
        f.get()
    }

    println(&quot;count = ${count}&quot;)
    return 0
}
</code></pre>
<p>输出结果应为：</p>
<pre><code class="language-text">count = 1000
</code></pre>
<p>下方示例演示了如何使用 <code>tryLock</code>：</p>
<!-- compile -->
<pre><code class="language-cangjie">import std.sync.*

main(): Int64 {
    let mtx: ReentrantMutex = ReentrantMutex()
    var future: Future&lt;Unit&gt; = spawn {
        mtx.lock()
        while (true) {}
        mtx.unlock()
    }
    let res: Option&lt;Unit&gt; = future.get(10*1000*1000)
    match (res) {
        case Some(v) =&gt; ()
        case None =&gt;
            if (mtx.tryLock()) {
                return 1
            }
            return 0
    }
    return 2
}
</code></pre>
<p>输出结果应为空。</p>
<p>以下是互斥锁的一些错误示例：</p>
<p>错误示例 1：线程操作临界区后没有解锁，导致其他线程无法获得锁而阻塞。</p>
<pre><code class="language-cangjie">import std.sync.*

var sum: Int64 = 0
let mutex = ReentrantMutex()

main() {
    let foo = spawn { =&gt;
        mutex.lock()
        sum = sum + 1
    }
    let bar = spawn { =&gt;
        mutex.lock()
        sum = sum + 1
    }
    foo.get()
    println(&quot;${sum}&quot;)
    bar.get() // Because the thread is not unlocked, other threads waiting to obtain the current mutex will be blocked.
}
</code></pre>
<p>错误示例 2：在本线程没有持有锁的情况下调用 <code>unlock</code> 将会抛出异常。</p>
<pre><code class="language-cangjie">import std.sync.*

var sum: Int64 = 0
let mutex = ReentrantMutex()

main() {
    let foo = spawn { =&gt;
        sum = sum + 1
        mutex.unlock() // Error, Unlock without obtaining the lock and throw an exception: IllegalSynchronizationStateException.
    }
    foo.get()
    0
}
</code></pre>
<p>错误示例 3：<code>tryLock()</code> 并不保证获取到锁，可能会造成不在锁的保护下操作临界区和在没有持有锁的情况下调用 <code>unlock</code> 抛出异常等行为。</p>
<pre><code class="language-cangjie">var sum: Int64 = 0
let mutex = ReentrantMutex()

main() {
    for (i in 0..100) {
        spawn { =&gt;
            mutex.tryLock() // Error, `tryLock()` just trying to acquire a lock, there is no guarantee that the lock will be acquired, and this can lead to abnormal behavior.
            sum = sum + 1
            mutex.unlock()
        }
    }
}
</code></pre>
<p>另外，<code>ReentrantMutex</code> 在设计上是一个可重入锁，也就是说：在某个线程已经持有一个 <code>ReentrantMutex</code> 锁的情况下，再次尝试获取同一个 <code>ReentrantMutex</code> 锁，永远可以立即获得该 <code>ReentrantMutex</code> 锁。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>虽然 <code>ReentrantMutex</code> 是一个可重入锁，但是调用 <code>unlock()</code> 的次数必须和调用 <code>lock()</code> 的次数相同，才能成功释放该锁。</p>
</blockquote>
<p>下方示例代码演示了 <code>ReentrantMutex</code> 可重入的特性：</p>
<!-- verify -->
<pre><code class="language-cangjie">import std.sync.*
import std.time.*

var count: Int64 = 0
let mtx = ReentrantMutex()

func foo() {
    mtx.lock()
    count += 10
    bar()
    mtx.unlock()
}

func bar() {
    mtx.lock()
    count += 100
    mtx.unlock()
}

main(): Int64 {
    let fut = spawn {
        sleep(Duration.millisecond) // sleep for 1ms.
        foo()
    }

    foo()

    fut.get()

    println(&quot;count = ${count}&quot;)
    return 0
}
</code></pre>
<p>输出结果应为：</p>
<pre><code class="language-text">count = 220
</code></pre>
<p>在上方示例中，无论是主线程还是新创建的线程，如果在 <code>foo()</code> 中已经获得了锁，那么继续调用 <code>bar()</code> 的话，在 <code>bar()</code> 函数中由于是对同一个 <code>ReentrantMutex</code> 进行加锁，因此也是能立即获得该锁的，不会出现死锁。</p>
<h2 id="monitor"><a class="header" href="#monitor">Monitor</a></h2>
<p><code>Monitor</code> 是一个内置的数据结构，它绑定了互斥锁和单个与之相关的条件变量（也就是等待队列）。<code>Monitor</code> 可以使线程阻塞并等待来自另一个线程的信号以恢复执行。这是一种利用共享变量进行线程同步的机制，主要提供如下方法：</p>
<pre><code class="language-cangjie">public class Monitor &lt;: ReentrantMutex {
    // Create a monitor.
    public init()

    // Wait for a signal, blocking the current thread.
    public func wait(timeout!: Duration = Duration.Max): Bool

    // Wake up one thread of those waiting on the monitor, if any.
    public func notify(): Unit

    // Wake up all threads waiting on the monitor, if any.
    public func notifyAll(): Unit
}
</code></pre>
<p>调用 <code>Monitor</code> 对象的 <code>wait</code>、<code>notify</code> 或 <code>notifyAll</code> 方法前，需要确保当前线程已经持有对应的 <code>Monitor</code> 锁。<code>wait</code> 方法包含如下动作：</p>
<ol>
<li>添加当前线程到该 <code>Monitor</code> 对应的等待队列中;</li>
<li>阻塞当前线程，同时完全释放该 <code>Monitor</code> 锁，并记录锁的重入次数;</li>
<li>等待某个其它线程使用同一个 <code>Monitor</code> 实例的 <code>notify</code> 或 <code>notifyAll</code> 方法向该线程发出信号;</li>
<li>当前线程被唤醒后，会自动尝试重新获取 <code>Monitor</code> 锁，且持有锁的重入状态与第 2 步记录的重入次数相同；但是如果尝试获取 <code>Monitor</code> 锁失败，则当前线程会阻塞在该 <code>Monitor</code> 锁上。</li>
</ol>
<p><code>wait</code> 方法接受一个可选参数 <code>timeout</code>。需要注意的是，业界很多常用的常规操作系统不保证调度的实时性，因此无法保证一个线程会被阻塞“精确的 N 纳秒”——可能会观察到与系统相关的不精确情况。此外，当前语言规范明确允许实现产生虚假唤醒——在这种情况下，<code>wait</code> 返回值是由实现决定的——可能为 <code>true</code> 或 <code>false</code>。因此鼓励开发者始终将 <code>wait</code> 包在一个循环中：</p>
<pre><code class="language-cangjie">synchronized (obj) {
  while (&lt;condition is not true&gt;) {
    obj.wait()
  }
}
</code></pre>
<p>以下是使用 <code>Monitor</code> 的一个正确示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import std.sync.*
import std.time.*

var mon = Monitor()
var flag: Bool = true

main(): Int64 {
    let fut = spawn {
        mon.lock()
        while (flag) {
            println(&quot;New thread: before wait&quot;)
            mon.wait()
            println(&quot;New thread: after wait&quot;)
        }
        mon.unlock()
    }

    // Sleep for 10ms, to make sure the new thread can be executed.
    sleep(10 * Duration.millisecond)

    mon.lock()
    println(&quot;Main thread: set flag&quot;)
    flag = false
    mon.unlock()

    mon.lock()
    println(&quot;Main thread: notify&quot;)
    mon.notifyAll()
    mon.unlock()

    // wait for the new thread finished.
    fut.get()
    return 0
}
</code></pre>
<p>输出结果应为：</p>
<pre><code class="language-text">New thread: before wait
Main thread: set flag
Main thread: notify
New thread: after wait
</code></pre>
<p><code>Monitor</code> 对象执行 <code>wait</code> 时，必须在锁的保护下进行，否则 <code>wait</code> 中释放锁的操作会抛出异常。</p>
<p>以下是使用条件变量的一些错误示例：</p>
<pre><code class="language-cangjie">import std.sync.*

var m1 = Monitor()
var m2 = ReentrantMutex()
var flag: Bool = true
var count: Int64 = 0

func foo1() {
    spawn {
        m2.lock()
        while (flag) {
            m1.wait() // Error：The lock used together with the condition variable must be the same lock and in the locked state. Otherwise, the unlock operation in `wait` throws an exception.
        }
        count = count + 1
        m2.unlock()
    }
    m1.lock()
    flag = false
    m1.notifyAll()
    m1.unlock()
}

func foo2() {
    spawn {
        while (flag) {
            m1.wait() // Error：The `wait` of a conditional variable must be called with a lock held.
        }
        count = count + 1
    }
    m1.lock()
    flag = false
    m1.notifyAll()
    m1.unlock()
}

main() {
    foo1()
    foo2()
    m1.wait()
    return 0
}
</code></pre>
<h2 id="multiconditionmonitor"><a class="header" href="#multiconditionmonitor">MultiConditionMonitor</a></h2>
<p><code>MultiConditionMonitor</code> 是一个内置的数据结构，它绑定了互斥锁和一组与之相关的动态创建的条件变量。该类应仅当在 <code>Monitor</code> 类不足以满足复杂的线程间同步的场景下使用。主要提供如下方法：</p>
<pre><code class="language-cangjie">public class MultiConditionMonitor &lt;: ReentrantMutex {
   // Constructor.
   init()

   // Returns a new ConditionID associated with this monitor. May be used to implement
   // &quot;single mutex -- multiple wait queues&quot; concurrent primitives.
   // Throws IllegalSynchronizationStateException(&quot;Mutex is not locked by the current thread&quot;) if the current thread does not hold this mutex.
   func newCondition(): ConditionID

   // Blocks until either a paired `notify` is invoked or `timeout` nanoseconds pass.
   // Returns `true` if the specified condition was signalled by another thread or `false` on timeout.
   // Spurious wakeups are allowed.
   // Throws IllegalSynchronizationStateException(&quot;Mutex is not locked by the current thread&quot;) if the current thread does not hold this mutex.
   // Throws IllegalSynchronizationStateException(&quot;Invalid condition&quot;) if `id` was not returned by `newCondition` of this MultiConditionMonitor instance.
   func wait(id: ConditionID, timeout!: Duration = Duration.Max): Bool

   // Wakes up a single thread waiting on the specified condition, if any (no particular admission policy implied).
   // Throws IllegalSynchronizationStateException(&quot;Mutex is not locked by the current thread&quot;) if the current thread does not hold this mutex.
   // Throws IllegalSynchronizationStateException(&quot;Invalid condition&quot;) if `id` was not returned by `newCondition` of this MultiConditionMonitor instance.
   func notify(id: ConditionID): Unit

   // Wakes up all threads waiting on the specified condition, if any (no particular admission policy implied).
   // Throws IllegalSynchronizationStateException(&quot;Mutex is not locked by the current thread&quot;) if the current thread does not hold this mutex.
   // Throws IllegalSynchronizationStateException(&quot;Invalid condition&quot;) if `id` was not returned by `newCondition` of this MultiConditionMonitor instance.
   func notifyAll(id: ConditionID): Unit
}
</code></pre>
<ol>
<li><code>newCondition(): ConditionID</code>：创建一个新的条件变量并与当前对象关联，返回一个特定的 <code>ConditionID</code> 标识符</li>
<li><code>wait(id: ConditionID, timeout!: Duration = Duration.Max): Bool</code>：等待信号，阻塞当前线程</li>
<li><code>notify(id: ConditionID): Unit</code>：唤醒一个在 <code>Monitor</code> 上等待的线程（如果有）</li>
<li><code>notifyAll(id: ConditionID): Unit</code>：唤醒所有在 <code>Monitor</code> 上等待的线程（如果有）</li>
</ol>
<p>初始化时，<code>MultiConditionMonitor</code> 没有与之相关的 <code>ConditionID</code> 实例。每次调用 <code>newCondition</code> 都会将创建一个新的条件变量并与当前对象关联，并返回如下类型作为唯一标识符：</p>
<pre><code class="language-cangjie">public struct ConditionID {
   private init() { ... } // constructor is intentionally private to prevent
                          // creation of such structs outside of MultiConditionMonitor
}
</code></pre>
<p>请注意使用者不可以将一个 <code>MultiConditionMonitor</code> 实例返回的 <code>ConditionID</code> 传给其它实例，或者手动创建 <code>ConditionID</code>（例如使用 <code>unsafe</code>）。由于 <code>ConditionID</code> 所包含的数据（例如内部数组的索引，内部队列的直接地址，或任何其他类型数据等）和创建它的 <code>MultiConditionMonitor</code> 相关，所以将“外部” <code>conditonID</code> 传入 <code>MultiConditionMonitor</code> 中会导致 <code>IllegalSynchronizationStateException</code>。</p>
<p>以下是使用 <code>MultiConditionMonitor</code> 去实现一个长度固定的有界 <code>FIFO</code> 队列，当队列为空，<code>get()</code> 会被阻塞；当队列满了时，<code>put()</code> 会被阻塞。</p>
<pre><code class="language-cangjie">import std.sync.*

class BoundedQueue {
    // Create a MultiConditionMonitor, two Conditions.
    let m: MultiConditionMonitor = MultiConditionMonitor()
    var notFull: ConditionID
    var notEmpty: ConditionID

    var count: Int64 // Object count in buffer.
    var head: Int64  // Write index.
    var tail: Int64  // Read index.

    // Queue's length is 100.
    let items: Array&lt;Object&gt; = Array&lt;Object&gt;(100, {i =&gt; Object()})

    init() {
        count = 0
        head = 0
        tail = 0

        synchronized(m) {
          notFull  = m.newCondition()
          notEmpty = m.newCondition()
        }
    }

    // Insert an object, if the queue is full, block the current thread.
    public func put(x: Object) {
        // Acquire the mutex.
        synchronized(m) {
          while (count == 100) {
            // If the queue is full, wait for the &quot;queue notFull&quot; event.
            m.wait(notFull)
          }
          items[head] = x
          head++
          if (head == 100) {
            head = 0
          }
          count++

          // An object has been inserted and the current queue is no longer
          // empty, so wake up the thread previously blocked on get()
          // because the queue was empty.
          m.notify(notEmpty)
        } // Release the mutex.
    }

    // Pop an object, if the queue is empty, block the current thread.
    public func get(): Object {
        // Acquire the mutex.
        synchronized(m) {
          while (count == 0) {
            // If the queue is empty, wait for the &quot;queue notEmpty&quot; event.
            m.wait(notEmpty)
          }
          let x: Object = items[tail]
          tail++
          if (tail == 100) {
            tail = 0
          }
          count--

          // An object has been popped and the current queue is no longer
          // full, so wake up the thread previously blocked on put()
          // because the queue was full.
          m.notify(notFull)

          return x
        } // Release the mutex.
    }
}
</code></pre>
<h2 id="synchronized-关键字"><a class="header" href="#synchronized-关键字">synchronized 关键字</a></h2>
<p>互斥锁 <code>ReentrantMutex</code> 提供了一种便利灵活的加锁的方式，同时因为它的灵活性，也可能引起忘了解锁，或者在持有互斥锁的情况下抛出异常不能自动释放持有的锁的问题。因此，仓颉编程语言提供一个 <code>synchronized</code> 关键字，搭配<code>ReentrantMutex</code>一起使用，可以在其后跟随的作用域内自动进行加锁解锁操作，用来解决类似的问题。</p>
<p>下方示例代码演示了如何使用 <code>synchronized</code> 关键字来保护共享数据：</p>
<!-- verify -->
<pre><code class="language-cangjie">import std.sync.*
import std.time.*
import std.collection.*

var count: Int64 = 0
let mtx = ReentrantMutex()

main(): Int64 {
    let list = ArrayList&lt;Future&lt;Unit&gt;&gt;()

    // creat 1000 threads.
    for (i in 0..1000) {
        let fut = spawn {
            sleep(Duration.millisecond) // sleep for 1ms.
            // Use synchronized(mtx), instead of mtx.lock() and mtx.unlock().
            synchronized(mtx) {
                count++
            }
        }
        list.append(fut)
    }

    // Wait for all threads finished.
    for (f in list) {
        f.get()
    }

    println(&quot;count = ${count}&quot;)
    return 0
}
</code></pre>
<p>输出结果应为：</p>
<pre><code class="language-text">count = 1000
</code></pre>
<p>通过在 <code>synchronized</code> 后面加上一个 <code>ReentrantMutex</code> 实例，对其后面修饰的代码块进行保护，可以使得任意时刻最多只有一个线程可以执行被保护的代码：</p>
<ol>
<li>一个线程在进入 <code>synchronized</code> 修饰的代码块之前，会自动获取 <code>ReentrantMutex</code> 实例对应的锁，如果无法获取锁，则当前线程被阻塞；</li>
<li>一个线程在退出 <code>synchronized</code> 修饰的代码块之前，会自动释放该 <code>ReentrantMutex</code> 实例的锁。</li>
</ol>
<p>对于控制转移表达式（如 <code>break</code>、<code>continue</code>、<code>return</code>、<code>throw</code>），在导致程序的执行跳出 <code>synchronized</code> 代码块时，也符合上面第 2 条的说明，也就说也会自动释放 <code>synchronized</code> 表达式对应的锁。</p>
<p>下方示例演示了在 <code>synchronized</code> 代码块中出现 <code>break</code> 语句的情况：</p>
<!-- verify -->
<pre><code class="language-cangjie">import std.sync.*
import std.collection.*

var count: Int64 = 0
var mtx: ReentrantMutex = ReentrantMutex()

main(): Int64 {
    let list = ArrayList&lt;Future&lt;Unit&gt;&gt;()
    for (i in 0..10) {
        let fut = spawn {
            while (true) {
                synchronized(mtx) {
                    count = count + 1
                    break
                    println(&quot;in thread&quot;)
                }
            }
        }
        list.append(fut)
    }

    // Wait for all threads finished.
    for (f in list) {
        f.get()
    }

    synchronized(mtx) {
        println(&quot;in main, count = ${count}&quot;)
    }
    return 0
}
</code></pre>
<p>输出结果应为：</p>
<pre><code class="language-text">in main, count = 10
</code></pre>
<p>实际上 <code>in thread</code> 这行不会被打印，因为 <code>break</code> 语句实际上会让程序执行跳出 <code>while</code> 循环（当然，在跳出 <code>while</code> 循环之前，是先跳出 <code>synchronized</code> 代码块）。</p>
<h2 id="线程局部变量-threadlocal"><a class="header" href="#线程局部变量-threadlocal">线程局部变量 ThreadLocal</a></h2>
<p>使用 core 包中的 <code>ThreadLocal</code> 可以创建并使用线程局部变量，每一个线程都有它独立的一个存储空间来保存这些线程局部变量，因此，在每个线程可以安全地访问他们各自的线程局部变量，而不受其他线程的影响。</p>
<pre><code class="language-cangjie">public class ThreadLocal&lt;T&gt; {
    /*
     * 构造一个携带空值的仓颉线程局部变量
     */
    public init()

    /*
     * 获得仓颉线程局部变量的值，如果值不存在，则返回 Option&lt;T&gt;.None
     * 返回值 Option&lt;T&gt; - 仓颉线程局部变量的值
     */
    public func get(): Option&lt;T&gt;

    /*
     * 通过 value 设置仓颉线程局部变量的值
     * 如果传入 Option&lt;T&gt;.None，该局部变量的值将被删除，在线程后续操作中将无法获取
     * 参数 value - 需要设置的局部变量的值
     */
    public func set(value: Option&lt;T&gt;): Unit
}
</code></pre>
<p>下方示例代码演示了如何通过 <code>ThreadLocal</code>类来创建并使用各自线程的局部变量：</p>
<pre><code class="language-cangjie">
main(): Int64 {
    let tl = ThreadLocal&lt;Int64&gt;()
    let fut1 = spawn {
        tl.set(123)
        println(&quot;tl in spawn1 = ${tl.get().getOrThrow()}&quot;)
    }
    let fut2 = spawn {
        tl.set(456)
        println(&quot;tl in spawn2 = ${tl.get().getOrThrow()}&quot;)
    }
    fut1.get()
    fut2.get()
    0
}
</code></pre>
<p>可能的输出结果如下：</p>
<pre><code class="language-text">tl in spawn1 = 123
tl in spawn2 = 456
</code></pre>
<p>或者</p>
<pre><code class="language-text">tl in spawn2 = 456
tl in spawn1 = 123
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="线程睡眠指定时长-sleep"><a class="header" href="#线程睡眠指定时长-sleep">线程睡眠指定时长 sleep</a></h1>
<p><code>sleep</code> 函数会阻塞当前运行的线程，该线程会主动睡眠一段时间，之后再恢复执行，其参数类型为 Duration 类型。函数原型为：</p>
<pre><code class="language-cangjie">func sleep(dur: Duration): Unit // Sleep for at least `dur`.
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p>如果 <code>dur</code> &lt;= Duration.Zero, 那么当前线程只会让出执行资源，并不会进入睡眠。</p>
</blockquote>
<p>以下是使用 <code>sleep</code> 的示例：</p>
<!-- verify -->
<pre><code class="language-cangjie">import std.sync.*
import std.time.*

main(): Int64 {
    println(&quot;Hello&quot;)
    sleep(Duration.second)  // sleep for 1s.
    println(&quot;World&quot;)
    return 0
}
</code></pre>
<p>输出结果如下：</p>
<pre><code class="language-text">Hello
World
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="io-流概述"><a class="header" href="#io-流概述">I/O 流概述</a></h1>
<p>本章我们会介绍基本的 I/O 概念和文件操作。</p>
<p>在仓颉编程语言中，我们将与应用程序外部载体交互的操作称之为 I/O 操作。I 对应输入（Input），O 对应输出（Output）。</p>
<p>仓颉编程语言所有的 I/O 机制都是基于数据流进行输入输出，这些数据流表示了字节数据的序列。数据流是一串连续的数据集合，它就像承载数据的管道，在管道的一端输入数据，在管道的另一端就可以输出数据。</p>
<p>仓颉编程语言将输入输出抽象为流（Stream）：</p>
<ul>
<li>将数据从外存中读取到内存中的称为输入流（InputStream），输入端可以一段一段地向管道中写入数据，这些数据段会按先后顺序形成一个长的数据流；</li>
<li>将数据从内存写入外存中的称为输出流（OutputStream），输出端也可以一段一段地从管道中读出数据，每次可以读取其中的任意长度的数据（不需要跟输入端匹配），但只能读取先输入的数据，再读取后输入的数据。</li>
</ul>
<p>有了这一层抽象，仓颉编程语言就可以使用统一的接口来实现与外部数据的交互。</p>
<p>仓颉编程语言将标准输入输出、文件操作、网络数据流、字符串流、加密流、压缩流等等形式的操作，统一用 Stream 描述。</p>
<p>Stream 主要面向处理原始二进制数据，Stream 中最小的数据单元是 <code>Byte</code>。</p>
<p>仓颉编程语言将 Stream 定义成了 <code>interface</code>，它让不同的 Stream 可以用装饰器模式进行组合，极大地提升了可扩展性。</p>
<h2 id="输入流"><a class="header" href="#输入流">输入流</a></h2>
<p>程序从输入流读取数据源（数据源包括外界的键盘、文件、网络...），即输入流是将数据源读入到程序的通信通道。</p>
<p>仓颉编程语言用 <code>InputStream</code> 接口类型来表示输入流，它提供了 <code>read</code> 函数，这个函数会将可读的数据写入到 <code>buffer</code> 中，返回值表示了该次读取的字节总数。</p>
<p>InputStream 接口定义：</p>
<!-- run -->
<pre><code class="language-cangjie">interface InputStream {
    func read(buffer: Array&lt;Byte&gt;): Int64
}
</code></pre>
<p>当我们拥有一个输入流的时候，就可以像下面的代码那样去读取字节数据，读取的数据会被写到 <code>read</code> 的入参数组中。</p>
<p>输入流读取示例：</p>
<pre><code class="language-cangjie">import std.io.InputStream

main() {
    let input: InputStream = ...
    let buf = Array&lt;Byte&gt;(256, item: 0)
    while (input.read(buf) &gt; 0) {
        println(buf)
    }
}
</code></pre>
<h2 id="输出流"><a class="header" href="#输出流">输出流</a></h2>
<p>程序向输出流写入数据。输出流是将程序中的数据输出到外界（显示器、打印机、文件、网络等）的通信通道。</p>
<p>仓颉编程语言用 <code>OutputStream</code> 接口类型来表示输出流，它提供了 <code>write</code> 函数，这个函数会将 <code>buffer</code> 中的数据写入到绑定的流中。</p>
<p>特别的，有一些输出流的 <code>write</code> 不会立即写到外存中，而是有一定的缓冲策略，只有当符合条件或主动调用 <code>flush</code> 时才会真实写入，目的是提高性能。</p>
<p>为了统一处理这些 <code>flush</code> 操作，在 <code>OutputStream</code> 中有一个 <code>flush</code> 的默认实现，它有助于抹平 API 调用的差异性。</p>
<p>OutputStream 接口定义：</p>
<pre><code class="language-cangjie">interface OutputStream {
    func write(buffer: Array&lt;Byte&gt;): Unit

    func flush(): Unit {
        // 空实现
    }
}
</code></pre>
<p>当我们拥有一个输出流时，我们可以像下面的代码那样去写入字节数据。</p>
<p>输出流写入示例：</p>
<pre><code class="language-cangjie">import std.io.OutputStream

main() {
    let output: OutputStream = ...
    let buf = Array&lt;Byte&gt;(256, item: 111)
    output.write(buf)
    output.flush()
}
</code></pre>
<h2 id="数据流分类"><a class="header" href="#数据流分类">数据流分类</a></h2>
<p>按照数据流职责上的差异，我们可以给 Stream 简单分成两类：</p>
<ul>
<li>节点流：直接提供数据源，节点流的构造方式通常是依赖某种直接的外部资源（即文件、网络等）。</li>
<li>处理流：只能代理其它数据流进行处理，处理流的构造方式通常是依赖其它的流。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="io-节点流"><a class="header" href="#io-节点流">I/O 节点流</a></h1>
<p>节点流是指直接提供数据源的流，节点流的构造方式通常是依赖某种直接的外部资源（即文件、网络等）。</p>
<p>仓颉编程语言中常见的节点流包含标准流（StdIn、StdOut、StdErr）、文件流（File）、网络流（Socket）等。</p>
<p>我们本章会着重介绍一下标准流和文件流。</p>
<h2 id="标准流"><a class="header" href="#标准流">标准流</a></h2>
<p>标准流包含了标准输入流（stdin）、标准输出流（stdout）和标准错误输出流（stderr）。</p>
<p>标准流是我们的程序与外部数据交互的标准接口。程序运行的时候从输入流读取数据，作为程序的输入，程序运行过程中输出的信息被传送到输出流，类似的，错误信息被传送到错误流。</p>
<p>在仓颉编程语言中我们可以使用 <code>Console</code> 类型来分别访问它们。</p>
<p>使用 <code>Console</code> 类型需要导入 <code>console</code> 包：</p>
<p>导入 console 包示例：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.console.*
</code></pre>
<p><code>Console</code> 对三个标准流都进行了易用性封装，提供了更方便的基于 <code>String</code> 的扩展操作，并且对于很多常见类型都提供了丰富的重载来优化性能。</p>
<p>其中最重要的是 <code>Console</code> 提供了并发安全的保证，我们可以在任意线程中安全的通过 <code>Console</code> 提供的接口来读写内容。</p>
<p>默认情况下标准输入流来源于键盘输入的信息，例如我们在命令行界面中输入的文本。</p>
<p>当我们需要从标准输入流中获取数据时，可以通过 <code>stdIn</code> 来读取，例如通过 <code>readln</code> 函数来获取命令行的输入。</p>
<p>标准输入流读取示例：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.console.*

main() {
    let txt = Console.stdIn.readln()
    println(txt ?? &quot;&quot;)
}
</code></pre>
<p>运行上面的代码，在命令行上输入一些文字，然后换行结束，我们就能看到我们输入的内容了！</p>
<p>输出流分为标准输出流和标准错误流，默认情况下，它们都会输出到屏幕，例如我们在命令行界面中看到的文本。</p>
<p>当我们需要往标准输出流中写入数据时，可以通过 <code>stdOut</code>/<code>stdErr</code> 来写入，例如通过 <code>write</code> 函数来向命令打印内容。</p>
<p>使用 <code>stdOut</code> 和直接使用 <code>print</code> 函数的差别是，<code>stdOut</code> 是并发安全的，并且由于 <code>stdOut</code> 使用了缓存技术，在输入内容较多时拥有更好的性能表现。</p>
<p>需要注意的是，写完数据后我们需要对 <code>stdOut</code> 调用 <code>flush</code> 才能保证内容被写到标准流中。</p>
<p>标准输出流写入示例：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.console.*

main() {
    for (i in 0..1000) {
        Console.stdOut.writeln(&quot;hello, world!&quot;)
    }
    Console.stdOut.flush()
}
</code></pre>
<h2 id="文件流"><a class="header" href="#文件流">文件流</a></h2>
<p>仓颉编程语言提供了 <code>fs</code> 包来支持通用文件系统任务。虽然不同的操作系统对于文件系统提供的接口有所不同，但是仓颉编程语言抽象出以下一些共通的功能，通过统一的功能接口，屏蔽不同操作系统之间的差异，来简化我们的使用。</p>
<p>这些常规操作任务包括：创建文件/目录、读写文件、重命名或移动文件/目录、删除文件/目录、复制文件/目录、获取文件/目录元数据、检查文件/目录是否存在。具体 API 可以查阅库文档。</p>
<p>使用文件系统相关的功能需要导入 <code>fs</code> 包：</p>
<p>导入 fs 包示例：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.fs.*
</code></pre>
<p>本章会着重介绍 <code>File</code> 相关的使用，对于 <code>Path</code> 和 <code>Directory</code> 的使用可以查阅对应的 API 文档。</p>
<p><code>File</code> 类型在仓颉编程语言中同时提供了常规文件操作和文件流两类功能。</p>
<h3 id="常规文件操作"><a class="header" href="#常规文件操作">常规文件操作</a></h3>
<p>对于常规的文件操作，我们可以使用一系列静态函数来完成快捷的操作。</p>
<p>例如我们如果要检查某个路径对应的文件是否存在，可以使用 <code>exists</code> 函数。当 <code>exists</code> 函数返回 <code>true</code> 时表示文件存在，反之不存在。</p>
<p>exists 函数使用示例：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.fs.*

main() {
    let exist = File.exists(&quot;./tempFile.txt&quot;)
    println(&quot;exist: ${exist}&quot;)
}
</code></pre>
<p>移动文件、拷贝文件和删除文件也非常简单，<code>File</code> 同样提供了对应的静态函数 <code>move</code>、<code>copy</code>、<code>delete</code>。</p>
<p>move、copy、delete 函数使用示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">import std.fs.*

main() {
    File.copy(&quot;./tempFile.txt&quot;, &quot;./tempFile2.txt&quot;, false)
    File.move(&quot;./tempFile2.txt&quot;, &quot;./tempFile3.txt&quot;, false)
    File.delete(&quot;./tempFile3.txt&quot;)
}
</code></pre>
<p>如果我们需要直接将文件的所有数据读出来，或者一次性将数据写入文件里，我们可以使用 <code>File</code> 提供的 <code>readFrom</code>、<code>writeTo</code> 函数直接读写文件。在数据量较少的情况下它们既简单易用又能提供较好的性能表现，让我们不需要手动处理数据流的事情。</p>
<p>readFrom、writeTo 函数使用示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">import std.fs.*

main() {
    let bytes = File.readFrom(&quot;./tempFile.txt&quot;) // 一次性读取了所有的数据
    File.writeTo(&quot;./otherFile.txt&quot;, bytes) // 把数据一次性写入另一个文件中
}
</code></pre>
<h3 id="文件流操作"><a class="header" href="#文件流操作">文件流操作</a></h3>
<p>除了上述的常规文件操作之外，<code>File</code> 类型也被设计为一种数据流类型，因此 <code>File</code> 类型本身实现了 <code>IOStream</code> 接口。当我们创建了一个 <code>File</code> 的实例，我们就可以把这个实例当成数据流来使用。</p>
<p>File 类定义：</p>
<pre><code class="language-cangjie">public class File &lt;: Resource &amp; IOStream &amp; Seekable {
    ...
}
</code></pre>
<p><code>File</code> 提供了两种构造方式，一种是通过两个方便的静态函数 <code>openRead</code>/<code>create</code> 直接打开文件或创建新文件的实例，另一种是通过构造函数传入完整的打开文件选项来构造新实例。</p>
<p>其中，<code>openRead</code> 打开的文件是只读的，我们不能对实例进行写操作，否则会抛出运行时异常；而 <code>create</code> 创建的文件是只写的，我们不能对实例进行读操作，否则也会抛出运行时异常。</p>
<p>File 构造示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">// 创建
internal import std.fs.*

main() {
    let file = File.create(&quot;./tempFile.txt&quot;)
    file.write(&quot;hello, world!&quot;.toArray())

    // 打开
    let file2 = File.openRead(&quot;./tempFile.txt&quot;)
    let bytes = file2.readToEnd() // 读取所有数据
    println(bytes)
}
</code></pre>
<p>当我们需要更精细的打开选项时，可以使用构造函数传入一个 <code>OpenOption</code> 值。<code>OpenOption</code> 是一个 <code>enum</code> 类型，它提供了丰富的文件打开选项，例如 <code>Append</code>、<code>Create</code>、<code>Truncate</code>、<code>Open</code> 以及其它便捷的复合操作。</p>
<p>File 打开选项使用示例：</p>
<pre><code class="language-cangjie">// 使用指定选项打开文件
let file = File(&quot;./tempFile.txt&quot;, OpenOption.Truncate(false))
...
</code></pre>
<p>因为我们打开 <code>File</code> 的实例会占用宝贵的系统资源，所以使用完 <code>File</code> 的实例之后需要注意及时关闭 <code>File</code>，以释放系统资源。</p>
<p>所幸 <code>File</code> 实现了 <code>Resource</code> 接口，我们在大多数时候都可以使用 try-with-resource 语法来简化我们的使用。</p>
<p>try-with-resource 语法使用示例：</p>
<pre><code class="language-cangjie">try (file2 = File.openRead(&quot;./tempFile.txt&quot;)) {
    ...
    // 结束使用后自动释放文件
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="io-处理流"><a class="header" href="#io-处理流">I/O 处理流</a></h1>
<p>处理流是指代理其它数据流进行处理的流。</p>
<p>仓颉编程语言中常见的处理流包含 <code>BufferedInputStream</code>、<code>BufferedOutputStream</code>、<code>StringReader</code>、<code>StringWriter</code>、<code>ChainedInputStream</code> 等。</p>
<p>我们本章会着重介绍一下缓冲流和字符串流。</p>
<h2 id="缓冲流"><a class="header" href="#缓冲流">缓冲流</a></h2>
<p>由于涉及磁盘的 I/O 操作相比内存的 I/O 操作要慢很多，所以对于高频次且小数据量的读写操作来说，不带缓冲的数据流效率很低，每次读取和写入数据都会带来大量的 I/O 耗时。而带缓冲的数据流，可以多次读写数据，但不触发磁盘 I/O 操作，只是先放到内存里。等凑够了缓冲区大小的时候再一次性操作磁盘，这种方式可以显著减少磁盘操作次数，从而提升性能表现。</p>
<p>仓颉编程语言标准库提供了 <code>BufferedInputStream</code> 和 <code>BufferedOutputStream</code> 这两个类型用来提供缓冲功能。</p>
<p>使用 <code>BufferedInputStream</code> 和 <code>BufferedOutputStream</code> 类型需要导入 <code>io</code> 包。</p>
<p>导入 io 包示例：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.io.*
</code></pre>
<p><code>BufferedInputStream</code> 的作用是为另一个输入流添加缓冲的功能。本质上 <code>BufferedInputStream</code> 是通过一个内部缓冲数组实现的。</p>
<p>当我们通过 <code>BufferedInputStream</code> 来读取流的数据时，<code>BufferedInputStream</code> 会一次性读取整个缓冲区大小的数据，然后我们再使用 <code>read</code> 函数就可以分多次读取更小规模的数据；当缓冲区中的数据被读完之后，输入流就会再次填充缓冲区；如此反复，直到我们读完数据流的所有数据。</p>
<p>构造一个 <code>BufferedInputStream</code> 很简单，我们只需要在构造函数中传入另一个输入流就可以了。如果我们需要指定缓冲区的大小，也可以额外传入 <code>capacity</code> 参数进行指定。</p>
<p>BufferedInputStream 构造示例：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.io.*

main(): Unit {
    let arr1 = &quot;0123456789&quot;.toArray()
    let byteArrayStream = ByteArrayStream()
    byteArrayStream.write(arr1)
    let bufferedInputStream = BufferedInputStream(byteArrayStream)
    let arr2 = Array&lt;Byte&gt;(20, item: 0)

    /* 读取流中数据，返回读取到的数据的长度 */
    let readLen = bufferedInputStream.read(arr2)
    println(String.fromUtf8(arr2[..readLen])) // 0123456789
}
</code></pre>
<p><code>BufferedOutputStream</code> 的作用是为另一个输出流添加缓冲的功能。BufferedOutputStream 也是通过一个内部缓冲数组实现的。</p>
<p>当我们通过 <code>BufferedOutputStream</code> 来向输出流写入数据时，<code>write</code> 的数据会先写入内部缓冲数组中；当缓冲区中的数据被填满之后，<code>BufferedOutputStream</code> 会将缓冲区的数据一次性写入输出流中，然后清空缓冲区再次被写入；如此反复，直到我们写完所有的数据。</p>
<p>需要注意的是，由于我们没写够缓冲区时不会触发输出流的写入操作，所以当我们往 <code>BufferedOutputStream</code> 写完所有的数据后，需要额外调用 <code>flush</code> 函数来最终完成写入。</p>
<p>构造一个 <code>BufferedOutputStream</code> 也很简单，我们只需要在构造函数中传入另一个输出流就可以了。如果我们需要指定缓冲区的大小，也可以额外传入 <code>capacity</code> 参数指定。</p>
<p>BufferedOutputStream 构造示例：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.io.*

main(): Unit {
    let arr1 = &quot;01234&quot;.toArray()
    let byteArrayStream = ByteArrayStream()
    byteArrayStream.write(arr1)
    let bufferedOutputStream = BufferedOutputStream(byteArrayStream)
    let arr2 = &quot;56789&quot;.toArray()

    /* 向流中写入数据，此时数据在外部流的缓冲区中 */
    bufferedOutputStream.write(arr2)

    /* 调用 flush 函数，真正将数据写入内部流中 */
    bufferedOutputStream.flush()
    println(String.fromUtf8(byteArrayStream.readToEnd())) // 0123456789
}
</code></pre>
<h2 id="字符串流"><a class="header" href="#字符串流">字符串流</a></h2>
<p>由于仓颉编程语言的输入流和输出流是基于字节数据来抽象的（拥有更好的性能），在部分以字符串为主的场景中使用起来不太友好，例如往文件里写入大量的文本内容时，需要将文本内容转换成字节数据，再写入文件。</p>
<p>为了提供友好的字符串操作能力，仓颉编程语言提供了 <code>StringReader</code> 和 <code>StringWriter</code> 来添加字符串处理能力。</p>
<p>使用 <code>StringReader</code> 和 <code>StringWriter</code> 类型需要导入 <code>io</code> 包：</p>
<p>导入 io 包示例：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.io.*
</code></pre>
<p><code>StringReader</code> 提供了按行读、按筛选条件读的能力，相比将字节数据读出来再手动转换成字符串，具有更好的性能表现和易用性。</p>
<p>构造 <code>StringReader</code> 很简单，传入另一个输入流就可以了。</p>
<p>StringReader 使用示例：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.io.*

main(): Unit {
    let arr1 = &quot;012\n346789&quot;.toArray()
    let byteArrayStream = ByteArrayStream()
    byteArrayStream.write(arr1)
    let stringReader = StringReader(byteArrayStream)

    /* 读取一行数据 */
    let line = stringReader.readln()
    println(line ?? &quot;error&quot;) // 012
}
</code></pre>
<p><code>StringWriter</code> 提供了直接写字符串、按行直接写字符串的能力，相比将字节数据手动转换成字符串再写入，具有更好的性能表现和易用性。</p>
<p>构造 <code>StringWriter</code> 也很简单，传入另一个输出流就可以了。</p>
<p>StringWriter 使用示例：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.io.*

main(): Unit {
    let byteArrayStream = ByteArrayStream()
    let stringWriter = StringWriter(byteArrayStream)

    /* 写入字符串 */
    stringWriter.write(&quot;number&quot;)

    /* 写入字符串并自动转行 */
    stringWriter.writeln(&quot; is:&quot;)

    /* 写入数字 */
    stringWriter.write(100.0f32)

    stringWriter.flush()

    println(String.fromUtf8(byteArrayStream.readToEnd())) // number is:\n100.000000
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网络编程概述"><a class="header" href="#网络编程概述">网络编程概述</a></h1>
<p>网络通信是两个设备通过计算机网络进行数据交换的过程。通过编写软件达成网络通信的行为即为网络编程。</p>
<p>仓颉为开发者提供了基础的网络编程功能，在仓颉标准库中，用户可使用 std 模块下的 socket 包来实现传输层网络通信。</p>
<p>在传输层协议中，分为不可靠传输和可靠传输两种，仓颉将其抽象为 DatagramSocket 和 StreamSocket。其中不可靠传输协议常见的是 UDP，可靠传输协议常见的是 TCP，仓颉分别将其抽象为 UdpSocket 和 TcpSocket。另外，仓颉也实现了对传输层 Unix Domain 协议的支持，并支持其通过可靠和不可靠传输两种方式进行通信。</p>
<p>而在应用层协议中，较为常见的是 HTTP 协议，常用于开发 Web 应用程序等。当前 HTTP 协议已有多个版本，仓颉目前支持 HTTP/1.1、HTTP/2.0 等。</p>
<p>另外，WebSocket 作为一种提升 Web 服务端与客户端间的通信效率的应用层协议，仓颉将其抽象为 WebSocket 对象，并支持从 HTTP 协议升级至 WebSocket 协议。</p>
<p>需要注意的是，仓颉的网络编程是阻塞式的。但被阻塞的是仓颉线程，阻塞中的仓颉线程会将系统线程让渡出去，因此并不会真正阻塞一个系统线程。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="socket-编程"><a class="header" href="#socket-编程">Socket 编程</a></h1>
<p>仓颉的 Socket 编程指的是基于传输层协议实现网络传输数据包的功能。</p>
<p>在可靠传输场景下，仓颉分别启动客户端套接字和服务端套接字。客户端套接字必须指定将要连接的远端地址，可选择性地绑定本端地址，在连接成功后，才可以收发报文。而服务端套接字必须绑定本端地址，在绑定成功后，才可以收发报文。</p>
<p>在不可靠传输场景下，套接字无需区分客户端和服务端，仓颉分别启动两个套接字进行数据传输。套接字必须绑定本端地址，绑定成功后，才可以收发报文。并且，套接字也可选择性地指定远端连接地址，指定后将仅接受指定的远端地址的报文，同时在 send 时无需指定远端地址，报文将发送至成功连接的地址。</p>
<h2 id="tcp-编程"><a class="header" href="#tcp-编程">Tcp 编程</a></h2>
<p>Tcp 作为一种常见的可靠传输协议，以 Tcp 类型套接字举例，仓颉在可靠传输场景下的可参考的编程模型如下：</p>
<ol>
<li>创建服务端套接字，并指定本端绑定地址。</li>
<li>执行绑定。</li>
<li>执行 accept 动作，将阻塞等待，直到获取到一个客户端套接字连接。</li>
<li>同步创建客户端套接字，并指定远端的待连接的地址。</li>
<li>执行连接。</li>
<li>连接成功后，服务端会在 accept 接口返回一个新的套接字，此时服务端可以通过此套接字进行读写操作，即收发报文。客户端则可以直接进行读写操作。</li>
</ol>
<p>Tcp 服务端和客户端程序示例如下：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.socket.*
import std.time.*
import std.sync.*

let SERVER_PORT: UInt16 = 8080

func runTcpServer() {
    try (serverSocket = TcpServerSocket(bindAt: SERVER_PORT)) {
        serverSocket.bind()

        try (client = serverSocket.accept()) {
            let buf = Array&lt;Byte&gt;(10, item: 0)
            let count = client.read(buf)

            // 服务端读取到的数据为: [1, 2, 3, 0, 0, 0, 0, 0, 0, 0]
            println(&quot;Server read ${count} bytes: ${buf}&quot;)
        }
    }
}

main(): Int64 {
    spawn {
        runTcpServer()
    }
    sleep(Duration.millisecond * 500)

    try (socket = TcpSocket(&quot;127.0.0.1&quot;, SERVER_PORT)) {
        socket.connect()
        socket.write(Array&lt;Byte&gt;([1, 2, 3]))
    }

    return 0
}
</code></pre>
<h2 id="udp-编程"><a class="header" href="#udp-编程">Udp 编程</a></h2>
<p>Udp 作为一种常见的不可靠传输协议，以 Udp 类型套接字举例，仓颉在不可靠传输场景下的可参考的编程模型如下：</p>
<ol>
<li>创建套接字，并指定本端绑定地址。</li>
<li>执行绑定。</li>
<li>指定远端地址进行报文发送。</li>
<li>不连接远端地址场景下，可以收取来自不同远端地址的报文，并返回远端地址信息。</li>
</ol>
<p>Udp 收发报文程序示例如下：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.socket.*
import std.time.*
import std.sync.*

let SERVER_PORT: UInt16 = 8080

func runUpdServer() {
    try (serverSocket = UdpSocket(bindAt: SERVER_PORT)) {
        serverSocket.bind()

        let buf = Array&lt;Byte&gt;(3, item: 0)
        let (clientAddr, count) = serverSocket.receiveFrom(buf)
        let sender = clientAddr.hostAddress

        // 套接字收取到的报文以及远端地址: [1, 2, 3]， 127.0.0.1
        println(&quot;Server receive ${count} bytes: ${buf} from ${sender}&quot;)
    }
}

main(): Int64 {
    let future = spawn {
        runUpdServer()
    }
    sleep(Duration.second)

    try (udpSocket = UdpSocket(bindAt: 0)) {
        udpSocket.sendTimeout = Duration.second * 2
        udpSocket.bind()
        udpSocket.sendTo(
            SocketAddress(&quot;127.0.0.1&quot;, SERVER_PORT),
            Array&lt;Byte&gt;([1, 2, 3])
        )
    }

    future.get()

    return 0
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-编程"><a class="header" href="#http-编程">HTTP 编程</a></h1>
<p>HTTP 作为一种通用的应用层协议，通过请求-响应的机制实现数据传输，客户端发送请求，服务端返回响应。请求和响应的格式是固定的，由报文头和报文体组成。</p>
<p>常用的请求类型为 GET 和 POST，GET 请求只有报文头，用于向服务器请求应用层数据，POST 请求带有报文体，以一个空行与报文头进行分隔，用于向服务器提供应用层数据。</p>
<p>请求-响应的报文头字段内容较多，此处不再一一赘述，仓颉支持 HTTP 1.0/1.1/2.0 等协议版本，开发者可以基于协议 RFC 9110、9112、9113、9218、7541 以及仓颉所提供的 HttpRequestBuilder 和 HttpResponseBuilder 类构造请求及响应报文。</p>
<p>以下示例展示了如何使用仓颉进行客户端和服务端编程，实现的功能是客户端发送请求头为 GET /hello 的请求，服务端返回响应，响应体为 &quot;Hello Cangjie!&quot;，代码如下:</p>
<!-- run -->
<pre><code class="language-cangjie">import net.http.*
import std.time.*
import std.sync.*

func startServer(): Unit {
    // 1. 构建 Server 实例
    let server = ServerBuilder()
                        .addr(&quot;127.0.0.1&quot;)
                        .port(8080)
                        .build()
    // 2. 注册请求处理逻辑
    server.distributor.register(&quot;/hello&quot;, {httpContext =&gt;
        httpContext.responseBuilder.body(&quot;Hello Cangjie!&quot;)
    })
    // 3. 启动服务
    server.serve()
}

func startClient(): Unit {
    // 1. 构建 client 实例
    let client = ClientBuilder().build()
    // 2. 发送 request
    let resp = client.get(&quot;http://127.0.0.1:8080/hello&quot;)
    // 3. 读取response
    println(resp)
    // 4. 关闭连接
    client.close()
}

main () {
    spawn {
        startServer()
    }
    sleep(Duration.second)
    startClient()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="websocket-编程"><a class="header" href="#websocket-编程">WebSocket 编程</a></h1>
<p>在网络编程中，WebSocket 也是一种常用的应用层协议，与 HTTP 一样，它也基于 TCP 协议之上，并且常用于 web 服务端应用开发。</p>
<p>不同于 HTTP 的是， WebSocket 只需要客户端和服务端进行一次握手，即可创建长久的连接，并且进行双向的数据传输。即，基于 WebSocket 实现的服务端可以主动传输数据给客户端，从而实现实时通讯。</p>
<p>WebSocket 是一个独立的协议，它与 HTTP 的关联在于，它的握手被 HTTP 服务端解释为一个升级请求。因此，仓颉将 WebSocket 包含在 http 包中。</p>
<p>仓颉将 WebSocket 协议通信机制抽象为 WebSocket 类，提供方法将一个 http/1.1 或 http/2.0 服务端句柄升级到 WebSocket 协议实例，通过返回的 WebSocket 实例进行 WebSocket 通信，例如数据报文的读写。</p>
<p>在仓颉中，WebSocket 所传输的数据基本单元称为帧，帧分为两类，一类为传输控制信息的帧，即 Close Frame 用于关闭连接， Ping Frame 用于实现 Keep-Alive ， Pong Frame 是 Ping Frame 的响应类型，另一类是传输应用数据的帧，应用数据帧支持分段传输。</p>
<p>仓颉的帧由三个属性构成，其中 fin 和 frameType 共同说明了帧是否分段和帧的类型，payload 为帧的载荷，除此之外开发者无需关心其他属性即可进行报文传输。</p>
<p>如下示例展示了 WebSocket 的握手以及消息收发过程：创建 HTTP 客户端和服务端，分别发起 WebSocket 升级（或握手），握手成功后开始帧的读写。</p>
<!-- verify -->
<pre><code class="language-cangjie">import net.http.*
import encoding.url.*
import std.time.*
import std.sync.*
import std.collection.*
import std.log.*

let server = ServerBuilder()
                        .addr(&quot;127.0.0.1&quot;)
                        .port(0)
                        .build()

// client：
main() {
    // 1 启动服务器
    spawn { startServer() }
    sleep(Duration.millisecond * 200)

    let client = ClientBuilder().build()
    let u = URL.parse(&quot;ws://127.0.0.1:${server.port}/webSocket&quot;)

    let subProtocol = ArrayList&lt;String&gt;([&quot;foo1&quot;, &quot;bar1&quot;])
    let headers = HttpHeaders()
    headers.add(&quot;test&quot;, &quot;echo&quot;)

    // 2 完成 WebSocket 握手，获取 WebSocket 实例
    let websocket: WebSocket
    let respHeaders: HttpHeaders
    (websocket, respHeaders) = WebSocket.upgradeFromClient(client, u, subProtocols: subProtocol, headers: headers)
    client.close()

    println(&quot;subProtocol: ${websocket.subProtocol}&quot;)      // fool1
    println(respHeaders.getFirst(&quot;rsp&quot;) ?? &quot;&quot;) // echo

    // 3 消息收发
    // 发送 hello
    websocket.write(TextWebFrame, &quot;hello&quot;.toArray())
    // 收
    let data = ArrayList&lt;UInt8&gt;()
    var frame = websocket.read()
    while(true) {
        match(frame.frameType) {
            case ContinuationWebFrame =&gt;
                data.appendAll(frame.payload)
                if (frame.fin) {
                    break
                }
            case TextWebFrame | BinaryWebFrame =&gt;
                if (!data.isEmpty()) {
                    throw Exception(&quot;invalid frame&quot;)
                }
                data.appendAll(frame.payload)
                if (frame.fin) {
                    break
                }
            case CloseWebFrame =&gt;
                websocket.write(CloseWebFrame, frame.payload)
                break
            case PingWebFrame =&gt;
                websocket.writePongFrame(frame.payload)
            case _ =&gt; ()
        }
        frame = websocket.read()
    }
    println(&quot;data size: ${data.size}&quot;)      // 4097
    println(&quot;last item: ${String.fromUtf8(Array(data)[4096])}&quot;)        // a


    // 4 关闭 websocket，
    // 收发 CloseFrame
    websocket.writeCloseFrame(status: 1000)
    let websocketFrame = websocket.read()
    println(&quot;close frame type: ${websocketFrame.frameType}&quot;)      // CloseWebFrame
    println(&quot;close frame payload: ${websocketFrame.payload}&quot;)     // 3, 232
    // 关闭底层连接
    websocket.closeConn()

    server.close()
}

func startServer() {
    // 1 注册 handler
    server.distributor.register(&quot;/webSocket&quot;, handler1)
    server.logger.level = OFF
    server.serve()
}

// server:
func handler1(ctx: HttpContext): Unit {
    // 2 完成 websocket 握手，获取 websocket 实例
    let websocketServer = WebSocket.upgradeFromServer(ctx, subProtocols: ArrayList&lt;String&gt;([&quot;foo&quot;, &quot;bar&quot;, &quot;foo1&quot;]),
        userFunc: {request: HttpRequest =&gt;
            let value = request.headers.getFirst(&quot;test&quot;) ?? &quot;&quot;
            let headers = HttpHeaders()
            headers.add(&quot;rsp&quot;, value)
            headers
        })
    // 3 消息收发
    // 收 hello
    let data = ArrayList&lt;UInt8&gt;()
    var frame = websocketServer.read()
    while(true) {
        match(frame.frameType) {
            case ContinuationWebFrame =&gt;
                data.appendAll(frame.payload)
                if (frame.fin) {
                    break
                }
            case TextWebFrame | BinaryWebFrame =&gt;
                if (!data.isEmpty()) {
                    throw Exception(&quot;invalid frame&quot;)
                }
                data.appendAll(frame.payload)
                if (frame.fin) {
                    break
                }
            case CloseWebFrame =&gt;
                websocketServer.write(CloseWebFrame, frame.payload)
                break
            case PingWebFrame =&gt;
                websocketServer.writePongFrame(frame.payload)
            case _ =&gt; ()
        }
        frame = websocketServer.read()
    }
    println(&quot;data: ${String.fromUtf8(Array(data))}&quot;)    // hello
    // 发 4097 个 a
    websocketServer.write(TextWebFrame, Array&lt;UInt8&gt;(4097, item: 97))

    // 4 关闭 websocket，
    // 收发 CloseFrame
    let websocketFrame = websocketServer.read()
    println(&quot;close frame type: ${websocketFrame.frameType}&quot;)   // CloseWebFrame
    println(&quot;close frame payload: ${websocketFrame.payload}&quot;)     // 3, 232
    websocketServer.write(CloseWebFrame, websocketFrame.payload)
    // 关闭底层连接
    websocketServer.closeConn()
}
</code></pre>
<p>该示例运行结果如下：</p>
<pre><code class="language-text">subProtocol: foo1
echo
data: hello
data size: 4097
last item: a
close frame type: CloseWebFrame
close frame payload: [3, 232]
close frame type: CloseWebFrame
close frame payload: [3, 232]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="宏的简介"><a class="header" href="#宏的简介">宏的简介</a></h1>
<p>宏可以理解为一种特殊的函数。一般的函数在输入的值上进行计算，然后输出一个新的值，而宏的输入和输出都是程序本身。在输入一段程序（或程序片段，例如表达式），输出一段新的程序，这段输出的程序随后用于编译和执行。为了把宏的调用和函数调用区分开来，我们在调用宏时使用 <code>@</code> 加上宏的名称。</p>
<p>让我们从一个简单的例子开始：假设我们想在调试过程中打印某个表达式的值，同时打印出表达式本身。</p>
<pre><code class="language-cangjie">let x = 3
let y = 2
@dprint(x)        // 打印 &quot;x = 3&quot;
@dprint(x + y)    // 打印 &quot;x + y = 5&quot;
</code></pre>
<p>显然，<code>dprint</code> 不能被写为常规的函数，由于函数只能获得输入的值，不能获得输入的程序片段。但是，我们可以将 <code>dprint</code> 实现为一个宏。一个基本的实现如下：</p>
<pre><code class="language-cangjie">macro package define

import std.ast.*

public macro dprint(input: Tokens): Tokens {
    let inputStr = input.toString()
    let result = quote(
        print($(inputStr) + &quot; = &quot;)
        println($(input)))
    return result
}
</code></pre>
<p>在解释每行代码之前，我们先测试这个宏可以达到预期的效果。首先，在当前目录下创建一个 <code>macros</code> 文件夹，并在 <code>macros</code> 文件夹中创建 <code>dprint.cj</code> 文件，将以上内容复制到 <code>dprint.cj</code> 文件中。另外在当前目录下创建 <code>main.cj</code>，包含以下测试代码：</p>
<pre><code class="language-cangjie">import define.*

main() {
    let x = 3
    let y = 2
    @dprint(x)
    @dprint(x + y)
}
</code></pre>
<p>请注意，得到的目录结构如下：</p>
<pre><code>// Directory layout.
src
|-- macros
|     `-- dprint.cj
`-- main.cj
</code></pre>
<p>在当前目录（<code>src</code>）下，运行编译命令：</p>
<pre><code class="language-bash">cjc macros/*.cj --compile-macro
cjc main.cj -o main
</code></pre>
<p>然后运行 <code>./main</code>，可以看到如下输出：</p>
<pre><code>x = 3
x + y = 5
</code></pre>
<p>让我们依次查看代码的每个部分：</p>
<ul>
<li>
<p>第 1 行：<code>macro package define</code></p>
<p>宏必须声明在独立的包中（不能和其他 public 函数一起），含有宏的包使用 <code>macro package</code> 来声明。这里我们声明了一个名为 <code>define</code> 的宏包。</p>
</li>
<li>
<p>第 2 行：<code>import std.ast.*</code></p>
<p>实现宏需要的数据类型，例如 <code>Tokens</code> 和后面会讲到的语法节点类型，位于仓颉标准库的 <code>ast</code> 包中，因此任何宏的实现都需要首先引入 <code>ast</code> 包。</p>
</li>
<li>
<p>第 3 行：<code>public macro dprint(input: Tokens): Tokens</code></p>
<p>在这里我们声明一个名为 <code>dprint</code> 的宏。由于这个宏是一个非属性宏（之后我们会解释这个概念），它接受一个类型为 <code>Tokens</code> 的参数。该输入代表传给宏的程序片段。宏的返回值也是一个程序片段。</p>
</li>
<li>
<p>第 4 行：<code>let inputStr = input.toString()</code></p>
<p>在宏的实现中，首先将输入的程序片段转化为字符串。在前面的测试案例中，<code>inputStr</code> 成为 <code>&quot;x&quot;</code> 或 <code>&quot;x + y&quot;</code></p>
</li>
<li>
<p>第 5-7 行：<code>let result = quote(...)</code></p>
<p>这里 <code>quote</code> 表达式是用于构造 <code>Tokens</code> 的一种表达式，它将括号内的程序片段转换为 <code>Tokens</code>。在 <code>quote</code> 的输入中，可以使用插值 <code>$(...)</code> 来将括号内的表达式转换为 <code>Tokens</code>，然后插入到 <code>quote</code> 构建的 <code>Tokens</code> 中。对于以上代码，<code>$(inputStr)</code> 插入 <code>inputStr</code> 字符串的值（包含字符串两端的引号），<code>$(input)</code> 插入 <code>input</code>，即输入的程序片段。因此，如果输入的表达式是 <code>x + y</code>，那么形成的<code>Tokens</code>为：</p>
<pre><code>print(&quot;x + y&quot; + &quot; = &quot;)
println(x + y)
</code></pre>
</li>
<li>
<p>第 8 行：<code>return result</code></p>
<p>最后，我们将构造出来的代码返回，这两行代码将被编译，运行时将输出 <code>x + y = 5</code>。</p>
</li>
</ul>
<p>回顾 <code>dprint</code> 宏的定义，我们看到 <code>dprint</code> 使用 <code>Tokens</code> 作为入参，并使用 <code>quote</code> 和插值构造了另一个 <code>Tokens</code> 作为返回值。为了使用仓颉宏，我们需要详细了解 <code>Tokens</code>、<code>quote</code> 和插值的概念，下面我们将分别介绍它们。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tokens-相关类型和-quote-表达式"><a class="header" href="#tokens-相关类型和-quote-表达式">Tokens 相关类型和 quote 表达式</a></h1>
<h2 id="token-类型"><a class="header" href="#token-类型">Token 类型</a></h2>
<p>宏操作的基本类型是 <code>Tokens</code>，代表一个程序片段。<code>Tokens</code> 由若干个 <code>Token</code> 组成，每个 <code>Token</code> 可以理解为用户可操作的词法单元。一个 <code>Token</code> 可能是一个标识符（例如变量名等）、字面量（例如整数、浮点数、字符串）、关键字或运算符。每个 <code>Token</code> 包含它的类型、内容和位置信息。</p>
<p><code>Token</code> 的类型取值为 enum <code>TokenKind</code> 中的元素。<code>TokenKind</code> 的可用值详见《仓颉编程语言库 API》文档。通过提供 <code>TokenKind</code> 和（对于标识符和字面量）<code>Token</code> 的字符串，可以直接构造任何 <code>Token</code>。具体的构造函数如下：</p>
<pre><code class="language-cangjie">Token(k: TokenKind)
Token(k: TokenKind, v: String)
</code></pre>
<p>下面给出一些<code>Token</code>构造的例子：</p>
<pre><code>import std.ast.*

let tk1 = Token(TokenKind.ADD)   // '+'运算符
let tk2 = Token(TokenKind.FUNC)   // func关键字
let tk3 = Token(TokenKind.IDENTIFIER, &quot;x&quot;)   // x标识符
let tk4 = Token(TokenKind.INTEGER_LITERAL, &quot;3&quot;)  // 整数字面量
let tk5 = Token(TokenKind.STRING_LITERAL, &quot;xyz&quot;)  // 字符串字面量
</code></pre>
<h2 id="tokens-类型"><a class="header" href="#tokens-类型">Tokens 类型</a></h2>
<p>一个 <code>Tokens</code> 代表由多个 <code>Token</code> 组成的序列。我们可以通过 <code>Token</code> 数组直接构造 <code>Tokens</code>。下面是 3 种基本的构造 <code>Tokens</code> 实例的方式：</p>
<pre><code class="language-cangjie">Tokens()   // 构造空列表
Tokens(tks: Array&lt;Token&gt;)
Tokens(tks: ArrayList&lt;Token&gt;)
</code></pre>
<p>此外，<code>Tokens</code> 类型支持以下函数：</p>
<ul>
<li><code>size</code>：返回 <code>Tokens</code> 中包含 <code>Token</code> 的数量</li>
<li><code>get(index: Int64)</code>：获取指定下标的 <code>Token</code> 元素</li>
<li><code>[]</code>：获取指定下标的 <code>Token</code> 元素</li>
<li><code>+</code>：拼接两个 <code>Tokens</code>，或者直接拼接 <code>Tokens</code> 和 <code>Token</code></li>
<li><code>dump()</code>：打印包含的所有 <code>Token</code>，供调试使用</li>
<li><code>toString()</code>：打印 <code>Tokens</code> 对应的程序片段</li>
</ul>
<p>在下面的案例中，我们使用构造函数直接构造 <code>Token</code> 和 <code>Tokens</code>，然后打印详细的调试信息：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.ast.*

let tks = Tokens(Array&lt;Token&gt;([
    Token(TokenKind.INTEGER_LITERAL, &quot;1&quot;),
    Token(TokenKind.ADD),
    Token(TokenKind.INTEGER_LITERAL, &quot;2&quot;)
]))
main() {
    println(tks)
    tks.dump()
}
</code></pre>
<p>预期输出如下（具体的位置信息可能不同）：</p>
<pre><code>1 + 2
description: integer_literal, token_id: 140, token_literal_value: 1, fileID: 1, line: 4, column: 5
description: add, token_id: 12, token_literal_value: +, fileID: 1, line: 5, column: 5
description: integer_literal, token_id: 140, token_literal_value: 2, fileID: 1, line: 6, column: 5
</code></pre>
<p>在 dump 信息中，包含了每个 <code>Token</code> 的类型（<code>description</code>）和值（<code>token_literal_value</code>），最后打印每个 <code>Token</code> 的位置信息。</p>
<h2 id="quote-表达式和插值"><a class="header" href="#quote-表达式和插值">quote 表达式和插值</a></h2>
<p>在大多数情况下，直接构造和拼接 <code>Tokens</code> 会比较繁琐。因此，仓颉语言提供了 <code>quote</code> 表达式来从代码模版来构造 <code>Tokens</code>。之所以说是代码模版，因为在 <code>quote</code> 中可以使用 <code>$(...)</code> 来插入上下文中的表达式。插入的表达式的类型需要支持被转换为 <code>Tokens</code>（具体来说，实现了 <code>ToTokens</code> 接口）。在标准库中，以下类型实现了 <code>ToTokens</code> 接口：</p>
<ul>
<li>所有的节点类型（节点将在<a href="source_zh_cn/Macro/./sytax_node.html">语法节点</a>中讨论）</li>
<li><code>Token</code> 和 <code>Tokens</code> 类型</li>
<li>所有基础数据类型：整数、浮点数、<code>Bool</code>、<code>Rune</code>和<code>String</code></li>
<li><code>Array&lt;T&gt;</code> 和 <code>ArrayList&lt;T&gt;</code>，这里对 <code>T</code> 的类型有限制，并根据 <code>T</code> 的类型不同，输出不同的分隔符，详细请见《仓颉编程语言库 API》文档。</li>
</ul>
<p>下面的例子展示 <code>Array</code> 和基础数据类型的插值。</p>
<!-- run -->
<pre><code class="language-cangjie">import std.ast.*

let intList = Array&lt;Int64&gt;([1, 2, 3, 4, 5])
let float: Float64 = 1.0
let str: String = &quot;Hello&quot;
let tokens = quote(
    arr = $(intList)
    x = $(float)
    s = $(str)
)

main() {
    println(tokens)
}
</code></pre>
<p>输出结果是：</p>
<pre><code>arr =[1, 2, 3, 4, 5]
x = 1.000000
s = &quot;Hello&quot;
</code></pre>
<p>更多插值的用法可以参考  <a href="source_zh_cn/Macro/./sytax_node.html#%E4%BD%BF%E7%94%A8-quote-%E6%8F%92%E5%80%BC%E8%AF%AD%E6%B3%95%E8%8A%82%E7%82%B9">使用 quote 插值语法节点</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="语法节点"><a class="header" href="#语法节点">语法节点</a></h1>
<p>在仓颉语言的编译过程中，首先通过词法分析将代码转换成 <code>Tokens</code>，然后对 <code>Tokens</code> 进行语法解析，得到一个语法树。每个语法树的节点可能是一个表达式、声明、类型、模式等。仓颉 <code>ast</code> 库提供了每种节点对应的类，它们之间具有适当的继承关系。其中，主要的抽象类如下：</p>
<ul>
<li><code>Node</code>：所有语法节点的父类</li>
<li><code>TypeNode</code>：所有类型节点的父类</li>
<li><code>Expr</code>：所有表达式节点的父类</li>
<li><code>Decl</code>：所有声明节点的父类</li>
<li><code>Pattern</code>：所有模式节点的父类</li>
</ul>
<p>具体节点的类型众多，具体细节请参考 《仓颉编程语言库 API》文档。在下面的案例中，我们主要使用以下节点：</p>
<ul>
<li><code>BinaryExpr</code>：二元运算表达式</li>
<li><code>FuncDecl</code>：函数的声明</li>
</ul>
<h2 id="节点的解析"><a class="header" href="#节点的解析">节点的解析</a></h2>
<p>通过 <code>ast</code> 库，基本上每种节点都可以从 <code>Tokens</code> 解析。有两种调用解析的方法。</p>
<h3 id="使用解析表达式和声明的函数"><a class="header" href="#使用解析表达式和声明的函数">使用解析表达式和声明的函数。</a></h3>
<p>以下函数用于从 <code>Tokens</code> 解析任意的表达式或任意的声明：</p>
<ul>
<li><code>parseExpr(input: Tokens): Expr</code>：将输入的 <code>Tokens</code> 解析为表达式</li>
<li><code>parseExprFragment(input: Tokens, startFrom!: Int64 = 0): (Expr, Int64)</code>：将输入 <code>Tokens</code> 的一个片段解析为表达式，片段从 <code>startFrom</code> 索引开始，解析可能只消耗从索引 <code>startFrom</code> 开始的片段的一部分，并返回第一个未被消耗的 <code>Token</code> 的索引（如果消耗了整个片段，返回值为 <code>input.size</code>）</li>
<li><code>parseDecl(input: Tokens, astKind!: String = &quot;&quot;)</code>：将输入的 <code>Tokens</code> 解析为声明，<code>astKind</code> 为额外的设置，具体请见《仓颉编程语言库 API》文档。</li>
<li><code>parseDeclFragment(input: Tokens, startFrom!: Int64 = 0): (Decl, Int64)</code>：将输入 <code>Tokens</code> 的一个片段解析为声明，<code>startFrom</code> 参数和返回索引的含义和 <code>parseExpr</code> 相同。</li>
</ul>
<p>我们通过代码案例展示这些函数的使用：</p>
<pre><code class="language-cangjie">let tks1 = quote(a + b)
let tks2 = quote(a + b, x + y)
let tks3 = quote(
    func f1(x: Int64) { return x + 1 }
)
let tks4 = quote(
    func f1(x: Int64) { return x + 1 }
    func f2(x: Int64) { return x + 2 }
)

let binExpr1 = parseExpr(tks1)
println(&quot;binExpr1 is BinaryExpr: ${binExpr1 is BinaryExpr}&quot;)
let (binExpr2, mid) = parseExprFragment(tks2)
let (binExpr3, end) = parseExprFragment(tks2, startFrom: mid + 1) // 跳过逗号
println(&quot;size = ${tks2.size}, mid = ${mid}, end = ${end}&quot;)
let funcDecl1 = parseDecl(tks3)
println(&quot;funcDecl1 is FuncDecl: ${funcDecl1 is FuncDecl}&quot;)
let (funcDecl2, mid2) = parseDeclFragment(tks4)
let (funcDecl3, end2) = parseDeclFragment(tks4, startFrom: mid2)
println(&quot;size = ${tks4.size}, mid = ${mid2}, end = ${end2}&quot;)
</code></pre>
<p>输出结果是：</p>
<pre><code>binExpr1 is BinaryExpr: true
size = 7, mid = 3, end = 7
funcDecl1 is FuncDecl: true
size = 29, mid = 15, end = 29
</code></pre>
<h3 id="使用构造函数进行解析"><a class="header" href="#使用构造函数进行解析">使用构造函数进行解析</a></h3>
<p>大多数节点类型都支持 <code>init(input: Tokens)</code> 构造函数，将输入的 <code>Tokens</code> 解析为相应类型的节点，例如：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.ast.*

let binExpr = BinaryExpr(quote(a + b))
let funcDecl = FuncDecl(quote(func f1(x: Int64) { return x + 1 }))
</code></pre>
<p>如果解析失败将抛出异常。这种解析方式适用于类型已知的代码片段，解析后不需要再手动转换成具体的子类型。</p>
<h2 id="节点的组成部分"><a class="header" href="#节点的组成部分">节点的组成部分</a></h2>
<p>从 <code>Tokens</code> 解析出节点之后，我们可以查看节点的组成部分。作为例子，我们列出 <code>BinaryExpr</code> 和 <code>FuncDecl</code> 的组成部分，关于其他节点的更详细的解释请见《仓颉编程语言库 API》文档。</p>
<ul>
<li><code>BinaryExpr</code> 节点：
<ul>
<li><code>leftExpr: Expr</code>：运算符左侧的表达式</li>
<li><code>op: Token</code>：运算符</li>
<li><code>rightExpr: Expr</code>：运算符右侧的表达式</li>
</ul>
</li>
<li><code>FuncDecl</code> 节点（部分）：
<ul>
<li><code>identifier: Token</code>：函数名</li>
<li><code>funcParams: ArrayList&lt;FuncParam&gt;</code>：参数列表</li>
<li><code>declType: TypeNode</code>：返回值类型</li>
<li><code>block: Block</code>：函数体</li>
</ul>
</li>
<li><code>FuncParam</code>节点（部分）：
<ul>
<li><code>identifier: Token</code>：参数名</li>
<li><code>paramType: TypeNode</code>：参数类型</li>
</ul>
</li>
<li><code>Block</code>节点（部分）：
<ul>
<li><code>nodes: ArrayList&lt;Node&gt;</code>：块中的表达式和声明</li>
</ul>
</li>
</ul>
<p>每个组成部分都是 <code>public mut prop</code>，因此可以被查看和更新。我们通过一些例子展示更新的结果。</p>
<h3 id="binaryexpr-案例"><a class="header" href="#binaryexpr-案例">BinaryExpr 案例</a></h3>
<!-- run -->
<pre><code class="language-cangjie">let binExpr = BinaryExpr(quote(x * y))
binExpr.leftExpr = BinaryExpr(quote(a + b))
println(binExpr.toTokens())

binExpr.op = Token(TokenKind.ADD)
println(binExpr.toTokens())
</code></pre>
<p>输出结果是：</p>
<pre><code>(a + b) * y
a + b + y
</code></pre>
<p>首先，通过解析，获得 <code>binExpr</code> 为节点 <code>x * y</code>，图示如下：</p>
<pre><code>    *
  /   \
 x     y
</code></pre>
<p>第二步，我们将左侧的节点（即 <code>x</code>）替换为 <code>a + b</code>，因此，获得的语法树如下：</p>
<pre><code>      *
    /   \
   +     y
  / \
 a   b
</code></pre>
<p>当输出这个语法树的时候，我们必须在 <code>a + b</code> 周围添加括号，得到 <code>(a + b) * y</code>（如果输出<code>a + b * y</code>，含义为先做乘法，再做加法，与语法树的含义不同）。<strong><code>ast</code> 库具备在输出语法树时自动添加括号的功能</strong>。</p>
<p>第三步，我们将语法树根部的运算符从 <code>*</code> 替换为 <code>+</code>，因此得到语法树如下：</p>
<pre><code>      +
    /   \
   +     y
  / \
 a   b
</code></pre>
<p>这个语法树可以输出为 <code>a + b + y</code>，因为加法本身就是左结合的，不需要在左侧添加括号。</p>
<h3 id="funcdecl-案例"><a class="header" href="#funcdecl-案例">FuncDecl 案例</a></h3>
<pre><code class="language-cangjie">let funcDecl = FuncDecl(quote(func f1(x: Int64) { x + 1 }))
funcDecl.identifier = Token(TokenKind.IDENTIFIER, &quot;foo&quot;)
println(&quot;Number of parameters: ${funcDecl.funcParams.size}&quot;)
funcDecl.funcParams[0].identifier = Token(TokenKind.IDENTIFIER, &quot;a&quot;)
println(&quot;Number of nodes in body: ${funcDecl.block.nodes.size}&quot;)
let binExpr = (funcDecl.block.nodes[0] as BinaryExpr).getOrThrow()
binExpr.leftExpr = parseExpr(quote(a))
println(funcDecl.toTokens())
</code></pre>
<p>在这个案例中，我们首先通过解析构造出了一个 <code>FuncDecl</code> 节点，然后分别修改了该节点的函数名、参数名，以及函数体中表达式的一部分。输出结果是：</p>
<pre><code>Number of parameters: 1
Number of nodes in body: 1
func foo(a: Int64) {
    a + 1
}
</code></pre>
<h2 id="使用-quote-插值语法节点"><a class="header" href="#使用-quote-插值语法节点">使用 quote 插值语法节点</a></h2>
<p>任何 AST 节点都可以在 <code>quote</code> 语句中插值，部分 AST 节点的 <code>ArrayList</code> 列表也可以被插值（主要对应实际情况中会出现这类节点列表的情况）。插值直接通过 <code>$(node)</code> 表达即可，其中 <code>node</code> 是任意节点类型的实例。</p>
<p>下面，我们通过一些案例展示节点的插值。</p>
<!-- run -->
<pre><code class="language-cangjie">var binExpr = BinaryExpr(quote(1 + 2))
let a = quote($(binExpr))
let b = quote($binExpr)
let c = quote($(binExpr.leftExpr))
let d = quote($binExpr.leftExpr)
println(&quot;a: ${a.toTokens()}&quot;)
println(&quot;b: ${b.toTokens()}&quot;)
println(&quot;c: ${c.toTokens()}&quot;)
println(&quot;d: ${d.toTokens()}&quot;)
</code></pre>
<p>输出结果是：</p>
<pre><code>a: 1 + 2
b: 1 + 2
c: 1
d: 1 + 2.leftExpr
</code></pre>
<p>一般来说，插值运算符后面的表达式使用小括号限定作用域，例如 <code>$(binExpr)</code>。但是当后面只跟单个标识符的时候，小括号可省略，即可写为 <code>$binExpr</code>。因此，在案例中 <code>a</code> 和 <code>b</code> 都在 <code>quote</code> 中插入了 <code>binExpr</code>节点，结果为 <code>1 + 2</code>。然而，如果插值运算符后面的表达式更复杂，不加小括号可能造成作用域出错。例如，表达式 <code>binExpr.leftExpr</code> 求值为 <code>1 + 2</code> 的左表达式，即 <code>1</code>，因此 <code>c</code> 正确赋值为 <code>1</code>。但 <code>d</code> 中的插值被解释为 <code>($binExpr).leftExpr</code>，因此结果是 <code>1 + 2.leftExpr</code>。为了明确插值的作用域，我们推荐在插值运算符中使用小括号。</p>
<p>下面的案例展示节点列表（<code>ArrayList</code>）的插值。</p>
<pre><code class="language-cangjie">var incrs = ArrayList&lt;Node&gt;()
for (i in 1..=5) {
    incrs.append(parseExpr(quote(x += $(i))))
}
var foo = quote(
    func foo(n: Int64) {
        let x = n
        $(incrs)
        x
    })
println(foo)
</code></pre>
<p>输出结果是：</p>
<pre><code>func foo(n: Int64) {
    let x = n
    x += 1
    x += 2
    x += 3
    x += 4
    x += 5
    x
}
</code></pre>
<p>在这个案例中，我们创建了一个节点列表 <code>incrs</code>，包含表达式 <code>x += 1</code>，...，<code>x += 5</code>。对 <code>incrs</code> 的插值将节点依次列出，在每个节点后换行。这适用于插入需要依次执行的表达式和声明的情况。</p>
<p>下面的案例展示在某些情况下，需要在插值周围添加括号，以保证正确性。</p>
<!-- run -->
<pre><code class="language-cangjie">var binExpr1 = BinaryExpr(quote(x + y))
var binExpr2 = BinaryExpr(quote($(binExpr1) * z))       // 错误：得到 x + y * z
println(&quot;binExpr2: ${binExpr2.toTokens()}&quot;)
println(&quot;binExpr2.leftExpr: ${binExpr2.leftExpr.toTokens()}&quot;)
println(&quot;binExpr2.rightExpr: ${binExpr2.rightExpr.toTokens()}&quot;)
var binExpr3 = BinaryExpr(quote(($(binExpr1)) * z))     // 正确：得到 (x + y) * z
println(&quot;binExpr3: ${binExpr3.toTokens()}&quot;)
</code></pre>
<p>输出结果是：</p>
<pre><code>binExpr2: x + y * z
binExpr2.leftExpr: x
binExpr2.rightExpr: y * z
binExpr3: (x + y) * z
</code></pre>
<p>首先，我们构建了表达式 <code>x + y</code>，然后将该表达式插入到模版 <code>$(binExpr1) * z</code> 中。这里的意图是得到一个先计算 <code>x + y</code>，然后再乘 <code>z</code> 的表达式，但是，插值的结果是 <code>x + y * z</code>，先做 <code>y * z</code>，然后再加 <code>x</code>。这是因为插值不会自动添加括号以保证被插入的表达式的原子性（这和前一阶介绍的 <code>leftExpr</code> 的替换不同）。因此，需要在 <code>$(binExpr1)</code> 周围添加小括号，保证得到正确的结果。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="宏的实现"><a class="header" href="#宏的实现">宏的实现</a></h1>
<p>本章节介绍仓颉宏的定义和使用，仓颉宏可以分为<a href="source_zh_cn/Macro/implementation_of_macros.html#%E9%9D%9E%E5%B1%9E%E6%80%A7%E5%AE%8F">非属性宏</a>和<a href="source_zh_cn/Macro/implementation_of_macros.html#%E5%B1%9E%E6%80%A7%E5%AE%8F">属性宏</a>。同时本章节还会介绍宏出现嵌套时的行为。</p>
<h2 id="非属性宏"><a class="header" href="#非属性宏">非属性宏</a></h2>
<p>非属性宏只接受被转换的代码，不接受其他参数（属性），其定义格式如下：</p>
<pre><code class="language-cangjie">import std.ast.*

public macro MacroName(args: Tokens): Tokens {
    ... // Macro body
}
</code></pre>
<p>宏的调用格式如下：</p>
<pre><code class="language-cangjie">@MacroName(...)
</code></pre>
<p>宏调用使用 <code>()</code> 括起来。括号里面可以是任意合法 <code>tokens</code>，也可以是空。</p>
<p>当宏作用于声明时，一般可以省略括号。参考下面例子</p>
<pre><code class="language-cangjie">@MacroName func name() {}        // Before a FuncDecl
@MacroName struct name {}        // Before a StructDecl
@MacroName class name {}         // Before a ClassDecl
@MacroName var a = 1             // Before a VarDecl
@MacroName enum e {}             // Before a Enum
@MacroName interface i {}        // Before a InterfaceDecl
@MacroName extend e &lt;: i {}      // Before a ExtendDecl
@MacroName mut prop i: Int64 {}  // Before a PropDecl
@MacroName @AnotherMacro(input)  // Before a macro call
</code></pre>
<p>宏展开过程作用于仓颉语法树，宏展开后，编译器会继续进行后续的编译过程，因此，用户需要保证宏展开后的代码依然是合法的仓颉代码，否则可能引发编译问题。当宏用于声明时，如果省略括号，宏的输入必须是语法合法的声明，IDE 也会提供相应的语法检查和高亮。</p>
<p>下面是几个宏应用的典型示例。</p>
<ul>
<li>
<p>示例 1</p>
<p>宏定义文件 <code>macro_definition.cj</code></p>
<pre><code class="language-cangjie">macro package macro_definition

import std.ast.*

public macro TestDef(input: Tokens): Tokens {
    println(&quot;I'm in macro body&quot;)
    return input
}
</code></pre>
<p>宏调用文件 <code>macro_call.cj</code></p>
<pre><code class="language-cangjie">package macro_calling

import macro_definition.*

main(): Int64 {
    println(&quot;I'm in function body&quot;)
    let a: Int64 = @TestDef(1 + 2)
    println(&quot;a = ${a}&quot;)
    return 0
}
</code></pre>
<p>上述代码的编译过程可以参考<a href="source_zh_cn/Macro/./compiling_error_reporting_and_debugging.html#%E5%AE%8F%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E4%BD%BF%E7%94%A8">宏的编译和使用</a>。</p>
<p>我们在用例中添加了打印信息，其中宏定义中的 <code>I'm in macro body</code> 将在编译 <code>macro_call.cj</code> 的期间输出，即对宏定义求值。同时，宏调用点被展开，如编译如下代码：</p>
<pre><code class="language-cangjie">let a: Int64 = @TestDef(1 + 2)
</code></pre>
<p>编译器将宏返回的 <code>Tokens</code> 更新到调用点的语法树上，得到如下代码：</p>
<pre><code class="language-cangjie">let a: Int64 = 1 + 2
</code></pre>
<p>也就是说，可执行程序中的代码实际变为了：</p>
<pre><code class="language-cangjie">main(): Int64 {
    println(&quot;I'm in function body&quot;)
    let a: Int64 = 1 + 2
    println(&quot;a = ${a}&quot;)
    return 0
}
</code></pre>
<p><code>a</code> 经过计算得到的值为 3，在打印 <code>a</code> 的值时插值为 3。至此，上述程序的运行结果为：</p>
<pre><code class="language-text">I'm in function body
a = 3
</code></pre>
</li>
</ul>
<p>下面看一个更有意义的用宏处理函数的例子，这个宏 ModifyFunc 宏的作用是给 MyFunc 增加 Composer 参数，并在<code>counter++</code>前后插入一段代码。</p>
<ul>
<li>
<p>示例 2</p>
<p>宏定义文件 <code>macro_definition.cj</code></p>
<pre><code class="language-cangjie">// file macro_definition.cj
macro package macro_definition

import std.ast.*

public macro ModifyFunc(input: Tokens): Tokens {
    println(&quot;I'm in macro body&quot;)
    let funcDecl = FuncDecl(input)
    return quote(
    func $(funcDecl.identifier)(id: Int64) {
        println(&quot;start ${id}&quot;)
        $(funcDecl.block.nodes)
        println(&quot;end&quot;)
    })
}
</code></pre>
<p>宏调用文件 <code>macro_call.cj</code></p>
<pre><code>package macro_calling

import macro_definition.*

var counter = 0

@ModifyFunc
func MyFunc() {
    counter++
}

func exModifyFunc() {
    println(&quot;I'm in function body&quot;)
    MyFunc(123)
    println(&quot;MyFunc called: ${counter} times&quot;)
    return 0
}
</code></pre>
<p>同样的，上述两段代码分别位于不同文件中，先编译宏定义文件 <code>macro_definition.cj</code>，再编译宏调用 <code>macro_call.cj</code> 生成可执行文件。</p>
<p>这个例子中，ModifyFunc 宏的输入是一个函数声明，因此可以省略括号：</p>
<pre><code class="language-cangjie">@ModifyFunc
func MyFunc() {
    counter++
}
</code></pre>
<p>经过宏展开后，得到如下代码：</p>
<pre><code class="language-cangjie">func MyFunc(id: Int64) {
    println(&quot;start ${id}&quot;)
    counter++
    println(&quot;end&quot;)
}
</code></pre>
<p>MyFunc 会在 main 中调用，它接受的实参也是在 main 中定义的，从而形成了一段合法的仓颉程序。运行时打印如下：</p>
<pre><code class="language-text">I'm in function body
start 123
end
MyFunc called: 1 times
</code></pre>
</li>
</ul>
<h2 id="属性宏"><a class="header" href="#属性宏">属性宏</a></h2>
<p>和非属性宏相比，属性宏的定义会增加一个 Tokens 类型的输入，这个增加的入参可以让开发者输入额外的信息。比如开发者可能希望在不同的调用场景下使用不同的宏展开策略，则可以通过这个属性入参进行标记位设置。同时，这个属性入参也可以传入任意 Tokens，这些 Tokens 可以与被宏修饰的代码进行组合拼接等。下面是一个简单的例子：</p>
<pre><code class="language-cangjie">// Macro definition with attribute
public macro Foo(attrTokens: Tokens, inputTokens: Tokens): Tokens {
    return attrTokens + inputTokens  // Concatenate attrTokens and inputTokens.
}
</code></pre>
<p>如上面的宏定义，属性宏的入参数量为 2，入参类型为 <code>Tokens</code>，在宏定义内，可以对 <code>attrTokens</code> 和 <code>inputTokens</code> 进行一系列的组合、拼接等变换操作，最后返回新的 <code>Tokens</code>。</p>
<p>带属性的宏与不带属性的宏的调用类似，属性宏调用时新增的入参 attrTokens 通过 [] 传入，其调用形式为：</p>
<pre><code class="language-cangjie">// attribute macro with parentheses
var a: Int64 = @Foo[1+](2+3)

// attribute macro without parentheses
@Foo[public]
struct Data {
    var count: Int64 = 100
}
</code></pre>
<ul>
<li>
<p>宏 Foo 调用，当参数是 <code>2+3</code> 时，与 <code>[]</code> 内的属性 <code>1+</code> 进行拼接，经过宏展开后，得到 <code>var a: Int64 = 1+2+3</code> 。</p>
</li>
<li>
<p>宏 Foo 调用，当参数是 struct Data 时，与 <code>[]</code> 内的属性 <code>public</code> 进行拼接，经过宏展开后，得到</p>
<pre><code class="language-cangjie">public struct Data {
    var count: Int64 = 100
}
</code></pre>
</li>
</ul>
<p>关于属性宏，需要注意以下几点：</p>
<ul>
<li>
<p>带属性的宏，与不带属性的宏相比，能修饰的 AST 是相同的，可以理解为带属性的宏对可传入参数做了增强。</p>
</li>
<li>
<p>要求属性宏调用时，<code>[]</code> 内中括号匹配，且可以为空。中括号内只允许对中括号的转义 <code>\[</code> 或 <code>\]</code>，该转义中括号不计入匹配规则，其他字符会被作为 Token，不能进行转义。</p>
<pre><code class="language-cangjie">@Foo[[miss one](2+3) // Illegal
@Foo[[matched]](2+3) // Legal
@Foo[](2+3)          // Legal, empty in []
@Foo[\[](2+3)        // Legal, use escape for [
@Foo[\(](2+3)        // Illegal, only [ and ] allowed in []
</code></pre>
</li>
<li>
<p>宏的定义和调用的类型要保持一致：如果宏定义有两个入参，即为属性宏定义，调用时必须加上 <code>[]</code>，且内容可以为空；如果宏定义有一个入参，即为非属性宏定义，调用时不能使用 <code>[]</code>。</p>
</li>
</ul>
<h2 id="嵌套宏"><a class="header" href="#嵌套宏">嵌套宏</a></h2>
<p>仓颉语言不支持宏定义的嵌套；有条件地支持在宏定义和宏调用中嵌套宏调用。</p>
<h3 id="宏定义中嵌套宏调用"><a class="header" href="#宏定义中嵌套宏调用">宏定义中嵌套宏调用</a></h3>
<p>下面是一个宏定义中包含其他宏调用的例子。</p>
<p>宏包 <code>pkg1</code> 中定义 <code>GetIdent</code> 宏：</p>
<pre><code class="language-cangjie">macro package pkg1

import std.ast.*

public macro GetIdent(attr:Tokens, input:Tokens):Tokens {
    return quote(
        let decl = (parseDecl(input) as VarDecl).getOrThrow()
        let name = decl.identifier.value
        let size = name.size - 1
        let $(attr) = Token(TokenKind.IDENTIFIER, name[0..size])
    )
}
</code></pre>
<p>宏包 <code>pkg2</code> 中定义 <code>Prop</code> 宏，其中嵌套了 <code>GetIdent</code> 宏的调用：</p>
<pre><code class="language-cangjie">macro package pkg2

import std.ast.*
import pkg1.*

public macro Prop(input:Tokens):Tokens {
    let v = parseDecl(input)
    @GetIdent[ident](input)
    return quote(
        $(input)
        public prop $(ident): $(decl.declType) {
            get() {
                this.$(v.identifier)
            }
        }
    )
}
</code></pre>
<p>宏调用包 <code>pkg3</code>  中调用 <code>Prop</code> 宏：</p>
<pre><code class="language-cangjie">package pkg3

import pkg2.*
class A {
    @Prop
    private let a_: Int64 = 1
}

main() {
    let b = A()
    println(&quot;${b.a}&quot;)
}
</code></pre>
<p>注意，按照宏定义必须比宏调用点先编译的约束，上述 3 个文件的编译顺序必须是：pkg1 -&gt; pkg2 -&gt; pkg3。pkg2 中的 <code>Prop</code> 宏定义：</p>
<pre><code class="language-cangjie">public macro Prop(input:Tokens):Tokens {
    let v = parseDecl(input)
    @GetIdent[ident](input)
    return quote(
        $(input)
        public prop $(ident): $(decl.declType) {
            get() {
                this.$(v.identifier)
            }
        }
    )
}
</code></pre>
<p>会先被展开成如下代码，再进行编译。</p>
<pre><code class="language-cangjie">public macro Prop(input: Tokens): Tokens {
    let v = parseDecl(input)

    let decl = (parseDecl(input) as VarDecl).getOrThrow()
    let name = decl.identifier.value
    let size = name.size - 1
    let ident = Token(TokenKind.IDENTIFIER, name[0 .. size])

    return quote(
        $(input)
        public prop $(ident): $(decl.declType) {
            get() {
                this.$(v.identifier)
            }
        }
    )
}
</code></pre>
<h3 id="宏调用中嵌套宏调用"><a class="header" href="#宏调用中嵌套宏调用">宏调用中嵌套宏调用</a></h3>
<p>嵌套宏的常见场景，是宏修饰的代码块中，出现了宏调用。一个具体的例子如下：</p>
<p><code>pkg1</code> 包中定义 <code>Foo</code> 和 <code>Bar</code> 宏：</p>
<pre><code class="language-cangjie">macro package pkg1

import std.ast.*

public macro Foo(input: Tokens): Tokens {
    return input
}

public macro Bar(input: Tokens): Tokens {
    return input
}
</code></pre>
<p><code>pkg2</code> 包中定义 <code>AddToMul</code> 宏：</p>
<pre><code class="language-cangjie">macro package pkg2

import std.ast.*

public macro AddToMul(inputTokens: Tokens): Tokens {
    var expr: BinaryExpr = match (parseExpr(inputTokens) as BinaryExpr) {
        case Some(v) =&gt; v
        case None =&gt; throw Exception()
    }
    var op0: Expr = expr.leftExpr
    var op1: Expr = expr.rightExpr
    return quote(($(op0)) * ($(op1)))
}
</code></pre>
<p><code>pkg3</code> 包中使用上面定义的三个宏：</p>
<pre><code class="language-cangjie">package pkg3

import pkg1.*
import pkg2.*
@Foo
struct Data {
    let a = 2
    let b = @AddToMul(2+3)

    @Bar
    public func getA() {
        return a
    }

    public func getB() {
        return b
    }
}

main(): Int64 {
    let data = Data()
    var a = data.getA() // a = 2
    var b = data.getB() // b = 6
    println(&quot;a: ${a}, b: ${b}&quot;)
    return 0
}
</code></pre>
<p>如上代码所示，宏 <code>Foo</code> 修饰了 <code>struct Data</code>，而在 <code>struct Data</code> 内，出现了宏调用 <code>AddToMul</code> 和 <code>Bar</code>。这种嵌套场景下，代码变换的规则是：将嵌套内层的宏 (<code>AddToMul</code> 和 <code>Bar</code>) 展开后，再去展开外层的宏 (<code>Foo</code>)。允许出现多层宏嵌套，代码变换的规则总是由内向外去依次展开宏。</p>
<p>嵌套宏可以出现在带括号和不带括号的宏调用中，二者可以组合，但用户需要保证没有歧义，且明确宏的展开顺序：</p>
<pre><code class="language-cangjie">var a = @Foo(@Foo1(2 * 3)+@Foo2(1 + 3))  // Foo1, Foo2 have to be defined.

@Foo1 // Foo2 expands first, then Foo1 expands.
@Foo2[attr: struct] // Attribute macro can be used in nested macro.
struct Data{
    @Foo3 @Foo4[123] var a = @Bar1(@Bar2(2 + 3) + 3)  // Bar2, Bar1, Foo4, Foo3 expands in order.
    public func getA() {
        return @Foo(a + 2)
    }
}
</code></pre>
<h3 id="嵌套宏之间的消息传递"><a class="header" href="#嵌套宏之间的消息传递">嵌套宏之间的消息传递</a></h3>
<p>这里指的是宏调用的嵌套。</p>
<p>内层宏可以调用库函数 <code>assertParentContext</code> 来保证内层宏调用一定嵌套在特定的外层宏调用中。如果内层宏调用这个函数时没有嵌套在给定的外层宏调用中，该函数将抛出一个错误。库函数 <code>InsideParentContext</code> 同样用于检查内层宏调用是否嵌套在特定的外层宏调用中，该函数返回一个布尔值。下面是一个简单的例子。</p>
<p>宏定义如下：</p>
<pre><code class="language-cangjie">public macro Outer(input: Tokens): Tokens {
    return input
}

public macro Inner(input: Tokens): Tokens {
    assertParentContext(&quot;Outer&quot;)
    return input
}
</code></pre>
<p>宏调用如下：</p>
<pre><code class="language-cangjie">@Outer var a = 0
@Inner var b = 0 // Error, The macro call 'Inner' should with the surround code contains a call 'Outer'.
</code></pre>
<p>如上代码所示，<code>Inner</code> 宏在定义时使用了 <code>assertParentContext</code> 函数用于检查其在调用阶段是否位于 <code>Outer</code> 宏中，在代码示例的宏调用场景下，由于 <code>Outer</code> 和 <code>Inner</code> 在调用时不存在这样的嵌套关系，因此编译器将报告一个错误。</p>
<p>内层宏也可以通过发送键/值对的方式与外层宏通信。当内层宏执行时，通过调用标准库函数 <code>setItem</code> 向外层宏发送信息；随后，当外层宏执行时，调用标准库函数 <code>getChildMessages</code> 接收每一个内层宏发送的信息（一组键/值对映射）。下面是一个简单的例子。</p>
<p>宏定义如下：</p>
<pre><code class="language-cangjie">macro package define

import std.ast.*

public macro Outer(input: Tokens): Tokens {
    let messages = getChildMessages(&quot;Inner&quot;)

    let getTotalFunc = quote(public func getCnt() {
                       )
    for (m in messages) {
        let identName = m.getString(&quot;identifierName&quot;)
        // let value = m.getString(&quot;key&quot;)            // 接收多组消息
        getTotalFunc.append(Token(TokenKind.IDENTIFIER, identName))
        getTotalFunc.append(quote(+))
    }
    getTotalFunc.append(quote(0))
    getTotalFunc.append(quote(}))
    let funcDecl = parseDecl(getTotalFunc)

    let decl = (parseDecl(input) as ClassDecl).getOrThrow()
    decl.body.decls.append(funcDecl)
    return decl.toTokens()

}

public macro Inner(input: Tokens): Tokens {
    assertParentContext(&quot;Outer&quot;)
    let decl = parseDecl(input)
    setItem(&quot;identifierName&quot;, decl.identifier.value)
    // setItem(&quot;key&quot;, &quot;value&quot;)                      // 可以通过不同的key值传递多组消息
    return input
}
</code></pre>
<p>宏调用如下：</p>
<pre><code class="language-cangjie">import define.*

@Outer
class Demo {
    @Inner var state = 1
    @Inner var cnt = 42
}

main(): Int64 {
    let d = Demo()
    println(&quot;${d.getCnt()}&quot;)
    return 0
}
</code></pre>
<p>在上面的代码中，<code>Outer</code> 接收两个 <code>Inner</code> 宏发送来的变量名，自动为类添加如下内容：</p>
<pre><code class="language-cangjie">public func getCnt() {
    state + cnt + 0
}
</code></pre>
<p>具体流程为：内层宏 <code>Inner</code> 通过 <code>setItem</code> 向外层宏发送信息；<code>Outer</code> 宏通过 <code>getChildMessages</code> 函数接收到 <code>Inner</code> 发送的一组信息对象（<code>Outer</code> 中可以调用多次 <code>Inner</code>）；最后通过该信息对象的 <code>getString</code> 函数接收对应的值。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编译报错与调试"><a class="header" href="#编译报错与调试">编译、报错与调试</a></h1>
<h2 id="宏的编译和使用"><a class="header" href="#宏的编译和使用">宏的编译和使用</a></h2>
<p>当前编译器约束宏的定义与宏的调用不允许在同一包里。宏包必须首先被编译，然后再编译宏调用的包。在宏调用的包中，不允许出现宏的定义。由于宏需在包中导出给另一个包使用，因此编译器约束宏定义必须使用 <code>public</code> 修饰。</p>
<p>下面介绍一个简单的例子。</p>
<p>源码目录结构如下：</p>
<pre><code>// Directory layout.
src
`-- macros
      |-- m.cj

`-- demo.cj
</code></pre>
<p>宏定义放在 _macros_子目录下：</p>
<pre><code class="language-cangjie">// macros/m.cj
// In this file, we define the macro Inner, Outer.
macro package define
import std.ast.*

public macro Inner(input: Tokens) {
    return input
}

public macro Outer(input: Tokens) {
    return input
}

</code></pre>
<p>宏调用代码如下：</p>
<pre><code class="language-cangjie">// demo.cj
import define.*
@Outer
class Demo {
    @Inner var state = 1
    @Inner var cnt = 42
}

main() {
    println(&quot;test macro&quot;)
    0
}
</code></pre>
<p>以下为 Linux 平台的编译命令（具体编译选项会随着 cjc 更新而演进，以最新 cjc 的编译选项为准）：</p>
<pre><code class="language-shell"># 当前目录: src

# 先编译宏定义文件在当前目录产生默认的动态库文件（允许指定动态库的路径，但不能指定动态库的名字）
cjc macros/m.cj --compile-macro

# 编译使用宏的文件，宏替换完成，产生可执行文件
cjc demo.cj -o demo

# 运行可执行文件
./demo
</code></pre>
<p>在 linux 平台上，将生成用于包管理的 <code>macro_define.cjo</code> 和实际的动态库文件。</p>
<p>若在 Windows 平台：</p>
<pre><code class="language-shell"># 当前目录: src

# 先编译宏定义文件在当前目录产生默认的动态库文件（允许指定动态库的路径，但不能指定动态库的名字）
cjc macros/m.cj --compile-macro

# 编译使用宏的文件，宏替换完成，产生可执行文件
cjc demo.cj -o demo.exe
</code></pre>
<blockquote>
<p>说明：</p>
<p>宏替换过程依赖仓颉 runtime ，宏替换过程中仓颉 runtime 的初始化配置采用宏提供的默认配置，配置参数支持使用仓颉 runtime 运维日志进行查询，其中 cjHeapSize 与 cjStackSize 支持用户修改，其余暂不支持，仓颉 runtime 初始化配置可参见<a href="source_zh_cn/Macro/../Appendix/runtime_env.html#runtime%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%AF%E9%80%89%E9%85%8D%E7%BD%AE">runtime 初始化可选配置</a>章节。</p>
</blockquote>
<h2 id="并行宏展开"><a class="header" href="#并行宏展开">并行宏展开</a></h2>
<p>可以在编译宏调用文件时添加 <code>--parallel-macro-expansion</code> 选项，启用并行宏展开的能力。编译器会自动分析宏调用之间的依赖关系，无依赖关系的宏调用可以并行执行，如上述例子中的两个 <code>@Inner</code> 就可以并行展开，如此可以缩短整体编译时间。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>如果宏函数依赖一些全局变量，使用并行宏展开会存在风险。</p>
</blockquote>
<pre><code class="language-cangjie">macro package define
import std.ast.*
import std.collection.*

var Counts = HashMap&lt;String, Int64&gt;()

public macro Inner(input: Tokens) {
    for (t in input) {
        if (t.value.size == 0) {
            continue
        }
        // 统计所有有效token value的出现次数
        if (!Counts.contains(t.value)) {
            Counts[t.value] = 0
        }
        Counts[t.value] = Counts[t.value] + 1
    }
    return input
}

public macro B(input: Tokens) {
    return input
}
</code></pre>
<p>参考上述代码，如果 <code>@Inner</code> 的宏调用出现在多处，并且启用了并行宏展开选项，则访问全局变量 <code>Counts</code> 就可能存在冲突，导致最后获取的结果不正确。</p>
<p>建议不要在宏函数中使用全局变量，如果必须使用，要么关闭并行宏展开选项，或者可以通过仓颉线程锁对全局变量进行保护。</p>
<h2 id="diagreport-报错机制"><a class="header" href="#diagreport-报错机制">diagReport 报错机制</a></h2>
<p>仓颉 ast 包提供了自定义报错接口 <code>diagReport</code>。方便定义宏的用户，在解析传入 tokens 时，对错误 tokens 内容进行自定义报错。</p>
<p>自定义报错接口提供同原生编译器报错一样的输出格式，允许用户报 warning 和 error 两类错误提示信息。</p>
<p><code>diagReport</code> 的函数原型如下：</p>
<pre><code class="language-cangjie">public func diagReport(level: DiagReportLevel, tokens: Tokens, message: String, hint: String): Unit
</code></pre>
<p>其参数含义如下：</p>
<ul>
<li>level: 报错信息等级</li>
<li>tokens: 报错信息中所引用源码内容对应的 tokens</li>
<li>message: 报错的主信息</li>
<li>hint: 辅助提示信息</li>
</ul>
<p>参考如下使用示例。</p>
<p>宏定义文件：</p>
<pre><code class="language-cangjie">// macro_definition.cj
macro package macro_definition

import std.ast.*

public macro TestDef(input: Tokens): Tokens {
    for (i in 0..input.size) {
        if (input[i].kind == IDENTIFIER) {
            diagReport(DiagReportLevel.ERROR, input[i..(i + 1)],
                       &quot;This expression is not allowed to contain identifier&quot;,
                       &quot;Here is the illegal identifier&quot;)
        }
    }
    return input
}
</code></pre>
<p>宏调用文件：</p>
<pre><code class="language-cangjie">// macro_call.cj
package macro_calling

import std.ast.*
import macro_definition.*

main(): Int64 {
    let a = @TestDef(1)
    let b = @TestDef(a)
    let c = @TestDef(1 + a)
    return 0
}
</code></pre>
<p>编译宏调用文件过程中，会出现如下报错信息：</p>
<pre><code>error: This expression is not allowed to contain identifier
 ==&gt; call.cj:9:22:
  |
9 |     let b = @TestDef(a)
  |                      ^ Here is the illegal identifier
  |

error: This expression is not allowed to contain identifier
  ==&gt; call.cj:10:26:
   |
10 |     let c = @TestDef(1 + a)
   |                          ^ Here is the illegal identifier
   |

2 errors generated, 2 errors printed.
</code></pre>
<h2 id="使用---debug-macro-输出宏展开结果"><a class="header" href="#使用---debug-macro-输出宏展开结果">使用 --debug-macro 输出宏展开结果</a></h2>
<p>借助宏在编译期做代码生成时，如果发生错误，处理起来十分棘手，这是开发者经常遇到但一般很难定位的问题。这是因为，开发者写的源码，经过宏的变换后变成了不同的代码片段。编译器抛出的错误信息是基于宏最终生成的代码进行提示的，但这些代码在开发者的源码中没有体现。</p>
<p>为了解决这个问题，仓颉宏提供 debug 模式，在这个模式下，开发者可以从编译器为宏生成的 debug 文件中看到完整的宏展开后的代码，如下所示。</p>
<p>宏定义文件：</p>
<pre><code class="language-cangjie">macro package define

import std.ast.*

public macro Outer(input: Tokens): Tokens {
    let messages = getChildMessages(&quot;Inner&quot;)

    let getTotalFunc = quote(public func getCnt() {
                       )
    for (m in messages) {
        let identName = m.getString(&quot;identifierName&quot;)
        getTotalFunc.append(Token(TokenKind.IDENTIFIER, identName))
        getTotalFunc.append(quote(+))
    }
    getTotalFunc.append(quote(0))
    getTotalFunc.append(quote(}))
    let funcDecl = parseDecl(getTotalFunc)

    let decl = (parseDecl(input) as ClassDecl).getOrThrow()
    decl.body.decls.append(funcDecl)
    return decl.toTokens()

}

public macro Inner(input: Tokens): Tokens {
    assertParentContext(&quot;Outer&quot;)
    let decl = parseDecl(input)
    setItem(&quot;identifierName&quot;, decl.identifier.value)
    return input
}
</code></pre>
<p>宏调用文件 <code>demo.cj</code>：</p>
<pre><code class="language-cangjie">import define.*

@Outer
class Demo {
    @Inner var state = 1
    @Inner var cnt = 42
}

main(): Int64 {
    let d = Demo()
    println(&quot;${d.getCnt()}&quot;)
    return 0
}

</code></pre>
<p>在编译使用宏的文件时，在选项中，增加 <code>--debug-macro</code>，即使用仓颉宏的 <em>debug</em> 模式。</p>
<pre><code class="language-shell">cjc --debug-macro demo.cj
</code></pre>
<p>在 <em>debug</em> 模式下，会生成临时文件 <em>demo.cj.macrocall</em>，对应宏展开的部分如下：</p>
<pre><code class="language-cangjie">// demo.cj.macrocall
/* ===== Emitted by MacroCall @Outer in demo.cj:3:1 ===== */
/* 3.1 */class Demo {
/* 3.2 */    var state = 1
/* 3.3 */    var cnt = 42
/* 3.4 */    public func getCnt() {
/* 3.5 */        state + cnt + 0
/* 3.6 */    }
/* 3.7 */}
/* 3.8 */
/* ===== End of the Emit ===== */
</code></pre>
<p>如果宏展开后的代码有语义错误，则编译器的错误信息会溯源到宏展开后代码的具体行列号。仓颉宏的 <em>debug</em> 模式有以下注意事项：</p>
<ul>
<li>
<p>宏的 <em>debug</em> 模式会重排源码的行列号信息，不适用于某些特殊的换行场景。比如</p>
<pre><code class="language-cangjie">// before expansion
@M{} - 2 // macro M return 2

// after expansion
// ===== Emmitted my Macro M at line 1 ===
2
// ===== End of the Emit =====
- 2
</code></pre>
<p>这些因换行符导致语义改变的情形，不应使用 <em>debug</em> 模式。</p>
</li>
<li>
<p>不支持宏调用在宏定义内的调试，会编译报错。</p>
<pre><code class="language-cangjie">public macro M(input: Tokens) {
    let a = @M2(1+2) // M2 is in macro M, not suitable for debug mode.
    return input + quote($a)
}
</code></pre>
</li>
<li>
<p>不支持带括号宏的调试。</p>
<pre><code class="language-cangjie">// main.cj

main() {
    // For macro with parenthesis, newline introduced by debug will change the semantics
    // of the expression, so it is not suitable for debug mode.
    let t = @M(1+2)
    0
}
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="宏包定义和导入"><a class="header" href="#宏包定义和导入">宏包定义和导入</a></h1>
<p>仓颉宏的定义需要放在由 <code>macro package</code> 声明的包中，被 <code>macro package</code> 限定的包仅允许宏定义对外可见，其他声明包内可见。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>重导出的声明也允许对外可见，关于包管理和重导出的相关概念，请参见<a href="source_zh_cn/Macro/../package/import.html">包的导入</a>章节。</p>
</blockquote>
<pre><code class="language-cangjie">// file define.cj
macro package define         // 编译 define.cjo 携带 macro 属性
import std.ast.*

public func A() {}          // Error, 宏包不允许定义外部可见的非宏定义，此处需报错

public macro M(input: Tokens): Tokens { // macro M 外部可见
    return input
}
</code></pre>
<p>需要特殊说明的是，在 <code>macro package</code> 中允许其它 <code>macro package</code> 和非 <code>macro package</code> 符号被重导出，在非 <code>macro package</code> 中仅允许非 <code>macro package</code> 符号被重导出。</p>
<p>参考如下示例：</p>
<ul>
<li>
<p>在宏包 A 中定义宏 <code>M1</code></p>
<pre><code class="language-cangjie">macro package A
import std.ast.*

public macro M1(input: Tokens): Tokens {
    return input
}
</code></pre>
<p>编译命令如下：</p>
<pre><code class="language-shell">cjc A.cj --compile-macro
</code></pre>
</li>
<li>
<p>在非宏包 B 中定义一个 public 函数 <code>F1</code>。注意在非 <code>macro package</code> 中无法重导出 <code>macro package</code> 的符号</p>
<pre><code class="language-cangjie">package B
// public import A.* // Error, it is not allowed to re-export a macro package in a package.

public func F1(input: Int64): Int64 {
    return input
}
</code></pre>
<p>编译命令如下，这里选择使用 <code>--output-type</code> 选项将 B 包编译成到动态库，关于 cjc 编译选项介绍可以参考<a href="source_zh_cn/Macro/../Appendix/compile_options_OHOS.html">cjc 编译选项</a>章节。</p>
<pre><code class="language-shell">cjc B.cj --output-type=dylib -o libB.so
</code></pre>
</li>
<li>
<p>在宏包 C 中定义宏 <code>M2</code>，依赖了 A 包和 B 包的内容。可以看到 <code>macro package</code> 中可以重导出 <code>macro package</code> 和非 <code>macro package</code> 的符号</p>
<pre><code class="language-cangjie">macro package C
public import A.* // correct: macro package is allowed to re-export in a macro package.
public import B.* // correct: non-macro package is also allowed to re-export in a macro package.
import std.ast.*

public macro M2(input: Tokens): Tokens {
    return @M1(input) + Token(TokenKind.NL) + quote(F1(1))
}
</code></pre>
<p>编译命令如下，注意这里需要显式链接 B 包动态库：</p>
<pre><code class="language-cangjie">cjc C.cj --compile-macro -L. -lB
</code></pre>
</li>
<li>
<p>在 <code>main.cj</code> 中使用 <code>M2</code> 宏</p>
<pre><code class="language-cangjie">import C.*

main() {
    @M2(let a = 1)
}
</code></pre>
<p>编译命令如下：</p>
<pre><code class="language-cangjie">cjc main.cj -o main -L. -lB
</code></pre>
<p><code>main.cj</code>中 <code>M2</code> 宏展开后的结果如下：</p>
<pre><code class="language-cangjie">import C.*

main() {
    let a = 1
    F1(1)
}
</code></pre>
</li>
</ul>
<p>可以看到 <code>main.cj</code> 中出现了来自于 B 包的符号 <code>F1</code>。宏的编写者可以在 C 包中重导出 B 包里的符号，这样宏的使用者仅需导入宏包，就可以正确的编译宏展开后的代码。如果在 <code>main.cj</code> 中仅使用 <code>import C.M2</code> 导入宏符号，则会报 <code>undeclared identifier 'F1'</code> 的错误信息。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内置编译标记"><a class="header" href="#内置编译标记">内置编译标记</a></h1>
<p>仓颉语言提供了一些预定义的编译标记，可以通过这些编译标记控制仓颉编译器的编译行为。</p>
<h2 id="源码位置"><a class="header" href="#源码位置">源码位置</a></h2>
<p>仓颉提供了几个内置编译标记，用于在编译时获取源代码的位置。</p>
<ul>
<li><code>@sourcePackage()</code> 展开后是一个 <code>String</code> 类型的字面量，内容为当前宏所在的源码的包名</li>
<li><code>@sourceFile()</code> 展开后是一个 <code>String</code> 类型的字面量，内容为当前宏所在的源码的文件名</li>
<li><code>@sourceLine()</code> 展开后是一个 <code>Int64</code> 类型的字面量，内容为当前宏所在的源码的代码行</li>
</ul>
<p>这几个编译标记可以在任意表达式内部使用，只要能符合类型检查规则即可。示例如下：</p>
<!-- run -->
<pre><code class="language-cangjie">func test1() {
    let s: String = @sourceFile()  // The value of `s` is the current source file name
}

func test2(n!: Int64 = @sourceLine()) { /* at line 5 */
    // The default value of `n` is the source file line number of the definition of `test2`
    println(n) // print 5
}
</code></pre>
<h2 id="条件编译"><a class="header" href="#条件编译">条件编译</a></h2>
<p>条件编译使用 <code>@When</code> 标记，是一种在程序代码中根据特定条件选择性地编译不同代码段的技术。条件编译的作用主要体现在以下几个方面：</p>
<ul>
<li>平台适应：支持根据当前的编译环境选择性地编译代码，用于实现跨平台的兼容性。</li>
<li>功能选择：支持根据不同的需求选择性地启用或禁用某些功能，用于实现功能的灵活配置。例如，选择性地编译包含或排除某些功能的代码。</li>
<li>调试支持：支持调试模式下编译相关代码，用于提高程序的性能和安全性。例如，在调试模式下编译调试信息或记录日志相关的代码，而在发布版本中将其排除。</li>
<li>性能优化：支持根据预定义的条件选择性地编译代码，用于提高程序的性能。</li>
</ul>
<p>关于条件编译的具体内容，可以参考<a href="source_zh_cn/Macro/../Compile-And-Build/conditional_compilation.html">条件编译</a>章节，这里不再额外展开。</p>
<h2 id="fastnative"><a class="header" href="#fastnative">@FastNative</a></h2>
<p>为了提升与 <code>C</code> 语言互操作的性能，仓颉提供 <code>@FastNative</code> 标记用于优化对 <code>C</code> 函数的调用。值得注意的是 <code>@FastNative</code> 只能用于 <code>foreign</code> 声明的函数。</p>
<p>使用示例如下</p>
<!-- run -->
<pre><code class="language-cangjie">@FastNative
foreign func strlen(str: CPointer&lt;UInt8&gt;): UIntNative
</code></pre>
<p>开发者在使用 <code>@FastNative</code> 修饰 <code>foreign</code> 函数时，应确保对应的 <code>C</code> 函数满足以下两点要求：</p>
<ol>
<li>函数的整体执行时间不宜太长。例如:不允许函数内部存在很大的循环；不允许函数内部产生阻塞行为，如，调用 <code>sleep</code>、<code>wait</code> 等函数。</li>
<li>函数内部不能调用仓颉方法。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实用案例"><a class="header" href="#实用案例">实用案例</a></h1>
<h2 id="快速幂的计算"><a class="header" href="#快速幂的计算">快速幂的计算</a></h2>
<p>我们通过一个简单的例子展示使用宏进行编译期求值，生成优化代码的应用。在计算幂 <code>n ^ e</code> 的时候，如果 <code>e</code> 是一个（比较大的）整数，可以通过重复取平方（而不是迭代相乘）的方式加速计算。这个算法可以直接使用 while 循环实现，例如：</p>
<!-- run -->
<pre><code class="language-cangjie">func power(n: Int64, e: Int64) {
    var result = 1
    var vn = n
    var ve = e
    while (ve &gt; 0) {
        if (ve % 2 == 1) {
            result *= vn
        }
        ve /= 2
        if (ve &gt; 0) {
            vn *= vn
        }
    }
    result
}
</code></pre>
<p>然而，这个实现需要每次对 <code>e</code> 的值进行分析，在循环和条件判断中多次对 <code>ve</code> 进行判断和更新。此外，实现只支持 <code>n</code> 的类型为<code>Int64</code>的情况，如果要支持其他类型的 <code>n</code>，还要处理如何表达 <code>result = 1</code> 的问题。如果我们预先知道 <code>e</code> 的具体值，可以将这个代码写的更简单。例如，如果知道 <code>e</code> 的值为 10，我们可以展开整个循环如下：</p>
<!-- run -->
<pre><code class="language-cangjie">func power_10(n: Int64) {
    var vn = n
    vn *= vn         // vn = n ^ 2
    var result = vn  // result = n ^ 2
    vn *= vn         // vn = n ^ 4
    vn *= vn         // vn = n ^ 8
    result *= vn     // result = n ^ 10
    result
}
</code></pre>
<p>当然，手动编写这些代码非常繁琐，我们希望在给定 <code>e</code> 的值之后，自动将这些代码生成出来。宏允许我们做到这一点。我们先看使用案例：</p>
<pre><code class="language-cangjie">public func power_10(n: Int64) {
    @power[10](n)
}
</code></pre>
<p>这个宏展开的代码是（根据<code>.macrocall</code>文件）：</p>
<pre><code class="language-cangjie">public func power_10(n: Int64) {
    /* ===== Emitted by MacroCall @power in main.cj:20:5 ===== */
    /* 20.1 */var _power_vn = n
    /* 20.2 */_power_vn *= _power_vn
    /* 20.3 */var _power_result = _power_vn
    /* 20.4 */_power_vn *= _power_vn
    /* 20.5 */_power_vn *= _power_vn
    /* 20.6 */_power_result *= _power_vn
    /* 20.7 */_power_result
/* ===== End of the Emit ===== */
}
</code></pre>
<p>下面，我们看宏 <code>@power</code> 的实现。</p>
<pre><code class="language-cangjie">macro package define

import std.ast.*
import std.convert.*

public macro power(attrib: Tokens, input: Tokens) {
    let attribExpr = parseExpr(attrib)
    if (let Some(litExpr) &lt;- attribExpr as LitConstExpr) {
        let lit = litExpr.literal
        if (lit.kind != TokenKind.INTEGER_LITERAL) {
            diagReport(DiagReportLevel.ERROR, attrib,
                       &quot;Attribute must be integer literal&quot;,
                       &quot;Expected integer literal&quot;)
        }
        var n = Int64.parse(lit.value)
        var result = quote(var _power_vn = $(input)
        )
        var flag = false
        while (n &gt; 0) {
            if (n % 2 == 1) {
                if (!flag) {
                    result += quote(var _power_result = _power_vn
                    )
                    flag = true
                } else {
                    result += quote(_power_result *= _power_vn
                    )
                }
            }
            n /= 2
            if (n &gt; 0) {
                result += quote(_power_vn *= _power_vn
                )
            }
        }
        result += quote(_power_result)
        return result
    } else {
        diagReport(DiagReportLevel.ERROR, attrib,
                   &quot;Attribute must be integer literal&quot;,
                   &quot;Expected integer literal&quot;)
    }
    return input
}
</code></pre>
<p>这段代码的解释如下：</p>
<ul>
<li>首先，确认输入的属性 <code>attrib</code> 是一个整数字面量，否则通过 <code>diagReport</code> 报错。将这个字面量解析为整数 <code>n</code>。</li>
<li>设 <code>result</code> 为当前积累的输出代码，首先添加 <code>var _power_vn</code> 的声明。这里为了避免变量名冲突，我们使用不易造成冲突的名字 <code>_power_vn</code>。</li>
<li>下面进入 while 循环，布尔变量 <code>flag</code> 表示 <code>var _power_result</code> 是否已经被初始化。其余的代码结构和之前展示的 <code>power</code> 函数的实现类似，但区别是我们使用 while 循环和 if 判断在编译时决定生成的代码是什么，而不是在运行时做这些判断。最后生成由 <code>_power_result *= _power_vn</code> 和 <code>_power_vn *= _power_vn</code> 适当组合的代码。</li>
<li>最后添加返回 <code>_power_result</code> 的代码。</li>
</ul>
<p>将这段代码放到 <code>macros/power.cj</code> 文件中，并在 <code>main.cj</code> 添加如下测试：</p>
<pre><code class="language-cangjie">public func power_10(n: Int64) {
    @power[10](n)
}

main() {
    let a = 3
    println(power_10(a))
}
</code></pre>
<p>输出结果为：</p>
<pre><code>59049
</code></pre>
<h2 id="memoize-宏"><a class="header" href="#memoize-宏">Memoize 宏</a></h2>
<p>Memoize（记忆化）是动态规划算法的常用手段。它将已经计算过的子问题的结果存储起来，当同一个子问题再次出现时，可以直接查询表来获取结果，从而避免重复的计算，提高算法的效率。</p>
<p>通常 Memoize 的使用需要开发者手动实现存储和提取的功能。通过宏，我们可以自动化这一过程。首先，让我们先看一下宏使用的效果：</p>
<pre><code class="language-cangjie">@Memoize[true]
func fib(n: Int64): Int64 {
    if (n == 0 || n == 1) {
        return n
    }
    return fib(n - 1) + fib(n - 2)
}

main() {
    let start = DateTime.now()
    let f35 = fib(35)
    let end = DateTime.now()
    println(&quot;fib(35): ${f35}&quot;)
    println(&quot;execution time: ${(end - start).toMicroseconds()} us&quot;)
}
</code></pre>
<p>在以上代码中，<code>fib</code> 函数采用简单的递归方式实现。如果没有 <code>@Memoize[true]</code> 标注，这个函数的运行时间将随着 <code>n</code> 指数增长。例如，如果在前面的代码中去掉 <code>@Memoize[true]</code> 这一行，或者把 <code>true</code> 改为 <code>false</code>，则 <code>main</code> 函数的运行结果为：</p>
<pre><code>fib(35): 9227465
execution time: 199500 us
</code></pre>
<p>恢复 <code>@Memoize[true]</code>，运行结果为：</p>
<pre><code>fib(35): 9227465
execution time: 78 us
</code></pre>
<p>相同的答案和大幅缩短的计算时间表明，<code>@Memoize</code> 的使用确实实现了记忆化。</p>
<p>现在让我们理解 <code>@Memoize</code> 的原理。首先，展示对以上 <code>fib</code> 函数进行宏展开的结果（来自 <code>.macrocall</code> 文件，但是为了提高可读性整理了格式）。</p>
<!-- run -->
<pre><code class="language-cangjie">import std.collection.*

var _memoize_fib_map = HashMap&lt;Int64, Int64&gt;()

func fib(n: Int64): Int64 {
    if (_memoize_fib_map.contains(n)) {
        return _memoize_fib_map.get(n).getOrThrow()
    }

    let _memoize_eval_result = { =&gt;
        if (n == 0 || n == 1) {
            return n
        }

        return fib(n - 1) + fib(n - 2)
    }()
    _memoize_fib_map.put(n, _memoize_eval_result)
    return _memoize_eval_result
}
</code></pre>
<p>上述代码的执行流程如下：</p>
<ul>
<li>首先，定义 <code>_memoize_fib_map</code> 为一个从 <code>Int64</code> 到 <code>Int64</code> 的哈希表，这里第一个 <code>Int64</code> 对应 <code>fib</code> 的唯一参数的类型，第二个 <code>Int64</code> 对应 <code>fib</code> 返回值的类型。</li>
<li>其次，在函数体中，检查入参是否在 <code>_memoize_fib_map</code> 中，如果是则立即反馈哈希表中存储的值。否则，使用 <code>fib</code> 原来的函数体得到计算结果。这里使用了（不带参数的）匿名函数使 <code>fib</code> 的函数体不需要任何改变，并且能够处理任何从 <code>fib</code> 函数退出的方式（包括中间的 return，返回最后一个表达式等）。</li>
<li>最后，把计算结果存储到 <code>_memoize_fib_map</code> 中，然后将计算结果返回。</li>
</ul>
<p>有了这样一个“模版”之后，下面宏的实现就不难理解了。我们给出完整的代码如下。</p>
<pre><code class="language-cangjie">public macro Memoize(attrib: Tokens, input: Tokens) {
    if (attrib.size != 1 || attrib[0].kind != TokenKind.BOOL_LITERAL) {
        diagReport(DiagReportLevel.ERROR, attrib,
                   &quot;Attribute must be a boolean literal (true or false)&quot;,
                   &quot;Expected boolean literal (true or false) here&quot;)
    }

    let memoized = (attrib[0].value == &quot;true&quot;)
    if (!memoized) {
        return input
    }

    let fd = FuncDecl(input)
    if (fd.funcParams.size != 1) {
        diagReport(DiagReportLevel.ERROR, fd.lParen + fd.funcParams.toTokens() + fd.rParen,
                   &quot;Input function to memoize should take exactly one argument&quot;,
                   &quot;Expect only one argument here&quot;)
    }

    let memoMap = Token(TokenKind.IDENTIFIER, &quot;_memoize_&quot; + fd.identifier.value + &quot;_map&quot;)
    let arg1 = fd.funcParams[0]

    return quote(
        var $(memoMap) = HashMap&lt;$(arg1.paramType), $(fd.declType)&gt;()

        func $(fd.identifier)($(arg1)): $(fd.declType) {
            if ($(memoMap).contains($(arg1.identifier))) {
                return $(memoMap).get($(arg1.identifier)).getOrThrow()
            }

            let _memoize_eval_result = { =&gt; $(fd.block.nodes) }()
            $(memoMap).put($(arg1.identifier), _memoize_eval_result)
            return _memoize_eval_result
        }
    )
}
</code></pre>
<p>首先，对属性和输入做合法性检查。属性必须是布尔字面量，如果为 <code>false</code> 则直接返回输入。否则，检查输入必须能够解析为函数声明（<code>FuncDecl</code>），并且必须包含正好一个参数。下面，产生哈希表的变量，取不容易造成冲突的变量名。最后，通过 <code>quote</code> 模版生成返回的代码，其中用到哈希表的变量名，以及唯一参数的名称、类型和输入函数的返回类型。</p>
<h2 id="一个-dprint-宏的扩展"><a class="header" href="#一个-dprint-宏的扩展">一个 dprint 宏的扩展</a></h2>
<p>本节一开始使用了一个打印表达式的宏作为案例，但这个宏一次只能接受一个表达式。我们希望扩展这个宏，使其能够接受多个表达式，由逗号分开。我们展示如何使用 <code>parseExprFragment</code> 来实现这个功能。</p>
<p>宏的实现如下：</p>
<pre><code class="language-cangjie">public macro dprint2(input: Tokens) {
    let exprs = ArrayList&lt;Expr&gt;()
    var index: Int64 = 0
    while (true) {
        let (expr, nextIndex) = parseExprFragment(input, startFrom: index)
        exprs.append(expr)
        if (nextIndex == input.size) {
            break
        }
        if (input[nextIndex].kind != TokenKind.COMMA) {
            diagReport(DiagReportLevel.ERROR, input[nextIndex..nextIndex+1],
                       &quot;Input must be a comma-separated list of expressions&quot;,
                       &quot;Expected comma&quot;)
        }
        index = nextIndex + 1  // 跳过逗号
    }
    let result = quote()
    for (expr in exprs) {
        result.append(quote(
            print($(expr.toTokens().toString()) + &quot; = &quot;)
            println($(expr))
        ))
    }
    return result
}
</code></pre>
<p>使用案例：</p>
<pre><code class="language-cangjie">let x = 3
let y = 2
@dprint2(x, y, x + y)
</code></pre>
<p>输出结果为：</p>
<pre><code>x = 3
y = 2
x + y = 5
</code></pre>
<p>在宏的实现中，使用 while 循环从索引 0 开始依次解析每个表达式。变量 <code>index</code> 保存当前解析的位置。每次调用 <code>parseExprFragment</code> 时，从当前位置开始，并返回解析后的位置（以及解析得到的表达式）。如果解析后的位置到达了输入的结尾，则退出循环。否则检查到达的位置是一个括号，如果不是括号，报错并退出，如果是括号，跳过这个括号并开始下一轮的解析。在得到表达式的列表后，依次输出每个表达式。</p>
<h2 id="一个简单的-dsl"><a class="header" href="#一个简单的-dsl">一个简单的 DSL</a></h2>
<p>在这个案例中，我们展示如何使用宏实现一个简单的 DSL（Domain Specific Language，领域特定语言）。LINQ（Language Integrated Query，语言集成查询）是微软 .NET 框架的一个组成部分，它提供了一种统一的数据查询语法，允许开发者使用类似 SQL 的查询语句来操作各种数据源。在这里，我们仅展示一个最简单的 LINQ 语法的支持。</p>
<p>我们希望支持的语法为：</p>
<pre><code>from &lt;variable&gt; in &lt;list&gt; where &lt;condition&gt; select &lt;expression&gt;
</code></pre>
<p>其中，<code>variable</code> 是一个标识符，<code>list</code>、<code>condition</code> 和 <code>expression</code> 都是表达式。因此，实现宏的策略是先后提取标识符和表达式，同时检查中间的关键字是正确的。最后，生成由提取部分组成的查询结果。</p>
<p>宏的实现如下：</p>
<pre><code class="language-cangjie">public macro linq(input: Tokens) {
    let syntaxMsg = &quot;Syntax is \&quot;from &lt;attrib&gt; in &lt;table&gt; where &lt;cond&gt; select &lt;expr&gt;\&quot;&quot;
    if (input.size == 0 || input[0].value != &quot;from&quot;) {
        diagReport(DiagReportLevel.ERROR, input[0..1], syntaxMsg,
                   &quot;Expected keyword \&quot;from\&quot; here.&quot;)
    }
    if (input.size &lt;= 1 || input[1].kind != TokenKind.IDENTIFIER) {
        diagReport(DiagReportLevel.ERROR, input[1..2], syntaxMsg,
                   &quot;Expected identifier here.&quot;)
    }
    let attribute = input[1]
    if (input.size &lt;= 2 || input[2].value != &quot;in&quot;) {
        diagReport(DiagReportLevel.ERROR, input[2..3], syntaxMsg,
                   &quot;Expected keyword \&quot;in\&quot; here.&quot;)
    }
    var index: Int64 = 3
    let (table, nextIndex) = parseExprFragment(input, startFrom: index)
    if (nextIndex == input.size || input[nextIndex].value != &quot;where&quot;) {
        diagReport(DiagReportLevel.ERROR, input[nextIndex..nextIndex+1], syntaxMsg,
                   &quot;Expected keyword \&quot;where\&quot; here.&quot;)
    }
    index = nextIndex + 1  // 跳过where
    let (cond, nextIndex2) = parseExprFragment(input, startFrom: index)
    if (nextIndex2 == input.size || input[nextIndex2].value != &quot;select&quot;) {
        diagReport(DiagReportLevel.ERROR, input[nextIndex2..nextIndex2+1], syntaxMsg,
                   &quot;Expected keyword \&quot;select\&quot; here.&quot;)
    }
    index = nextIndex2 + 1  // 跳过select
    let (expr, nextIndex3) = parseExprFragment(input, startFrom: index)

    return quote(
        for ($(attribute) in $(table)) {
            if ($(cond)) {
                println($(expr))
            }
        }
    )
}
</code></pre>
<p>使用案例：</p>
<pre><code>@linq(from x in 1..=10 where x % 2 == 1 select x * x)
</code></pre>
<p>这个例子从 1, 2, ... 10 列表中筛选出奇数，然后返回所有奇数的平方。输出结果为：</p>
<pre><code>1
9
25
49
81
</code></pre>
<p>可以看到，宏的实现的很大部分用于解析并校验输入的 tokens，这对宏的可用性至关重要。实际的 LINQ 语言（以及大多数 DSL）的语法更加复杂，需要一整套解析的机制，通过识别不同的关键字或连接符来决定下一步解析的内容。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="动态特性"><a class="header" href="#动态特性">动态特性</a></h1>
<p>本章我们来介绍 Cangjie 的动态特性，应用动态特性开发者能够更为优雅的实现一些功能。仓颉的动态特性主要包含反射、动态加载。</p>
<h2 id="仓颉反射基本介绍"><a class="header" href="#仓颉反射基本介绍">仓颉反射基本介绍</a></h2>
<p>反射指程序可以访问、检测和修改它本身状态或行为的一种机制。</p>
<p>反射这一动态特性有以下的优点：</p>
<ul>
<li>
<p>提高了程序的灵活性和扩展性。</p>
</li>
<li>
<p>程序能够在运行时获悉各种对象的类型，对其成员进行枚举、调用等操作。</p>
</li>
<li>
<p>允许在运行时创建新类型，无需提前硬编码。</p>
</li>
</ul>
<p>但使用反射调用，其性能通常低于直接调用，因此反射机制主要应用于对灵活性和拓展性要求很高的系统框架上。</p>
<h2 id="如何获得-typeinfo"><a class="header" href="#如何获得-typeinfo">如何获得 TypeInfo</a></h2>
<p>对于仓颉的反射特性，我们需要知道 TypeInfo 这一类型，这个核心类型中记录任意类型的类型信息，并且定义了方法用于获取类型信息、设置值等。当然为了便于用户操作我们还提供了 ClassTypeInfo、PrimitiveTypeInfo、ParameterInfo 等一系列的信息类型。</p>
<p>我们可以使用三种静态的 <code>of</code> 方法来生成 TypeInfo 信息类。</p>
<pre><code class="language-cangjie">public class TypeInfo {
    public static func of(a: Any): TypeInfo
    public static func of(a: Object): ClassTypeInfo
    public static func of&lt;T&gt;(): TypeInfo
}
</code></pre>
<p>当采用入参为 <code>Any</code> 和 <code>Object</code> 类型的 <code>of</code> 函数，输出为该实例的运行时类型信息，采用泛型参数的 <code>of</code> 函数则会返回传入参数的静态类型信息。两种方法产生的信息完全相同，但不保证一定对应同一对象。</p>
<p>例如我们可以用反射来获取一个自定义类型的类型信息。</p>
<pre><code class="language-cangjie">import std.reflect.*

class Foo {}

main() {
    let a: Foo = Foo()
    let info: TypeInfo = TypeInfo.of(a)
    let info2: TypeInfo = TypeInfo.of&lt;Foo&gt;()
    println(info)
    println(info2)
}
</code></pre>
<p>编译并执行上面的代码，会输出：</p>
<pre><code class="language-text">default.Foo
default.Foo
</code></pre>
<p>此外，为配合动态加载使用，TypeInfo 还提供了静态函数 <code>get</code>，该接口可通过传入的类型名称获取 TypeInfo。</p>
<pre><code class="language-cangjie">public class TypeInfo {
    public static func get(qualifiedName: String): TypeInfo
}
</code></pre>
<p>请注意，传入参数需要符合 <code>module/package.type</code> 的完全限定模式规则。对于编译器预导入的类型，包含 core 包中的类型和编译器内置类型，例如 <code>primitive type</code>、<code>Option</code>、<code>Iterable</code> 等，查找的字符串需要直接使用其类型名，不能带包名和模块名前缀。当运行时无法查询到对应类型的实例，则会抛出 <code>InfoNotFoundException</code>。</p>
<pre><code class="language-cangjie">let t1: TypeInfo = TypeInfo.get(&quot;Int64&quot;)
let t1: TypeInfo = TypeInfo.get(&quot;default.Foo&quot;)
let t2: TypeInfo = TypeInfo.get(&quot;std/socket.TcpSocket&quot;)
let t3: TypeInfo = TypeInfo.get(&quot;net/http.ServerBuilder&quot;)
</code></pre>
<p>采用这种方式时无法获取一个未实例化的泛型类型。</p>
<pre><code class="language-cangjie">import std.collection.*
import std.reflect.*

class A&lt;T&gt; {
    A(public let t: T) {}
}

class B&lt;T&gt; {
    B(public let t: T) {}
}

main() {
    let aInfo: TypeInfo = TypeInfo.get(&quot;default.A&lt;Int64&gt;&quot;)// Error,`default.A&lt;Int64&gt;` is not instantiated，will throw InfoNotFoundException
    let b: B&lt;Int64&gt; = B&lt;Int64&gt;(1)
    let bInfo: TypeInfo = TypeInfo.get(&quot;default.B&lt;Int64&gt;&quot;)// Ok `default.B&lt;Int64&gt;` has been instantiated.
}
</code></pre>
<h2 id="如何使用反射访问成员"><a class="header" href="#如何使用反射访问成员">如何使用反射访问成员</a></h2>
<p>在获取到对应的类型信息类即 <code>TypeInfo</code>，我们便可以通过其相应接口访问对应类的实例成员以及静态成员。此外 <code>TypeInfo</code> 的子类 <code>ClassTypeInfo</code> 还提供了接口用于访问类公开的构造函数以及它的成员变量、属性、函数。仓颉的反射被设计为只能访问到类型内 public 的成员，意味着 private、protected 和 default 修饰的成员在反射中是不可见的。</p>
<p>例如当我们想要在运行时对类的某一实例成员变量进行获取与修改。</p>
<pre><code class="language-cangjie">import std.reflect.*

public class Foo {
    public static var param1 = 20
    public var param2 = 10
}

main(): Unit{
    let obj = Foo()
    let info = TypeInfo.of(obj)
    let staticVarInfo = info.getStaticVariable(&quot;param1&quot;)
    let instanceVarInfo = info.getInstanceVariable(&quot;param2&quot;)
    println(&quot;成员变量初始值&quot;)
    print(&quot;Foo 的静态成员变量 ${staticVarInfo} = &quot;)
    println((staticVarInfo.getValue() as Int64).getOrThrow())
    print(&quot;obj 的实例成员变量 ${instanceVarInfo} = &quot;)
    println((instanceVarInfo.getValue(obj) as Int64).getOrThrow())
    println(&quot;更改成员变量&quot;)
    staticVarInfo.setValue(8)
    instanceVarInfo.setValue(obj, 25)
    print(&quot;Foo 的静态成员变量 ${staticVarInfo} = &quot;)
    println((staticVarInfo.getValue() as Int64).getOrThrow())
    print(&quot;obj 的实例成员变量 ${instanceVarInfo} = &quot;)
    println((instanceVarInfo.getValue(obj) as Int64).getOrThrow())
    return
}
</code></pre>
<p>编译并执行上面的代码，会输出：</p>
<pre><code class="language-text">成员变量初始值
Foo 的静态成员变量 static param1: Int64 = 20
obj 的实例成员变量 param2: Int64 = 10
更改成员变量
Foo 的静态成员变量 static param1: Int64 = 8
obj 的实例成员变量 param2: Int64 = 25
</code></pre>
<p>同时我们也可以通过反射对属性进行检查以及修改。</p>
<pre><code class="language-cangjie">import std.reflect.*

public class Foo {
    public let _p1: Int64 = 1
    public prop p1: Int64 {
        get() { _p1 }
    }
    public var _p2: Int64 = 2
    public mut prop p2: Int64 {
        get() { _p2 }
        set(v) { _p2 = v }
    }
}

main(): Unit{
    let obj = Foo()
    let info = TypeInfo.of(obj)
    let instanceProps = info.instanceProperties.toArray()
    println(&quot;obj的实例成员属性包含${instanceProps}&quot;)
    let PropInfo1 = info.getInstanceProperty(&quot;p1&quot;)
    let PropInfo2 = info.getInstanceProperty(&quot;p2&quot;)

    println((PropInfo1.getValue(obj) as Int64).getOrThrow())
    println((PropInfo2.getValue(obj) as Int64).getOrThrow())
    if (PropInfo1.isMutable()) {
        PropInfo1.setValue(obj, 10)
    }
    if (PropInfo2.isMutable()) {
        PropInfo2.setValue(obj, 20)
    }
    println((PropInfo1.getValue(obj) as Int64).getOrThrow())
    println((PropInfo2.getValue(obj) as Int64).getOrThrow())
    return
}
</code></pre>
<p>编译并执行上面的代码，会输出：</p>
<pre><code class="language-text">obj 的实例成员属性包含[prop p1: Int64, mut prop p2: Int64]
1
2
1
20
</code></pre>
<p>我们还可以通过反射机制进行函数调用。</p>
<pre><code class="language-cangjie">import std.reflect.*

public class Foo {
    public static func f1(v0: Int64, v1: Int64): Int64 {
        return v0 + v1
    }
}

main(): Unit {
    var num = 0
    let intInfo = TypeInfo.of&lt;Int64&gt;()
    let funcInfo = TypeInfo.of&lt;default.Foo&gt;().getStaticFunction(&quot;f1&quot;, intInfo, intInfo)
    num = (funcInfo.apply([1, 1]) as Int64).getOrThrow()
    println(num)
}
</code></pre>
<p>编译并执行上面的代码，会输出：</p>
<pre><code class="language-text">2
</code></pre>
<h2 id="动态加载"><a class="header" href="#动态加载">动态加载</a></h2>
<p>编译时刻加载称之为静态加载，而动态加载指的是仓颉程序可以在运行过程中通过特定函数来访问仓颉动态模块，以此读写全局变量、调用全局函数、获取类型信息的能力。仓颉中主要通过 <code>ModuleInfo</code> 和 <code>PackageInfo</code> 这两个类型来提供动态加载的能力。</p>
<p>例如我们存在一个 module0 模块下的 package0 包含一个公开的类型 Foo，其对应的仓颉动态模块路径为 &quot;./module_package.so&quot; 。应用动态加载我们便可以在运行时得到这个 Foo 的类型信息。</p>
<pre><code class="language-cangjie">let m = ModuleInfo.load(&quot;./module_package&quot;)
let p = m.getPackageInfo(&quot;package0&quot;).getOrThrow()
let at = TypeInfo.get(&quot;module0/package0.Foo&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="注解"><a class="header" href="#注解">注解</a></h1>
<p>仓颉中提供了一些属性宏用来支持一些特殊情况的处理。</p>
<h2 id="确保正确使用整数运算溢出策略的注解"><a class="header" href="#确保正确使用整数运算溢出策略的注解">确保正确使用整数运算溢出策略的注解</a></h2>
<p>仓颉中提供三种属性宏来控制整数溢出的处理策略，即 <code>@OverflowThrowing</code>，<code>@OverflowWrapping</code> 和 <code>@OverflowSaturating</code> ，这些属性宏当前只能标记于函数声明之上，作用于函数内的整数运算和整型转换。它们分别对应以下三种溢出处理策略：</p>
<p>(1) 抛出异常（throwing）：当整数运算溢出时，抛出异常。</p>
<pre><code class="language-cangjie">@OverflowThrowing
main() {
    let res: Int8 = Int8(100) + Int8(29)
    /* 100 + 29 在数学上等于 129，
     * 在 Int8 的表示范围上发生了上溢出，
     * 程序抛出异常
     */
    let con: UInt8 = UInt8(-132)
    /* -132 在 UInt8 的表示范围上发生了下溢出，
     * 程序抛出异常
     */
    0
}
</code></pre>
<p>(2) 高位截断（wrapping）：当整数运算的结果超出用于接收它的内存空间所能表示的数据范围时，则截断超出该内存空间的部分。</p>
<pre><code class="language-cangjie">@OverflowWrapping
main() {
    let res: Int8 = Int8(105) * Int8(4)
    /* 105 * 4 在数学上等于 420，
     * 对应的二进制为 1 1010 0100，
     * 超过了用于接收该结果的 8 位内存空间，
     * 截断后的结果在二进制上表示为 1010 0100，
     * 对应为有符号整数 -92
     */
    let temp: Int16 = Int16(-132)
    let con: UInt8 = UInt8(temp)
    /* -132 对应的二进制为 1111 1111 0111 1100，
     * 超过了用于接收该结果的 8 位内存空间，
     * 截断后的结果在二进制上表示为 0111 1100
     * 对应为有符号整数 124
     */
    0
}
</code></pre>
<p>(3) 饱和（saturating）：当整数运算溢出时，选择对应固定精度的极值作为结果。</p>
<pre><code class="language-cangjie">@OverflowSaturating
main() {
    let res: Int8 = Int8(-100) - Int8(45)
    /* -100 - 45 在数学上等于 -145，
     * 在 Int8 的表示范围上发生了下溢出，
     * 选择 Int8 的最小值 -128 作为结果
     */
    let con: Int8 = Int8(1024)
    /* 1024 在 Int8 的表示范围上发生了上溢出，
     * 选择 Int8 的最大值 127 作为结果
     */
    0
}
</code></pre>
<p>默认情况下（即未标注该类属性宏时），采取抛出异常（<code>@OverflowThrowing</code>）的处理策略。</p>
<p>实际情况下需要根据业务场景的需求正确选择溢出策略。例如要在 <code>Int32</code> 上实现某种安全运算，使得计算结果和计算过程在数学上相等，就需要使用抛出异常的策略。</p>
<p>【反例】</p>
<pre><code class="language-cangjie">// 计算结果被高位截断
@OverflowWrapping
func operation(a: Int32, b: Int32): Int32 {
    a + b // No exception will be thrown when overflow occurs
}
</code></pre>
<p>该错误例子使用了高位截断的溢出策略，比如当传入的参数 <code>a</code> 和 <code>b</code> 较大导致结果溢出时，会产生高位截断的情况，导致函数返回结果和计算表达式 <code>a + b</code> 在数学上不是相等关系。</p>
<p>【正例】</p>
<pre><code class="language-cangjie">// 安全
@OverflowThrowing
func operation(a: Int32, b: Int32): Int32 {
    a + b
}

main() {
    try {
        operation(a, b)
    } catch (e: ArithmeticException) {
        //Handle error
    }
    0
}
</code></pre>
<p>该正确例子使用了抛出异常的溢出策略，当传入的参数 <code>a</code> 和 <code>b</code> 较大导致整数溢出时，<code>operation</code> 函数会抛出异常。</p>
<p>下面总结了可能造成整数溢出的数学操作符。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">操作符</th><th style="text-align: center">溢出</th><th style="text-align: center">操作符</th><th style="text-align: center">溢出</th><th style="text-align: center">操作符</th><th style="text-align: center">溢出</th><th style="text-align: center">操作符</th><th style="text-align: center">溢出</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>+</code></td><td style="text-align: center">Y</td><td style="text-align: center"><code>-=</code></td><td style="text-align: center">Y</td><td style="text-align: center"><code>&lt;&lt;</code></td><td style="text-align: center">N</td><td style="text-align: center"><code>&lt;</code></td><td style="text-align: center">N</td></tr>
<tr><td style="text-align: center"><code>-</code></td><td style="text-align: center">Y</td><td style="text-align: center"><code>*=</code></td><td style="text-align: center">Y</td><td style="text-align: center"><code>&gt;&gt;</code></td><td style="text-align: center">N</td><td style="text-align: center"><code>&gt;</code></td><td style="text-align: center">N</td></tr>
<tr><td style="text-align: center"><code>*</code></td><td style="text-align: center">Y</td><td style="text-align: center"><code>/=</code></td><td style="text-align: center">Y</td><td style="text-align: center"><code>&amp;</code></td><td style="text-align: center">N</td><td style="text-align: center"><code>&gt;=</code></td><td style="text-align: center">N</td></tr>
<tr><td style="text-align: center"><code>/</code></td><td style="text-align: center">Y</td><td style="text-align: center"><code>%=</code></td><td style="text-align: center">N</td><td style="text-align: center"><code>|</code></td><td style="text-align: center">N</td><td style="text-align: center"><code>&lt;=</code></td><td style="text-align: center">N</td></tr>
<tr><td style="text-align: center"><code>%</code></td><td style="text-align: center">N</td><td style="text-align: center"><code>&lt;&lt;=</code></td><td style="text-align: center">N</td><td style="text-align: center"><code>^</code></td><td style="text-align: center">N</td><td style="text-align: center"><code>==</code></td><td style="text-align: center">N</td></tr>
<tr><td style="text-align: center"><code>++</code></td><td style="text-align: center">Y</td><td style="text-align: center"><code>&gt;&gt;=</code></td><td style="text-align: center">N</td><td style="text-align: center"><code>**=</code></td><td style="text-align: center">Y</td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"><code>--</code></td><td style="text-align: center">Y</td><td style="text-align: center"><code>&amp;=</code></td><td style="text-align: center">N</td><td style="text-align: center"><code>!</code></td><td style="text-align: center">N</td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"><code>=</code></td><td style="text-align: center">N</td><td style="text-align: center"><code>|=</code></td><td style="text-align: center">N</td><td style="text-align: center"><code>!=</code></td><td style="text-align: center">N</td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"><code>+=</code></td><td style="text-align: center">Y</td><td style="text-align: center"><code>^=</code></td><td style="text-align: center">N</td><td style="text-align: center"><code>**</code></td><td style="text-align: center">Y</td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
</tbody></table>
</div>
<h2 id="性能优化注解"><a class="header" href="#性能优化注解">性能优化注解</a></h2>
<p>为了提升与 <code>C</code> 语言互操作的性能，仓颉提供属性宏 <code>@FastNative</code> 控制 <code>cjnative</code> 后端优化对于 <code>C</code> 函数的调用。值得注意的是，属性宏 <code>@FastNative</code> 只能用于 <code>foreign</code> 声明的函数。</p>
<h3 id="fastnative-使用限制"><a class="header" href="#fastnative-使用限制"><code>@FastNative</code> 使用限制</a></h3>
<p>开发者在使用 <code>@FastNative</code> 修饰 <code>foreign</code> 函数时，应确保对应的 <code>C</code> 函数满足以下两点要求。</p>
<ul>
<li>首先，函数的整体执行时间不宜太长。例如：
<ul>
<li>不允许函数内部存在很大的循环；</li>
<li>不允许函数内部产生阻塞行为，如，调用 <code>sleep</code>、<code>wait</code> 等函数。</li>
</ul>
</li>
<li>其次，函数内部不能调用仓颉方法。</li>
</ul>
<h2 id="自定义注解"><a class="header" href="#自定义注解">自定义注解</a></h2>
<p>自定义注解机制用来让反射（详见反射章节）获取标注内容，目的是在类型元数据之外提供更多的有用信息，以支持更复杂的逻辑。</p>
<p>开发者可以通过自定义类型标注 <code>@Annotation</code> 方式创建自己的自定义注解。<code>@Annotation</code> 只能修饰 <code>class</code>，并且不能是 <code>abstract</code> 或 <code>open</code> 或 <code>sealed</code> 修饰的 <code>class</code>。当一个 <code>class</code> 声明它标注了 <code>@Annotation</code>，那么它必须要提供至少一个 <code>const init</code> 函数，否则编译器会报错。</p>
<p>下面的例子定义了一个自定义注解 <code>@Version</code>，并用其修饰 <code>A</code>, <code>B</code> 和 <code>C</code>。在 <code>main</code> 中，我们通过反射获取到类上的 <code>@Version</code> 注解信息，并将其打印出来。</p>
<pre><code class="language-cangjie">package pkg

import std.reflect.TypeInfo

@Annotation
public class Version {
    let code: String
    const init(code: String) {
        this.code = code
    }
}

@Version[&quot;1.0&quot;]
class A {}

@Version[&quot;1.1&quot;]
class B {}

main() {
    let objects = [A(), B()]
    for (obj in objects) {
        let annOpt = TypeInfo.of(obj).findAnnotation(&quot;pkg.Version&quot;)
        if (let Some(ann) &lt;- annOpt) {
            if (let Some(version) &lt;- ann as Version) {
                println(version.code)
            }
        }
    }
}
</code></pre>
<p>编译并执行上述代码，输出结果为：</p>
<pre><code class="language-text">1.0
1.1
</code></pre>
<p>注解信息需要在编译时生成信息并绑定到类型上，自定义注解在使用时必须使用 <code>const init</code> 构建出合法的实例。注解声明语法与声明宏语法一致，后面的 <code>[]</code> 括号中需要按顺序或命名参数规则传入参数，且参数必须是 const 表达式（详见常量求值章节）。对于拥有无参构造函数的注解类型，声明时允许省略括号。</p>
<p>下面的例子中定义了一个拥有无参 <code>const init</code> 的自定义注解 <code>@Deprecated</code>，使用时 <code>@Deprecated</code> 和 <code>@Deprecated[]</code> 这两种写法均可。</p>
<pre><code class="language-cangjie">package pkg

import std.reflect.TypeInfo

@Annotation
public class Deprecated {
    const init() {}
}

@Deprecated
class A {}

@Deprecated[]
class B {}

main() {
    if (TypeInfo.of(A()).findAnnotation(&quot;pkg.Deprecated&quot;).isSome()) {
        println(&quot;A is deprecated&quot;)
    }
    if (TypeInfo.of(B()).findAnnotation(&quot;pkg.Deprecated&quot;).isSome()) {
        println(&quot;B is deprecated&quot;)
    }
}
</code></pre>
<p>编译并执行上述代码，输出结果为：</p>
<pre><code class="language-text">A is deprecated
B is deprecated
</code></pre>
<p>对于同一个注解目标，同一个注解类不允许声明多次，即不可重复。</p>
<pre><code class="language-cangjie">@Deprecated
@Deprecated // Error
class A {}
</code></pre>
<p><code>Annotation</code> 不会被继承，因此一个类型的注解元数据只会来自它定义时声明的注解。如果需要父类型的注解元数据信息，需要开发者自己用反射接口查询。</p>
<p>下面的例子中，<code>A</code> 被 <code>@Deprecated</code> 注解修饰，<code>B</code> 继承 <code>A</code>，但是 <code>B</code> 没有 <code>A</code> 的注解。</p>
<pre><code class="language-cangjie">package pkg

import std.reflect.TypeInfo

@Annotation
public class Deprecated {
    const init() {}
}

@Deprecated
open class A {}

class B &lt;: A {}

main() {
    if (TypeInfo.of(A()).findAnnotation(&quot;pkg.Deprecated&quot;).isSome()) {
        println(&quot;A is deprecated&quot;)
    }
    if (TypeInfo.of(B()).findAnnotation(&quot;pkg.Deprecated&quot;).isSome()) {
        println(&quot;B is deprecated&quot;)
    }
}
</code></pre>
<p>编译并执行上述代码，输出结果为：</p>
<pre><code class="language-text">A is deprecated
</code></pre>
<p>自定义注解可以用在类型声明（<code>class</code>、<code>struct</code>、<code>enum</code>、<code>interface</code>）、成员函数/构造函数中的参数、构造函数声明、成员函数声明、成员变量声明、成员属性声明。也可以限制自己可以使用的位置，这样可以减少开发者的误用，这类注解需要在声明 <code>@Annotation</code> 时标注 <code>target</code> 参数，参数类型为 <code>Array&lt;AnnotationKind&gt;</code>。其中，<code>AnnotationKind</code> 是标准库中定义的 <code>enum</code>。当没有限定 target 的时候，该自定义注解可以用在以上全部位置。当限定 target 时，只能用在声明的列表中。</p>
<pre><code class="language-cangjie">public enum AnnotaitionKind {
    | Type
    | Parameter
    | Init
    | MemberProperty
    | MemberFunction
    | MemberVariable
}
</code></pre>
<p>下面的例子中，自定义注解通过 <code>target</code> 限定只能用在成员函数上，用在其他位置会编译报错。</p>
<pre><code class="language-cangjie">@Annotation[target: [MemberFunction]]
public class Deprecated {
    const init() {}
}

class A {
    @Deprecated // Ok, member funciton
    func deprecated() {}
}

@Deprecated // Error, type
class B {}

main() {}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="仓颉-c-互操作"><a class="header" href="#仓颉-c-互操作">仓颉-C 互操作</a></h1>
<p>为了兼容已有的生态，仓颉支持调用 C 语言的函数，也支持 C 语言调用仓颉的函数。</p>
<h2 id="仓颉调用-c-的函数"><a class="header" href="#仓颉调用-c-的函数">仓颉调用 C 的函数</a></h2>
<p>在仓颉中要调用 C 的函数，需要在仓颉语言中用 <code>@C</code> 和 <code>foreign</code> 关键字声明这个函数，但 <code>@C</code> 在修饰 <code>foreign</code> 声明的时候，可以省略。</p>
<p>举个例子，假设我们要调用 C 的 <code>rand</code> 和 <code>printf</code> 函数，它的函数签名是这样的：</p>
<pre><code class="language-c">// stdlib.h
int rand();

// stdio.h
int printf (const char *fmt, ...);
</code></pre>
<p>那么在仓颉中调用这两个函数的方式如下：</p>
<pre><code class="language-cangjie">// declare the function by `foreign` keyword, and omit `@C`
foreign func rand(): Int32
foreign func printf(fmt: CString, ...): Int32

main() {
    // call this function by `unsafe` block
    let r = unsafe { rand() }
    println(&quot;random number ${r}&quot;)
    unsafe {
        var fmt = LibC.mallocCString(&quot;Hello, No.%d\n&quot;)
        printf(fmt, 1)
        LibC.free(fmt)
    }
}
</code></pre>
<p>需要注意的是：</p>
<ol>
<li><code>foreign</code> 修饰函数声明，代表该函数为外部函数。被 <code>foreign</code> 修饰的函数只能有函数声明，不能有函数实现。</li>
<li><code>foreign</code> 声明的函数，参数和返回类型必须符合 C 和仓颉数据类型之间的映射关系（详见下节：<a href="source_zh_cn/FFI/./cangjie-c.html#%E7%B1%BB%E5%9E%8B%E6%98%A0%E5%B0%84">类型映射</a>）。</li>
<li>由于 C 侧函数很可能产生不安全操作，所以调用 <code>foreign</code> 修饰的函数需要被 <code>unsafe</code> 块包裹，否则会发生编译错误。</li>
<li><code>@C</code> 修饰的 <code>foreign</code> 关键字只能用来修饰函数声明，不可用来修饰其他声明，否则会发生编译错误。</li>
<li><code>@C</code> 只支持修饰 <code>foreign</code> 函数、<code>top-level</code> 作用域中的非泛型函数和 <code>struct</code> 类型。</li>
<li><code>foreign</code> 函数不支持命名参数和参数默认值。<code>foreign</code> 函数允许变长参数，使用 <code>...</code>表达，只能用于参数列表的最后。变长参数均需要满足 <code>CType</code> 约束，但不必是同一类型。</li>
<li>仓颉（CJNative 后端）虽然提供了栈扩容能力，但是由于 C 侧函数实际使用栈大小仓颉无法感知，所以 ffi 调用进入 C 函数后，仍然存在栈溢出的风险，需要开发者根据实际情况，修改 <code>cjStackSize</code> 的配置。</li>
</ol>
<p>一些不合法的 <code>foreign</code> 声明的示例代码如下：</p>
<pre><code class="language-cangjie">foreign func rand(): Int32 { // compiler error
    return 0
}
@C
foreign var a: Int32 = 0 // compiler error
@C
foreign class A{} // compiler error
@C
foreign interface B{} // compiler error
</code></pre>
<h2 id="cfunc"><a class="header" href="#cfunc">CFunc</a></h2>
<p>仓颉中的 <code>CFunc</code> 指可以被 C 语言代码调用的函数，共有以下三种形式：</p>
<ol>
<li><code>@C</code> 修饰的 <code>foreign</code> 函数</li>
<li><code>@C</code> 修饰的仓颉函数</li>
<li>类型为 <code>CFunc</code> 的 <code>lambda</code> 表达式，与普通的 lambda 表达式不同，<code>CFunc lambda</code> 不能捕获变量。</li>
</ol>
<!-- run -->
<pre><code class="language-cangjie">// Case 1
foreign func free(ptr: CPointer&lt;Int8&gt;): Unit

// Case 2
@C
func callableInC(ptr: CPointer&lt;Int8&gt;) {
    print(&quot;This function is defined in Cangjie.&quot;)
}

// Case 3
let f1: CFunc&lt;(CPointer&lt;Int8&gt;) -&gt; Unit&gt; = { ptr =&gt;
    print(&quot;This function is defined with CFunc lambda.&quot;)
}
</code></pre>
<p>以上三种形式声明/定义的函数的类型均为 <code>CFunc&lt;(CPointer&lt;Int8&gt;) -&gt; Unit&gt;</code>。<code>CFunc</code> 对应 C 语言的函数指针类型。这个类型为泛型类型，其泛型参数表示该 <code>CFunc</code> 入参和返回值类型，使用方式如下：</p>
<!-- run -->
<pre><code class="language-cangjie">foreign func atexit(cb: CFunc&lt;() -&gt; Unit&gt;): Int32
</code></pre>
<p>与 <code>foreign</code> 函数一样，其他形式的 <code>CFunc</code> 的参数和返回类型必须满足 <code>CType</code> 约束，且不支持命名参数和参数默认值。</p>
<p><code>CFunc</code> 在仓颉代码中被调用时，需要处在 <code>unsafe</code> 上下文中。</p>
<p>仓颉语言支持将一个 <code>CPointer&lt;T&gt;</code> 类型的变量类型转换为一个具体的 <code>CFunc</code>，其中 <code>CPointer</code> 的泛型参数 <code>T</code> 可以是满足 <code>CType</code> 约束的任意类型，使用方式如下：</p>
<!-- compile -->
<pre><code class="language-cangjie">main() {
    var ptr = CPointer&lt;Int8&gt;()
    var f = CFunc&lt;() -&gt; Unit&gt;(ptr)
    unsafe { f() } // core dumped when running, because the pointer is nullptr.
}
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p>将一个指针强制类型转换为 <code>CFunc</code> 并进行函数调用是危险行为，需要用户保证指针指向的是一个切实可用的函数地址，否则将发生运行时错误。</p>
</blockquote>
<h2 id="inout-参数"><a class="header" href="#inout-参数">inout 参数</a></h2>
<p>在仓颉中调用 <code>CFunc</code> 时，其实参可以使用 <code>inout</code> 关键字修饰，组成引用传值表达式，此时，该参数按引用传递。引用传值表达式的类型为 <code>CPointer&lt;T&gt;</code>，其中 <code>T</code> 为 <code>inout</code> 修饰的表达式的类型。</p>
<p>引用传值表达式具有以下约束：</p>
<ul>
<li>仅可用于对 <code>CFunc</code> 的调用处；</li>
<li>其修饰对象的类型必须满足 <code>CType</code> 约束，但不可以是 <code>CString</code>；</li>
<li>其修饰对象不可以是用 <code>let</code> 定义的，不可以是字面量、入参、其他表达式的值等临时变量；</li>
<li>通过仓颉侧引用传值表达式传递到 C 侧的指针，仅保证在函数调用期间有效，即此种场景下 C 侧不应该保存指针以留作后用。</li>
</ul>
<p><code>inout</code> 修饰的变量，可以是定义在 <code>top-level</code> 作用域中的变量、局部变量、<code>struct</code> 中的成员变量，但不能直接或间接来源于 <code>class</code> 的实例成员变量。</p>
<p>下面是一个例子：</p>
<pre><code class="language-cangjie">foreign func foo1(ptr: CPointer&lt;Int32&gt;): Unit

@C
func foo2(ptr: CPointer&lt;Int32&gt;): Unit {
    let n = unsafe { ptr.read() }
    println(&quot;*ptr = ${n}&quot;)
}

let foo3: CFunc&lt;(CPointer&lt;Int32&gt;) -&gt; Unit&gt; = { ptr =&gt;
    let n = unsafe { ptr.read() }
    println(&quot;*ptr = ${n}&quot;)
}

struct Data {
    var n: Int32 = 0
}

class A {
    var data = Data()
}

main() {
    var n: Int32 = 0
    unsafe {
        foo1(inout n)  // OK
        foo2(inout n)  // OK
        foo3(inout n)  // OK
    }
    var data = Data()
    var a = A()
    unsafe {
        foo1(inout data.n)   // OK
        foo1(inout a.data.n) // Error, n is derived indirectly from instance member variables of class A
    }
}
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p>使用宏扩展特性时，在宏的定义中，暂时不能使用 <code>inout</code> 参数特性。</p>
</blockquote>
<h2 id="unsafe"><a class="header" href="#unsafe">unsafe</a></h2>
<p>在引入与 C 语言的互操作过程中，同时也引入了 C 的许多不安全因素，因此在仓颉中使用 <code>unsafe</code> 关键字，用于对跨 C 调用的不安全行为进行标识。</p>
<p>关于 unsafe 关键字，有以下几点说明：</p>
<ul>
<li><code>unsafe</code> 可以修饰函数、表达式，也可以修饰一段作用域。</li>
<li>被 <code>@C</code> 修饰的函数，被调用处需要在 <code>unsafe</code> 上下文中。</li>
<li>在调用 <code>CFunc</code> 时，使用处需要在 <code>unsafe</code> 上下文中。</li>
<li><code>foreign</code> 函数在仓颉中进行调用，被调用处需要在 <code>unsafe</code> 上下文中。</li>
<li>当被调用函数被 <code>unsafe</code> 修饰时，被调用处需要在 <code>unsafe</code> 上下文中。</li>
</ul>
<p>使用方式如下：</p>
<!-- run -->
<pre><code class="language-cangjie">foreign func rand(): Int32

@C
func foo(): Unit {
    println(&quot;foo&quot;)
}

var foo1: CFunc&lt;() -&gt; Unit&gt; = { =&gt;
    println(&quot;foo1&quot;)
}

main(): Int64 {
    unsafe {
        rand()           // Call foreign func.
        foo()            // Call @C func.
        foo1()           // Call CFunc var.
    }
    0
}
</code></pre>
<p>需要注意的是，普通 <code>lambda</code> 无法传递 <code>unsafe</code> 属性，当 <code>unsafe</code> 的 <code>lambda</code> 逃逸后，可以不在 <code>unsafe</code> 上下文中直接调用而未产生任何编译错误。当需要在 <code>lambda</code> 中调用 <code>unsafe</code> 函数时，建议在 <code>unsafe</code> 块中进行调用，参考如下用例：</p>
<!-- run -->
<pre><code class="language-cangjie">unsafe func A(){}
unsafe func B(){
    var f = { =&gt;
        unsafe { A() } // Avoid calling A() directly without unsafe in a normal lambda.
    }  
    return f  
}
main() {
    var f = unsafe{ B() }
    f()
    println(&quot;Hello World&quot;)
}
</code></pre>
<h2 id="调用约定"><a class="header" href="#调用约定">调用约定</a></h2>
<p>函数调用约定描述调用者和被调用者双方如何进行函数调用（如参数如何传递、栈由谁清理等），函数调用和被调用双方必须使用相同的调用约定才能正常运行。仓颉编程语言通过 <code>@CallingConv</code> 来表示各种调用约定，支持的调用约定如下：</p>
<ul>
<li><strong>CDECL</strong>：<code>CDECL</code> 表示 clang 的 C 编译器在不同平台上默认使用的调用约定。</li>
<li><strong>STDCALL</strong>：<code>STDCALL</code> 表示 Win32 API 使用的调用约定。</li>
</ul>
<p>通过 C 语言互操作机制调用的 C 函数，未指定调用约定时将采用默认的 <code>CDECL</code> 调用约定。如下调用 C 标准库函数 <code>rand</code> 示例：</p>
<!-- run -->
<pre><code class="language-cangjie">@CallingConv[CDECL]   // Can be omitted in default.
foreign func rand(): Int32

main() {
    println(unsafe { rand() })
}
</code></pre>
<p><code>@CallingConv</code> 只能用于修饰 <code>foreign</code> 块、单个 <code>foreign</code> 函数和 <code>top-level</code> 作用域中的 <code>CFunc</code> 函数。当 <code>@CallingConv</code> 修饰 <code>foreign</code> 块时，会为 <code>foreign</code> 块中的每个函数分别加上相同的 <code>@CallingConv</code> 修饰。</p>
<h2 id="类型映射"><a class="header" href="#类型映射">类型映射</a></h2>
<h3 id="基础类型"><a class="header" href="#基础类型">基础类型</a></h3>
<p>仓颉与 C 语言支持基本数据类型的映射，总体原则是：</p>
<ol>
<li>仓颉的类型不包含指向托管内存的引用类型；</li>
<li>仓颉的类型和 C 的类型具有同样的内存布局。</li>
</ol>
<p>比如说，一些基本的类型映射关系如下：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Cangjie Type</th><th style="text-align: center">C Type</th><th style="text-align: center">Size (byte)</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>Unit</code></td><td style="text-align: center"><code>void</code></td><td style="text-align: center">0</td></tr>
<tr><td style="text-align: center"><code>Bool</code></td><td style="text-align: center"><code>bool</code></td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center"><code>UInt8</code></td><td style="text-align: center"><code>char</code></td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center"><code>Int8</code></td><td style="text-align: center"><code>int8_t</code></td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center"><code>UInt8</code></td><td style="text-align: center"><code>uint8_t</code></td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center"><code>Int16</code></td><td style="text-align: center"><code>int16_t</code></td><td style="text-align: center">2</td></tr>
<tr><td style="text-align: center"><code>UInt16</code></td><td style="text-align: center"><code>uint16_t</code></td><td style="text-align: center">2</td></tr>
<tr><td style="text-align: center"><code>Int32</code></td><td style="text-align: center"><code>int32_t</code></td><td style="text-align: center">4</td></tr>
<tr><td style="text-align: center"><code>UInt32</code></td><td style="text-align: center"><code>uint32_t</code></td><td style="text-align: center">4</td></tr>
<tr><td style="text-align: center"><code>Int64</code></td><td style="text-align: center"><code>int64_t</code></td><td style="text-align: center">8</td></tr>
<tr><td style="text-align: center"><code>UInt64</code></td><td style="text-align: center"><code>uint64_t</code></td><td style="text-align: center">8</td></tr>
<tr><td style="text-align: center"><code>IntNative</code></td><td style="text-align: center"><code>ssize_t</code></td><td style="text-align: center">platform dependent</td></tr>
<tr><td style="text-align: center"><code>UIntNative</code></td><td style="text-align: center"><code>size_t</code></td><td style="text-align: center">platform dependent</td></tr>
<tr><td style="text-align: center"><code>Float32</code></td><td style="text-align: center"><code>float</code></td><td style="text-align: center">4</td></tr>
<tr><td style="text-align: center"><code>Float64</code></td><td style="text-align: center"><code>double</code></td><td style="text-align: center">8</td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>说明：</strong></p>
<p><code>int</code> 类型、<code>long</code> 类型等由于其在不同平台上的不确定性，需要程序员自行指定对应仓颉编程语言类型。在 C 互操作场景中，与 C 语言类似，<code>Unit</code> 类型仅可作为 <code>CFunc</code> 中的返回类型和 <code>CPointer</code> 的泛型参数。</p>
</blockquote>
<p>仓颉也支持与 C 语言的结构体和指针类型的映射。</p>
<h3 id="结构体"><a class="header" href="#结构体">结构体</a></h3>
<p>对于结构体类型，仓颉用 <code>@C</code> 修饰的 <code>struct</code> 来对应。比如说 C 语言里面有这样的一个结构体：</p>
<pre><code class="language-c">typedef struct {
    long long x;
    long long y;
    long long z;
} Point3D;
</code></pre>
<p>那么它对应的仓颉类型可以这么定义：</p>
<!-- run -example00-->
<pre><code class="language-cangjie">@C
struct Point3D {
    var x: Int64 = 0
    var y: Int64 = 0
    var z: Int64 = 0
}
</code></pre>
<p>如果 C 语言里有这样的一个函数：</p>
<pre><code class="language-c">Point3D addPoint(Point3D p1, Point3D p2);
</code></pre>
<p>那么对应的，在仓颉里面可以这样声明这个函数：</p>
<!-- run -example00-->
<pre><code class="language-cangjie">foreign func addPoint(p1: Point3D, p2: Point3D): Point3D
</code></pre>
<p>用 <code>@C</code> 修饰的 <code>struct</code> 必须满足以下限制：</p>
<ul>
<li>成员变量的类型必须满足 <code>CType</code> 约束</li>
<li>不能实现或者扩展 <code>interfaces</code></li>
<li>不能作为 <code>enum</code> 的关联值类型</li>
<li>不允许被闭包捕获</li>
<li>不能具有泛型参数</li>
</ul>
<p>用 <code>@C</code> 修饰的 <code>struct</code> 自动满足 <code>CType</code> 约束。</p>
<h3 id="指针"><a class="header" href="#指针">指针</a></h3>
<p>对于指针类型，仓颉提供 <code>CPointer&lt;T&gt;</code> 类型来对应 C 侧的指针类型，其泛型参数 <code>T</code> 需要满足 <code>CType</code> 约束。比如对于 malloc 函数，在 C 里面的签名为：</p>
<pre><code class="language-c">void* malloc(size_t size);
</code></pre>
<p>那么在仓颉中，它可以声明为：</p>
<!-- run -->
<pre><code class="language-cangjie">foreign func malloc(size: UIntNative): CPointer&lt;Unit&gt;
</code></pre>
<p><code>CPointer</code> 可以进行读写、偏移计算、判空以及转为指针的整型形式等，详细 API 可以参考《仓颉编程语言库 API》。其中读写和偏移计算为不安全行为，当不合法的指针调用这些函数时，可能发生未定义行为，这些 unsafe 函数需要在 unsafe 块中调用。</p>
<p><code>CPointer</code> 的使用示例如下：</p>
<!-- run -->
<pre><code class="language-cangjie">foreign func malloc(size: UIntNative): CPointer&lt;Unit&gt;
foreign func free(ptr: CPointer&lt;Unit&gt;): Unit

@C
struct Point3D {
    var x: Int64
    var y: Int64
    var z: Int64

    init(x: Int64, y: Int64, z: Int64) {
        this.x = x
        this.y = y
        this.z = z
    }
}

main() {
    let p1 = CPointer&lt;Point3D&gt;() // create a CPointer with null value
    if (p1.isNull()) {  // check if the pointer is null
        print(&quot;p1 is a null pointer&quot;)
    }

    let sizeofPoint3D: UIntNative = 24
    var p2 = unsafe { malloc(sizeofPoint3D) }    // malloc a Point3D in heap
    var p3 = unsafe { CPointer&lt;Point3D&gt;(p2) }    // pointer type cast

    unsafe { p3.write(Point3D(1, 2, 3)) } // write data through pointer

    let p4: Point3D = unsafe { p3.read() } // read data through pointer

    let p5: CPointer&lt;Point3D&gt; = unsafe { p3 + 1 } // offset of pointer

    unsafe { free(p2) }
}
</code></pre>
<p>仓颉语言支持 <code>CPointer</code> 之间的强制类型转换，转换前后的 <code>CPointer</code> 的泛型参数 <code>T</code> 均需要满足 <code>CType</code> 的约束，使用方式如下：</p>
<!-- run -->
<pre><code class="language-cangjie">main() {
    var pInt8 = CPointer&lt;Int8&gt;()
    var pUInt8 = CPointer&lt;UInt8&gt;(pInt8) // CPointer&lt;Int8&gt; convert to CPointer&lt;UInt8&gt;
    0
}
</code></pre>
<p>仓颉语言支持将一个 <code>CFunc</code> 类型的变量类型转换为一个具体的 <code>CPointer</code>，其中 <code>CPointer</code> 的泛型参数 <code>T</code> 可以是满足 <code>CType</code> 约束的任意类型，使用方式如下：</p>
<!-- run -->
<pre><code class="language-cangjie">foreign func rand(): Int32
main() {
    var ptr = CPointer&lt;Int8&gt;(rand)
    0
}
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p>将一个 <code>CFunc</code> 强制类型转换为指针通常是安全的，但是不应该对转换后的指针执行任何的 <code>read</code>，<code>write</code> 操作，可能会导致运行时错误。</p>
</blockquote>
<h3 id="数组"><a class="header" href="#数组">数组</a></h3>
<p>仓颉使用 <code>VArray</code> 类型与 C 的数组类型映射，<code>VArray</code> 可以用户作为函数参数和 <code>@C struct</code> 成员。当 <code>VArray&lt;T, $N&gt;</code> 中的元素类型 <code>T</code> 满足 <code>CType</code> 约束时， <code>VArray&lt;T, $N&gt;</code> 类型也满足 <code>CType</code> 约束。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>CJVM 后端暂时不支持 <code>VArray</code>。</p>
</blockquote>
<p><strong>作为函数参数类型：</strong></p>
<p>当 <code>VArray</code> 作为 <code>CFunc</code> 的参数时， <code>CFunc</code> 的函数签名仅可以是 <code>CPointer&lt;T&gt;</code> 类型或 <code>VArray&lt;T, $N&gt;</code> 类型。当函数签名中的参数类型为 <code>VArray&lt;T, $N&gt;</code> 时，传递的参数仍以 <code>CPointer&lt;T&gt;</code> 形式传递。</p>
<p><code>VArray</code> 作为参数的使用示例如下：</p>
<pre><code class="language-cangjie">foreign func cfoo1(a: CPointer&lt;Int32&gt;)：Unit
foreign func cfoo2(a: VArray&lt;Int32, $3&gt;): Unit
</code></pre>
<p>对应的 C 侧函数定义可以是：</p>
<pre><code class="language-c">void cfoo1(int *a) { ... }
void cfoo2(int a[3]) { ... }
</code></pre>
<p>调用 <code>CFunc</code> 时，需要通过 <code>inout</code> 修饰 <code>VArray</code> 类型变量：</p>
<pre><code class="language-cangjie">var a: VArray&lt;Int32, $3&gt; = [1, 2, 3]
unsafe {
    cfoo1(inout a)
    cfoo2(inout a)
}
</code></pre>
<p><code>VArray</code> 不允许作为 <code>CFunc</code> 的返回值类型。</p>
<p><strong>作为 @C struct 成员：</strong></p>
<p>当 <code>VArray</code> 作为 <code>@C struct</code> 成员时，它的内存布局与 C 侧的结构体排布一致，需要保证仓颉侧声明长度与类型也与 C 完全一致：</p>
<pre><code class="language-c">struct S {
    int a[2];
    int b[0];
}
</code></pre>
<p>在仓颉中，可以声明为如下结构体与 C 代码对应：</p>
<!-- run -->
<pre><code class="language-cangjie">@C
struct S {
    var a = VArray&lt;Int32, $2&gt;(item: 0)
    var b = VArray&lt;Int32, $0&gt;(item: 0)
}
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p>C 语言中允许结构体的最后一个字段为未指明长度的数组类型，该数组被称为柔性数组（flexible array），仓颉不支持包含柔性数组的结构体的映射。</p>
</blockquote>
<h3 id="字符串"><a class="header" href="#字符串">字符串</a></h3>
<p>特别地，对于 C 语言中的字符串类型，仓颉中设计了一个 <code>CString</code> 类型来对应。为简化为 C 语言字符串的操作，<code>CString</code> 提供了以下成员函数：</p>
<ul>
<li><code>init(p: CPointer&lt;UInt8&gt;)</code>  通过 CPointer 构造一个 CString</li>
<li><code>func getChars()</code> 获取字符串的地址，类型为 <code>CPointer&lt;UInt8&gt;</code></li>
<li><code>func size(): Int64</code>  计算该字符串的长度</li>
<li><code>func isEmpty(): Bool</code>  判断该字符串的长度是否为 0，如果字符串的指针为空返回 true</li>
<li><code>func isNotEmpty(): Bool</code>  判断该字符串的长度是否不为 0，如果字符串的指针为空返回 false</li>
<li><code>func isNull(): Bool</code>  判断该字符串的指针是否为 null</li>
<li><code>func startsWith(str: CString): Bool</code>  判断该字符串是否以 str 开头</li>
<li><code>func endsWith(str: CString): Bool</code>  判断该字符串是否以 str 结尾</li>
<li><code>func equals(rhs: CString): Bool</code>  判断该字符串是否与 rhs 相等</li>
<li><code>func equalsLower(rhs: CString): Bool</code>  判断该字符串是否与 rhs 相等，忽略大小写</li>
<li><code>func subCString(start: UInt64): CString</code>  从 start 开始截取子串，返回的子串存储在新分配的空间中</li>
<li><code>func subCString(start: UInt64, len: UInt64): CString</code>  从 start 开始截取长度为 len 的子串，返回的子串存储在新分配的空间中</li>
<li><code>func compare(str: CString): Int32</code>  该字符串与 str 比较，返回结果与 C 语言的 <code>strcmp(this, str)</code> 一样</li>
<li><code>func toString(): String</code>  用该字符串构造一个新的 String 对象</li>
<li><code>func asResource(): CStringResource</code> 获取 CString 的 Resource 类型</li>
</ul>
<p>另外，将 <code>String</code> 类型转换为 <code>CString</code> 类型，可以通过调用 LibC 中的 <code>mallocCString</code> 接口，使用完成后需要对 <code>CString</code> 进行释放。</p>
<p><code>CString</code> 的使用示例如下：</p>
<!-- run -->
<pre><code class="language-cangjie">foreign func strlen(s: CString): UIntNative

main() {
    var s1 = unsafe { LibC.mallocCString(&quot;hello&quot;) }
    var s2 = unsafe { LibC.mallocCString(&quot;world&quot;) }

    let t1: Int64 = s1.size()
    let t2: Bool = s2.isEmpty()
    let t3: Bool = s1.equals(s2)
    let t4: Bool = s1.startsWith(s2)
    let t5: Int32 = s1.compare(s2)

    let length = unsafe { strlen(s1) }

    unsafe {
        LibC.free(s1)
        LibC.free(s2)
    }
}
</code></pre>
<h3 id="sizeofalignof"><a class="header" href="#sizeofalignof">sizeOf/alignOf</a></h3>
<p>仓颉还提供了 <code>sizeOf</code> 和 <code>alignOf</code> 两个函数，用于获取上述 C 互操作类型的内存占用和内存对齐数值（单位：字节），函数声明如下：</p>
<pre><code class="language-cangjie">public func sizeOf&lt;T&gt;(): UIntNative where T &lt;: CType
public func alignOf&lt;T&gt;(): UIntNative where T &lt;: CType
</code></pre>
<p>使用示例：</p>
<!-- run -->
<pre><code class="language-cangjie">@C
struct Data {
    var a: Int64 = 0
    var b: Float32 = 0.0
}

main() {
    println(sizeOf&lt;Data&gt;())
    println(alignOf&lt;Data&gt;())
}
</code></pre>
<p>在 64 位机器上运行，将输出：</p>
<pre><code class="language-text">16
8
</code></pre>
<h2 id="ctype"><a class="header" href="#ctype">CType</a></h2>
<p>除类型映射一节提供的与 C 侧类型进行映射的类型外，仓颉还提供了一个 <code>CType</code> 接口，接口本身不包含任何方法，它可以作为所有 C 互操作支持的类型的父类型，便于在泛型约束中使用。</p>
<p>需要注意的是：</p>
<ol>
<li><code>CType</code> 接口是仓颉中的一个接口类型，它本身不满足 <code>CType</code> 约束；</li>
<li><code>CType</code> 接口不允许被继承、扩展；</li>
<li><code>CType</code> 接口不会突破子类型的使用限制。</li>
</ol>
<p><code>CType</code> 的使用示例如下：</p>
<!-- verify -->
<pre><code class="language-cangjie">func foo&lt;T&gt;(x: T): Unit where T &lt;: CType {
    match (x) {
        case i32: Int32 =&gt; println(i32)
        case ptr: CPointer&lt;Int8&gt; =&gt; println(ptr.isNull())
        case f: CFunc&lt;() -&gt; Unit&gt; =&gt; unsafe { f() }
        case _ =&gt; println(&quot;match failed&quot;)
    }
}

main() {
    var i32: Int32 = 1
    var ptr = CPointer&lt;Int8&gt;()
    var f: CFunc&lt;() -&gt; Unit&gt; = { =&gt; println(&quot;Hello&quot;) }
    var f64 = 1.0
    foo(i32)
    foo(ptr)
    foo(f)
    foo(f64)
}
</code></pre>
<p>执行结果如下：</p>
<pre><code class="language-text">1
true
Hello
match failed
</code></pre>
<h2 id="c-调用仓颉的函数"><a class="header" href="#c-调用仓颉的函数">C 调用仓颉的函数</a></h2>
<p>仓颉提供 <code>CFunc</code> 类型来对应 C 侧的函数指针类型。C 侧的函数指针可以传递到仓颉，仓颉也可以构造出对应 C 的函数指针的变量传递到 C 侧。</p>
<p>假设一个 C 的库 API 如下：</p>
<pre><code class="language-c">typedef void (*callback)(int);
void set_callback(callback cb);
</code></pre>
<p>对应的，在仓颉里面这个函数可以声明为：</p>
<pre><code class="language-cangjie">foreign func set_callback(cb: CFunc&lt;(Int32) -&gt; Unit&gt;): Unit
</code></pre>
<p>CFunc 类型的变量可以从 C 侧传递过来，也可以在仓颉侧构造出来。在仓颉侧构造 CFunc 类型有两种办法，一个是用 <code>@C</code> 修饰的函数，另外一个是标记为 CFunc 类型的闭包。</p>
<p><code>@C</code> 修饰的函数，表明它的函数签名是满足 C 的调用规则的，定义还是写在仓颉这边。<code>foreign</code> 修饰的函数定义是在 C 侧的。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p><code>foreign</code> 修饰的函数与 <code>@C</code> 修饰的函数，这两种 <code>CFunc</code> 的命名不建议使用 <code>CJ_</code>（不区分大小写）作为前缀，否则可能与标准库及运行时等编译器内部符号出现冲突，导致未定义行为。</p>
</blockquote>
<p>示例如下：</p>
<pre><code class="language-cangjie">@C
func myCallback(s: Int32): Unit {
    println(&quot;handle ${s} in callback&quot;)
}

main() {
    // the argument is a function qualified by `@C`
    unsafe { set_callback(myCallback) }

    // the argument is a lambda with `CFunc` type
    let f: CFunc&lt;(Int32) -&gt; Unit&gt; = { i =&gt; &quot;handle ${i} in callback&quot; }
    unsafe { set_callback(f) }
}
</code></pre>
<p>假设 C 函数编译出来的库是 &quot;libmyfunc.so&quot;，那么需要使用 <code>cjc -L. -lmyfunc test.cj -o test.out</code> 编译命令，使仓颉编译器去链接这个库。最终就能生成想要的可执行程序。</p>
<p>另外，在编译 C 代码时，请打开 <code>-fstack-protector-all/-fstack-protector-strong</code> 栈保护选项，仓颉侧代码默认拥有溢出检查与栈保护功能。在引入 C 代码后，需要同步保证 unsafe 块中的溢出的安全性。</p>
<h2 id="编译选项"><a class="header" href="#编译选项">编译选项</a></h2>
<p>使用 C 互操作通常需要手动链接 C 的库，仓颉编译器提供了相应的编译选项。</p>
<ul>
<li>
<p><code>--library-path &lt;value&gt;</code>, <code>-L &lt;value&gt;</code>, <code>-L&lt;value&gt;</code>：指定要链接的库文件所在的目录。</p>
<p><code>--library-path &lt;value&gt;</code> 指定的路径会被加入链接器的库文件搜索路径。另外环境变量 <code>LIBRARY_PATH</code> 中指定的路径也会被加入链接器的库文件搜索路径中，通过 <code>--library-path</code> 指定的路径会比 <code>LIBRARY_PATH</code> 中的路径拥有更高的优先级。</p>
</li>
<li>
<p><code>--library &lt;value&gt;</code>, <code>-l &lt;value&gt;</code>, <code>-l&lt;value&gt;</code>：指定要链接的库文件。</p>
<p>给定的库文件会被直接传给链接器，库文件名的格式应为 <code>lib[arg].[extension]</code>。</p>
</li>
</ul>
<p>关于仓颉编译器支持的所有编译选项，详见<a href="source_zh_cn/FFI/../Appendix/compile_options_OHOS.html">cjc 编译选项</a>。</p>
<h2 id="示例"><a class="header" href="#示例">示例</a></h2>
<p>这里我们演示一下如何使用 C 互操作以及 <code>write/read</code> 接口对一个结构体进行赋值和读取值：</p>
<p>C 代码如下：</p>
<pre><code class="language-c">// draw.c
#include&lt;stdio.h&gt;
#include&lt;stdint.h&gt;

typedef struct {
    int64_t x;
    int64_t y;
} Point;

typedef struct {
    float x;
    float y;
    float z;
} Cube;

int32_t drawPicture(Point* point, Cube* cube) {
    point-&gt;x = 1;
    point-&gt;y = 2;
    printf(&quot;Draw Point finished.\n&quot;);

    printf(&quot;Before draw cube\n&quot;);
    printf(&quot;%f\n&quot;, cube-&gt;x);
    printf(&quot;%f\n&quot;, cube-&gt;y);
    printf(&quot;%f\n&quot;, cube-&gt;z);
    cube-&gt;x = 4.4;
    cube-&gt;y = 5.5;
    cube-&gt;z = 6.6;
    printf(&quot;Draw Cube finished.\n&quot;);
}
</code></pre>
<p>仓颉代码如下：</p>
<pre><code class="language-cangjie">// main.cj
@C
struct Point {
    var x: Int64 = 0
    var y: Int64 = 0
}

@C
struct Cube {
    var x: Float32 = 0.0
    var y: Float32 = 0.0
    var z: Float32 = 0.0

    init(x: Float32, y: Float32, z: Float32) {
        this.x = x
        this.y = y
        this.z = z
    }
}

foreign func drawPicture(point: CPointer&lt;Point&gt;, cube: CPointer&lt;Cube&gt;): Int32

main() {
    let pPoint = unsafe { LibC.malloc&lt;Point&gt;() }
    let pCube = unsafe { LibC.malloc&lt;Cube&gt;() }

    var cube = Cube(1.1, 2.2, 3.3)
    unsafe {
        pCube.write(cube)
        drawPicture(pPoint, pCube)   // in which x, y will be changed

        println(pPoint.read().x)
        println(pPoint.read().y)
        println(pCube.read().x)
        println(pCube.read().y)
        println(pCube.read().z)

        LibC.free(pPoint)
        LibC.free(pCube)
    }
}
</code></pre>
<p>编译仓颉代码的命令如下（以 CJNative 后端为例）：</p>
<pre><code class="language-shell">cjc -L . -l draw ./main.cj
</code></pre>
<p>其中编译命令中 <code>-L .</code> 表示链接库时从当前目录查找（假设 <code>libdraw.so</code> 存在于当前目录），<code>-l draw</code> 表示链接的库的名字，编译成功后默认生成二进制文件 <code>main</code>，执行二进制文件的命令如下：</p>
<pre><code class="language-shell">LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH ./main
</code></pre>
<p>运行结果如下：</p>
<pre><code class="language-shell">Draw Point finished.
Before draw cube
1.100000
2.200000
3.300000
Draw Cube finished.
1
2
4.400000
5.500000
6.600000
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="仓颉-python-互操作"><a class="header" href="#仓颉-python-互操作">仓颉-Python 互操作</a></h1>
<p>为了兼容强大的计算和 AI 生态，仓颉支持与 Python 语言的互操作调用。Python 的互操作通过 std 模块中的 ffi.python 库为用户提供能力。</p>
<p>目前 Python 互操作仅支持在 Linux 平台使用，并且仅支持仓颉编译器的 cjnative 后端。</p>
<h2 id="python-的全局资源及使用"><a class="header" href="#python-的全局资源及使用">Python 的全局资源及使用</a></h2>
<h3 id="提供内建函数类以及全局资源"><a class="header" href="#提供内建函数类以及全局资源">提供内建函数类以及全局资源</a></h3>
<p>代码原型：</p>
<pre><code class="language-cangjie">public class PythonBuiltins {
    ...
}
public let Python = PythonBuiltins()
</code></pre>
<p>Python 库提供的接口不能保证并发安全，当对 Python 进行异步调用时（系统线程 <code>ID</code> 不一致）会抛出 <code>PythonException</code> 异常。</p>
<p>在 Python 初始化时，GIL 全局解释器锁基于当前所在 OS 线程被锁定，如果执行的代码所在的 Cangjie 线程（包括 <code>main</code> 所在
Cangjie 线程）在 OS 线程上发生调度（OS 线程 <code>ID</code> 发生变化），Python 内部再次尝试检查 GIL 时会对线程状态进行校验，发现 GIL
状态中保存的 OS 线程 <code>ID</code> 与当前执行的 OS 线程 <code>ID</code> 不一致，此时会触发内部错误，导致程序崩溃。</p>
<p>由于 Python 互操作使用到大量 Python 库的 native 代码，这部分代码在仓颉侧无法对其进行相应的栈保护。仓颉栈保护默认大小为
64KB，在对 Python C API 进行调用过程中，容易造成 native 代码超出默认栈大小，发生溢出，会触发不可预期的结果。建议用户在执行
Python 互操作相关代码前，配置仓颉默认栈大小至少为 1MB：<code>export cjStackSize=1MB</code> 。</p>
<p>使用示例：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.ffi.python.*

main(): Int64 {
    Python.load()
    Python.unload()
    return 0
}
</code></pre>
<h3 id="提供-python-库日志类-pythonlogger"><a class="header" href="#提供-python-库日志类-pythonlogger">提供 Python 库日志类 <code>PythonLogger</code></a></h3>
<p>代码原型：</p>
<pre><code class="language-cangjie">public class PythonLogger &lt;: Logger {
    mut prop level: LogLevel {...}
    public func setOutput(output: io.File): Unit {} // do nothing
    public func trace(msg: String): Unit {...}
    public func debug(msg: String): Unit {...}
    public func info(msg: String): Unit {...}
    public func warn(msg: String): Unit {...}
    public func error(msg: String): Unit {...}
    public func log(level: LogLevel, msg: String): Unit {...}
}
public let PYLOG = PythonLogger()
</code></pre>
<p>Logger 类的几点声明：</p>
<ul>
<li><code>PythonLogger</code> 实现 <code>Logger</code> 接口仅做打印输出以及打印等级控制，不做日志转储到 log 文件；</li>
<li><code>setOutput</code> 为空实现，不支持 log 转储文件；</li>
<li><code>info/warn/error</code> 等接口输出打印以对应前缀开头，其他不做区分；</li>
<li><code>PythonLogger</code> 默认打印等级为 <code>LogLevel.WARN</code> ；</li>
<li><code>PYLOG.error(msg)</code> 和 <code>log(LogLevel.ERROR, msg)</code> 接口会抛出 <code>PythonException</code> 异常。</li>
</ul>
<p>使用示例：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.ffi.python.*
import std.log.*

main(): Int64 {
    PYLOG.level = LogLevel.WARN // Only logs of the warn level and above are printed.
    PYLOG.info(&quot;log info&quot;)
    PYLOG.warn(&quot;log warn&quot;)
    try {
        PYLOG.error(&quot;log error&quot;)
    } catch(e: PythonException) {}

    PYLOG.log(LogLevel.INFO, &quot;loglevel info&quot;)
    PYLOG.log(LogLevel.WARN, &quot;loglevel warn&quot;)
    try {
        PYLOG.log(LogLevel.ERROR, &quot;loglevel error&quot;)
    } catch(e: PythonException) {}
    return 0
}
</code></pre>
<p>执行结果：</p>
<pre><code class="language-text">WARN: log warn
ERROR: log error
WARN: loglevel warn
ERROR: loglevel error
</code></pre>
<h3 id="提供-python-库异常类-pythonexception"><a class="header" href="#提供-python-库异常类-pythonexception">提供 Python 库异常类 <code>PythonException</code></a></h3>
<p>代码原型：</p>
<pre><code class="language-cangjie">public class PythonException &lt;: Exception {
    public init() {...}
    public init(message: String) {...}
}
</code></pre>
<p><code>PythonException</code> 有以下说明：</p>
<ul>
<li><code>PythonException</code> 与被继承的 <code>Exception</code> 除了异常前缀存在差异，其他使用无差异；</li>
<li>当 Python 内部出现异常时，外部可以通过 <code>try-catch</code> 进行捕获，如果不进行捕获会打印异常堆栈并退出程序，返回值为 1。</li>
</ul>
<p>使用示例：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.ffi.python.*
import std.log.*

main(): Int64 {
    try {
        Python.load(&quot;/usr/lib/&quot;, loglevel: LogLevel.INFO)
    } catch(e: PythonException) {
        print(&quot;${e}&quot;) // PythonException: &quot;/usr/lib/&quot; does not exist or the file path is invalid.
    }
    return 0
}
</code></pre>
<h3 id="提供-python-库的版本信息类-version"><a class="header" href="#提供-python-库的版本信息类-version">提供 Python 库的版本信息类 <code>Version</code></a></h3>
<p>代码原型：</p>
<pre><code class="language-cangjie">public struct Version &lt;: ToString {
    public init(major: Int64, minor: Int64, micro: Int64)
    public func getMajor(): Int64
    public func getMinor(): Int64
    public func getMicro(): Int64
    public func getVersion(): (Int64, Int64, Int64)
    public func toString(): String
}
</code></pre>
<p>关于 <code>Version</code> 类的几点声明：</p>
<ul>
<li><code>Version</code> 版本信息包含三个部分：<code>major version</code>，<code>minor version</code>，<code>micro version</code>。</li>
<li><code>Version</code> 版本仅通过构造函数进行初始化，一旦定义，后续无法修改。</li>
<li>提供 <code>toString</code> 接口，可以直接进行打印。</li>
<li>提供 <code>getVersion</code> 接口，可以获取版本的 tuple 形式。</li>
</ul>
<p>使用示例：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.ffi.python.*

main(): Int64 {
    Python.load()
    var version = Python.getVersion()
    print(&quot;${version}&quot;)
    var tuple_version = version.getVersion()
    Python.unload()
    return 0
}
</code></pre>
<h2 id="pythonbuiltins-内建函数类"><a class="header" href="#pythonbuiltins-内建函数类"><code>PythonBuiltins</code> 内建函数类</a></h2>
<h3 id="python-库的导入和加载"><a class="header" href="#python-库的导入和加载">Python 库的导入和加载</a></h3>
<p>代码原型：</p>
<pre><code class="language-cangjie">public class PythonBuiltins {
    public func load(loglevel!: LogLevel = LogLevel.WARN): Unit
    public func load(path: String, loglevel!: LogLevel = LogLevel.WARN): Unit
    public func isLoad(): Bool
    public func unload(): Unit
}
public let Python = PythonBuiltins()
</code></pre>
<p>关于加载与卸载有以下几点声明：</p>
<ul>
<li><code>load</code> 函数使用重载的方式实现，同时支持无参加载和指定动态库路径加载，提供可选参数配置 <code>PythonLogger</code> 的打印等级，如果不配置，会将 <code>PYLOG</code> 重置为 <code>warn</code> 打印等级；</li>
<li><code>load()</code> 函数进行了 Python 相关的准备工作，在进行 Python 互操作前必须调用，其中动态库查询方式请见：动态库的加载策略；</li>
<li><code>load(path: String)</code> 函数需要用户配置动态库路径 <code>path</code>， <code>path</code> 指定到动态库文件（如：<code>/usr/lib/libpython3.9.so</code>），不可以配置为目录或者非动态库文件；</li>
<li><code>load</code> 函数失败时会抛出 <code>PythonException</code> 异常，如果程序仍然需要继续执行，请注意 <code>try-catch</code> ；</li>
<li><code>unload</code> 函数在进行完 Python 互操作时调用，否则会造成相关资源泄露；</li>
<li>加载和卸载操作仅需要调用一次，并且一一对应，多次调用仅第一次生效；</li>
<li><code>isload()</code> 函数用于判断 Python 库是否被加载。</li>
</ul>
<p>使用示例：</p>
<p><code>load</code> 与 <code>unload</code> ：</p>
<!-- compile -->
<pre><code class="language-cangjie">import std.ffi.python.*

main(): Int64 {
    Python.load()
    Python.unload()
    Python.load(&quot;/usr/lib/libpython3.9.so&quot;)
    Python.unload()
    return 0
}
</code></pre>
<p><strong><code>isLoad</code> 函数:</strong></p>
<!-- run -->
<pre><code class="language-cangjie">import std.ffi.python.*

main(): Int64 {
    print(&quot;${Python.isLoad()}\n&quot;)       // false
    Python.load()
    print(&quot;${Python.isLoad()}\n&quot;)       // true
    Python.unload()
    return 0
}
</code></pre>
<h3 id="动态库的加载策略"><a class="header" href="#动态库的加载策略">动态库的加载策略</a></h3>
<p>Python 库需要依赖 Python 的官方动态链接库： <code>libpython3.x.so</code> ，推荐版本：3.9.2，支持读取 Python3.0 以上版本。</p>
<p><strong>从 Python 源码编译获取动态库：</strong></p>
<pre><code class="language-shell"># 在Python源码路径下：
./configure --enable-shared --with-system-ffi --prefix=/usr
make
make install
</code></pre>
<p><strong>Python 的动态库按照以下方式进行自动查找：</strong></p>
<p>1、使用指定的环境变量：</p>
<pre><code class="language-shell">export PYTHON_DYNLIB=&quot;.../libpython3.9.so&quot;
</code></pre>
<p>2、如果环境变量未指定，从可执行文件的依赖中查找：</p>
<ul>
<li>需要保证可执行文件 <code>python3</code> 可正常执行（所在路径已添加值 PATH 环境变量中），通过对 python3 可执行文件的动态库依赖进行查询。</li>
<li>非动态库依赖的 Python 可执行文件无法使用（源码编译未使用 <code>--enable-shared</code> 编译的 Python 可执行文件，不会对动态库依赖）。</li>
</ul>
<pre><code class="language-shell">$ ldd $(which python3)
    ...
    libpython3.9d.so.1.0 =&gt; /usr/local/lib/libpython3.9d.so.1.0 (0x00007f499102f000)
    ...
</code></pre>
<p>3、如果无法找到可执行文件依赖，尝试从系统默认动态库查询路径中查找：</p>
<!-- run -->
<pre><code class="language-cangjie">[&quot;/lib&quot;, &quot;/usr/lib&quot;, &quot;/usr/local/lib&quot;]
</code></pre>
<p>所在路径下查询的动态库名称必须满足 <code>libpythonX.Y.so</code> 的命名方式，其中 <code>X</code> <code>Y</code> 分别为主版本号以及次版本号，并且支持的后缀有：<code>d.so</code>，<code>m.so</code>，<code>dm.so</code>，<code>.so</code>，支持的版本高于 python3.0，低于或等于 python3.10。如：</p>
<pre><code class="language-shell">libpython3.9.so
libpython3.9d.so
libpython3.9m.so
libpython3.9dm.so
</code></pre>
<p>使用示例：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.ffi.python.*
import std.log.*

main(): Int64 {
    Python.load(loglevel: LogLevel.INFO)
    print(&quot;${Python.getVersion()}\n&quot;)
    Python.unload()
    return 0
}
</code></pre>
<p>可以开启 Python 的 <code>INFO</code> 级打印，查看 Python 库路径的搜索过程：</p>
<pre><code class="language-shell"># Specifying .so by Using Environment Variables
$ export PYTHON_DYNLIB=/root/code/python_source_code/Python-3.9.2/libpython3.9d.so
$ cjc ./main.cj -o ./main &amp;&amp; ./main
INFO: Try to get libpython path.
INFO: Found PYTHON_DYNLIB value: /root/code/python_source_code/Python-3.9.2/libpython3.9d.so
...

# Find dynamic libraries by executable file dependency.
INFO: Try to get libpython path.
INFO: Can't get path from environment PYTHON_DYNLIB, try to find it from executable file path.
INFO: Exec cmd: &quot;ldd $(which python3)&quot;:
INFO:   ...
        libpython3.9d.so.1.0 =&gt; /usr/local/lib/libpython3.9d.so.1.0 (0x00007fbbb5014000)
        ...

INFO: Found lib: /usr/local/lib/libpython3.9d.so.1.0.
INFO: Found exec dependency: /usr/local/lib/libpython3.9d.so.1.0
...

# Search for the dynamic library in the system path.
$ unset PYTHON_DYNLIB
$ cjc ./main.cj -o ./main &amp;&amp; ./main
INFO: Can't get path from environment PYTHON_DYNLIB, try to find it from executable file path.
INFO: Can't get path from executable file path, try to find it from system lib path.
INFO: Find in /lib.
INFO: Found lib: /lib/libpython3.9.so.
...

# Failed to find the dynamic library.
$ cjc ./main.cj -o ./main &amp;&amp; ./main
INFO: Can't get path from environment PYTHON_DYNLIB, try to find it from executable file path.
INFO: Can't get path from executable file path, try to find it from system lib path.
INFO: Find in /lib.
INFO: Can't find lib in /lib.
INFO: Find in /usr/lib.
INFO: Can't find lib in /usr/lib.
INFO: Find in /usr/local/lib.
INFO: Can't find lib in /usr/local/lib.
An exception has occurred:
PythonException: Can't get path from system lib path, load exit.
         at std/ffi/python.std/ffi/python::(PythonException::)init(std/core::String)(stdlib/std/ffi/python/Python.cj:82)
         at std/ffi/python.std/ffi/python::(PythonBuiltins::)load(std/log::LogLevel)(stdlib/std/ffi/python/Python.cj:127)
         at default.default::main()(/root/code/debug/src/main.cj:5)
</code></pre>
<h3 id="getversion-函数"><a class="header" href="#getversion-函数"><code>getVersion()</code> 函数</a></h3>
<p>函数原型：</p>
<pre><code class="language-cangjie">public func getVersion(): Version
</code></pre>
<p>接口描述：</p>
<ul>
<li><code>getVersion()</code> 函数用于获取当前使用的 Python 版本。</li>
</ul>
<p>入参返回值：</p>
<ul>
<li><code>getVersion()</code> 函数无参数，返回 <code>Version</code> 类对象。</li>
</ul>
<p>异常情况：</p>
<ul>
<li><code>getVersion()</code> 函数需要保证 <code>load</code> 函数已被调用，否则返回的版本信息号为 <code>0.0.0</code>。</li>
</ul>
<p>使用示例：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.ffi.python.*

main(): Int64 {
    Python.load()
    var version = Python.getVersion()
    print(&quot;${version}&quot;)
    var tuple_version = version.getVersion()
    Python.unload()
    return 0
}
</code></pre>
<h3 id="import-函数"><a class="header" href="#import-函数"><code>Import()</code> 函数</a></h3>
<p>函数原型：</p>
<pre><code class="language-cangjie">public func Import(module: String): PyModule
</code></pre>
<p>入参返回值：</p>
<ul>
<li><code>Import</code> 函数接受一个 <code>String</code> 类型入参，即模块名，并且返回一个 <code>PyModule</code> 类型的对象。</li>
</ul>
<p>异常情况：</p>
<ul>
<li><code>Import</code> 函数需要保证 load 函数已被调用，否则返回的 <code>PyModule</code> 类型对象不可用（ <code>isAvaliable()</code> 为 <code>false</code> ）；</li>
<li>如果找不到对应的模块，仅会报错，且返回的 <code>PyModule</code> 类型对象不可用（ <code>isAvaliable()</code> 为 <code>false</code> ）。</li>
</ul>
<p>使用示例：</p>
<!-- compile -->
<pre><code class="language-cangjie">import std.ffi.python.*

main(): Int64 {
    Python.load()
    var sys = Python.Import(&quot;sys&quot;)
    if (sys.isAvailable()) {
        print(&quot;Import sys success\n&quot;)
    }
    // Import the test.py file in the current folder.
    var test = Python.Import(&quot;test&quot;)
    if (test.isAvailable()) {
        print(&quot;Import test success\n&quot;)
    }
    var xxxx = Python.Import(&quot;xxxx&quot;)
    if (!xxxx.isAvailable()) {
        print(&quot;Import test failed\n&quot;)
    }
    Python.unload()
    return 0
}
</code></pre>
<p>执行结果：</p>
<pre><code class="language-text">Import sys success
Import test success
Import test failed
</code></pre>
<h3 id="eval-函数"><a class="header" href="#eval-函数"><code>Eval()</code> 函数</a></h3>
<p>函数原型：</p>
<pre><code class="language-cangjie">public func Eval(cmd: String, module!: String = &quot;__main__&quot;): PyObj
</code></pre>
<p>接口描述：</p>
<ul>
<li><code>Eval()</code> 函数用于创建一个 Python 数据类型。</li>
</ul>
<p>入参返回值：</p>
<ul>
<li><code>Eval()</code> 接受一个 <code>String</code> 类型的命令 <code>cmd</code> ，并返回该指令的结果的 <code>PyObj</code> 形式；</li>
<li><code>Eval()</code> 接受一个 <code>String</code> 类型的指定域，默认域为 <code>&quot;__main__&quot;</code>。</li>
</ul>
<p>异常情况：</p>
<ul>
<li><code>Eval()</code> 接口需要保证 <code>load</code> 函数已被调用，否则返回的 <code>PyObj</code> 类型对象不可用（ <code>isAvaliable()</code> 为 <code>false</code> ）；</li>
<li><code>Eval()</code> 如果接收的命令执行失败，Python 侧会进行报错，并且返回的 <code>PyObj</code> 类型对象不可用（ <code>isAvaliable()</code> 为 <code>false</code> ）。</li>
</ul>
<p>使用示例：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.ffi.python.*

main(): Int64 {
    Python.load()
    var a = Python.Eval(&quot;123&quot;)
    if (a.isAvailable()) {
        Python[&quot;print&quot;]([a])
    }
    var b = Python.Eval(&quot;x = 123&quot;) // The expression in `Eval` needs have a return value.
    if (!b.isAvailable()) {
        print(&quot;b is unavailable.\n&quot;)
    }
    Python.unload()
    return 0
}
</code></pre>
<p>执行结果：</p>
<pre><code class="language-text">123
b is unavailable.
</code></pre>
<h3 id="index--运算符重载"><a class="header" href="#index--运算符重载"><code>index []</code> 运算符重载</a></h3>
<p>接口描述：</p>
<ul>
<li><code>[]</code> 函数提供了其他 Python 的内置函数调用能力。</li>
</ul>
<p>入参返回值：</p>
<ul>
<li><code>[]</code> 函数入参接受 <code>String</code> 类型的内建函数名，返回类型为 <code>PyObj</code> 。</li>
</ul>
<p>异常处理：</p>
<ul>
<li><code>[]</code> 函数需要保证 <code>load</code> 函数已被调用，否则返回的 <code>PyObj</code> 类型对象不可用（ <code>isAvaliable()</code> 为 <code>false</code> ）；</li>
<li>如果指定的函数名未找到，则会报错，且返回的 <code>PyObj</code> 类型对象不可用（ <code>isAvaliable()</code> 为 <code>false</code> ）。</li>
</ul>
<p>使用示例：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.ffi.python.*

main(): Int64 {
    Python.load()
    if (Python[&quot;type&quot;].isAvailable()) {
        print(&quot;find type\n&quot;)
    }
    if (!Python[&quot;type1&quot;].isAvailable()) {
        print(&quot;cant find type1\n&quot;)
    }
    Python.unload()
    return 0
}
</code></pre>
<p>执行结果：</p>
<pre><code class="language-text">find type
WARN: Dict key &quot;type1&quot; not found!
cant find type1
</code></pre>
<h2 id="类型映射-1"><a class="header" href="#类型映射-1">类型映射</a></h2>
<p>由于 Python 与仓颉互操作基于 C API 开发，Python 与 C 的数据类型映射统一通过 <code>PyObject</code> 结构体指针完成，并且具有针对不同数据类型的一系列接口。对比 C 语言，仓颉具有面向对象的编程优势，因此将 <code>PyObject</code> 结构体指针统一封装为父类，并且被不同的数据类型进行继承。</p>
<h3 id="类型映射表"><a class="header" href="#类型映射表">类型映射表</a></h3>
<p>仓颉类型到 Python 类型映射：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Cangjie Type</th><th style="text-align: center">Python Type</th></tr></thead><tbody>
<tr><td style="text-align: center">Bool</td><td style="text-align: center">PyBool</td></tr>
<tr><td style="text-align: center">UInt8/Int8/Int16/UInt16/Int32/UInt32/Int64/UInt64</td><td style="text-align: center">PyLong</td></tr>
<tr><td style="text-align: center">Float32/Float64</td><td style="text-align: center">PyFloat</td></tr>
<tr><td style="text-align: center">Rune/String</td><td style="text-align: center">PyString</td></tr>
<tr><td style="text-align: center">Array&lt; PyObj &gt;</td><td style="text-align: center">PyTuple</td></tr>
<tr><td style="text-align: center">Array</td><td style="text-align: center">PyList</td></tr>
<tr><td style="text-align: center">HashMap</td><td style="text-align: center">PyDict</td></tr>
<tr><td style="text-align: center">HashSet</td><td style="text-align: center">PySet</td></tr>
</tbody></table>
</div>
<p>Python 类型到仓颉类型映射：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Python Type</th><th style="text-align: center">Cangjie Type</th></tr></thead><tbody>
<tr><td style="text-align: center">PyBool</td><td style="text-align: center">Bool</td></tr>
<tr><td style="text-align: center">PyLong</td><td style="text-align: center">Int64/UInt64</td></tr>
<tr><td style="text-align: center">PyFloat</td><td style="text-align: center">Float64</td></tr>
<tr><td style="text-align: center">PyString</td><td style="text-align: center">String</td></tr>
<tr><td style="text-align: center">PyTuple</td><td style="text-align: center">-</td></tr>
<tr><td style="text-align: center">PyList</td><td style="text-align: center">Array</td></tr>
<tr><td style="text-align: center">PyDict</td><td style="text-align: center">HashMap</td></tr>
<tr><td style="text-align: center">PySet</td><td style="text-align: center">HashSet</td></tr>
</tbody></table>
</div>
<h3 id="python-ffi-库泛型约束的接口-pyffitype"><a class="header" href="#python-ffi-库泛型约束的接口-pyffitype">Python FFI 库泛型约束的接口 <code>PyFFIType</code></a></h3>
<!-- run -->
<pre><code class="language-cangjie">public interface PyFFIType { }
</code></pre>
<ul>
<li>由于部分类引入了泛型，为了对用户在泛型使用过程中进行约束，引入了抽象接口 <code>PyFFIType</code>；</li>
<li>该接口无抽象成员函数，其仅被 <code>PyObj</code> 和 <code>CjObj</code> 实现或继承，该接口不允许在包外进行实现，如果用户自定义类并实现改接口，可能发生未定义行为。</li>
</ul>
<h3 id="pyobj-类"><a class="header" href="#pyobj-类"><code>PyObj</code> 类</a></h3>
<p>与 Python 库中的结构体 <code>PyObject</code> 对应，对外提供细分数据类型通用的接口，如成员变量访问、函数访问、到仓颉字符串转换等。</p>
<p><strong>类原型：</strong></p>
<pre><code class="language-cangjie">public open class PyObj &lt;: ToString &amp; PyFFIType {
    public func isAvailable(): Bool { ... }
    public open operator func [](key: String): PyObj { ... }
    public open operator func [](key: String, value!: PyObj): Unit { ... }
    public operator func ()(): PyObj { ... }
    public operator func ()(kargs: HashMap&lt;String, PyObj&gt;): PyObj { ... }
    public operator func ()(args: Array&lt;PyObj&gt;): PyObj { ... }
    public operator func ()(args: Array&lt;PyObj&gt;, kargs: HashMap&lt;String, PyObj&gt;): PyObj { ... }
    public operator func ()(args: Array&lt;CjObj&gt;): PyObj { ... }
    public operator func ()(args: Array&lt;CjObj&gt;, kargs: HashMap&lt;String, PyObj&gt;): PyObj { ... }
    public operator func +(b: PyObj): PyObj { ... }
    public operator func -(b: PyObj): PyObj { ... }
    public operator func *(b: PyObj): PyObj { ... }
    public operator func /(b: PyObj): PyObj { ... }
    public operator func **(b: PyObj): PyObj { ... }
    public operator func %(b: PyObj): PyObj { ... }
    public open func toString(): String { ... }
    public func hashCode(): Int64 { ... }
    public operator func ==(right: PyObj): Bool { ... }
    public operator func !=(right: PyObj): Bool { ... }
}
</code></pre>
<p><strong>关于 <code>PyObj</code> 类的几点说明：</strong></p>
<ul>
<li>
<p><code>PyObj</code> 不对外提供创建的构造函数，该类不能在包外进行继承，如果用户自定义类并实现改接口，可能发生未定义行为；</p>
</li>
<li>
<p><code>public func isAvailable(): Bool { ... }</code> ：</p>
<ul>
<li><code>isAvailable</code> 接口用于判断该 <code>PyObj</code> 是否可用（即封装的 C 指针是否为 <code>NULL</code>）。</li>
</ul>
</li>
<li>
<p><code>public open operator func [](key: String): PyObj { ... }</code> ：</p>
<ul>
<li><code>[](key)</code> 用于访问 Python 类的成员或者模块中的成员等；</li>
<li>如果 <code>PyObj</code> 本身不可用（ <code>isAvaliable()</code> 为 <code>false</code> ），将抛出异常；</li>
<li>如果 <code>PyObj</code> 中不存在对应的 <code>key</code> ，此时由 Python 侧打印对应的错误，并返回不可用的 <code>PyObj</code> 类对象（ <code>isAvaliable()</code> 为 <code>false</code> ）。</li>
</ul>
</li>
<li>
<p><code>public open operator func [](key: String, value!: PyObj): Unit { ... }</code> ：</p>
<ul>
<li><code>[](key, value)</code> 设置 Python 类、模块的成员变量值为 <code>value</code> ；</li>
<li>如果 <code>PyObj</code> 本身不可用（ <code>isAvaliable()</code> 为 <code>false</code> ），将抛出异常；</li>
<li>如果 <code>PyObj</code> 中不存在对应的 <code>key</code> ，此时由 Python 侧打印对应的错误；</li>
<li>如果 <code>value</code> 值为一个不可用的对象（ <code>isAvaliable()</code> 为 <code>false</code> ），此时会将对应的 <code>key</code> 从模块或类中删除。</li>
</ul>
</li>
<li>
<p><code>()</code> 括号运算符重载，可调用对象的函数调用：</p>
<ul>
<li>如果 <code>PyObj</code> 本身不可用（ <code>isAvaliable()</code> 为 <code>false</code> ），将抛出异常；</li>
<li>如果 <code>PyObj</code> 本身为不可调用对象，将由 Python 侧报错，且返回不可用的 <code>PyObj</code> 类对象（ <code>isAvaliable()</code> 为 <code>false</code> ）；</li>
<li><code>()</code> 接受无参的函数调用；</li>
<li><code>([...])</code> 接受大于等于 1 个参数传递，参数类型支持仓颉类型 <code>CjObj</code> 和 Python 数据类型 <code>PyObj</code> ，需要注意的是，多个参数传递时，<code>CjObj</code> 和 <code>PyObj</code> 不可混用；</li>
<li>如果参数中包含不可用对象（ <code>isAvaliable()</code> 为 <code>false</code> ），此时将会抛出异常，避免发生在 Python 侧出现不可预测的程序崩溃；</li>
<li><code>()</code> 运算符支持 <code>kargs</code> ，即对应 Python 的可变命名参数设计，其通过一个 <code>HashMap</code> 进行传递，其 <code>key</code> 类型 <code>String</code> 配置为变量名， <code>value</code> 类型为 PyObj 配置为参数值。</li>
</ul>
</li>
<li>
<p>二元运算符重载：</p>
<ul>
<li>
<p><code>+</code> 两变量相加：</p>
<ul>
<li>基础数据类型：<code>PyString</code> 与 <code>PyBool/PyLong/PyFloat</code> 不支持相加，其他类型均可相互相加；</li>
<li>高级数据类型：<code>PyDict/PySet</code> 与所有类型均不支持相加，<code>PyTuple/PyList</code> 仅能与自身相加。</li>
</ul>
</li>
<li>
<p><code>-</code> 两变量相减：</p>
<ul>
<li>基础数据类型：<code>PyString</code> 与 <code>PyBool/PyLong/PyFloat/PyString</code> 不支持相减，其他类型均可相互相减；</li>
<li>高级数据类型：<code>PyDict/PySet/PyTuple/PyList</code> 与所有类型均不支持相减。</li>
</ul>
</li>
<li>
<p><code>*</code> 两变量相乘：</p>
<ul>
<li>基础数据类型：<code>PyString</code> 与 <code>PyFloat/PyString</code> 不支持相乘，其他类型均可相乘；</li>
<li>高级数据类型：<code>PyDict/PySet</code> 与所有类型均不支持相乘，<code>PyTuple/PyList</code> 仅能与 <code>PyLong/PyBool</code> 相乘。</li>
</ul>
</li>
<li>
<p><code>/</code> 两变量相除：</p>
<ul>
<li>基础数据类型：<code>PyString</code> 与 <code>PyBool/PyLong/PyFloat/PyString</code> 不支持相除，其他类型均可相互相除；如果除数为 0（<code>False</code> 在 Python 侧解释为 0，不可作为除数），会在 Python 侧进行错误打印；</li>
<li>高级数据类型：<code>PyDict/PySet/PyTuple/PyList</code> 与所有类型均不支持相除。</li>
</ul>
</li>
<li>
<p><code>**</code> 指数运算：</p>
<ul>
<li>基础数据类型：<code>PyString</code> 与 <code>PyBool/PyLong/PyFloat/PyString</code> 不支持指数运算，其他类型均可进行指数运算；</li>
<li>高级数据类型：<code>PyDict/PySet/PyTuple/PyList</code> 与所有类型均不支持指数运算。</li>
</ul>
</li>
<li>
<p><code>%</code> 取余：</p>
<ul>
<li>基础数据类型：<code>PyString</code> 与 <code>PyBool/PyLong/PyFloat/PyString</code> 不支持取余运算，其他类型均可进行取余运算；如果除数为 0（<code>False</code> 在 Python 侧解释为 0，不可作为除数），会在 Python 侧进行错误打印；</li>
<li>高级数据类型：<code>PyDict/PySet/PyTuple/PyList</code> 与所有类型均不支持取余运算。</li>
</ul>
</li>
<li>
<p>以上所有错误情况均会进行 warn 级别打印，并且返回的 <code>PyObj</code> 不可用（<code>isAvaliable()</code> 为 <code>false</code>）。</p>
</li>
</ul>
</li>
<li>
<p><code>public open func toString(): String { ... }</code> ：</p>
<ul>
<li><code>toString</code> 函数可以将 Python 数据类型以字符串形式返回，基础数据类型将以 Python 风格返回；</li>
<li>如果 <code>PyObj</code> 本身不可用（ <code>isAvaliable()</code> 为 <code>false</code> ），将抛出异常。</li>
</ul>
</li>
<li>
<p><code>hashCode</code> 函数为封装的 Python <code>hash</code> 算法，其返回一个 Int64 的哈希值；</p>
</li>
<li>
<p><code>==</code> 操作符用于判定两个 <code>PyObj</code> 对象是否相同，<code>!=</code> 与之相反，如果接口比较失败，<code>==</code> 返回为 <code>false</code> 并捕获 Python 侧报错，如果被比较的两个对象存在不可用，会抛出异常。</p>
</li>
</ul>
<p><strong>使用示例：</strong></p>
<p>test01.py 文件：</p>
<pre><code class="language-python">a = 10
def function():
    print(&quot;a is&quot;, a)
def function02(b, c = 1):
    print(&quot;function02 call.&quot;)
    print(&quot;b is&quot;, b)
    print(&quot;c is&quot;, c)
</code></pre>
<p>同级目录下的仓颉文件 main.cj：</p>
<!-- compile -->
<pre><code class="language-cangjie">import std.ffi.python.*
import std.collection.*

main(): Int64 {
    Python.load()

    // Create an unavailable value.
    var a = Python.Eval(&quot;a = 10&quot;)   // SyntaxError: invalid syntax
    print(&quot;${a.isAvailable()}\n&quot;)   // false

    // Uncallable value `b` be invoked
    var b = Python.Eval(&quot;10&quot;)
    b()                           // TypeError: 'int' object is not callable

    // Import .py file.
    var test = Python.Import(&quot;test01&quot;)

    // `get []` get value of `a`.
    var p_a = test[&quot;a&quot;]
    print(&quot;${p_a}\n&quot;)               // 10

    // `set []` set the value of a to 20.
    test[&quot;a&quot;] = Python.Eval(&quot;20&quot;)
    test[&quot;function&quot;]()            // a is 20

    // Call function02 with a named argument.
    test[&quot;function02&quot;]([1], HashMap&lt;String, PyObj&gt;([(&quot;c&quot;, 2.toPyObj())]))

    // Set `a` in test01 to an unavailable value, and `a` will be deleted.
    test[&quot;a&quot;] = a
    test[&quot;function&quot;]()            // NameError: name 'a' is not defined

    Python.unload()
    0
}
</code></pre>
<h3 id="cjobj-接口"><a class="header" href="#cjobj-接口"><code>CjObj</code> 接口</a></h3>
<p>接口原型及类型扩展：</p>
<pre><code class="language-cangjie">public interface CjObj &lt;: PyFFIType {
    func toPyObj(): PyObj
}
extend Bool &lt;: CjObj {
    public func toPyObj(): PyBool { ... }
}
extend Rune &lt;: CjObj {
    public func toPyObj(): PyString { ... }
}
extend Int8 &lt;: CjObj {
    public func toPyObj(): PyLong { ... }
}
extend UInt8 &lt;: CjObj {
    public func toPyObj(): PyLong { ... }
}
extend Int16 &lt;: CjObj {
    public func toPyObj(): PyLong { ... }
}
extend UInt16 &lt;: CjObj {
    public func toPyObj(): PyLong { ... }
}
extend Int32 &lt;: CjObj {
    public func toPyObj(): PyLong { ... }
}
extend UInt32 &lt;: CjObj {
    public func toPyObj(): PyLong { ... }
}
extend Int64 &lt;: CjObj {
    public func toPyObj(): PyLong { ... }
}
extend UInt64 &lt;: CjObj  {
    public func toPyObj(): PyLong { ... }
}
extend Float32 &lt;: CjObj  {
    public func toPyObj(): PyFloat { ... }
}
extend Float64 &lt;: CjObj  {
    public func toPyObj(): PyFloat { ... }
}
extend String &lt;: CjObj  {
    public func toPyObj(): PyString { ... }
}
extend&lt;T&gt; Array&lt;T&gt; &lt;: CjObj where T &lt;: PyFFIType {
    public func toPyObj(): PyList&lt;T&gt; { ... }
}
extend&lt;K, V&gt; HashMap&lt;K, V&gt; &lt;: CjObj where K &lt;: Hashable &amp; Equatable&lt;K&gt; &amp; PyFFIType {
    public func toPyObj(): PyDict&lt;K, V&gt; { ... }
}
extend&lt;T&gt; HashSet&lt;T&gt; &lt;: CjObj where T &lt;: Hashable, T &lt;: Equatable&lt;T&gt; &amp; PyFFIType {
    public func toPyObj(): PySet&lt;T&gt; { ... }
}
</code></pre>
<p><strong>关于 <code>CjObj</code> 类的说明：</strong></p>
<p><code>CjObj</code> 接口被所有基础数据类型实现并完成 <code>toPyObj</code> 扩展，分别支持转换为与之对应的 Python 数据类型。</p>
<h3 id="pybool-与-bool-的映射"><a class="header" href="#pybool-与-bool-的映射"><code>PyBool</code> 与 <code>Bool</code> 的映射</a></h3>
<p><strong>类原型：</strong></p>
<pre><code class="language-cangjie">public class PyBool &lt;: PyObj {
    public init(bool: Bool) { ... }
    public func toCjObj(): Bool { ... }
}
</code></pre>
<p><strong>关于 <code>PyBool</code> 类的几点说明</strong></p>
<ul>
<li><code>PyBool</code> 类继承自 <code>PyObj</code> 类， <code>PyBool</code> 具有所有父类拥有的接口；</li>
<li><code>PyBool</code> 仅允许用户使用仓颉的 <code>Bool</code> 类型进行构造；</li>
<li><code>toCjObj</code> 接口将 <code>PyBool</code> 转换为仓颉数据类型 <code>Bool</code> 。</li>
</ul>
<p><strong>使用示例：</strong></p>
<!-- run -->
<pre><code class="language-cangjie">import std.ffi.python.*

main(): Int64 {
    Python.load()

    // Creation of `PyBool`.
    var a = PyBool(true)        // The type of `a` is `PyBool`.
    var b = Python.Eval(&quot;True&quot;) // The type of `b` is `PyObj` and needs to be matched to `PyBool`.
    var c = true.toPyObj()      // The type of `c` is `PyBool`, which is the same as `a`.

    print(&quot;${a}\n&quot;)
    if (a.toCjObj()) {
        print(&quot;success\n&quot;)
    }

    if (b is PyBool) {
        print(&quot;b is PyBool\n&quot;)
    }
    Python.unload()
    0
}
</code></pre>
<p>执行结果：</p>
<pre><code class="language-text">True
success
b is PyBool
</code></pre>
<h3 id="pylong-与整型的映射"><a class="header" href="#pylong-与整型的映射"><code>PyLong</code> 与整型的映射</a></h3>
<p><strong>类原型：</strong></p>
<pre><code class="language-cangjie">public class PyLong &lt;: PyObj {
    public init(value: Int64) { ... }
    public init(value: UInt64) { ... }
    public init(value: Int32) { ... }
    public init(value: UInt32) { ... }
    public init(value: Int16) { ... }
    public init(value: UInt16) { ... }
    public init(value: Int8) { ... }
    public init(value: UInt8) { ... }
    public func toCjObj(): Int64 { ... }
    public func toInt64(): Int64 { ... }
    public func toUInt64(): UInt64 { ... }
}
</code></pre>
<p><strong>关于 <code>PyLong</code> 类的几点说明</strong></p>
<ul>
<li>
<p><code>PyLong</code> 类继承自 <code>PyObj</code> 类， <code>PyLong</code> 具有所有父类拥有的接口；</p>
</li>
<li>
<p><code>PyLong</code> 支持来自所有仓颉整数类型的入参构造；</p>
</li>
<li>
<p><code>toCjObj</code> 与 <code>toInt64</code> 接口将 <code>PyLong</code> 转换为 <code>Int64</code> 类型；</p>
</li>
<li>
<p><code>toUInt64</code> 接口将 <code>PyLong</code> 转换为 <code>UInt64</code> 类型；</p>
</li>
<li>
<p><code>PyLong</code> 类型向仓颉类型转换统一转换为 8 字节类型，不支持转换为更低字节类型；</p>
</li>
<li>
<p>溢出问题：</p>
<ul>
<li><code>toInt64</code> 原数值（以 <code>UInt64</code> 赋值，赋值不报错）超出 <code>Int64</code> 范围判定为溢出；</li>
<li><code>toUInt64</code> 原数值（以 <code>Int64</code> 赋值，赋值不报错）超出 <code>UInt64</code> 范围判定为溢出；</li>
</ul>
</li>
<li>
<p><code>PyLong</code> 暂不支持大数处理。</p>
</li>
</ul>
<p><strong>使用示例：</strong></p>
<!-- run -->
<pre><code class="language-cangjie">import std.ffi.python.*

main(): Int64 {
    Python.load()

    // Creation of `PyLong`.
    var a = PyLong(10)          // The type of `a` is `PyLong`.
    var b = Python.Eval(&quot;10&quot;)   // The type of `b` is `PyObj` and needs to be matched to `PyLong`.
    var c = 10.toPyObj()        // The type of `c` is `PyLong`, which is the same as `a`.

    print(&quot;${a}\n&quot;)
    if (a.toCjObj() == 10 &amp;&amp; a.toUInt64() == 10) {
        print(&quot;success\n&quot;)
    }

    if (b is PyLong) {
        print(&quot;b is PyLong\n&quot;)
    }
    Python.unload()
    0
}
</code></pre>
<p>执行结果：</p>
<pre><code class="language-text">10
success
b is PyLong
</code></pre>
<h3 id="pyfloat-与浮点的映射"><a class="header" href="#pyfloat-与浮点的映射"><code>PyFloat</code> 与浮点的映射</a></h3>
<p><strong>类原型：</strong></p>
<pre><code class="language-cangjie">public class PyFloat &lt;: PyObj {
    public init(value: Float32) { ... }
    public init(value: Float64) { ... }
    public func toCjObj(): Float64 { ... }
}
</code></pre>
<p><strong>关于 <code>PyFloat</code> 类的几点说明</strong></p>
<ul>
<li><code>PyFloat</code> 类继承自 <code>PyObj</code> 类， <code>PyFloat</code> 具有所有父类拥有的接口；</li>
<li><code>PyBool</code> 支持使用仓颉 <code>Float32</code>/<code>Float64</code> 类型的数据进行构造；</li>
<li><code>toCjObj</code> 接口为了保证精度，将 <code>PyFloat</code> 转换为仓颉数据类型 <code>Float64</code> 。</li>
</ul>
<p><strong>使用示例：</strong></p>
<!-- run -->
<pre><code class="language-cangjie">import std.ffi.python.*

main(): Int64 {
    Python.load()

    // Creation of `PyLong`.
    var a = PyFloat(3.14)       // The type of `a` is `PyFloat`.
    var b = Python.Eval(&quot;3.14&quot;) // The type of `b` is `PyObj` and needs to be matched to `PyFloat`.
    var c = 3.14.toPyObj()      // The type of `c` is `PyFloat`, which is the same as `a`.

    print(&quot;${a}\n&quot;)
    if (a.toCjObj() == 3.14) {
        print(&quot;success\n&quot;)
    }

    if (b is PyFloat) {
        print(&quot;b is PyFloat\n&quot;)
    }
    Python.unload()
    0
}
</code></pre>
<p>执行结果：</p>
<pre><code class="language-text">3.14
success
b is PyFloat
</code></pre>
<h3 id="pystring-与字符字符串的映射"><a class="header" href="#pystring-与字符字符串的映射"><code>PyString</code> 与字符、字符串的映射</a></h3>
<p><strong>类原型：</strong></p>
<pre><code class="language-cangjie">public class PyString &lt;: PyObj {
    public init(value: String) { ... }
    public init(value: Rune) { ... }
    public func toCjObj(): String { ... }
    public override func toString(): String { ... }
}
</code></pre>
<p><strong>关于 <code>PyString</code> 类的几点说明</strong></p>
<ul>
<li><code>PyString</code> 类继承自 <code>PyObj</code> 类， <code>PyString</code> 具有所有父类拥有的接口；</li>
<li><code>PyString</code> 支持使用仓颉 <code>Rune</code>/<code>String</code> 类型的数据进行构造；</li>
<li><code>toCjObj</code>/<code>toString</code> 接口为将 <code>PyString</code> 转换为仓颉数据类型 <code>String</code> 。</li>
</ul>
<p><strong>使用示例：</strong></p>
<!-- run -->
<pre><code class="language-cangjie">import std.ffi.python.*

main(): Int64 {
    Python.load()

    // Creation of `PyString`.
    var a = PyString(&quot;hello python&quot;)        // The type of `a` is `PyString`.
    var b = Python.Eval(&quot;\&quot;hello python\&quot;&quot;) // The type of `b` is `PyObj` and needs to be matched to `PyString`.
    var c = &quot;hello python&quot;.toPyObj()        // The type of `c` is `PyString`, which is the same as `a`.

    print(&quot;${a}\n&quot;)
    if (a.toCjObj() == &quot;hello python&quot;) {
        print(&quot;success\n&quot;)
    }

    if (b is PyString) {
        print(&quot;b is PyString\n&quot;)
    }
    Python.unload()
    0
}
</code></pre>
<p>执行结果：</p>
<pre><code class="language-text">hello python
success
b is PyString
</code></pre>
<h3 id="pytuple-类型"><a class="header" href="#pytuple-类型"><code>PyTuple</code> 类型</a></h3>
<p><strong>类原型：</strong></p>
<pre><code class="language-cangjie">public class PyTuple &lt;: PyObj {
    public init(args: Array&lt;PyObj&gt;) { ... }
    public operator func [](key: Int64): PyObj { ... }
    public func size(): Int64 { ... }
    public func slice(begin: Int64, end: Int64): PyTuple { ... }
}
</code></pre>
<p><strong>关于 <code>PyTuple</code> 类的几点说明</strong></p>
<ul>
<li><code>PyTuple</code> 与 Python 中的元组类型一致，即 Python 代码中使用 <code>(...)</code> 的变量；</li>
<li><code>PyTuple</code> 类继承自 <code>PyObj</code> 类， <code>PyTuple</code> 具有所有父类拥有的接口；</li>
<li><code>PyTuple</code> 支持使用仓颉 <code>Array</code> 来进行构造， <code>Array</code> 的元素类型必须为 <code>PyObj</code> （Python 不同数据类型均可以使用 <code>PyObj</code> 传递，即兼容 <code>Tuple</code> 中不同元素的不同数据类型），当成员中包含不可用对象时，会抛出异常；</li>
<li><code>[]</code> 操作符重载：
<ul>
<li>父类 <code>PyObj</code> 中 <code>[]</code> 入参类型为 <code>String</code> 类型，该类对象调用时能够访问或设置 <code>Python</code> 元组类型内部成员变量或者函数；</li>
<li>子类 <code>PyTuple</code> 支持使用 <code>[]</code> 对元素进行访问，如果角标 <code>key</code> 超出 [0, size()) 区间，会进行报错，并且返回不可用的 <code>PyObj</code> 对象；</li>
<li>由于 Python 的元组为不可变对象，未进行 <code>set []</code> 操作符重载。</li>
</ul>
</li>
<li><code>size</code> 函数用于获取 <code>PyTuple</code> 的长度；</li>
<li><code>slice</code> 函数用于对源 <code>PyTuple</code> 进行剪裁，并返回一个新的 <code>PyTuple</code> , 如果 <code>slice</code> 的入参 <code>begin</code> 和 <code>end</code> 不在 [0, size()) 区间内，仍会正常裁切。</li>
</ul>
<p><strong>使用示例：</strong></p>
<!-- run -->
<pre><code class="language-cangjie">import std.ffi.python.*

main(): Int64 {
    Python.load()

    // Creation of `PyTuple`.
    var a = PyTuple([&quot;Array&quot;.toPyObj(), 'a'.toPyObj(), 1.toPyObj(), 1.1.toPyObj()])
    var b = match (Python.Eval(&quot;('Array', 'a', 1, 1.1)&quot;)) {
        case val: PyTuple =&gt; val
        case _ =&gt; throw PythonException()
    }

    // Usage of size
    println(a.size())           // 4

    // Usage of slice
    println(a.slice(1, 2))      // ('a',). This print is same as Python code `a[1: 2]`.
    println(a.slice(-1, 20))    // ('Array', 'a', 'set index 3 to String', 1.1)

    Python.unload()
    return 0
}
</code></pre>
<p>执行结果：</p>
<pre><code class="language-text">4
('a',)
('Array', 'a', 1, 1.1)
</code></pre>
<h3 id="pylist-与-array-的映射"><a class="header" href="#pylist-与-array-的映射"><code>PyList</code> 与 <code>Array</code> 的映射</a></h3>
<p><strong>类原型：</strong></p>
<pre><code class="language-cangjie">public class PyList&lt;T&gt; &lt;: PyObj where T &lt;: PyFFIType {
    public init(args: Array&lt;T&gt;) { ... }
    public operator func [](key: Int64): PyObj { ... }
    public operator func [](key: Int64, value!: T): Unit { ... }
    public func toCjObj(): Array&lt;PyObj&gt; { ... }
    public func size(): Int64 { ... }
    public func insert(index: Int64, value: T): Unit { ... }
    public func append(item: T): Unit { ... }
    public func slice(begin: Int64, end: Int64): PyList&lt;T&gt; { ... }
}
</code></pre>
<p><strong>关于 <code>PyList</code> 类的几点说明</strong></p>
<ul>
<li>
<p><code>PyList</code> 类与 Python 中的列表类型一致，即 Python 代码中使用 <code>[...]</code> 的变量；</p>
</li>
<li>
<p><code>PyList</code> 类继承自 <code>PyObj</code> 类， <code>PyList</code> 具有所有父类拥有的接口，该类由于对仓颉的 Array 进行映射，因此该类引入了泛型 <code>T</code> ， <code>T</code> 类型约束为 <code>PyFFIType</code> 接口的子类；</p>
</li>
<li>
<p><code>PyList</code> 类可以通过仓颉的 <code>Array</code> 类型进行构造， <code>Array</code> 的成员类型同样约束为 <code>PyFFIType</code> 接口的子类；</p>
</li>
<li>
<p><code>[]</code> 操作符重载：</p>
<ul>
<li>父类 <code>PyObj</code> 中 <code>[]</code> 入参类型为 <code>String</code> 类型，该类对象调用时仅能访问或设置 <code>Python</code> 内部成员变量或者函数；</li>
<li>该类中的 <code>[]</code> 入参类型为 <code>Int64</code> ，即对应 <code>Array</code> 的角标值，其范围为 [0, size())，如果入参不在范围内，将进行报错，并且返回的对象为不可用；</li>
<li><code>[]</code> 同样支持 <code>get</code> 以及 <code>set</code> ，并且 <code>set</code> 时， <code>value</code> 类型为 <code>T</code> ，如果 <code>value</code> 其中包含不可用的 Python 对象时，会抛出异常。</li>
</ul>
</li>
<li>
<p><code>toCjObj</code> 函数支持将 <code>PyList</code> 转换为仓颉的 <code>Array&lt;PyObj&gt;</code>，请注意，此时并不会转换为 <code>Array&lt;T&gt;</code>；</p>
</li>
<li>
<p><code>size</code> 函数返回 <code>PyList</code> 的长度；</p>
</li>
<li>
<p><code>insert</code> 函数将在 <code>index</code> 位置插入 <code>value</code> ，其后元素往后移，index 不在 [0, size()) 可以正常插入，如果 <code>value</code> 为不可用对象，将会抛出异常；</p>
</li>
<li>
<p><code>append</code> 函数将 <code>item</code> 追加在 <code>PyList</code> 最后，如果 <code>value</code> 为不可用对象，将会抛出异常；</p>
</li>
<li>
<p><code>slice</code> 函数用于截取 [begin, end) 区间内的数据并且返回一个新的 <code>PyList</code> , <code>begin</code> 和 <code>end</code> 不在 [0, size()) 也可以正常截取。</p>
</li>
</ul>
<p><strong>使用示例：</strong></p>
<!-- run -->
<pre><code class="language-cangjie">import std.ffi.python.*

main(): Int64 {
    Python.load()

    // Creation of `PyList`.
    var a = PyList&lt;Int64&gt;([1, 2, 3])
    var b = match (Python.Eval(&quot;[1, 2, 3]&quot;)) {
        case val: PyList&lt;PyObj&gt; =&gt; val
        case _ =&gt; throw PythonException()
    }
    var c = [1, 2, 3].toPyObj()

    // Usage of `[]`
    println(a[&quot;__add__&quot;]([b]))   // [1, 2, 3, 1, 2, 3]
    a[1]
    b[1]
    a[2] = 13
    b[2] = 15.toPyObj()

    // Usage of `toCjObj`
    var cjArr = a.toCjObj()
    for (v in cjArr) {
        print(&quot;${v} &quot;)          // 1 2 13
    }
    print(&quot;\n&quot;)

    // Usage of `size`
    println(a.size())           // 3

    // Usage of `insert`
    a.insert(1, 4)              // [1, 4, 2, 13]
    a.insert(-100, 5)           // [5, 1, 4, 2, 13]
    a.insert(100, 6)            // [5, 1, 4, 2, 13, 6]
    b.insert(1, 4.toPyObj())    // [1, 4, 2, 15]

    // Usage of `append`
    a.append(7)                 // [5, 1, 4, 2, 13, 6, 7]
    b.append(5.toPyObj())       // [1, 4, 2, 15, 5]

    // Usage of `slice`
    a.slice(1, 2)               // [1]
    a.slice(-100, 100)          // [5, 1, 4, 2, 13, 6, 7]
    b.slice(-100, 100)          // [1, 4, 2, 15, 5]

    return 0
}
</code></pre>
<p>执行结果：</p>
<pre><code class="language-text">[1, 2, 3, 1, 2, 3]
1 2 13
3
</code></pre>
<h3 id="pydict-与-hashmap-的映射"><a class="header" href="#pydict-与-hashmap-的映射"><code>PyDict</code> 与 <code>HashMap</code> 的映射</a></h3>
<p><strong>类原型：</strong></p>
<pre><code class="language-cangjie">public class PyDict&lt;K, V&gt; &lt;: PyObj where K &lt;: Hashable &amp; Equatable&lt;K&gt; &amp; PyFFIType {
    public init(args: HashMap&lt;K, V&gt;) { ... }
    public func getItem(key: K): PyObj { ... }
    public func setItem(key: K, value: V): Unit { ... }
    public func toCjObj(): HashMap&lt;PyObj, PyObj&gt; { ... }
    public func contains(key: K): Bool { ... }
    public func copy(): PyDict&lt;K, V&gt; { ... }
    public func del(key: K): Unit { ... }
    public func size(): Int64 { ... }
    public func empty(): Unit { ... }
    public func items(): PyList&lt;PyObj&gt; { ... }
    public func values(): PyList&lt;PyObj&gt; { ... }
    public func keys(): PyList&lt;PyObj&gt; { ... }
}
</code></pre>
<p><strong>关于 <code>PyDict</code> 类的几点说明</strong></p>
<ul>
<li>
<p><code>PyDict</code> 与 Python 的字典类型一致，即 Python 代码中使用 <code>{ a: b }</code> 的变量；</p>
</li>
<li>
<p><code>PyDict</code> 类继承自 <code>PyObj</code> 类， <code>PyDict</code> 具有所有父类拥有的接口，该类由于对仓颉的 HashMap 进行映射，因此该类引入了泛型 <code>&lt;K, V&gt;</code> ，其中 <code>K</code> 类型约束为 <code>PyFFIType</code> 接口的子类，且可被 <code>Hash</code> 计算以及重载了 <code>==</code> 与 <code>!=</code> 运算符；</p>
</li>
<li>
<p><code>PyDict</code> 接受来自仓颉类型 <code>HashMap</code> 的数据进行构造：</p>
<ul>
<li><code>K</code> 仅接受 <code>CjObj</code> 或 <code>PyObj</code> 类型或其子类；</li>
<li>相同的 Python 数据其值也相同，例如 <code>Python.Eval(&quot;1&quot;)</code> 与 <code>1.toPyObj()</code> 为 <code>==</code> 关系。</li>
</ul>
</li>
<li>
<p><code>getItem</code> 函数用于获取 <code>PyDict</code> 对应键值的 <code>value</code> ，如果键值无法找到，会进行报错并返回不可用的 <code>PyObj</code> ，如果配置的值 <code>key</code> 或为 <code>value</code> 为 <code>PyObj</code> 类型且不可用，此时抛出异常；</p>
</li>
<li>
<p><code>setItem</code> 函数用于配置 <code>PyDict</code> 对应键值的 <code>value</code> ，如果对应键值无法找到，会进行插入，如果配置的值 <code>key</code> 或为 <code>value</code> 为 <code>PyObj</code> 类型且不可用，此时抛出异常；</p>
</li>
<li>
<p><code>toCjObj</code> 函数用于将 <code>PyDict</code> 转换为 <code>HashMap&lt;PyObj, PyObj&gt;</code> 类型；</p>
</li>
<li>
<p><code>contains</code> 函数用于判断 <code>key</code> 值是否包含在当前字典中，返回类型为 Bool 型，如果接口失败，进行报错，并且返回 false；</p>
</li>
<li>
<p><code>copy</code> 函数用于拷贝当前字典，并返回一个新的 <code>PyDict&lt;T&gt;</code> 类型，如果拷贝失败，返回的 PyDict 不可用；</p>
</li>
<li>
<p><code>del</code> 函数用于删除对应 <code>key</code> 的值，如果 key 值为 PyObj 类型且不可用，会抛出异常；</p>
</li>
<li>
<p><code>size</code> 函数用于返回当前字典的长度；</p>
</li>
<li>
<p><code>empty</code> 函数用于清空当前字典内容；</p>
</li>
<li>
<p><code>items</code> 函数用于获取一个 Python <code>list</code> 类型的键值对列表，可以被迭代访问；</p>
</li>
<li>
<p><code>values</code> 函数用于获取一个 Python <code>list</code> 类型的值列表，可以被迭代访问；</p>
</li>
<li>
<p><code>keys</code> 函数用于获取一个 Python <code>list</code> 类型的键列表，可以被迭代访问。</p>
</li>
</ul>
<p>使用示例：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.ffi.python.*
import std.collection.*

main() {
    Python.load()

    // Creation of `PyDict`
    var a = PyDict(HashMap&lt;Int64, Int64&gt;([(1, 1), (2, 2)]))             // The key type is `CjObj`.
    var b = PyDict(HashMap&lt;PyObj, Int64&gt;([(Python.Eval(&quot;1&quot;), 1), (Python.Eval(&quot;2&quot;), 2)]))   // The key type is `PyObj`.
    var c = match (Python.Eval(&quot;{'pydict': 1, 'hashmap': 2, 3: 3, 3.1: 4}&quot;)) {
        case val: PyDict&lt;PyObj, PyObj&gt; =&gt; val       // Python side return `PyDict&lt;PyObj, PyObj&gt;`
        case _ =&gt; throw PythonException()
    }
    var d = HashMap&lt;Int64, Int64&gt;([(1, 1), (2, 2)]).toPyObj()

    // Usage of `getItem`
    println(a.getItem(1))               // 1
    println(b.getItem(1.toPyObj()))     // 1

    // Usage of `setItem`
    a.setItem(1, 10)
    b.setItem(1.toPyObj(), 10)
    println(a.getItem(1))               // 10
    println(b.getItem(1.toPyObj()))     // 10

    // Usage of `toCjObj`
    var hashA = a.toCjObj()
    for ((k, v) in hashA) {
        print(&quot;${k}: ${v}, &quot;)           // 1: 10, 2: 2,
    }
    print(&quot;\n&quot;)
    var hashB = b.toCjObj()
    for ((k, v) in hashB) {
        print(&quot;${k}: ${v}, &quot;)           // 1: 10, 2: 2,
    }
    print(&quot;\n&quot;)

    // Usage of `contains`
    println(a.contains(1))              // true
    println(a.contains(3))              // false
    println(b.contains(1.toPyObj()))    // true

    // Usage of `copy`
    println(a.copy())                   // {1: 10, 2: 2}

    // Usage of `del`
    a.del(1)                            // Delete the key-value pair (1: 1).

    // Usage of `size`
    println(a.size())                   // 1

    // Usage of `empty`
    a.empty()                           // Clear all elements in dict.

    // Usage of `items`
    for (i in b.items()) {
        print(&quot;${i} &quot;)                  // (1, 10) (2, 2)
    }
    print(&quot;\n&quot;)

    // Usage of `values`
    for (i in b.values()) {
        print(&quot;${i} &quot;)                  // 10 2
    }
    print(&quot;\n&quot;)

    // Usage of `keys`
    for (i in b.keys()) {
        print(&quot;${i} &quot;)                  // 1, 2
    }
    print(&quot;\n&quot;)

    Python.unload()
}
</code></pre>
<h3 id="pyset-与-hashset-的映射"><a class="header" href="#pyset-与-hashset-的映射"><code>PySet</code> 与 <code>HashSet</code> 的映射</a></h3>
<p><strong>类原型：</strong></p>
<pre><code class="language-cangjie">public class PySet&lt;T&gt; &lt;: PyObj where T &lt;: Hashable, T &lt;: Equatable&lt;T&gt; &amp; PyFFIType {
    public init(args: HashSet&lt;T&gt;) { ... }
    public func toCjObj(): HashSet&lt;PyObj&gt; { ... }
    public func contains(key: T): Bool { ... }
    public func add(key: T): Unit { ... }
    public func pop(): PyObj { ... }
    public func del(key: T): Unit { ... }
    public func size(): Int64 { ... }
    public func empty(): Unit { ... }
}
</code></pre>
<p><strong>关于 <code>PySet</code> 类的几点说明</strong></p>
<ul>
<li>
<p><code>PySet</code> 对应的是 Python 中的集合的数据类型，当元素插入时会使用 Python 内部的 hash 算法对集合元素进行排序（并不一定按照严格升序，一些方法可能因此每次运行结果不一致）。</p>
</li>
<li>
<p><code>PySet</code> 类继承自 <code>PyObj</code> 类， <code>PySet</code> 具有所有父类拥有的接口，该类由于对仓颉的 <code>HashSet</code> 进行映射，因此该类引入了泛型 <code>T</code> ， <code>T</code> 类型约束为 <code>PyFFIType</code> 接口的子类，且可被 <code>Hash</code> 计算以及重载了 <code>==</code> 与 <code>!=</code> 运算符；</p>
</li>
<li>
<p><code>PySet</code> 接受来自仓颉类型 <code>HashMap</code> 的数据进行构造：</p>
<ul>
<li><code>K</code> 仅接受 <code>CjObj</code> 或 <code>PyObj</code> 类型或其子类；</li>
<li>相同的 Python 数据其值也相同，例如 <code>Python.Eval(&quot;1&quot;)</code> 与 <code>1.toPyObj()</code> 为 <code>==</code> 关系。</li>
</ul>
</li>
<li>
<p><code>toCjObj</code> 函数用于将 <code>PySet&lt;T&gt;</code> 转为 <code>HashSet&lt;PyObj&gt;</code> 需要注意的是此处只能转为元素类型为 <code>PyObj</code> 类型；</p>
</li>
<li>
<p><code>contains</code> 函数用于判断 <code>key</code> 是否在当前字典中存在， <code>key</code> 类型为 <code>T</code> ；</p>
</li>
<li>
<p><code>add</code> 函数可以进行值插入，当 <code>PySet</code> 中已存在键值，则插入不生效，如果 <code>key</code> 为 <code>PyObj</code> 且不可用，则会抛出异常；</p>
</li>
<li>
<p><code>pop</code> 函数将 <code>PySet</code> 中的第一个元素取出；</p>
</li>
<li>
<p><code>del</code> 删除对应的键值，如果 <code>key</code> 不在 <code>PySet</code> 中，则会报错并正常退出，如果 <code>key</code> 为 <code>PyObj</code> 且不可用，则会抛出异常；</p>
</li>
<li>
<p><code>size</code> 用于返回 <code>PySet</code> 的长度；</p>
</li>
<li>
<p><code>empty</code> 用于清空当前 <code>PySet</code> 。</p>
</li>
</ul>
<blockquote>
<p><strong>注意：</strong></p>
<p>调用 <code>toCjObj</code> 完后，所有元素将被 <code>pop</code> 出来，此时原 <code>PySet</code> 将会为空（ <code>size</code> 为 0，原 <code>PySet</code> 仍然可用）；</p>
</blockquote>
<p>使用示例：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.ffi.python.*
import std.collection.*

main() {
    Python.load()

    // Creation of `PySet`
    var a = PySet&lt;Int64&gt;(HashSet&lt;Int64&gt;([1, 2, 3]))
    var b = match (Python.Eval(&quot;{'PySet', 'HashSet', 1, 1.1, True}&quot;)) {
        case val: PySet&lt;PyObj&gt; =&gt; val
        case _ =&gt; throw PythonException()
    }
    var c = HashSet&lt;Int64&gt;([1, 2, 3]).toPyObj()

    // Usage of `toCjObj`
    var cja = a.toCjObj()
    println(a.size())                           // 0

    // Usage of `contains`
    println(b.contains(&quot;PySet&quot;.toPyObj()))      // true

    // Usage of `add`
    a.add(2)
    println(a.size())   // 1
    a.add(2)            // Insert same value, do nothing.
    println(a.size())   // 1
    a.add(1)            // Insert `1`.

    // Usage of `pop`
    println(a.pop())    // 1. Pop the first element.
    println(a.size())   // 1

    // Usage of `del`
    c.del(2)
    println(c.contains(2))  // false

    // Usage of `empty`
    println(c.size())   // 2
    c.empty()
    println(c.size())   // 0

    Python.unload()
}
</code></pre>
<h3 id="pyslice-类型"><a class="header" href="#pyslice-类型"><code>PySlice</code> 类型</a></h3>
<p><code>PySlice</code> 类型与 Python 内建函数 <code>slice()</code> 的返回值用法一致，可以被用来标识一段区间及步长，可以用来作为可被切片的类型下标值来剪裁获取子串。为了方便从仓颉侧构造， <code>PySlice</code> 类可以与仓颉的 <code>Range</code> 区间类型进行互相转换，详细描述见以下。</p>
<p><strong>类原型：</strong></p>
<pre><code class="language-cangjie">public class PySlice&lt;T&gt; &lt;: PyObj where T &lt;: Countable&lt;T&gt; &amp; Comparable&lt;T&gt; &amp; Equatable&lt;T&gt; &amp; CjObj {
    public init(args: Range&lt;T&gt;) { ... }
    public func toCjObj(): Range&lt;Int64&gt; { ... }
}
</code></pre>
<p><strong>关于 <code>PySlice</code> 的几点说明：</strong></p>
<ul>
<li><code>PySlice</code> 可以使用仓颉的 <code>Range</code> 类型来进行构造，并且支持 <code>Range</code> 的语法糖，其中泛型 <code>T</code> 在原有 <code>Range</code> 约束的同时，加上约束在来自 <code>CjObj</code> 的实现，不支持 <code>PyObj</code> 类型；</li>
<li><code>toCjObj</code> 函数支持将 <code>PySlice</code> 转为仓颉 <code>Range</code> 的接口，应注意此时 <code>Range</code> 的泛型类型为 <code>Int64</code> 类型的整型；</li>
<li>如果希望把 <code>PySlice</code> 类型传递给 <code>PyString/PyList/PyTuple</code> 或者是其他可被 <code>slice</code> 的 <code>PyObj</code> 类型，可以通过其成员函数 <code>__getitem__</code> 进行传递，详情见示例。</li>
</ul>
<p><strong>使用示例：</strong></p>
<!-- run -->
<pre><code class="language-cangjie">import std.ffi.python.*

main() {
    Python.load()
    var range = 1..6:2

    // Create a PySlice.
    var slice1 = PySlice(range)
    var slice2 = match (Python[&quot;slice&quot;]([0, 6, 2])) {
        case val: PySlice&lt;Int64&gt; =&gt; val
        case _ =&gt; throw PythonException()
    }
    var slice3 = range.toPyObj()

    // Use PySlice in PyString.
    var str = PyString(&quot;1234567&quot;)
    println(str[&quot;__getitem__&quot;]([range]))    // 246
    println(str[&quot;__getitem__&quot;]([slice1]))   // 246

    // Use PySlice in PyList.
    var list = PyList([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;])
    println(list[&quot;__getitem__&quot;]([range]))   // ['b', 'd', 'f']
    println(list[&quot;__getitem__&quot;]([slice1]))  // ['b', 'd', 'f']

    // Use PySlice in PyTuple.
    var tup = PyTuple(list.toCjObj())
    println(tup[&quot;__getitem__&quot;]([range]))    // ('b', 'd', 'f')
    println(tup[&quot;__getitem__&quot;]([slice1]))   // ('b', 'd', 'f')

    Python.unload()
    0
}
</code></pre>
<p>执行结果：</p>
<pre><code class="language-text">246
246
['b', 'd', 'f']
['b', 'd', 'f']
('b', 'd', 'f')
('b', 'd', 'f')
</code></pre>
<h3 id="pyobj-的迭代器类型-pyobjiterator"><a class="header" href="#pyobj-的迭代器类型-pyobjiterator"><code>PyObj</code> 的迭代器类型 <code>PyObjIterator</code></a></h3>
<p><strong>代码原型：</strong></p>
<p><code>PyObj</code> 的扩展：</p>
<pre><code class="language-cangjie">extend PyObj &lt;: Iterable&lt;PyObj&gt; {
    public func iterator(): Iterator&lt;PyObj&gt; { ... }
}
</code></pre>
<p><code>PyObjIterator</code> 类型：</p>
<pre><code class="language-cangjie">public class PyObjIterator &lt;: Iterator&lt;PyObj&gt; {
    public init(obj: PyObj) { ... }
    public func next(): Option&lt;PyObj&gt; { ... }
    public func iterator(): Iterator&lt;PyObj&gt; { ... }
}
</code></pre>
<p><strong>关于 <code>PyObjIterator</code> 的几点说明：</strong></p>
<ul>
<li>
<p>获取 <code>PyObjIterator</code> 可以通过 <code>PyObj</code> 的 iterator 方法获取；</p>
</li>
<li>
<p><code>PyObjIterator</code> 允许被外部构造，如果提供的 <code>PyObj</code> 不可以被迭代或提供的 <code>PyObj</code> 不可用，则会直接抛出异常；</p>
<ul>
<li>可以被迭代的对象有：<code>PyString/PyTuple/PyList/PySet/PyDict</code>；</li>
<li>直接对 <code>PyDict</code> 进行迭代时，迭代的为其键 <code>key</code> 的值。</li>
</ul>
</li>
<li>
<p><code>next</code> 函数用于对该迭代器进行迭代；</p>
</li>
<li>
<p><code>iterator</code> 方法用于返回本身。</p>
</li>
</ul>
<p><strong>使用示例：</strong></p>
<!-- run -->
<pre><code class="language-cangjie">import std.ffi.python.*
import std.collection.*

main() {
    Python.load()

    // iter of PyString
    var S = PyString(&quot;Str&quot;)
    for (s in S) {
        print(&quot;${s} &quot;)      // S t r
    }
    print(&quot;\n&quot;)

    // iter of PyTuple
    var T = PyTuple([&quot;T&quot;.toPyObj(), &quot;u&quot;.toPyObj(), &quot;p&quot;.toPyObj()])
    for (t in T) {
        print(&quot;${t} &quot;)      // T u p
    }
    print(&quot;\n&quot;)

    // iter of PyList
    var L = PyList([&quot;L&quot;, &quot;i&quot;, &quot;s&quot;, &quot;t&quot;])
    for (l in L) {
        print(&quot;${l} &quot;)      // L i s t
    }
    print(&quot;\n&quot;)

    // iter of PyDict
    var D = PyDict(HashMap&lt;Int64, String&gt;([(1, &quot;D&quot;), (2, &quot;i&quot;), (3, &quot;c&quot;), (4, &quot;t&quot;)]))
    for (d in D) {
        print(&quot;${d} &quot;)      // 1 2 3 4, dict print keys.
    }
    print(&quot;\n&quot;)

    // iter of PySet
    var Se = PySet(HashSet&lt;Int64&gt;([1, 2, 3]))
    for (s in Se) {
        print(&quot;${s} &quot;)      // 1 2 3
    }
    print(&quot;\n&quot;)
    0
}
</code></pre>
<p>执行结果：</p>
<pre><code class="language-text">S t r
T u p
L i s t
1 2 3 4
1 2 3
</code></pre>
<h2 id="仓颉与-python-的注册回调"><a class="header" href="#仓颉与-python-的注册回调">仓颉与 Python 的注册回调</a></h2>
<p>Python 互操作库支持简单的函数注册及 Python 对仓颉函数调用。</p>
<p>Python 回调仓颉代码通过需要通过 C 作为介质进行调用，并且使用到了 Python 的三方库： <code>ctypes</code> 以及 <code>_ctypes</code> 。</p>
<h3 id="cangjie-类型c-类型与-python-类型之间的映射"><a class="header" href="#cangjie-类型c-类型与-python-类型之间的映射">Cangjie 类型、C 类型与 Python 类型之间的映射</a></h3>
<p>基础数据对照如下表：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Cangjie Type</th><th style="text-align: center">CType</th><th style="text-align: center">Python Type</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>Bool</code></td><td style="text-align: center"><code>PyCBool</code></td><td style="text-align: center"><code>PyBool</code></td></tr>
<tr><td style="text-align: center"><code>Rune</code></td><td style="text-align: center"><code>PyCWchar</code></td><td style="text-align: center"><code>PyString</code></td></tr>
<tr><td style="text-align: center"><code>Int8</code></td><td style="text-align: center"><code>PyCByte</code></td><td style="text-align: center"><code>PyLong</code></td></tr>
<tr><td style="text-align: center"><code>UInt8</code></td><td style="text-align: center"><code>PyCUbyte/PyCChar</code></td><td style="text-align: center"><code>PyLong</code></td></tr>
<tr><td style="text-align: center"><code>Int16</code></td><td style="text-align: center"><code>PyCShort</code></td><td style="text-align: center"><code>PyLong</code></td></tr>
<tr><td style="text-align: center"><code>UInt16</code></td><td style="text-align: center"><code>PyCUshort</code></td><td style="text-align: center"><code>PyLong</code></td></tr>
<tr><td style="text-align: center"><code>Int32</code></td><td style="text-align: center"><code>PyCInt</code></td><td style="text-align: center"><code>PyLong</code></td></tr>
<tr><td style="text-align: center"><code>UInt32</code></td><td style="text-align: center"><code>PyCUint</code></td><td style="text-align: center"><code>PyLong</code></td></tr>
<tr><td style="text-align: center"><code>Int64</code></td><td style="text-align: center"><code>PyCLonglong</code></td><td style="text-align: center"><code>PyLong</code></td></tr>
<tr><td style="text-align: center"><code>UInt64</code></td><td style="text-align: center"><code>PyCUlonglong</code></td><td style="text-align: center"><code>PyLong</code></td></tr>
<tr><td style="text-align: center"><code>Float32</code></td><td style="text-align: center"><code>PyCFloat</code></td><td style="text-align: center"><code>PyFloat</code></td></tr>
<tr><td style="text-align: center"><code>Float64</code></td><td style="text-align: center"><code>PyCDouble</code></td><td style="text-align: center"><code>PyFloat</code></td></tr>
<tr><td style="text-align: center">[unsupport CPointer as param] <code>CPointer&lt;T&gt;</code></td><td style="text-align: center"><code>PyCPointer</code></td><td style="text-align: center"><code>ctypes.pointer</code></td></tr>
<tr><td style="text-align: center">[unsupport CString as param] <code>CString</code></td><td style="text-align: center"><code>PyCCpointer</code></td><td style="text-align: center"><code>ctypes.c_char_p</code></td></tr>
<tr><td style="text-align: center">[unsupport CString as param] <code>CString</code></td><td style="text-align: center"><code>PyCWcpointer</code></td><td style="text-align: center"><code>ctypes.c_wchar_p</code></td></tr>
<tr><td style="text-align: center"><code>Unit</code></td><td style="text-align: center"><code>PyCVoid</code></td><td style="text-align: center">-</td></tr>
</tbody></table>
</div>
<ul>
<li><code>Cangjie Type</code> 是在仓颉侧修饰的变量类型，无特殊说明则支持传递该类型参数给 Python 代码，并且支持从 Python 传递给仓颉；</li>
<li><code>PyCType</code> 为仓颉侧对应的 <code>PyCFunc</code> 接口配置类型，详细见<a href="source_zh_cn/FFI/cangjie-python.html#pycfunc-%E7%B1%BB%E5%8E%9F%E5%9E%8B"><code>PyCFunc</code> 类原型</a>以及<a href="source_zh_cn/FFI/cangjie-python.html#%E7%A4%BA%E4%BE%8B">示例</a>展示；</li>
<li><code>Python Type</code> 是在仓颉侧的类型映射，无指针类型映射，不支持从仓颉侧调用 Python 带有指针的函数；</li>
<li><code>PyCCpointer</code> 与 <code>PyCWcpointer</code> 同样都是映射到 <code>CString</code> ，两者区别为 <code>PyCCpointer</code> 为 C 中的字符串， <code>PyCWcpointer</code> 仅为字符指针，即使传递多个字符，也只取第一个字符；</li>
<li>类型不匹配将会导致不可预测的结果。</li>
</ul>
<h3 id="pycfunc-类原型"><a class="header" href="#pycfunc-类原型"><code>PyCFunc</code> 类原型</a></h3>
<p><code>PyCFunc</code> 是基于 Python 互操作库和 Python 三方库 <code>ctype/_ctype</code> 的一个 PyObj 子类型，该类型可以直接传递给 Python
侧使用。 <code>PyCFunc</code> 为用户提供了注册仓颉的 <code>CFunc</code> 函数给 Python 侧，并且支持由 Python 回调 <code>CFunc</code> 函数的能力。</p>
<p><strong>代码原型：</strong></p>
<pre><code class="language-cangjie">public enum PyCType {
    PyCBool |
    PyCChar |
    PyCWchar |
    PyCByte |
    PyCUbyte |
    PyCShort |
    PyCUshort |
    PyCInt |
    PyCUint |
    PyCLonglong |
    PyCUlonglong |
    PyCFloat |
    PyCDouble |
    PyCPointer |
    PyCCpointer |
    PyCWcpointer |
    PyCVoid
}

public class PyCFunc &lt;: PyObj {
    public init(f: CPointer&lt;Unit&gt;, argsTy!: Array&lt;PyCType&gt; = [], retTy!: PyCType = PyCType.PyCVoid) { ... }
    public func setArgTypes(args: Array&lt;PyCType&gt;): PyCFunc { ... }
    public func setRetTypes(ret: PyCType): PyCFunc { ... }
}
</code></pre>
<p><strong>关于类的几点说明：</strong></p>
<ul>
<li>
<p><code>PyCFunc</code> 继承自 <code>PyObj</code> ，可以使用父类的部分接口（如果不支持的接口会相应报错）；</p>
</li>
<li>
<p><code>init</code> 允许外部用户构造，必须提供函数指针作为第一个参数（仓颉侧需要将 <code>CFunc</code> 类型转换为 <code>CPointer&lt;Unit&gt;</code> 类型），后面两个可选参数分别为入参类型的数组、返回值类型；</p>
<p><strong>这里特别声明，如果传入的指针并非函数指针会导致函数调用时程序崩溃（库层面无法进行拦截）。</strong></p>
</li>
<li>
<p><code>setArgTypes/setRetTypes</code> 函数用于配置参数和返回值类型，支持的参数见 <code>PyCType</code> 枚举；</p>
</li>
<li>
<p>父类中的 <code>()</code> 操作符，支持在仓颉侧调用该注册的 <code>CFunc</code> 函数；</p>
</li>
<li>
<p>该类可以直接传递给 Python 侧使用，也可以在仓颉侧直接调用（如果该类构造时使用非函数指针，这里调用将会崩溃）；</p>
</li>
<li>
<p>该类支持类似 Js 的链式调用。</p>
</li>
</ul>
<h3 id="示例-1"><a class="header" href="#示例-1">示例</a></h3>
<p>1、准备仓颉的 <code>CFunc</code> 函数：</p>
<!-- run -->
<pre><code class="language-cangjie">@C
func cfoo(a: Bool, b: Int32, c: Int64): CPointer&lt;Unit&gt; {
    print(&quot;cfoo called.\n&quot;)
    print(&quot;${a}, ${b}, ${c}\n&quot;)
    return CPointer&lt;Unit&gt;()
}
</code></pre>
<p>2、构造 PyCFunc 类对象：</p>
<!-- run -->
<pre><code class="language-cangjie">import std.ffi.python.*

// Define the @C function.
@C
func cfoo(a: Bool, b: Int32, c: Int64): CPointer&lt;Unit&gt; {
    print(&quot;cfoo called.\n&quot;)
    print(&quot;${a}, ${b}, ${c}\n&quot;)
    return CPointer&lt;Unit&gt;()
}

main() {
    Python.load()
    /*
    Construct PyCFunc class.
    Set args type:  Bool -&gt; PyCBool
                    Int32 -&gt; PyCInt
                    Int64 -&gt; PyCLonglong
                    CPointer&lt;Unit&gt; -&gt; PyCPointer
    */
    var f1 = PyCFunc(unsafe {CPointer&lt;Unit&gt;(cfoo)},
                    argsTy: [PyCBool, PyCInt, PyCLonglong],
                    retTy: PyCPointer)

    // You also can use it by chain-call.
    var f2 = PyCFunc(unsafe {CPointer&lt;Unit&gt;(cfoo)})
            .setArgTypes([PyCBool, PyCInt, PyCLonglong])
            .setRetTypes(PyCPointer)([true, 1, 2])

    // Call f1
    f1([true, 1, 2])
    f1([PyBool(true), PyLong(1), PyLong(2)])

    Python.unload()
    0
}
</code></pre>
<p>编译仓颉文件并执行：</p>
<pre><code class="language-shell">$ cjc ./main.cj -o ./main &amp;&amp; ./main
cfoo called.
true, 1, 2
cfoo called.
true, 1, 2
cfoo called.
true, 1, 2
</code></pre>
<p>3、将函数注册给 Python 并且由 Python 进行调用：</p>
<p>Python 代码如下：</p>
<pre><code class="language-python"># File test.py

# `foo` get a function pointer and call it.
def foo(func):
    func(True, 10, 40)
</code></pre>
<p>对上面仓颉 <code>main</code> 进行修改：</p>
<!-- compile -->
<pre><code class="language-cangjie">import std.ffi.python.*

// Define the @C function.
@C
func cfoo(a: Bool, b: Int32, c: Int64): CPointer&lt;Unit&gt; {
    print(&quot;cfoo called.\n&quot;)
    print(&quot;${a}, ${b}, ${c}\n&quot;)
    return CPointer&lt;Unit&gt;()
}

main() {
    Python.load()

    var f1 = PyCFunc(unsafe {CPointer&lt;Unit&gt;(cfoo)},
                    argsTy: [PyCBool, PyCInt, PyCLonglong],
                    retTy: PyCPointer)

    // Import test.py
    var cfunc01 = Python.Import(&quot;test&quot;)

    // Call `foo` and transfer `f1`
    cfunc01[&quot;foo&quot;]([f1])

    Python.unload()
    0
}
</code></pre>
<p>4、Python 侧传递指针到仓颉侧：</p>
<p>为 Python 文件增加函数：</p>
<pre><code class="language-python"># File test.py

# If you want transfer pointer type to Cangjie CFunc, you need import ctypes.
import ctypes.*

# `foo` get a function pointer and call it.
def foo(func):
    func(True, 10, 40)

# `fooptr` get a function pointer and call it with pointer type args.
def fooptr(func):
    a = c_int(10)
    # c_char_p will get whole symbols, but c_wchar_p only get first one symbol 'd'.
    func(pointer(a), c_char_p(b'abc'), c_wchar_p('def'))
</code></pre>
<p>修改仓颉代码：</p>
<!-- compile -->
<pre><code class="language-cangjie">import std.ffi.python.*

var x = Python.load()

// Modify the `foo` param type to pointer.
@C
func foo(a: CPointer&lt;Int64&gt;, b: CString, c: CString): Unit {
    print(&quot;${unsafe {a.read(0)}}, ${b.toString()}, ${c.toString()}\n&quot;)
}

main(): Int64 {

    var f1 = PyCFunc(unsafe {CPointer&lt;Unit&gt;(foo)},
                    argsTy: [PyCPointer, PyCCpointer, PyCWcpointer],
                    retTy: PyCVoid)

    // Import test.py
    var test = Python.Import(&quot;test&quot;)

    // Call `fooptr` and transfer `f1`
    test[&quot;fooptr&quot;]([f1])
    return 0
}
</code></pre>
<p>由于仓颉侧调用函数不能将指针类型传递给 Python 库，所以该处仅支持在 Python 侧进行调用。</p>
<p>对其编译并执行：</p>
<pre><code class="language-shell">$ cjc ./main.cj -o ./main &amp;&amp; ./main
10, abc, d
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cjc-使用"><a class="header" href="#cjc-使用"><code>cjc</code> 使用</a></h1>
<p><code>cjc</code>是仓颉编程语言的编译命令，其提供了丰富的功能及对应的编译选项，本章将对基本使用方法进行介绍。</p>
<p><code>cjc-frontend</code> （仓颉前端编译器）会随 <code>cjc</code> 一起通过 <code>Cangjie SDK</code> 提供，<code>cjc-frontend</code> 能够将仓颉源码编译至仓颉的中间表示 （<code>LLVM IR</code>）。 <code>cjc-frontend</code> 仅进行仓颉代码的前端编译，虽然 <code>cjc-frontend</code> 和 <code>cjc</code> 共享部分编译选项，但编译流程会在前端编译结束时中止。使用 <code>cjc</code> 时仓颉编译器会自动进行前端、后端的编译以及链接工作。<code>cjc-frontend</code> 仅作为前端编译器的实体体现提供，除编译器开发者外，仓颉代码的编译应优先使用 <code>cjc</code> 。</p>
<h2 id="cjc-基本使用方法"><a class="header" href="#cjc-基本使用方法"><code>cjc</code> 基本使用方法</a></h2>
<p>想必你已经在学习仓颉的过程中尝试着使用 <code>cjc</code> 了，我们先来看一下 <code>cjc</code> 的基本使用方法，如果你想了解详细的编译选项内容，请查阅<a href="source_zh_cn/Compile-And-Build/../Appendix/compile_options.html">“cjc 编译选项”</a>章节。</p>
<p><code>cjc</code> 的使用方式如下：</p>
<pre><code class="language-shell">cjc [option] file...
</code></pre>
<p>假如我们有一个名为 <code>hello.cj</code> 的仓颉文件：</p>
<!-- run -->
<pre><code class="language-cangjie">main() {
    println(&quot;Hello, World!&quot;)
}
</code></pre>
<p>我们可以使用以下命令来编译此文件：</p>
<pre><code class="language-shell">$ cjc hello.cj
</code></pre>
<p>此时工作目录下会新增可执行文件 <code>main</code> ，<code>cjc</code> 默认会将给定源代码文件编译成可执行文件，并将可执行文件命名为 <code>main</code>。</p>
<p>以上为不给任何编译选项时 <code>cjc</code> 的默认行为，我们可以通过使用编译选项来控制 <code>cjc</code> 的行为，例如让 <code>cjc</code> 进行整包编译，又或者是指定输出文件的名字。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cjpm-介绍"><a class="header" href="#cjpm-介绍"><code>cjpm</code> 介绍</a></h1>
<p><code>CJPM（Cangjie Package Manager）</code> 是仓颉语言的官方包管理工具，用来管理、维护仓颉项目的模块系统，并且提供更简易统一的编译入口，支持自定义编译命令。通过包管理器自动依赖管理实现对引入的多版本三方依赖软件进行分析合并，无需开发者担心多版本依赖冲突问题，大大减轻开发者负担；同时提供基于仓颉语言原生的自定义构建机制，允许开发者在构建的不同阶段增加预处理和后处理流程，实现构建流程可灵活定制，能够满足开发者不同业务场景下的编译构建诉求。</p>
<h2 id="cjpm-基本使用方法"><a class="header" href="#cjpm-基本使用方法"><code>cjpm</code> 基本使用方法</a></h2>
<p>通过 <code>cjpm -h</code> 即可查看主界面，由几个板块组成，从上到下分别是： 当前命令说明、使用示例（Usage）、支持的可用命令（Available subcommands）、支持的配置项（Available options）、更多提示内容。</p>
<pre><code class="language-text">Cangjie Package Manager

Usage:
  cjpm [subcommand] [option]

Available subcommands:
  init             Init a new cangjie module
  check            Check the dependencies
  update           Update cjpm.lock
  tree             Display the package dependencies in the source code
  build            Compile the current module
  run              Compile and run an executable product
  test             Unittest a local package or module
  clean            Clean up the target directory
  publish          Push a module to the repository
  load             Load a module from the repository
  list             Get module list from the repository
  install          Install a cangjie binary
  uninstall        Uninstall a cangjie binary

Available options:
  -h, --help       help for cjpm
  -v, --version    version for cjpm

Use &quot;cjpm [subcommand] --help&quot; for more information about a command.
</code></pre>
<p><code>cjpm init</code> 用来初始化一个新的仓颉模块或者工作空间。初始化模块时会默认在当前文件夹创建 <code>cjpm.toml</code> 文件，并且新建 <code>src</code> 源码文件夹，在 <code>src</code> 下生成默认的 <code>main.cj</code> 文件。自定义参数初始化功能支持可以通过<code>cjpm init -h</code> 查看。</p>
<p>例如：</p>
<pre><code class="language-text">输入: cjpm init
输出: cjpm init success
</code></pre>
<p><code>cjpm build</code> 用来构建当前仓颉项目，执行该命令前会先检查依赖项，检查通过后调用 <code>cjc</code> 进行构建。支持全量编译、增量编译、交叉编译、并行编译等，更多编译功能支持可以通过<code>cjpm build -h</code> 查看。通过<code>cjpm build -V</code> 命令可以打印所有的编译过程命令。</p>
<p>例如：</p>
<pre><code class="language-text">输入: cjpm build -V
输出:
compile package module1.package1: cjc --import-path target -p &quot;src/package1&quot; --output-type=staticlib -o target/release/module1/libmodule1.package1.a
compile package module1: cjc --import-path target -L target/release/module1 -lmodule1.package1 -p &quot;src&quot; --output-type=exe --output-dir target/release/bin -o main

cjpm build success
</code></pre>
<h2 id="cjpmtoml-配置文件说明"><a class="header" href="#cjpmtoml-配置文件说明"><code>cjpm.toml</code> 配置文件说明</a></h2>
<p>配置文件 <code>cjpm.toml</code> 用来配置一些基础信息、依赖项、编译选项等内容，<code>cjpm</code> 主要通过这个文件进行解析执行。</p>
<p>配置文件代码如下所示：</p>
<pre><code class="language-text">[package]
  cjc-version = &quot;0.49.1&quot; # 所需 `cjc` 的最低版本要求，必须
  name = &quot;demo&quot; # 模块名及模块 root 包名，必须
  description = &quot;nothing here&quot; # 描述信息，非必须
  version = &quot;1.0.0&quot; # 模块版本信息，必须
  compile-option = &quot;&quot; # 额外编译命令选项，非必须
  link-option = &quot;&quot; # 链接器透传选项，可透传安全编译命令，非必须
  output-type = &quot;executable&quot; # 编译输出产物类型，必须
  src-dir = &quot;&quot; # 指定源码存放路径，非必须
  target-dir = &quot;&quot; # 指定产物存放路径，非必须
  package-configuration = {} # 单包配置选项，非必须

[workspace] # 工作空间管理字段，与 package 字段不能同时存在
  members = []
  build-members = []
  test-members = []
  compile-option = &quot;&quot;
  link-option = &quot;&quot;
  target-dir = &quot;&quot;

[dependencies] # 源码依赖配置项
  aoo = { version = &quot;1.0.0&quot; } # 导入中心仓依赖
  boo = &quot;1.1.0&quot;  # 导入中心仓依赖
  coo = { git = &quot;xxx&quot;，branch = &quot;dev&quot; , version = &quot;1.0.0&quot;} # 导入 `git` 依赖，`version`字段可缺省
  doo = { path = &quot;./pro1&quot; ,version = &quot;1.0.0&quot;} # 导入源码依赖，`version`字段可缺省

[test-dependencies] # 测试阶段的依赖配置项

[ffi.c] # 导入 `c` 库依赖
  clib1.path = &quot;xxx&quot;

[profile] # 命令剖面配置项
  build = {}
  test = {}
  customized-option = {}

[target.x86_64-unknown-linux-gnu] # 后端和平台隔离配置项
  compile-option = &quot;value1&quot; # 额外编译命令选项，适用于特定 target 的编译流程和指定该 target 作为交叉编译目标平台的编译流程，非必须
  link-option = &quot;value2&quot; # 链接器透传选项，适用于特定 target 的编译流程和指定该 target 作为交叉编译目标平台的编译流程，非必须

[target.x86_64-w64-mingw32.dependencies] # 适用于对应 target 的源码依赖配置项，非必须

[target.x86_64-w64-mingw32.test-dependencies] # 适用于对应 target 的测试阶段依赖配置项，非必须

[target.cjvm.bin-dependencies] # 仓颉二进制库依赖，适用于特定 target 的编译流程和指定该 target 作为交叉编译目标平台的编译流程，非必须
  path-option = [&quot;./test/pro0&quot;, &quot;./test/pro1&quot;]
[target.cjvm.bin-dependencies.package-option]
  &quot;pro0.xoo&quot; = &quot;./test/pro0/pro0.xoo.cjo&quot;
  &quot;pro0.yoo&quot; = &quot;./test/pro0/pro0.yoo.cjo&quot;
  &quot;pro1.zoo&quot; = &quot;./test/pro1/pro1.zoo.cjo&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="条件编译-1"><a class="header" href="#条件编译-1">条件编译</a></h1>
<p>开发者可以通过预定义或自定义的条件完成条件编译；仓颉目前支持导入和声明的条件编译。</p>
<h2 id="导入和声明的条件编译"><a class="header" href="#导入和声明的条件编译">导入和声明的条件编译</a></h2>
<p>仓颉支持使用内置编译标记 <code>@When</code> 来完成条件编译，编译条件使用 <code>[]</code> 括起来，<code>[]</code> 内支持输入一组或多组编译条件。<code>@When</code> 可以作用于导入节点和除 <code>package</code> 外的声明节点。</p>
<h3 id="使用方法"><a class="header" href="#使用方法">使用方法</a></h3>
<p>以内置 os 编译条件为例，其使用方法如下：</p>
<!-- run -->
<pre><code class="language-cangjie">@When[os == &quot;Linux&quot;]
class mc{}

main(): Int64 {
    var a = mc()
    return 0
}
</code></pre>
<p>在上面代码中，开发者在 <code>Linux</code> 系统中可以正确编译执行；在 <code>非 Linux</code> 系统中，则会遇到找不到 <code>mc</code> 类定义的编译错误。</p>
<p>值得注意的是：</p>
<ul>
<li>
<p>仓颉不支持编译条件嵌套，以下写法均不允许：</p>
<pre><code class="language-cangjie">@When[os == &quot;Windows&quot;]
@When[os == &quot;Linux&quot;]    // Error, illegal nested when conditional compilation
import std.ast.*
@When[os == &quot;Windows&quot;]
@When[os == &quot;Linux&quot;]    // Error, illegal nested when conditional compilation
func A(){}
</code></pre>
</li>
<li>
<p><code>@When[...]</code> 作为内置编译标记，在导入前处理，由宏展开生成的代码中含有 <code>@When[...]</code> 会编译报错，如：</p>
<pre><code class="language-cangjie">@M0                     // macro which returns the input
@When[os == &quot;Linux&quot;]    // Error, unexpected when conditional compilation directive
func A(){}
</code></pre>
</li>
</ul>
<h2 id="内置编译条件变量"><a class="header" href="#内置编译条件变量">内置编译条件变量</a></h2>
<p>仓颉提供了五个内置条件变量: <code>os</code>、 <code>backend</code>、 <code>cjc_version</code>、 <code>debug</code> 和 <code>test</code>。</p>
<h3 id="os"><a class="header" href="#os">os</a></h3>
<p>os 表示目标平台的操作系统。<code>os</code> 支持 <code>==</code> 和 <code>!=</code> 两种操作符。支持的操作系统有：<code>Windows</code>、<code>Linux</code>、<code>macOS</code>、<code>HarmonyOS</code>。</p>
<p>使用方式如下：</p>
<!-- run -->
<pre><code class="language-cangjie">@When[os == &quot;Linux&quot;]
func foo() {
    print(&quot;Linux, &quot;)
}
@When[os == &quot;Windows&quot;]
func foo() {
    print(&quot;Windows, &quot;)
}
@When[os != &quot;Windows&quot;]
func fee() {
    println(&quot;NOT Windows&quot;)
}
@When[os != &quot;Linux&quot;]
func fee() {
    println(&quot;NOT Linux&quot;)
}
main() {
    foo()
    fee()
}
</code></pre>
<p>如果在 <code>Windows</code> 环境下编译执行，会得到 <code>Windows, NOT Linux</code> 的信息；如果是在 <code>Linux</code> 环境下，则会得到 <code>Linux, NOT Windows</code> 的信息。</p>
<h3 id="backend"><a class="header" href="#backend">backend</a></h3>
<p><code>backend</code> 是仓颉内置的条件。仓颉是多后端语言，支持多种后端条件编译。<code>backend</code> 条件支持 <code>==</code> 和 <code>!=</code> 两种操作符。</p>
<p>支持的后端有：<code>cjnative</code>、<code>cjnative-x86</code>、<code>cjnative-x86_64</code>、<code>cjnative-arm</code>、<code>cjnative-aarch64</code>、<code>cjvm</code>、<code>cjvm-x86</code>、<code>cjvm-x86_64</code>、<code>cjvm-arm</code>、<code>cjvm-aarch64</code>。</p>
<p>当用户使用的条件为 <code>cjnative</code>/<code>cjvm</code> 时，arch 信息将会按编译器执行时环境信息自动补全。</p>
<p>使用方式如下：</p>
<!-- run -->
<pre><code class="language-cangjie">@When[backend == &quot;cjnative&quot;]
func foo() {
    print(&quot;cjnative backend, &quot;)
}
@When[backend == &quot;cjvm&quot;]
func foo() {
    print(&quot;cjvm backend, &quot;)
}
@When[backend != &quot;cjnative&quot;]
func fee() {
    println(&quot;NOT cjnative backend&quot;)
}
@When[backend != &quot;cjvm&quot;]
func fee() {
    println(&quot;NOT cjvm backend&quot;)
}
main() {
    foo()
    fee()
}
</code></pre>
<p>用 <code>cjnative</code> 后端的发布包编译执行，会得到 <code>cjnative backend, NOT cjvm backend</code> 的信息；用 <code>cjvm</code> 后端的发布包编译执行，则会得到 <code>cjvm backend, NOT cjnative backend</code> 的信息。</p>
<h3 id="cjc_version"><a class="header" href="#cjc_version">cjc_version</a></h3>
<p><code>cjc_version</code> 是仓颉内置的条件，开发者可以根据当前仓颉编译器的版本选择要编译的代码。<code>cjc_version</code> 条件支持 <code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code> 六种操作符，格式为 <code>xx.xx.xx</code> 支持每个 <code>xx</code> 支持 1-2 位数字，计算规则为补位 (补齐 2 位) 比较，例如：<code>0.18.8 &lt; 0.18.11</code>， <code>0.18.8 == 0.18.08</code>。</p>
<p>使用方式如下：</p>
<!-- run -->
<pre><code class="language-cangjie">@When[cjc_version == &quot;0.18.6&quot;]
func foo() {
    println(&quot;cjc_version equals 0.18.6&quot;)
}
@When[cjc_version != &quot;0.18.6&quot;]
func foo() {
    println(&quot;cjc_version is NOT equal to 0.18.6&quot;)
}
@When[cjc_version &gt; &quot;0.18.6&quot;]
func fnn() {
    println(&quot;cjc_version is greater than 0.18.6&quot;)
}
@When[cjc_version &lt;= &quot;0.18.6&quot;]
func fnn() {
    println(&quot;cjc_version is less than or equal to 0.18.6&quot;)
}
@When[cjc_version &lt; &quot;0.18.6&quot;]
func fee() {
    println(&quot;cjc_version is less than 0.18.6&quot;)
}
@When[cjc_version &gt;= &quot;0.18.6&quot;]
func fee() {
    println(&quot;cjc_version is greater than or equal to 0.18.6&quot;)
}
main() {
    foo()
    fnn()
    fee()
}
</code></pre>
<p>根据 <code>cjc</code> 的版本，上面代码的执行输出结果会有不同。</p>
<h3 id="debug"><a class="header" href="#debug">debug</a></h3>
<p><code>debug</code> 表示当前是否启用了调试模式即开启 <code>-g</code> 编译选项, 可以用于在编译代码时进行调试和发布版本之间的切换。<code>debug</code> 条件仅支持逻辑非运算符（<code>!</code>）。</p>
<p>使用方式如下：</p>
<!-- run -->
<pre><code class="language-cangjie">@When[debug]
func foo() {
    println(&quot;debug&quot;)
}
@When[!debug]
func foo() {
    println(&quot;NOT debug&quot;)
}
main() {
    foo()
}
</code></pre>
<p>启用 <code>-g</code> 编译执行会得到 <code>cjc debug</code> 的信息，如果没有启用 <code>-g</code> 编译执行会得到 <code>NOT debug</code> 的信息。</p>
<h3 id="test"><a class="header" href="#test">test</a></h3>
<p><code>test</code> 表示当前是否启用了单元测试选项 <code>--test</code>。<code>test</code> 条件仅支持逻辑非运算符（<code>!</code>）。可以用于区分测试代码与普通代码。
使用方式如下：</p>
<!-- run -->
<pre><code class="language-cangjie">@When[test]
@Test
class Tests {
    @TestCase
    public func case1(): Unit {
        @Expect(&quot;run&quot;, foo())
    }
}

func foo() {
    &quot;run&quot;
}

@When[!test]
main () {
    println(foo())
}
</code></pre>
<p>使用 <code>--test</code> 编译执行得到的测试结果，不使用 <code>--test</code> 也可正常完成编译运行得到 <code>run</code> 的信息。</p>
<h2 id="自定义编译条件变量"><a class="header" href="#自定义编译条件变量">自定义编译条件变量</a></h2>
<p>仓颉允许开发者自定义编译条件变量和取值，自定义的条件变量必须是一个合法的标识符且不允许和内置条件变量同名，其值是一个字符串字面量。自定义条件支持 <code>==</code> 和 <code>!=</code> 两种运算符。和内置条件变量不同点在于自定义的条件需要开发者在编译时通过 <code>--cfg</code> 编译选项或者在配置文件 <code>cfg.toml</code> 中定义。</p>
<h3 id="配置自定义条件变量"><a class="header" href="#配置自定义条件变量">配置自定义条件变量</a></h3>
<p>配置自定义条件变量的方式有两种：在编译选项中直接配置键值对或在配置文件配置键值对。</p>
<p>用户可以使用 <code>--cfg &lt;value&gt;</code> 以键值对的形式向编译器传递自定义编译条件变量或者指定配置文件 <code>cfg.toml</code> 的搜索路径。</p>
<ul>
<li>
<p>选项值需要使用双引号括起来</p>
</li>
<li>
<p>若选项值中包含 <code>=</code> 则会按照键值对的形式直接进行配置（若路径中包含 <code>=</code> 则需要通过 <code>\</code> 转义），多个键值对可以使用逗号 <code>,</code> 分隔。如：</p>
<pre><code class="language-shell">$ cjc --cfg &quot;feature = lion, platform = dsp&quot; source.cj
</code></pre>
</li>
<li>
<p>允许多次使用 <code>--cfg</code> 编译选项配置进行配置, 如：</p>
<pre><code class="language-shell">$ cjc --cfg &quot;feature = lion&quot; --cfg &quot;platform = dsp&quot; source.cj
</code></pre>
</li>
<li>
<p>不允许多次定义同一个条件变量, 如：</p>
<pre><code class="language-shell">$ cjc --cfg &quot;feature = lion&quot; --cfg &quot;feature = meta&quot; source.cj
</code></pre>
<pre><code class="language-shell">$ cjc --cfg &quot;feature = lion, feature = meta&quot; source.cj
</code></pre>
<p>上述两条编译指令都会报错。</p>
</li>
<li>
<p>若选项值中不包含 <code>=</code> 或 存在通过 <code>\</code> 转义的 <code>=</code> 则将选项值作为配置文件 <code>cfg.toml</code> 的搜索路径传递给编译器，如：</p>
<pre><code class="language-shell">$ cjc --cfg &quot;./cfg&quot; source.cj
</code></pre>
<p>若 <code>./cfg</code> 目录下存在 <code>cfg.toml</code> 则在编译时，编译器会将 <code>./cfg/cfg.toml</code> 中配置的自定义编译条件传递给编译器。<code>cfg.toml</code> 文件中应采用键值对的方式配置自定义条件变量，每个键值对独占一行, 健名是一个合法的标识符, 键值是一个双引号括起来的字符串。如：</p>
<pre><code class="language-toml">feature = &quot;lion&quot;
platform = &quot;dsp&quot;
</code></pre>
</li>
<li>
<p>多次使用 <code>--cfg</code> 配置 <code>cfg.toml</code> 文件的搜索路径时，按照传入的顺序依次搜索<code>cfg.toml</code> 文件，若在所有传入的搜索路径下都没有找到 <code>cfg.toml</code> 文件，则在默认路径下搜索配置文件 <code>cfg.toml</code>。</p>
</li>
<li>
<p>多次使用 <code>--cfg</code> 编译选项进行配置时，若某次以键值对的形式直接进行配置，则会忽略配置文件 <code>cfg.toml</code> 中的配置。</p>
</li>
<li>
<p>若没有使用 <code>--cfg</code> 编译选项，编译器会在默认路径（通过<code>--package</code> 或 <code>-p</code> 指定的 <code>package</code> 目录或 <code>cjc</code> 执行目录）下搜索配置文件 <code>cfg.toml</code>。</p>
</li>
</ul>
<h2 id="多条件编译"><a class="header" href="#多条件编译">多条件编译</a></h2>
<p>仓颉条件编译允许开发者自由组合多个条件编译选项。支持逻辑运算符组合多个条件，支持括号运算符明确优先级。</p>
<p>使用方式如下：</p>
<pre><code class="language-cangjie">//source.cj
@When[(test || feature == &quot;lion&quot;) &amp;&amp; !debug]
func fee() {
    println(&quot;feature lion&quot;)
}
main() {
    fee()
}
</code></pre>
<p>使用如下编译命令编译运行上段代码，</p>
<pre><code class="language-shell">$ cjc --cfg=&quot;feature=lion&quot; source.cj -o runner.out
</code></pre>
<p>会得到输出结果如下：</p>
<pre><code class="language-text">platform lion
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cjc-编译选项"><a class="header" href="#cjc-编译选项"><code>cjc</code> 编译选项</a></h1>
<p>本章会介绍一些常用的 <code>cjc</code> 编译选项。若某一选项同时适用于 <code>cjc-frontend</code>，则该选项会有 <sup>[frontend]</sup> 上标；若该选项在 <code>cjc-frontend</code> 下行为与 <code>cjc</code> 不同，选项会有额外说明。</p>
<ul>
<li>
<p>两个横杠开头的选项为长选项，如 <code>--xxxx</code>。
对于长选项，如果其后有参数，选项和参数之间既可以用空格隔开，也可以用等号连接，如 <code>--xxxx &lt;value&gt;</code> 与 <code>--xxxx=&lt;value&gt;</code> 等价。</p>
</li>
<li>
<p>一个横杠开头的选项为短选项，如 <code>-x</code>。
对于短选项，如果其后有参数，选项和参数之间可以用空格隔开，也可以不隔开，如 <code>-x &lt;value&gt;</code> 与 <code>-x&lt;value&gt;</code> 等价。</p>
</li>
</ul>
<h2 id="基本选项"><a class="header" href="#基本选项">基本选项</a></h2>
<h3 id="--output-typeexestaticlibdylib-frontend"><a class="header" href="#--output-typeexestaticlibdylib-frontend"><code>--output-type=[exe|staticlib|dylib]</code> <sup>[frontend]</sup></a></h3>
<p>指定输出文件的类型，<code>exe</code> 模式下会生成可执行文件，<code>staticlib</code> 模式下会生成静态库文件（ <code>.a</code> 文件），<code>dylib</code> 模式下会生成动态库文件（Linux 平台为 <code>.so</code> 文件、Windows 平台为 <code>.dll</code> 文件，macOS 平台为 <code>.dylib</code> 文件）。
<code>cjc</code> 默认为 <code>exe</code> 模式。</p>
<p>我们除了可以将 <code>.cj</code> 文件编译成一个可执行文件以外，也可以将其编译成一个静态或者是动态的链接库，
例如使用</p>
<pre><code class="language-shell">$ cjc tool.cj --output-type=dylib
</code></pre>
<p>可以将 <code>tool.cj</code> 编译成一个动态链接库，在 Linux 平台 <code>cjc</code> 会生成一个名为 <code>libtool.so</code> 的动态链接库文件。</p>
<p><sup>[frontend]</sup> 在 <code>cjc-frontend</code> 中，编译流程仅进行至 <code>LLVM IR</code>，因此输出总是 <code>.bc</code> 文件，但是不同的 <code>--output-type</code> 类型仍会影响前端编译的策略。</p>
<h3 id="--package--p-frontend"><a class="header" href="#--package--p-frontend"><code>--package</code>, <code>-p</code> <sup>[frontend]</sup></a></h3>
<p>编译包，使用此选项时需要指定一个目录作为输入，目录中的源码文件需要属于同一个包。</p>
<p>假如我们有文件 <code>log/printer.cj</code>：</p>
<pre><code class="language-cangjie">package log

public func printLog(message: String) {
    println(&quot;[Log]: ${message}&quot;)
}
</code></pre>
<p>与文件 <code>main.cj</code>:</p>
<pre><code class="language-cangjie">import log.*

main() {
    printLog(&quot;Everything is great&quot;)
}
</code></pre>
<p>我们可以使用</p>
<pre><code class="language-shell">$ cjc -p log --output-type=staticlib
</code></pre>
<p>来编译 <code>log</code> 包，<code>cjc</code> 会在当前目录下生成一个 <code>liblog.a</code> 文件。
然后我们可以使用 <code>liblog.a</code> 文件来编译 <code>main.cj</code> ，编译命令如下：</p>
<pre><code class="language-shell">$ cjc main.cj liblog.a
</code></pre>
<p><code>cjc</code> 会将 <code>main.cj</code> 与 <code>liblog.a</code> 一同编译成一个可执行文件 <code>main</code> 。</p>
<h3 id="--module-name-value-frontend"><a class="header" href="#--module-name-value-frontend"><code>--module-name &lt;value&gt;</code> <sup>[frontend]</sup></a></h3>
<p>指定要编译的模块的名字。</p>
<p>假如我们有文件 <code>MyModule/src/log/printer.cj</code>：</p>
<pre><code class="language-cangjie">package log

public func printLog(message: String) {
    println(&quot;[Log]: ${message}&quot;)
}
</code></pre>
<p>与文件 <code>main.cj</code>:</p>
<pre><code class="language-cangjie">import MyModule.log.*

main() {
    printLog(&quot;Everything is great&quot;)
}
</code></pre>
<p>我们可以使用</p>
<pre><code class="language-shell">$ cjc -p MyModule/src/log --module-name MyModule --output-type=staticlib -o MyModule/liblog.a
</code></pre>
<p>来编译 <code>log</code> 包并指定其模块名为 <code>MyModule</code>，<code>cjc</code> 会在 <code>MyModule</code> 目录下生成一个 <code>MyModule/liblog.a</code> 文件。
然后我们可以使用 <code>liblog.a</code> 文件来编译导入了 <code>log</code> 包的 <code>main.cj</code> ，编译命令如下：</p>
<pre><code class="language-shell">$ cjc main.cj MyModule/liblog.a
</code></pre>
<p><code>cjc</code> 会将 <code>main.cj</code> 与 <code>liblog.a</code> 一同编译成一个可执行文件 <code>main</code> 。</p>
<h3 id="--output-value--o-value--ovalue-frontend"><a class="header" href="#--output-value--o-value--ovalue-frontend"><code>--output &lt;value&gt;</code>, <code>-o &lt;value&gt;</code>, <code>-o&lt;value&gt;</code> <sup>[frontend]</sup></a></h3>
<p>指定输出文件的路径，编译器的输出将被写入指定的文件。</p>
<p>例如以下命令会将输出的可执行文件名字指定为 <code>a.out</code> 。</p>
<pre><code class="language-shell">cjc main.cj -o a.out
</code></pre>
<h3 id="--library-value--l-value--lvalue"><a class="header" href="#--library-value--l-value--lvalue"><code>--library &lt;value&gt;</code>, <code>-l &lt;value&gt;</code>, <code>-l&lt;value&gt;</code></a></h3>
<p>指定要链接的库文件。</p>
<p>给定的库文件会被直接传给链接器，此编译选项一般需要和 <code>--library-path &lt;value&gt;</code> 配合使用。</p>
<p>文件名的格式应为 <code>lib[arg].[extension]</code>。当我们需要链接库 <code>a</code> 时，我们可以使用选项 <code>-l a</code>，库文件搜索目录下的 <code>liba.a</code>、 <code>liba.so</code> （或链接 Windows 目标程序时会搜索 <code>liba.dll</code>) 等文件会被链接器搜索到并根据需要被链接至最终输出中。</p>
<h3 id="--library-path-value--l-value--lvalue"><a class="header" href="#--library-path-value--l-value--lvalue"><code>--library-path &lt;value&gt;</code>, <code>-L &lt;value&gt;</code>, <code>-L&lt;value&gt;</code></a></h3>
<p>指定要链接的库文件所在的目录。</p>
<p>使用 <code>--library &lt;value&gt;</code> 选项时，一般也需要使用此选项来指定要链接的库文件所在的目录。</p>
<p><code>--library-path &lt;value&gt;</code> 指定的路径会被加入链接器的库文件搜索路径。另外环境变量 <code>LIBRARY_PATH</code> 中指定的路径也会被加入链接器的库文件搜索路径中，通过 <code>--library-path</code> 指定的路径会比 <code>LIBRARY_PATH</code> 中的路径拥有更高的优先级。</p>
<p>假如我们有从以下 c 语言源文件通过 c 语言编译器编译得到的动态库文件 <code>libcProg.so</code>，</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void printHello() {
    printf(&quot;Hello World\n&quot;);
}
</code></pre>
<p>与仓颉文件 <code>main.cj</code>：</p>
<pre><code class="language-cangjie">foreign func printHello(): Unit

main(): Int64 {
  unsafe {
    printHello()
  }
  return 0
}
</code></pre>
<p>我们可以使用</p>
<pre><code class="language-shell">cjc main.cj -L . -l cProg
</code></pre>
<p>来编译 <code>main.cj</code> 并指定要链接的 cProg 库，这里 <code>cjc</code> 会输出一个可执行文件 <code>main</code> 。
执行 <code>main</code> 会有如下输出：</p>
<pre><code class="language-shell">$ LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH ./main
Hello World
</code></pre>
<p><strong>值得注意的是</strong>，由于使用了动态库文件，这里需要将库文件所在目录加入 <code>$LD_LIBRARY_PATH</code> 以保证 <code>main</code> 可以在执行时进行动态链接。</p>
<h3 id="-g-frontend"><a class="header" href="#-g-frontend"><code>-g</code> <sup>[frontend]</sup></a></h3>
<p>生成带有调试信息的可执行文件或者是库文件。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p><code>-g</code> 只能配合 <code>-O0</code> 使用，如果使用更高的优化级别可能会导致调试功能出现异常。</p>
</blockquote>
<h3 id="--trimpath-value-frontend"><a class="header" href="#--trimpath-value-frontend"><code>--trimpath &lt;value&gt;</code> <sup>[frontend]</sup></a></h3>
<p>移除调试信息中源文件路径信息的前缀。</p>
<p>编译仓颉代码时 <code>cjc</code> 会保存源文件（ <code>.cj</code> 文件）的绝对路径信息以在运行时提供调试与异常信息。
使用此选项可以将指定的路径前缀从源文件路径信息中移除，<code>cjc</code> 的输出文件中的源文件路径信息不会包含用户指定的部分。
可以多次使用 <code>--trimpath</code> 指定多个不同的路径前缀；对于每个源文件路径，编译器会将第一个匹配到的前缀从路径中移除。</p>
<h3 id="--coverage-frontend"><a class="header" href="#--coverage-frontend"><code>--coverage</code> <sup>[frontend]</sup></a></h3>
<p>生成支持统计代码覆盖率的可执行程序。编译器会为每一个编译单元都生成一个后缀名为 <code>gcno</code> 的代码信息文件。在执行程序后，每一个编译单元都会得到一个后缀名为 <code>gcda</code> 的执行统计文件。根据这两个文件，配合使用 <code>cjcov</code> 工具可以生成本次执行下的代码覆盖率报表。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p><code>--coverage</code> 只能配合 <code>-O0</code> 使用，如果使用更高的优化级别，编译器将告警并强制使用 <code>-O0</code>。<code>--coverage</code> 用于编译生成可执行程序，如果用于生成静态库或者动态库，那么在最终使用该库时可能出现链接错误。</p>
</blockquote>
<h3 id="--int-overflowthrowingwrappingsaturating-frontend"><a class="header" href="#--int-overflowthrowingwrappingsaturating-frontend"><code>--int-overflow=[throwing|wrapping|saturating]</code> <sup>[frontend]</sup></a></h3>
<p>指定固定精度整数运算的溢出策略，默认为 <code>throwing</code>。</p>
<ul>
<li><code>throwing</code> 策略下整数运算溢出时会抛出异常</li>
<li><code>wrapping</code> 策略下整数运算溢出时会回转至对应固定精度整数的另外一端</li>
<li><code>saturating</code> 策略下整数运算溢出时会选择对应固定精度的极值作为结果</li>
</ul>
<h3 id="--diagnostic-formatdefaultnocolorjson-frontend"><a class="header" href="#--diagnostic-formatdefaultnocolorjson-frontend"><code>--diagnostic-format=[default|noColor|json]</code> <sup>[frontend]</sup></a></h3>
<blockquote>
<p><strong>注意：</strong></p>
<p>Windows 版本暂不支持输出带颜色渲染的错误信息。</p>
</blockquote>
<p>指定错误信息的输出格式，默认为 <code>default</code> 。</p>
<ul>
<li><code>default</code> 错误信息默认格式输出（带颜色）</li>
<li><code>noColor</code> 错误信息默认格式输出（无颜色）</li>
<li><code>json</code> 错误信息<code>json</code>格式输出</li>
</ul>
<h3 id="--verbose--v-frontend"><a class="header" href="#--verbose--v-frontend"><code>--verbose</code>, <code>-V</code> <sup>[frontend]</sup></a></h3>
<p><code>cjc</code> 会打印出编译器版本信息，工具链依赖的相关信息以及编译过程中执行的命令。</p>
<h3 id="--help--h-frontend"><a class="header" href="#--help--h-frontend"><code>--help</code>, <code>-h</code> <sup>[frontend]</sup></a></h3>
<p>打印可用的编译选项。</p>
<p>使用此选项时编译器仅会打印编译选项相关信息，不会对任何输入文件进行编译。</p>
<h3 id="--version--v-frontend"><a class="header" href="#--version--v-frontend"><code>--version</code>, <code>-v</code> <sup>[frontend]</sup></a></h3>
<p>打印编译器版本信息。</p>
<p>使用此选项时编译器仅会打印版本信息，不会对任何输入文件进行编译。</p>
<h3 id="--save-temps-value"><a class="header" href="#--save-temps-value"><code>--save-temps &lt;value&gt;</code></a></h3>
<p>保留编译过程中生成的中间文件并保存至 <code>&lt;value&gt;</code> 路径下。</p>
<p>编译器会保留编译过程中生成的 <code>.bc</code>, <code>.o</code> 等中间文件。</p>
<h3 id="--import-path-value-frontend"><a class="header" href="#--import-path-value-frontend"><code>--import-path &lt;value&gt;</code> <sup>[frontend]</sup></a></h3>
<p>指定导入模块的 AST 文件的搜索路径。</p>
<p>假如我们已经有以下目录结构，<code>libs/myModule</code> 目录中包含 <code>myModule</code> 模块的库文件和 <code>log</code> 包的 AST 导出文件，</p>
<pre><code class="language-text">.
├── libs
|   └── myModule
|       ├── log.cjo
|       └── libmyModule.a
└── main.cj
</code></pre>
<p>且我们有代码如下的 <code>main.cj</code> 文件，</p>
<pre><code class="language-cangjie">import myModule.log.printLog

main() {
    printLog(&quot;Everything is great&quot;)
}
</code></pre>
<p>我们可以通过使用 <code>--import-path ./libs</code> 来将 <code>./libs</code> 加入导入模块的 AST 文件搜索路径，<code>cjc</code> 会使用 <code>./libs/myModule/log.cjo</code> 文件来对 <code>main.cj</code> 文件进行语义检查与编译。</p>
<p><code>--import-path</code> 提供与 <code>CANGJIE_PATH</code> 环境变量相同的功能，但通过 <code>--import-path</code> 设置的路径拥有更高的优先级。</p>
<h3 id="--scan-dependency-frontend"><a class="header" href="#--scan-dependency-frontend"><code>--scan-dependency</code> <sup>[frontend]</sup></a></h3>
<p>通过 <code>--scan-dependency</code> 指令可以获得指定包源码或者一个包的 <code>cjo</code> 文件对于其他包的直接依赖以及其他信息，以 <code>json</code> 格式输出。</p>
<pre><code class="language-cangjie">// this file is placed under directory pkgA
macro package pkgA
import pkgB.*
import std.io.*
import pkgB.subB.*
</code></pre>
<pre><code class="language-shell">cjc --scan-dependency --package pkgA
</code></pre>
<p>或</p>
<pre><code class="language-shell">cjc --scan-dependency pkgA.cjo
</code></pre>
<pre><code class="language-json">{
  &quot;package&quot;: &quot;pkgA&quot;,
  &quot;isMacro&quot;: true,
  &quot;dependencies&quot;: [
    {
      &quot;package&quot;: &quot;pkgB&quot;,
      &quot;isStd&quot;: false,
      &quot;imports&quot;: [
        {
          &quot;file&quot;: &quot;pkgA/pkgA.cj&quot;,
          &quot;begin&quot;: {
            &quot;line&quot;: 2,
            &quot;column&quot;: 1
          },
          &quot;end&quot;: {
            &quot;line&quot;: 2,
            &quot;column&quot;: 14
          }
        }
      ]
    },
    {
      &quot;package&quot;: &quot;pkgB.subB&quot;,
      &quot;isStd&quot;: false,
      &quot;imports&quot;: [
        {
          &quot;file&quot;: &quot;pkgA/pkgA.cj&quot;,
          &quot;begin&quot;: {
            &quot;line&quot;: 4,
            &quot;column&quot;: 1
          },
          &quot;end&quot;: {
            &quot;line&quot;: 4,
            &quot;column&quot;: 19
          }
        }
      ]
    },
    {
      &quot;package&quot;: &quot;std.io&quot;,
      &quot;isStd&quot;: true,
      &quot;imports&quot;: [
        {
          &quot;file&quot;: &quot;pkgA/pkgA.cj&quot;,
          &quot;begin&quot;: {
            &quot;line&quot;: 3,
            &quot;column&quot;: 1
          },
          &quot;end&quot;: {
            &quot;line&quot;: 3,
            &quot;column&quot;: 16
          }
        }
      ]
    }
  ]
}
</code></pre>
<h3 id="--warn-off--woff-value-frontend"><a class="header" href="#--warn-off--woff-value-frontend"><code>--warn-off</code>, <code>-Woff &lt;value&gt;</code> <sup>[frontend]</sup></a></h3>
<p>关闭编译期出现的全部或部分警告。</p>
<p><code>&lt;value&gt;</code> 可以为 <code>all</code> 或者一个设定好的警告组别。当参数为 <code>all</code> 时，对于编译过程中生成的所有警告，编译器都不会打印；当参数为其他设定好的组别时，编译器将不会打印编译过程中生成的该组别警告。</p>
<p>在打印每个警告时，会有一行 <code>#note</code> 提示该警告属于什么组别并如何关闭它，我们可以通过 <code>--help</code> 打印所有可用的编译选项参数，来查阅具体的组别名称。</p>
<h3 id="--warn-on--won-value-frontend"><a class="header" href="#--warn-on--won-value-frontend"><code>--warn-on</code>, <code>-Won &lt;value&gt;</code> <sup>[frontend]</sup></a></h3>
<p>开启编译期出现的全部或部分警告。</p>
<p><code>--warn-on</code> 的 <code>&lt;value&gt;</code> 与 <code>--warn-off</code> 的 <code>&lt;value&gt;</code> 取值范围相同，<code>--warn-on</code> 通常与 <code>--warn-off</code> 组合使用；比如，我们可以通过设定 <code>-Woff all -Won &lt;value&gt;</code> 来仅允许组别为 <code>&lt;value&gt;</code> 的警告被打印。</p>
<p><strong>特别要注意的是</strong>，<code>--warn-on</code> 与 <code>--warn-off</code> 在使用上顺序敏感；针对同一组别，后设定的选项会覆盖之前选项的设定，比如，调换上例中两个编译选项的位置，使其变为 <code>-Won &lt;value&gt; -Woff all</code>，其效果将变为关闭所有警告。</p>
<h3 id="--error-count-limit-value-frontend"><a class="header" href="#--error-count-limit-value-frontend"><code>--error-count-limit &lt;value&gt;</code> <sup>[frontend]</sup></a></h3>
<p>限制编译器打印错误个数的上限。</p>
<p>参数 <code>&lt;value&gt;</code> 可以为 <code>all</code> 或一个非负整数。当参数为 <code>all</code> 时，编译器会打印编译过程中生成的所有错误；当参数为非负整数 <code>N</code> 时，编译器最多会打印 <code>N</code> 个错误。此选项默认值为 8。</p>
<h3 id="--output-dir-value-frontend"><a class="header" href="#--output-dir-value-frontend"><code>--output-dir &lt;value&gt;</code> <sup>[frontend]</sup></a></h3>
<p>控制编译器生成的中间文件与最终文件的保存目录。</p>
<p>控制编译器生成的中间文件的保存目录，例如 <code>.cjo</code> 文件。当指定 <code>--output-dir &lt;path1&gt;</code> 时也指定了 <code>--output &lt;path2&gt;</code>，则中间文件会被保存至 <code>&lt;path1&gt;</code>，最终输出会被保存至 <code>&lt;path1&gt;/&lt;path2&gt;</code> 。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>同时指定此选项与 <code>--output</code> 选项时，<code>--output</code> 选项的参数必须是一个相对路径。</p>
</blockquote>
<h3 id="--static-std"><a class="header" href="#--static-std"><code>--static-std</code></a></h3>
<p>静态链接仓颉库的 std 模块。</p>
<p>此选项仅在编译动态链接库或可执行文件时生效。<code>cjc</code> 默认静态链接仓颉库的 std 模块。</p>
<h3 id="--dy-std"><a class="header" href="#--dy-std"><code>--dy-std</code></a></h3>
<p>动态链接仓颉库的 std 模块。</p>
<p>此选项仅在编译动态链接库或可执行文件时生效。</p>
<p><strong>值得注意的是：</strong></p>
<ol>
<li><code>--static-std</code> 和 <code>--dy-std</code> 选项一起叠加使用，仅最后的那个选项生效；</li>
<li><code>--dy-std</code> 与 <code>--static-libs</code>选项不可一起使用，否则会报错。</li>
</ol>
<h3 id="--static-libs"><a class="header" href="#--static-libs"><code>--static-libs</code></a></h3>
<p>静态链接仓颉库非 std 的其他模块。</p>
<p>此选项仅在编译动态链接库或可执行文件时生效。<code>cjc</code> 默认静态链接仓颉库的非 std 的其他模块。</p>
<h3 id="--dy-libs"><a class="header" href="#--dy-libs"><code>--dy-libs</code></a></h3>
<p>动态链接仓颉库非 std 的其他模块。</p>
<p>此选项仅在编译动态链接库或可执行文件时生效。</p>
<p><strong>值得注意的是：</strong></p>
<ol>
<li><code>--static-libs</code> 和 <code>--dy-libs</code> 选项一起叠加使用，仅最后的那个选项生效；</li>
<li><code>--static-std</code> 与 <code>--dy-libs</code> 选项不可一起使用，否则会报错；</li>
<li><code>--dy-std</code> 单独使用时，会默认生效 <code>--dy-libs</code> 选项，并有相关告警信息提示；</li>
<li><code>--dy-libs</code> 单独使用时，会默认生效 <code>--dy-std</code> 选项，并有相关告警信息提示。</li>
</ol>
<h3 id="--stack-trace-formatdefaultsimpleall"><a class="header" href="#--stack-trace-formatdefaultsimpleall"><code>--stack-trace-format=[default|simple|all]</code></a></h3>
<p>指定异常调用栈打印格式，用来控制异常抛出时的栈帧信息显示，默认为 <code>default</code> 格式。</p>
<p>异常调用栈的格式说明如下：</p>
<ul>
<li><code>default</code> 格式：<code>省略泛型参数的函数名 (文件名:行号)</code></li>
<li><code>simple</code> 格式： <code>文件名:行号</code></li>
<li><code>all</code> 格式：<code>完整的函数名 (文件名:行号)</code></li>
</ul>
<h3 id="--ltofullthin"><a class="header" href="#--ltofullthin"><code>--lto=[full|thin]</code></a></h3>
<p>使能且指定 <code>LTO</code> （<code>Link Time Optimization</code> 链接时优化）优化编译模式。</p>
<p><strong>值得注意的是：</strong></p>
<ol>
<li>支持编译可执行文件和 <code>LTO</code> 模式下的静态库（<code>.bc</code> 文件），不支持编译生成动态库，即如果在 <code>LTO</code> 模式下指定 <code>--output-type=dylib</code> 则会编译报错；</li>
<li><code>Windows</code> 以及 <code>macOS</code> 平台不支持该功能；</li>
<li>当使能且指定 <code>LTO</code> （<code>Link Time Optimization</code> 链接时优化）优化编译模式时，不允许同时使用如下优化编译选项：<code>-Os</code>、<code>-Oz</code>。</li>
</ol>
<p><code>LTO</code> 优化支持两种编译模式：</p>
<ul>
<li>
<p><code>--lto=full</code>：<code>full LTO</code> 将所有编译模块合并到一起，在全局上进行优化，这种方式可以获得最大的优化潜力，同时也需要更长的编译时间。</p>
</li>
<li>
<p><code>--lto=thin</code>：相比于 <code>full LTO</code>，<code>thin LTO</code> 在多模块上使用并行优化，同时默认支持链接时增量编译，编译时间比 <code>full LTO</code> 短，因为失去了更多的全局信息，所以优化效果不如 <code>full LTO</code>。</p>
<ul>
<li>通常情况下优化效果对比：<code>full LTO</code> <strong>&gt;</strong> <code>thin LTO</code> <strong>&gt;</strong> 常规静态链接编译。</li>
<li>通常情况下编译时间对比：<code>full LTO</code> <strong>&gt;</strong> <code>thin LTO</code> <strong>&gt;</strong> 常规静态链接编译。</li>
</ul>
</li>
</ul>
<p><code>LTO</code> 优化使用场景：</p>
<ol>
<li>
<p>使用以下命令编译可执行文件</p>
<pre><code class="language-shell">$ cjc test.cj --lto=full
or
$ cjc test.cj --lto=thin
</code></pre>
</li>
<li>
<p>使用以下命令编译 <code>LTO</code> 模式下需要的静态库（<code>.bc</code> 文件），并且使用该库文件参与可执行文件编译</p>
<pre><code class="language-shell"># 生成的静态库为 .bc 文件
$ cjc pkg.cj --lto=full --output-type=staticlib -o libpkg.bc
# .bc 文件和源文件一起输入给仓颉编译器编译可执行文件
$ cjc test.cj libpkg.bc --lto=full
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p><code>LTO</code> 模式下的静态库（<code>.bc</code> 文件）输入的时候需要将该文件的路径输入仓颉编译器。</p>
</blockquote>
</li>
<li>
<p>在 <code>LTO</code> 模式下，静态链接标准库（<code>--static-std</code> &amp; <code>-static-libs</code>）时，标准库的代码也会参与 <code>LTO</code> 优化，并静态链接到可执行文件；动态链接标准库（<code>--dy-std</code> &amp; <code>-dy-libs</code>）时，在 <code>LTO</code> 模式下依旧使用标准库中的动态库参与链接。</p>
<pre><code class="language-shell"># 静态链接，标准库代码也参与 LTO 优化
$ cjc test.cj --lto=full --static-std
# 动态链接，依旧使用动态库参与链接，标准库代码不会参与 LTO 优化
$ cjc test.cj --lto=full --dy-std
</code></pre>
</li>
</ol>
<h3 id="--pgo-instr-gen"><a class="header" href="#--pgo-instr-gen"><code>--pgo-instr-gen</code></a></h3>
<p>使能插桩编译，生成携带插桩信息的可执行程序。</p>
<p>编译 macOS 目标时暂不支持使用该功能。</p>
<p><code>PGO</code> （全称<code>Profile-Guided Optimization</code>）是一种常用编译优化技术，通过使用运行时 profiling 信息进一步提升程序性能。<code>Instrumentation-based PGO</code> 是使用插桩信息的一种 <code>PGO</code> 优化手段，它通常包含三个步骤：</p>
<ol>
<li>编译器对源码插桩编译，生成插桩后的可执行程序（instrumented program）；</li>
<li>运行插桩后的可执行程序，生成配置文件；</li>
<li>编译器使用配置文件，再次对源码进行编译。</li>
</ol>
<pre><code class="language-shell"># 生成支持源码执行信息统计（携带插桩信息）的可执行程序 test
$ cjc test.cj --pgo-instr-gen -o test
# 运行可执行程序 test 结束后，生成 test.profraw 配置文件
$ LLVM_PROFILE_FILE=&quot;test.profraw&quot; ./test
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p>运行程序时使用环境变量 <code>LLVM_PROFILE_FILE=&quot;test%c.profraw&quot;</code> 可开启连续模式，即在程序崩溃或被信号杀死的情况下也能生成配置文件，可使用 <code>llvm-profdata</code> 工具对其进行查看分析。但是，目前 <code>PGO</code> 不支持连续模式下进行后续的优化步骤。</p>
</blockquote>
<h3 id="--pgo-instr-useprofdata"><a class="header" href="#--pgo-instr-useprofdata"><code>--pgo-instr-use=&lt;.profdata&gt;</code></a></h3>
<p>使用指定 <code>profdata</code> 配置文件指导编译并生成优化后的可执行程序。</p>
<p>编译 macOS 目标时暂不支持使用该功能。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p><code>--pgo-instr-use</code> 编译选项仅支持格式为 <code>profdata</code> 的配置文件。可使用 <code>llvm-profdata</code> 工具可将 <code>profraw</code> 配置文件转换为 <code>profdata</code> 配置文件。</p>
</blockquote>
<pre><code class="language-shell"># 将 `profraw` 文件转换为 `profdata` 文件。
$ LD_LIBRARY_PATH=$CANGJIE_HOME/third_party/llvm/lib:$LD_LIBRARY_PATH $CANGJIE_HOME/third_party/llvm/bin/llvm-profdata merge test.profraw -o test.profdata
# 使用指定 `test.profdata` 配置文件指导编译并生成优化后的可执行程序 `testOptimized`
$ cjc test.cj --pgo-instr-use=test.profdata -o testOptimized
</code></pre>
<h3 id="--target-value-frontend"><a class="header" href="#--target-value-frontend"><code>--target &lt;value&gt;</code> <sup>[frontend]</sup></a></h3>
<p>指定编译的目标平台的 triple。</p>
<p>参数 <code>&lt;value&gt;</code> 一般为符合以下格式的字符串：<code>&lt;arch&gt;(-&lt;vendor&gt;)-&lt;os&gt;(-&lt;env&gt;)</code>。其中：</p>
<ul>
<li><code>&lt;arch&gt;</code> 表示目标平台的系统架构，例如 <code>aarch64</code>，<code>x86_64</code> 等；</li>
<li><code>&lt;vendor&gt;</code> 表示开发目标平台的厂商，常见的例如 <code>pc</code>，<code>apple</code> 等，在没有明确平台厂商或厂商不重要的情况下也经常写作 <code>unknown</code> 或直接省略；</li>
<li><code>&lt;os&gt;</code> 表示目标平台的操作系统，例如 <code>linux</code>，<code>win32</code> 等；</li>
<li><code>&lt;env&gt;</code> 表示目标平台的 ABI 或标准规范，用于更细粒度地区分同一操作系统的不同运行环境，例如 <code>gnu</code>，<code>musl</code> 等。在操作系统不需要根据 <code>&lt;env&gt;</code> 进行更细地区分的时候，此项也可以省略。</li>
</ul>
<p>目前，<code>cjc</code> 已支持交叉编译的本地平台和目标平台如下表所示：</p>
<div class="table-wrapper"><table><thead><tr><th>本地平台 (host)</th><th>目标平台 (target)</th></tr></thead><tbody>
<tr><td>x86_64-linux-gnu</td><td>aarch64-hm-gnu</td></tr>
</tbody></table>
</div>
<p>在使用 <code>--target</code> 指定目标平台进行交叉编译之前，请准备好对应目标平台的交叉编译工具链，以及可以在本地平台上运行的、向该目标平台编译的对应 Cangjie SDK 版本。</p>
<h3 id="--target-cpu-value"><a class="header" href="#--target-cpu-value"><code>--target-cpu &lt;value&gt;</code></a></h3>
<blockquote>
<p><strong>注意：</strong></p>
<p>该选项为实验性功能，使用该功能生成的二进制有可能会存在潜在的运行时问题，请注意使用该选项的风险。此选项必须配合 <code>--experimental</code> 选项一同使用。</p>
</blockquote>
<p>指定编译目标的 CPU 类型。</p>
<p>指定编译目标的 CPU 类型时，编译器在生成二进制时会尝试使用该 CPU 类型特有的扩展指令集，并尝试应用适用于该 CPU 类型的优化。为某个特定 CPU 类型生成的二进制通常会失去可移植性，该二进制可能无法在其他（拥有相同架构指令集的）CPU 上运行。</p>
<p>该选项支持以下经过测试的 CPU 类型：</p>
<p><strong>x86-64 架构：</strong></p>
<ul>
<li>generic</li>
</ul>
<p><strong>aarch64 架构：</strong></p>
<ul>
<li>generic</li>
<li>tsv110</li>
</ul>
<p><code>generic</code> 为通用 CPU 类型，指定 <code>generic</code> 时编译器会生成适用于该架构的通用指令，这样生成的二进制在操作系统和二进制本身的动态依赖一致的前提下，可以在基于该架构的各种 CPU 上运行，无关于具体的 CPU 类型。<code>--target-cpu</code> 选项的默认值为 <code>generic</code>。</p>
<p>该选项还支持以下 CPU 类型，但以下 CPU 类型未经过测试验证，请注意使用以下 CPU 类型生成的二进制可能会存在运行时问题。</p>
<p><strong>x86-64 架构：</strong></p>
<ul>
<li>alderlake</li>
<li>amdfam10</li>
<li>athlon</li>
<li>athlon-4</li>
<li>athlon-fx</li>
<li>athlon-mp</li>
<li>athlon-tbird</li>
<li>athlon-xp</li>
<li>athlon64</li>
<li>athlon64-sse3</li>
<li>atom</li>
<li>barcelona</li>
<li>bdver1</li>
<li>bdver2</li>
<li>bdver3</li>
<li>bdver4</li>
<li>bonnell</li>
<li>broadwell</li>
<li>btver1</li>
<li>btver2</li>
<li>c3</li>
<li>c3-2</li>
<li>cannonlake</li>
<li>cascadelake</li>
<li>cooperlake</li>
<li>core-avx-i</li>
<li>core-avx2</li>
<li>core2</li>
<li>corei7</li>
<li>corei7-avx</li>
<li>geode</li>
<li>goldmont</li>
<li>goldmont-plus</li>
<li>haswell</li>
<li>i386</li>
<li>i486</li>
<li>i586</li>
<li>i686</li>
<li>icelake-client</li>
<li>icelake-server</li>
<li>ivybridge</li>
<li>k6</li>
<li>k6-2</li>
<li>k6-3</li>
<li>k8</li>
<li>k8-sse3</li>
<li>knl</li>
<li>knm</li>
<li>lakemont</li>
<li>nehalem</li>
<li>nocona</li>
<li>opteron</li>
<li>opteron-sse3</li>
<li>penryn</li>
<li>pentium</li>
<li>pentium-m</li>
<li>pentium-mmx</li>
<li>pentium2</li>
<li>pentium3</li>
<li>pentium3m</li>
<li>pentium4</li>
<li>pentium4m</li>
<li>pentiumpro</li>
<li>prescott</li>
<li>rocketlake</li>
<li>sandybridge</li>
<li>sapphirerapids</li>
<li>silvermont</li>
<li>skx</li>
<li>skylake</li>
<li>skylake-avx512</li>
<li>slm</li>
<li>tigerlake</li>
<li>tremont</li>
<li>westmere</li>
<li>winchip-c6</li>
<li>winchip2</li>
<li>x86-64</li>
<li>x86-64-v2</li>
<li>x86-64-v3</li>
<li>x86-64-v4</li>
<li>yonah</li>
<li>znver1</li>
<li>znver2</li>
<li>znver3</li>
</ul>
<p><strong>aarch64 架构：</strong></p>
<ul>
<li>a64fx</li>
<li>ampere1</li>
<li>apple-a10</li>
<li>apple-a11</li>
<li>apple-a12</li>
<li>apple-a13</li>
<li>apple-a14</li>
<li>apple-a7</li>
<li>apple-a8</li>
<li>apple-a9</li>
<li>apple-latest</li>
<li>apple-m1</li>
<li>apple-s4</li>
<li>apple-s5</li>
<li>carmel</li>
<li>cortex-a34</li>
<li>cortex-a35</li>
<li>cortex-a510</li>
<li>cortex-a53</li>
<li>cortex-a55</li>
<li>cortex-a57</li>
<li>cortex-a65</li>
<li>cortex-a65ae</li>
<li>cortex-a710</li>
<li>cortex-a72</li>
<li>cortex-a73</li>
<li>cortex-a75</li>
<li>cortex-a76</li>
<li>cortex-a76ae</li>
<li>cortex-a77</li>
<li>cortex-a78</li>
<li>cortex-a78c</li>
<li>cortex-r82</li>
<li>cortex-x1</li>
<li>cortex-x1c</li>
<li>cortex-x2</li>
<li>cyclone</li>
<li>exynos-m3</li>
<li>exynos-m4</li>
<li>exynos-m5</li>
<li>falkor</li>
<li>kryo</li>
<li>neoverse-512tvb</li>
<li>neoverse-e1</li>
<li>neoverse-n1</li>
<li>neoverse-n2</li>
<li>neoverse-v1</li>
<li>saphira</li>
<li>thunderx</li>
<li>thunderx2t99</li>
<li>thunderx3t110</li>
<li>thunderxt81</li>
<li>thunderxt83</li>
<li>thunderxt88</li>
</ul>
<p>除以上可选 CPU 类型，该选项可以使用 native 作为当前 CPU 类型，编译器会尝试识别当前机器的 CPU 类型并使用该 CPU 类型作为目标类型生成二进制。</p>
<h3 id="--toolchain-value--b-value--bvalue"><a class="header" href="#--toolchain-value--b-value--bvalue"><code>--toolchain &lt;value&gt;</code>, <code>-B &lt;value&gt;</code>, <code>-B&lt;value&gt;</code></a></h3>
<p>指定编译工具链中，二进制文件存放的路径。</p>
<p>二进制文件包括：编译器、链接器、工具链等提供的 C 运行时目标文件（例如 <code>crt0.o</code>、 <code>crti.o</code>等）。</p>
<p>我们在准备好编译工具链后，可以在将其存放在一个自定义路径，然后通过 <code>--toolchain &lt;value&gt;</code> 向编译器传入该路径，即可让编译器调用到该路径下的二进制文件进行交叉编译。</p>
<h3 id="--sysroot-value"><a class="header" href="#--sysroot-value"><code>--sysroot &lt;value&gt;</code></a></h3>
<p>指定编译工具链的根目录路径。</p>
<p>对于目录结构固定的交叉编译工具链，如果我们没有指定该目录以外的二进制和动态库、静态库文件路径的需求，可以直接使用 <code>--sysroot &lt;value&gt;</code> 向编译器传入工具链的根目录路径，编译器会根据目标平台种类分析对应的目录结构，自动搜索所需的二进制文件和动态库、静态库文件。使用该选项后，我们无需再指定 <code>--toolchain</code>、<code>--library-path</code> 参数。</p>
<p>假如我们向 <code>triple</code> 为 <code>arch-os-env</code> 的平台进行交叉编译，同时我们的交叉编译工具链有以下目录结构：</p>
<pre><code class="language-text">/usr/sdk/arch-os-env
├── bin
|   ├── arch-os-env-gcc (交叉编译器)
|   ├── arch-os-env-ld  (链接器)
|   └── ...
├── lib
|   ├── crt1.o          (C 运行时目标文件)
|   ├── crti.o
|   ├── crtn.o
|   ├── libc.so         (动态库)
|   ├── libm.so
|   └── ...
└── ...
</code></pre>
<p>我们有仓颉源文件 <code>hello.cj</code> ，那么我们可以使用以下命令，将 <code>hello.cj</code> 交叉编译至 <code>arch-os-env</code> 平台：</p>
<pre><code class="language-shell">cjc --target=arch-os-env --toolchain /usr/sdk/arch-os-env/bin --toolchain /usr/sdk/arch-os-env/lib --library-path /usr/sdk/arch-os-env/lib hello.cj -o hello
</code></pre>
<p>也可以使用简写的参数：</p>
<pre><code class="language-shell">cjc --target=arch-os-env -B/usr/sdk/arch-os-env/bin -B/usr/sdk/arch-os-env/lib -L/usr/sdk/arch-os-env/lib hello.cj -o hello
</code></pre>
<p>如果该工具链的目录符合惯例的目录结构，也可以无需使用 <code>--toolchain</code>、<code>--library-path</code> 参数，而使用以下的命令：</p>
<pre><code class="language-shell">cjc --target=arch-os-env --sysroot /usr/sdk/arch-os-env hello.cj -o hello
</code></pre>
<h3 id="--strip-all--s"><a class="header" href="#--strip-all--s"><code>--strip-all</code>, <code>-s</code></a></h3>
<p>编译可执行文件或动态库时，指定该选项以删除输出文件中的符号表。</p>
<h3 id="--discard-eh-frame"><a class="header" href="#--discard-eh-frame"><code>--discard-eh-frame</code></a></h3>
<p>编译可执行文件或动态库时，指定该选项可以删除 eh_frame 段以及 eh_frame_hdr 段中的部分信息（涉及到 crt 的相关信息不作处理），减少可执行文件或动态库的大小，但会影响调试信息。</p>
<p>编译 macOS 目标时暂不支持使用该功能。</p>
<h3 id="--link-options-value1"><a class="header" href="#--link-options-value1"><code>--link-options &lt;value&gt;</code><sup>1</sup></a></h3>
<p>指定链接器选项。</p>
<p><code>cjc</code> 会将该选项的参数透传给链接器。可用的参数会因（系统或指定的）链接器的不同而不同。可以多次使用 <code>--link-options</code> 指定多个链接器选项。</p>
<p><sup>1</sup> 上标表示链接器透传选项可能会因为链接器的不同而不同，具体支持的选项请查阅链接器文档。</p>
<h3 id="--disable-reflection"><a class="header" href="#--disable-reflection"><code>--disable-reflection</code></a></h3>
<p>关闭反射选项，即编译过程中不生成相关反射信息。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>交叉编译至 aarch64-linux-ohos 目标时，默认关闭反射信息，该选项不生效。</p>
</blockquote>
<h2 id="单元测试选项"><a class="header" href="#单元测试选项">单元测试选项</a></h2>
<h3 id="--test-frontend"><a class="header" href="#--test-frontend"><code>--test</code> <sup>[frontend]</sup></a></h3>
<p><code>unittest</code> 测试框架提供的入口，由宏自动生成，当使用 <code>cjc --test</code> 选项编译时，程序入口不再是 <code>main</code>，而是 <code>test_entry</code>。unittest 测试框架的使用方法请参见 《仓颉语言库 API》文档。</p>
<p>对于 <code>pkgc</code> 目录下仓颉文件 <code>a.cj</code>:</p>
<!-- run -->
<pre><code class="language-cangjie">import std.unittest.*
import std.unittest.testmacro.*

@Test
public class TestA {
    @TestCase
    public func case1(): Unit {
        print(&quot;case1\n&quot;)
    }
}
</code></pre>
<p>我们可以在 <code>pkgc</code> 目录下使用：</p>
<pre><code class="language-shell">cjc a.cj --test
</code></pre>
<p>来编译 <code>a.cj</code> ，执行 <code>main</code> 会有如下输出：</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>不保证用例每次执行的用时都相同。</p>
</blockquote>
<pre><code class="language-cangjie">case1
--------------------------------------------------------------------------------------------------
TP: default, time elapsed: 29710 ns, Result:
    TCS: TestA, time elapsed: 26881 ns, RESULT:
    [ PASSED ] CASE: case1 (16747 ns)
Summary: TOTAL: 1
    PASSED: 1, SKIPPED: 0, ERROR: 0
    FAILED: 0
--------------------------------------------------------------------------------------------------
</code></pre>
<p>对于如下目录结构 :</p>
<pre><code class="language-text">application
├── src
├── pkgc
|   ├── a1.cj
|   └── a2.cj
└── a3.cj
</code></pre>
<p>我们可以在 <code>application</code>目录下使用 <code>-p</code> 编译选项配合编译整包：</p>
<pre><code class="language-shell">cjc pkgc --test -p
</code></pre>
<p>来编译整个 <code>pkgc</code> 包下的测试用例 <code>a1.cj</code> 和 <code>a2.cj</code>。</p>
<pre><code class="language-cangjie">/*a1.cj*/
package a

import std.unittest.*
import std.unittest.testmacro.*

@Test
public class TestA {
    @TestCase
    public func caseA(): Unit {
        print(&quot;case1\n&quot;)
    }
}
</code></pre>
<pre><code class="language-cangjie">/*a2.cj*/
package a

import std.unittest.*
import std.unittest.testmacro.*

@Test
public class TestB {
    @TestCase
    public func caseB(): Unit {
        throw IndexOutOfBoundsException()
    }
}
</code></pre>
<p>执行 <code>main</code> 会有如下输出（<strong>输出信息仅供参考</strong>）：</p>
<pre><code class="language-cangjie">case1
--------------------------------------------------------------------------------------------------
TP: a, time elapsed: 367800 ns, Result:
    TCS: TestA, time elapsed: 16802 ns, RESULT:
    [ PASSED ] CASE: caseA (14490 ns)
    TCS: TestB, time elapsed: 347754 ns, RESULT:
    [ ERROR  ] CASE: caseB (345453 ns)
    REASON: An exception has occurred:IndexOutOfBoundsException
        at std/core.Exception::init()(std/core/exception.cj:23)
        at std/core.IndexOutOfBoundsException::init()(std/core/index_out_of_bounds_exception.cj:9)
        at a.TestB::caseB()(/home/houle/cjtest/application/pkgc/a2.cj:7)
        at a.lambda.1()(/home/houle/cjtest/application/pkgc/a2.cj:7)
        at std/unittest.TestCases::execute()(std/unittest/test_case.cj:92)
        at std/unittest.UT::run(std/unittest::UTestRunner)(std/unittest/test_runner.cj:194)
        at std/unittest.UTestRunner::doRun()(std/unittest/test_runner.cj:78)
        at std/unittest.UT::run(std/unittest::UTestRunner)(std/unittest/test_runner.cj:200)
        at std/unittest.UTestRunner::doRun()(std/unittest/test_runner.cj:78)
        at std/unittest.UT::run(std/unittest::UTestRunner)(std/unittest/test_runner.cj:200)
        at std/unittest.UTestRunner::doRun()(std/unittest/test_runner.cj:75)
        at std/unittest.entryMain(std/unittest::TestPackage)(std/unittest/entry_main.cj:11)
Summary: TOTAL: 2
    PASSED: 1, SKIPPED: 0, ERROR: 1
    FAILED: 0
--------------------------------------------------------------------------------------------------
</code></pre>
<h3 id="--mock-onoffruntime-error-frontend"><a class="header" href="#--mock-onoffruntime-error-frontend"><code>--mock &lt;on|off|runtime-error&gt;</code> <sup>[frontend]</sup></a></h3>
<p>如果传递了 <code>on</code> ，则该包将使能 mock 编译，该选项允许在测试用例中 mock 该包中的类。<code>off</code> 是一种显式禁用 mock 的方法。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>在测试模式下（当使能 <code>--test</code> ）自动启用对此包的 mock 支持，不需要显式传递 <code>--mock</code> 选项。</p>
</blockquote>
<p><code>runtime-error</code> 仅在测试模式下可用（当使能 <code>--test</code> 时），它允许编译带有 mock 代码的包，但不在编译器中做任何 mock 相关的处理（这些处理可能会造成一些开销并影响测试的运行时性能）。这对于带有 mock 代码用例进行基准测试时可能是有用的。使用此编译选项时，避免编译带有 mock 代码的用例并运行测试，否则将抛出运行时异常。</p>
<h2 id="宏选项"><a class="header" href="#宏选项">宏选项</a></h2>
<p><code>cjc</code> 支持以下宏选项，关于宏的更多内容请参阅<a href="source_zh_cn/Appendix/./Chapter_15_Macro.html">“宏”</a>章节。</p>
<h3 id="--compile-macro-frontend"><a class="header" href="#--compile-macro-frontend"><code>--compile-macro</code> <sup>[frontend]</sup></a></h3>
<p>编译宏定义文件，生成默认的宏定义动态库文件。</p>
<h3 id="--debug-macro-frontend"><a class="header" href="#--debug-macro-frontend"><code>--debug-macro</code> <sup>[frontend]</sup></a></h3>
<p>生成宏展开后的仓颉代码文件。该选项可用于调试宏展开功能。</p>
<h3 id="--parallel-macro-expansion-frontend"><a class="header" href="#--parallel-macro-expansion-frontend"><code>--parallel-macro-expansion</code> <sup>[frontend]</sup></a></h3>
<p>开启宏展开并行。该选项可用于缩短宏展开编译时间。</p>
<h2 id="条件编译选项"><a class="header" href="#条件编译选项">条件编译选项</a></h2>
<p><code>cjc</code> 支持以下条件编译选项，关于条件编译的更多内容请参阅<a href="source_zh_cn/Appendix/../Compile-And-Build/conditional_compilation.html">“条件编译”</a>。</p>
<h3 id="--cfg-value-frontend"><a class="header" href="#--cfg-value-frontend"><code>--cfg &lt;value&gt;</code> <sup>[frontend]</sup></a></h3>
<p>指定自定义编译条件。</p>
<h2 id="并行编译选项"><a class="header" href="#并行编译选项">并行编译选项</a></h2>
<p><code>cjc</code> 支持以下并行编译选项以获得更高的编译效率。</p>
<h3 id="--jobs-value--j-value-frontend"><a class="header" href="#--jobs-value--j-value-frontend"><code>--jobs &lt;value&gt;</code>, <code>-j &lt;value&gt;</code> <sup>[frontend]</sup></a></h3>
<p>设置并行编译时所允许的最大并行数。其中 <code>value</code> 必须是一个合理的正整数，当 <code>value</code> 大于硬件支持最大并行能力时，编译器将会按基于硬件支持并行能力计算出的默认设置执行并行编译。</p>
<p>如果该编译选项未设置，编译器将会按基于硬件支持并行能力计算出的默认设置执行并行编译。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p><code>--jobs 1</code>表示完全使用串行方式进行编译。</p>
</blockquote>
<h3 id="--aggressive-parallel-compile---apc-frontend"><a class="header" href="#--aggressive-parallel-compile---apc-frontend"><code>--aggressive-parallel-compile</code>, <code>--apc</code> <sup>[frontend]</sup></a></h3>
<p>开启此选项后，编译器会采用更加激进的策略（可能会对优化造成影响）执行并行编译，以便获得更高的编译效率。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p><code>--aggressive-parallel-compile</code>选项在一些场景下会由编译器强制开启/关闭。</p>
</blockquote>
<p>在以下场景中<code>--aggressive-parallel-compile</code>选项将由编译器强制开启：</p>
<ul>
<li><code>-O0</code></li>
<li><code>-g</code></li>
</ul>
<p>在以下场景中<code>--aggressive-parallel-compile</code>选项将由编译器强制关闭：</p>
<ul>
<li><code>--fobf-string</code></li>
<li><code>--fobf-const</code></li>
<li><code>--fobf-layout</code></li>
<li><code>--fobf-cf-flatten</code></li>
<li><code>--fobf-cf-bogus</code></li>
<li><code>--lto</code></li>
<li><code>--coverage</code></li>
<li>编译 Windows 目标</li>
</ul>
<h2 id="优化选项"><a class="header" href="#优化选项">优化选项</a></h2>
<h3 id="--fchir-constant-propagation-frontend"><a class="header" href="#--fchir-constant-propagation-frontend"><code>--fchir-constant-propagation</code> <sup>[frontend]</sup></a></h3>
<p>开启 chir 常量传播优化。</p>
<h3 id="--fno-chir-constant-propagation-frontend"><a class="header" href="#--fno-chir-constant-propagation-frontend"><code>--fno-chir-constant-propagation</code> <sup>[frontend]</sup></a></h3>
<p>关闭 chir 常量传播优化。</p>
<h3 id="--fchir-function-inlining-frontend"><a class="header" href="#--fchir-function-inlining-frontend"><code>--fchir-function-inlining</code> <sup>[frontend]</sup></a></h3>
<p>开启 chir 函数内联优化。</p>
<h3 id="--fno-chir-function-inlining-frontend"><a class="header" href="#--fno-chir-function-inlining-frontend"><code>--fno-chir-function-inlining</code> <sup>[frontend]</sup></a></h3>
<p>关闭 chir 函数内联优化。</p>
<h3 id="--fchir-devirtualization-frontend"><a class="header" href="#--fchir-devirtualization-frontend"><code>--fchir-devirtualization</code> <sup>[frontend]</sup></a></h3>
<p>开启 chir 去虚函数调用优化。</p>
<h3 id="--fno-chir-devirtualization-frontend"><a class="header" href="#--fno-chir-devirtualization-frontend"><code>--fno-chir-devirtualization</code> <sup>[frontend]</sup></a></h3>
<p>关闭 chir 去虚函数调用优化。</p>
<h3 id="--fast-math-frontend"><a class="header" href="#--fast-math-frontend"><code>--fast-math</code> <sup>[frontend]</sup></a></h3>
<p>开启此选项后，编译器会对浮点数作一些激进且有可能损失精度的假设，以便优化浮点数运算。</p>
<h3 id="-on-frontend"><a class="header" href="#-on-frontend"><code>-O&lt;N&gt;</code> <sup>[frontend]</sup></a></h3>
<p>使用参数指定的代码优化级别。</p>
<p>指定越高的优化级别，编译器会越多地进行代码优化以生成更高效的程序，同时也可能会需要更长的编译时间。</p>
<p><code>cjc</code> 默认使用 O0 级别的代码优化。当前 <code>cjc</code> 支持如下优化级别：O0、O1、O2、Os、Oz。</p>
<p>当优化等级等于 2 时，<code>cjc</code> 除了进行对应的优化外，还会开启以下选项：</p>
<ul>
<li><code>--fchir-constant-propagation</code></li>
<li><code>--fchir-function-inlining</code></li>
<li><code>--fchir-devirtualization</code></li>
</ul>
<p>当优化等级等于 s 时， <code>cjc</code>除了进行 O2 级别优化外，将针对 code size 进行优化。</p>
<p>当优化等级等于 z 时， <code>cjc</code>除了进行 Os 级别优化外，还将进一步缩减 code size 大小。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>当优化等级等于 s 或 z 时，不允许同时使用链接时优化编译选项 <code>--lto=[full|thin]</code>。</p>
</blockquote>
<h3 id="-o-frontend"><a class="header" href="#-o-frontend"><code>-O</code> <sup>[frontend]</sup></a></h3>
<p>使用 O1 级别的代码优化，等价于 <code>-O1</code>。</p>
<h2 id="代码混淆选项"><a class="header" href="#代码混淆选项">代码混淆选项</a></h2>
<p><code>cjc</code> 支持代码混淆功能以提供对代码的额外安全保护，代码混淆功能默认不开启。</p>
<p><code>cjc</code> 支持以下代码混淆选项：</p>
<h3 id="--fobf-string"><a class="header" href="#--fobf-string"><code>--fobf-string</code></a></h3>
<p>开启字符串混淆。</p>
<p>混淆代码中出现的字符串常量，攻击者无法静态直接读取二进制程序中的字符串数据。</p>
<h3 id="--fno-obf-string"><a class="header" href="#--fno-obf-string"><code>--fno-obf-string</code></a></h3>
<p>关闭字符串混淆。</p>
<h3 id="--fobf-const"><a class="header" href="#--fobf-const"><code>--fobf-const</code></a></h3>
<p>开启常量混淆。</p>
<p>混淆代码中使用的数值常量，将的数值运算指令替换成等效的、更复杂的数值运算指令序列。</p>
<h3 id="--fno-obf-const"><a class="header" href="#--fno-obf-const"><code>--fno-obf-const</code></a></h3>
<p>关闭常量混淆。</p>
<h3 id="--fobf-layout"><a class="header" href="#--fobf-layout"><code>--fobf-layout</code></a></h3>
<p>开启外形混淆。</p>
<p>外形混淆功能会混淆代码中的符号（包括函数名和全局变量名）、路径名、代码行号和函数排布顺序。使用该编译选项后，<code>cjc</code> 会在当前目录生成符号映射输出文件 <code>*.obf.map</code>，如果配置了 <code>--obf-sym-output-mapping</code> 选项，则 <code>--obf-sym-output-mapping</code> 的参数值将作为 <code>cjc</code> 生成的符号映射输出文件名。符号映射输出文件中包含混淆前后符号的映射关系，使用符号映射输出文件我们可以解混淆被混淆过的符号。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>外形混淆功能和并行编译功能相互冲突，请勿同时开启。如果和并行编译同时开启，并行编译将失效。</p>
</blockquote>
<h3 id="--fno-obf-layout"><a class="header" href="#--fno-obf-layout"><code>--fno-obf-layout</code></a></h3>
<p>关闭外形混淆。</p>
<h3 id="--obf-sym-prefix-string"><a class="header" href="#--obf-sym-prefix-string"><code>--obf-sym-prefix &lt;string&gt;</code></a></h3>
<p>指定外形混淆功能在混淆符号时添加的前缀字符串。</p>
<p>设置该选项后，所有被混淆符号都会加上该前缀。在编译混淆多个仓颉包时可能出现符号冲突的问题，可以使用该选项给不同的包指定不同的前缀，避免符号冲突。</p>
<h3 id="--obf-sym-output-mapping-file"><a class="header" href="#--obf-sym-output-mapping-file"><code>--obf-sym-output-mapping &lt;file&gt;</code></a></h3>
<p>指定外形混淆的符号映射输出文件。</p>
<p>符号映射输出文件记录了符号的原始名称、混淆后的名称和所属文件路径。使用符号映射输出文件我们可以解混淆被混淆过的符号。</p>
<h3 id="--obf-sym-input-mapping-file"><a class="header" href="#--obf-sym-input-mapping-file"><code>--obf-sym-input-mapping &lt;file,...&gt;</code></a></h3>
<p>指定外形混淆的符号映射输入文件。</p>
<p>外形混淆功能会使用这些文件中的映射关系对符号进行混淆。因此在编译存在调用关系的仓颉包，请使用被调用包的符号映射输出文件作为调用包混淆时的 <code>--obf-sym-input-mapping</code> 选项的参数，以此保证同一个符号在调用包和被调用包两者混淆时混淆结果一致。</p>
<h3 id="--obf-apply-mapping-file-file"><a class="header" href="#--obf-apply-mapping-file-file"><code>--obf-apply-mapping-file &lt;file&gt;</code></a></h3>
<p>提供自定义的外形混淆符号映射关系文件，外形混淆功能将按照文件里的映射关系混淆符号。</p>
<p>文件格式如下：</p>
<pre><code class="language-markup">&lt;original_symbol_name&gt; &lt;new_symbol_name&gt;
</code></pre>
<p>其中 <code>original_symbol_name</code> 是混淆前的名称，<code>new_symbol_name</code> 是混淆后的名称。<code>original_symbol_name</code> 由多个 <code>field</code> 组成。<code>field</code> 表示字段名，可以是模块名、包名、类名、结构体名、枚举名、函数名或变量名。<code>field</code> 之间用分隔符 <code>'.'</code> 分隔。如果 <code>field</code> 是函数名，则需要将函数的参数类型用括号 <code>'()'</code> 修饰并附加在函数名后面。对于无参函数括号内的内容为空。如果 <code>field</code> 存在泛型参数，也需要用括号 <code>'&lt;&gt;'</code> 将具体的泛型参数附加在 <code>field</code> 后面。</p>
<p>外形混淆功能会将仓颉应用中的 <code>original_symbol_name</code> 替换为 <code>new_symbol_name</code>。对于不在该文件中的符号，外形混淆功能会正常使用随机名称进行替换。如果该文件中指定的映射关系和 <code>--obf-sym-input-mapping</code> 中的映射关系相冲突，编译器会抛出异常并停止编译。</p>
<h3 id="--fobf-export-symbols"><a class="header" href="#--fobf-export-symbols"><code>--fobf-export-symbols</code></a></h3>
<p>允许外形混淆功能混淆导出符号，该选项在开启外形混淆功能时默认开启。</p>
<p>开启该选项后，外形混淆功能会对导出符号进行混淆。</p>
<h3 id="--fno-obf-export-symbols"><a class="header" href="#--fno-obf-export-symbols"><code>--fno-obf-export-symbols</code></a></h3>
<p>禁止外形混淆功能混淆导出符号。</p>
<h3 id="--fobf-source-path"><a class="header" href="#--fobf-source-path"><code>--fobf-source-path</code></a></h3>
<p>允许外形混淆功能混淆符号的路径信息，该选项在开启外形混淆功能时默认开启。</p>
<p>开启该选项后，外形混淆功能会混淆异常堆栈信息中的路径信息，将路径名替换为字符串 <code>&quot;SOURCE&quot;</code>。</p>
<h3 id="--fno-obf-source-path"><a class="header" href="#--fno-obf-source-path"><code>--fno-obf-source-path</code></a></h3>
<p>禁止外形混淆功能混淆堆栈信息中的路径信息。</p>
<h3 id="--fobf-line-number"><a class="header" href="#--fobf-line-number"><code>--fobf-line-number</code></a></h3>
<p>允许外形混淆功能混淆堆栈信息中的行号信息，该选项在开启外形混淆功能时默认开启。</p>
<p>开启该选项后，外形混淆功能会混淆异常堆栈信息中的行号信息，将行号替换为 <code>0</code>。</p>
<h3 id="--fno-obf-line-number"><a class="header" href="#--fno-obf-line-number"><code>--fno-obf-line-number</code></a></h3>
<p>禁止外形混淆功能混淆堆栈信息中的行号信息。</p>
<h3 id="--fobf-cf-flatten"><a class="header" href="#--fobf-cf-flatten"><code>--fobf-cf-flatten</code></a></h3>
<p>开启控制流平坦化混淆。</p>
<p>混淆代码中既存的控制流，使其转移逻辑变得复杂。</p>
<h3 id="--fno-obf-cf-flatten"><a class="header" href="#--fno-obf-cf-flatten"><code>--fno-obf-cf-flatten</code></a></h3>
<p>关闭控制流平坦化混淆。</p>
<h3 id="--fobf-cf-bogus"><a class="header" href="#--fobf-cf-bogus"><code>--fobf-cf-bogus</code></a></h3>
<p>开启虚假控制流混淆。</p>
<p>在代码中插入虚假的控制流，使代码逻辑变得复杂。</p>
<h3 id="--fno-obf-cf-bogus"><a class="header" href="#--fno-obf-cf-bogus"><code>--fno-obf-cf-bogus</code></a></h3>
<p>关闭虚假控制流混淆。</p>
<h3 id="--fobf-all"><a class="header" href="#--fobf-all"><code>--fobf-all</code></a></h3>
<p>开启所有混淆功能。</p>
<p>指定该选项等同于同时指定以下选项：</p>
<ul>
<li><code>--fobf-string</code></li>
<li><code>--fobf-const</code></li>
<li><code>--fobf-layout</code></li>
<li><code>--fobf-cf-flatten</code></li>
<li><code>--fobf-cf-bogus</code></li>
</ul>
<h3 id="--obf-config-file"><a class="header" href="#--obf-config-file"><code>--obf-config &lt;file&gt;</code></a></h3>
<p>指定代码混淆配置文件路径。</p>
<p>在配置文件中我们可以禁止混淆工具对某些函数或者符号进行混淆。
配置文件的具体格式如下：</p>
<pre><code class="language-text">obf_func1 name1
obf_func2 name2
...
</code></pre>
<p>第一个参数 <code>obf_func</code> 是具体的混淆功能：</p>
<ul>
<li><code>obf-cf-bogus</code>：虚假控制流混淆</li>
<li><code>obf-cf-flatten</code>：控制流平坦化混淆</li>
<li><code>obf-const</code>：常数混淆</li>
<li><code>obf-layout</code>：外形混淆</li>
</ul>
<p>第二个参数 <code>name</code> 是需要被保留的对象，由多个 <code>field</code> 组成。<code>field</code> 表示字段名，可以是包名、类名、结构体名、枚举名、函数名或变量名。</p>
<p><code>field</code> 之间用分隔符 <code>'.'</code> 分隔。如果 <code>field</code> 是函数名，则需要将函数的参数类型用括号 <code>'()'</code> 修饰并附加在函数名后面。对于无参函数括号内的内容为空。</p>
<p>比如，假设在包 <code>packA</code> 中有以下代码：</p>
<pre><code>package packA
class MyClassA {
    func funcA(a: String, b: Int64): String {
        return a
    }
}
</code></pre>
<p>如果要禁止控制流平坦化功能混淆 <code>funcA</code>，用户可以编写如下规则：</p>
<pre><code>obf-cf-flatten packA.MyClassA.funcA(std.core.String, Int64)
</code></pre>
<p>用户也可以使用通配符编写更加灵活的规则，达到一条规则保留多个对象的目的。目前支持的通配符包含以下 3 类：</p>
<p>混淆功能通配符：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">混淆功能通配符</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>?</code></td><td style="text-align: left">匹配名称中的单个字符</td></tr>
<tr><td style="text-align: left"><code>*</code></td><td style="text-align: left">匹配名称中的任意数量字符</td></tr>
</tbody></table>
</div>
<p>字段名通配符：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">字段名通配符</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>?</code></td><td style="text-align: left">匹配字段名中单个非分隔符 <code>'.'</code> 的字符</td></tr>
<tr><td style="text-align: left"><code>*</code></td><td style="text-align: left">匹配字段名中的不包含分隔符 <code>'.'</code> 和参数的任意数量字符</td></tr>
<tr><td style="text-align: left"><code>**</code></td><td style="text-align: left">匹配字段名中的任意数量字符，包括字段之间的分隔符 <code>'.'</code> 和参数。<code>'**'</code> 只有在单独作为一个 <code>field</code> 时才生效，否则会被当作 <code>'*'</code> 处理</td></tr>
</tbody></table>
</div>
<p>函数的参数类型通配符：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">参数类型通配符</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>...</code></td><td style="text-align: left">匹配任意数量的参数</td></tr>
<tr><td style="text-align: left"><code>***</code></td><td style="text-align: left">匹配一个任意类型的参数</td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>说明：</strong></p>
<p>参数类型也由字段名组成，因此也可以使用字段名通配符对单个参数类型进行匹配。</p>
</blockquote>
<p>以下是通配符使用示例：</p>
<p>例子 1：</p>
<pre><code class="language-markup">obf-cf-flatten pro?.myfunc()
</code></pre>
<p>该规则表示禁止 <code>obf-cf-flatten</code> 功能混淆函数 <code>pro?.myfunc()</code>，<code>pro?.myfunc()</code> 可以匹配 <code>pro0.myfunc()</code>，但不能匹配 <code>pro00.myfunc()</code>。</p>
<p>例子 2：</p>
<pre><code class="language-markup">* pro0.**
</code></pre>
<p>该规则表示禁止任何混淆功能混淆包 <code>pro0</code> 下的任何函数和变量。</p>
<p>例子 3：</p>
<pre><code class="language-markup">* pro*.myfunc(...)
</code></pre>
<p>该规则表示禁止任何混淆功能混淆函数 <code>pro*.myfunc(...)</code>，<code>pro*.myfunc(...)</code> 可以匹配以 <code>pro</code> 开头的任意单层包内的 <code>myfunc</code> 函数，且可以为任意参数。</p>
<p>如果需要匹配多层包名，比如 <code>pro0.mypack.myfunc()</code>，请使用 <code>pro*.**.myfunc(...)</code>。请注意 <code>'**'</code> 只有单独作为字段名时才生效，因此 <code>pro**.myfunc(...)</code> 和 <code>pro*.myfunc(...)</code> 等价，无法匹配多层包名。如果要匹配以 <code>pro</code> 开头的所有包下的所有 <code>myfunc</code> 函数（包括类中名为 <code>myfunc</code> 的函数），请使用 <code>pro*.**.myfunc(...)</code>。</p>
<p>例子 4：</p>
<pre><code class="language-markup">obf-cf-* pro0.MyClassA.myfunc(**.MyClassB, ***, ...)
</code></pre>
<p>该规则表示禁止 <code>obf-cf-*</code> 功能混淆函数 <code>pro0.MyClassA.myfunc(**.MyClassB, ***, ...)</code>，其中 <code>obf-cf-*</code> 会匹配 <code>obf-cf-bogus</code> 和 <code>obf-cf-flatten</code> 两种混淆功能，<code>pro0.MyClassA.myfunc(**.MyClassB, ***, ...)</code> 会匹配函数 <code>pro0.MyClassA.myfunc</code>，且函数的第一个参数可以是任意包下的 <code>MyClassB</code> 类型，第二个参数可以是任意类型，后面可以接零至多个任意参数。</p>
<h3 id="--obf-level-value"><a class="header" href="#--obf-level-value"><code>--obf-level &lt;value&gt;</code></a></h3>
<p>指定混淆功能强度级别。</p>
<p>可指定 1-9 强度级别。默认强度级别为 5。级别数字越大，强度则越高，该选项会影响输出文件的大小以及执行开销。</p>
<h3 id="--obf-seed-value"><a class="header" href="#--obf-seed-value"><code>--obf-seed &lt;value&gt;</code></a></h3>
<p>指定混淆算法的随机数种子。</p>
<p>通过指定混淆算法的随机数种子，我们可以使同一份仓颉代码在不同构建时有不同的混淆结果。默认场景下，对于同一份仓颉代码，在每次混淆后都拥有相同的混淆结果。</p>
<h2 id="安全编译选项"><a class="header" href="#安全编译选项">安全编译选项</a></h2>
<blockquote>
<p><strong>注意：</strong></p>
<p>Windows 以及 macOS 版本暂不支持安全编译选项。</p>
</blockquote>
<p><code>cjc</code> 默认生成地址无关代码，在编译可执行文件时默认生成地址无关可执行文件。</p>
<p><code>cjc</code> 支持通过 <code>--link-options</code> 设置以下安全相关的链接器选项：</p>
<h3 id="--link-options--z-noexecstack1"><a class="header" href="#--link-options--z-noexecstack1"><code>--link-options &quot;-z noexecstack&quot;</code><sup>1</sup></a></h3>
<p>设置线程栈不可执行。</p>
<h3 id="--link-options--z-relro1"><a class="header" href="#--link-options--z-relro1"><code>--link-options &quot;-z relro&quot;</code><sup>1</sup></a></h3>
<p>设置 GOT 表重定位只读。</p>
<h3 id="--link-options--z-now1"><a class="header" href="#--link-options--z-now1"><code>--link-options &quot;-z now&quot;</code><sup>1</sup></a></h3>
<p>设置立即绑定。</p>
<h2 id="代码覆盖率插桩选项"><a class="header" href="#代码覆盖率插桩选项">代码覆盖率插桩选项</a></h2>
<blockquote>
<p><strong>注意：</strong></p>
<p>Windows 以及 macOS 版本暂不支持代码覆盖率插桩选项。</p>
</blockquote>
<p>仓颉支持对代码覆盖率插桩（SanitizerCoverage，以下简称 SanCov），提供与 <a href="https://clang.llvm.org/docs/SanitizerCoverage.html">LLVM 的 SanitizerCoverage</a> 一致的接口，编译器在函数级或 BasicBlock 级插入覆盖率反馈函数，用户只需要实现约定好的回调函数即可在运行过程中感知程序运行状态。</p>
<p>仓颉提供的 SanCov 功能以 package 为单位，即整个 package 只有全部插桩和全部不插桩两种情况。</p>
<h3 id="--sanitizer-coverage-level012"><a class="header" href="#--sanitizer-coverage-level012"><code>--sanitizer-coverage-level=0/1/2</code></a></h3>
<p>插桩等级：0 表示不插桩；1 表示函数级插桩，只在函数入口处插入回调函数；2 表示 BasicBlock 级插桩，在各个 BasicBlock 处插入回调函数。</p>
<p>如不指定，默认值为 2。</p>
<p>该编译选项只影响 <code>--sanitizer-coverage-trace-pc-guard</code>、<code>--sanitizer-coverage-inline-8bit-counters</code>、<code>--sanitizer-coverage-inline-bool-flag</code> 的插桩等级。</p>
<h3 id="--sanitizer-coverage-trace-pc-guard"><a class="header" href="#--sanitizer-coverage-trace-pc-guard"><code>--sanitizer-coverage-trace-pc-guard</code></a></h3>
<p>开启该选项，会在每个 Edge 插入函数调用 <code>__sanitizer_cov_trace_pc_guard(uint32_t *guard_variable)</code>，受 <code>sanitizer-coverage-level</code> 影响。</p>
<p><strong>值得注意的是</strong>，该功能存在与 gcc/llvm 实现不一致的地方：<strong>不会</strong>在 constructor 插入 <code>void __sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop)</code>，<strong>而是</strong>在 package 初始化阶段插入函数调用 <code>uint32_t *__cj_sancov_pc_guard_ctor(uint64_t edgeCount)</code>。</p>
<p><code>__cj_sancov_pc_guard_ctor</code> 回调函数需要开发者自行实现，开启 SanCov 的 package 会尽可能早地调用该回调函数，入参是该 Package 的 Edge 个数，返回值是通常是 calloc 创建的内存区域。</p>
<p>如果需要调用 <code>__sanitizer_cov_trace_pc_guard_init</code>，建议在 <code>__cj_sancov_pc_guard_ctor</code> 中调用，使用动态创建的缓冲区计算该函数的入参和返回值。</p>
<p>一个标准的<code>__cj_sancov_pc_guard_ctor</code>参考实现如下：</p>
<pre><code class="language-cpp">uint32_t *__cj_sancov_pc_guard_ctor(uint64_t edgeCount) {
    uint32_t *p = (uint32_t *) calloc(edgeCount, sizeof(uint32_t));
    __sanitizer_cov_trace_pc_guard_init(p, p + edgeCount);
    return p;
}
</code></pre>
<h3 id="--sanitizer-coverage-inline-8bit-counters"><a class="header" href="#--sanitizer-coverage-inline-8bit-counters"><code>--sanitizer-coverage-inline-8bit-counters</code></a></h3>
<p>开启该选项后，会在每个 Edge 插入一个累加器，每经历过一次，该累加器加一，受 <code>sanitizer-coverage-level</code> 影响。</p>
<p><strong>值得注意的是</strong>，该功能存在与 gcc/llvm 实现不一致的地方：<strong>不会</strong>在 constructor 插入 <code>void __sanitizer_cov_8bit_counters_init(char *start, char *stop)</code>，<strong>而是</strong>在 package 初始化阶段插入函数调用 <code>uint8_t *__cj_sancov_8bit_counters_ctor(uint64_t edgeCount)</code>。</p>
<p><code>__cj_sancov_pc_guard_ctor</code> 回调函数需要开发者自行实现，开启 SanCov 的 package 会尽可能早地调用该回调函数，入参是该 Package 的 Edge 个数，返回值是通常是 calloc 创建的内存区域。</p>
<p>如果需要调用 <code>__sanitizer_cov_8bit_counters_init</code>，建议在 <code>__cj_sancov_8bit_counters_ctor</code> 中调用，使用动态创建的缓冲区计算该函数的入参和返回值。</p>
<p>一个标准的<code>__cj_sancov_8bit_counters_ctor</code>参考实现如下：</p>
<pre><code class="language-cpp">uint8_t *__cj_sancov_8bit_counters_ctor(uint64_t edgeCount) {
    uint8_t *p = (uint8_t *) calloc(edgeCount, sizeof(uint8_t));
    __sanitizer_cov_8bit_counters_init(p, p + edgeCount);
    return p;
}
</code></pre>
<h3 id="--sanitizer-coverage-inline-bool-flag"><a class="header" href="#--sanitizer-coverage-inline-bool-flag"><code>--sanitizer-coverage-inline-bool-flag</code></a></h3>
<p>开启该选项后，会在每个 Edge 插入布尔值，经历过的 Edge 对应的布尔值会被设置为 True，受 <code>sanitizer-coverage-level</code> 影响。</p>
<p><strong>值得注意的是</strong>，该功能存在与 gcc/llvm 实现不一致的地方：<strong>不会</strong>在 constructor 插入 <code>void __sanitizer_cov_bool_flag_init(bool *start, bool *stop)</code>，<strong>而是</strong>在 package 初始化阶段插入函数调用 <code>bool *__cj_sancov_bool_flag_ctor(uint64_t edgeCount)</code>。</p>
<p><code>__cj_sancov_bool_flag_ctor</code> 回调函数需要开发者自行实现，开启 SanCov 的 package 会尽可能早地调用该回调函数，入参是该 Package 的 Edge 个数，返回值是通常是 calloc 创建的内存区域。</p>
<p>如果需要调用 <code>__sanitizer_cov_bool_flag_init</code>，建议在 <code>__cj_sancov_bool_flag_ctor</code> 中调用，使用动态创建的缓冲区计算该函数的入参和返回值。</p>
<p>一个标准的<code>__cj_sancov_8bit_counters_ctor</code>参考实现如下：</p>
<pre><code class="language-cpp">bool *__cj_sancov_bool_flag_ctor(uint64_t edgeCount) {
    bool *p = (bool *) calloc(edgeCount, sizeof(bool));
    __sanitizer_cov_bool_flag_init(p, p + edgeCount);
    return p;
}
</code></pre>
<h3 id="--sanitizer-coverage-pc-table"><a class="header" href="#--sanitizer-coverage-pc-table"><code>--sanitizer-coverage-pc-table</code></a></h3>
<p>该编译选项用于提供插桩点和源码之间的对应关系，当前只提供精确到函数级的对应关系。需要与 <code>--sanitizer-coverage-trace-pc-guard</code>、<code>--sanitizer-coverage-inline-8bit-counters</code>、<code>--sanitizer-coverage-inline-bool-flag</code> 共用，至少需要开启其中一项，可以同时开启多项。</p>
<p><strong>值得注意的是</strong>，该功能存在与 gcc/llvm 实现不一致的地方：<strong>不会</strong>在 constructor 插入 <code>void __sanitizer_cov_pcs_init(const uintptr_t *pcs_beg, const uintptr_t *pcs_end);</code>，<strong>而是</strong>在 package 初始化阶段插入函数调用 <code>void __cj_sancov_pcs_init(int8_t *packageName, uint64_t n, int8_t **funcNameTable, int8_t **fileNameTable, uint64_t *lineNumberTable)</code>，各入参含义如下：</p>
<ul>
<li><code>int8_t *packageName</code>: 字符串，表示包名（插桩用 c 风格的 int8 数组作为入参来表达字符串，下同）。</li>
<li><code>uint64_t n</code>: 共有 n 个函数被插桩。</li>
<li><code>int8_t **funcNameTable</code>: 长度为 n 的字符串数组，第 i 个插桩点对应的函数名为 funcNameTable[i]。</li>
<li><code>int8_t **fileNameTable</code>: 长度为 n 的字符串数组，第 i 个插桩点对应的文件名为 fileNameTable[i]。</li>
<li><code>uint64_t *lineNumberTable</code>: 长度为 n 的 uint64 数组，第 i 个插桩点对应的行号为 lineNumberTable[i]。</li>
</ul>
<p>如果需要调用 <code>__sanitizer_cov_pcs_init</code>，需要自行完成仓颉 pc-table 到 C 语言 pc-table 的转化。</p>
<h3 id="--sanitizer-coverage-stack-depth"><a class="header" href="#--sanitizer-coverage-stack-depth"><code>--sanitizer-coverage-stack-depth</code></a></h3>
<p>开启该编译选项后，由于仓颉无法获取 SP 指针的值，只能在每个函数入口处插入调用 <code>__updateSancovStackDepth</code>，在 C 侧实现该函数即可获得 SP 指针。</p>
<p>一个标准的 <code>updateSancovStackDepth</code> 实现如下：</p>
<pre><code class="language-cpp">thread_local void* __sancov_lowest_stack;

void __updateSancovStackDepth()
{
    register void* sp = __builtin_frame_address(0);
    if (sp &lt; __sancov_lowest_stack) {
        __sancov_lowest_stack = sp;
    }
}
</code></pre>
<h3 id="--sanitizer-coverage-trace-compares"><a class="header" href="#--sanitizer-coverage-trace-compares"><code>--sanitizer-coverage-trace-compares</code></a></h3>
<p>开启该选项后，会在所有的 compare 指令和 match 指令调用前插入函数回调函数，具体列表如下，与 LLVM 系的 API 功能一致。参考 <a href="https://clang.llvm.org/docs/SanitizerCoverage.html#tracing-data-flow">Tracing data flow</a>。</p>
<pre><code class="language-cpp">void __sanitizer_cov_trace_cmp1(uint8_t Arg1, uint8_t Arg2);
void __sanitizer_cov_trace_const_cmp1(uint8_t Arg1, uint8_t Arg2);
void __sanitizer_cov_trace_cmp2(uint16_t Arg1, uint16_t Arg2);
void __sanitizer_cov_trace_const_cmp2(uint16_t Arg1, uint16_t Arg2);
void __sanitizer_cov_trace_cmp4(uint32_t Arg1, uint32_t Arg2);
void __sanitizer_cov_trace_const_cmp4(uint32_t Arg1, uint32_t Arg2);
void __sanitizer_cov_trace_cmp8(uint64_t Arg1, uint64_t Arg2);
void __sanitizer_cov_trace_const_cmp8(uint64_t Arg1, uint64_t Arg2);
void __sanitizer_cov_trace_switch(uint64_t Val, uint64_t *Cases);
</code></pre>
<h3 id="--sanitizer-coverage-trace-memcmp"><a class="header" href="#--sanitizer-coverage-trace-memcmp"><code>--sanitizer-coverage-trace-memcmp</code></a></h3>
<p>该编译选项用于在 String 、 Array 等比较中反馈前缀比较信息。开启该选项后，会对 String 和 Array 的比较函数前插入函数回调函数。具体对于以下对各 String 和 Array 的 API，分别插入对应桩函数：</p>
<ul>
<li>String==: __sanitizer_weak_hook_memcmp</li>
<li>String.startsWith: __sanitizer_weak_hook_memcmp</li>
<li>String.endsWith: __sanitizer_weak_hook_memcmp</li>
<li>String.indexOf: __sanitizer_weak_hook_strstr</li>
<li>String.replace: __sanitizer_weak_hook_strstr</li>
<li>String.contains: __sanitizer_weak_hook_strstr</li>
<li>CString==: __sanitizer_weak_hook_strcmp</li>
<li>CString.startswith: __sanitizer_weak_hook_memcmp</li>
<li>CString.endswith: __sanitizer_weak_hook_strncmp</li>
<li>CString.compare: __sanitizer_weak_hook_strcmp</li>
<li>CString.equalsLower: __sanitizer_weak_hook_strcasecmp</li>
<li>Array==: __sanitizer_weak_hook_memcmp</li>
<li>ArrayList==: __sanitizer_weak_hook_memcmp</li>
</ul>
<h2 id="cffi-内存安全检测"><a class="header" href="#cffi-内存安全检测">CFFI 内存安全检测</a></h2>
<blockquote>
<p><strong>注意：</strong></p>
<p>当前版本暂不支持本节介绍的 CFFI 内存安全检测。</p>
</blockquote>
<p><code>cjc</code> 支持 CFFI 内存安全检测功能以提供检测仓颉代码与 C 代码互操作过程中，可能出现的时间、空间内存安全问题。</p>
<p>例如：</p>
<ol>
<li>
<p>仓颉 unsafe 代码导致的空间安全问题：堆（ <code>acquireRawData</code> 接口）、栈、全局变量（ <code>inout</code> 语义）溢出，例如：</p>
<pre><code class="language-cangjie">unsafe {
    let array = Array&lt;UInt8&gt;(4, item: 0)
    let cp = acquireArrayRawData(array)
    cp.pointer.read(5)  // 仓颉堆溢出
}
</code></pre>
</li>
<li>
<p>仓颉 unsafe 代码导致的时间安全问题：释放后使用、返回后使用、双重释放，例如：</p>
<pre><code class="language-cangjie">unsafe {
    let array = Array&lt;UInt8&gt;(4, item: 0)
    let cp = acquireArrayRawData(array)
    releaseArrayRawData(cp)
    array = Array&lt;UInt8&gt;(1, item: 0)
    ...... // GC 回收第一个 array
    cp.pointer.read()  // 释放后使用
}
</code></pre>
</li>
</ol>
<p>使用限制：</p>
<ol>
<li>不支持仓颉宏选项；</li>
<li>在协程 A 调用 <code>releaseArrayRawData</code> 接口后，若协程 B 仍持有该段数据的引用时，协程 A 再访问该段数据会产生<strong>漏报</strong>；</li>
<li>仓颉内存释放后使用的场景中，若该片内存再次被分配且设置为可访问后，原来的野指针（产生释放后使用的指针）访问该片内存则会产生<strong>漏报</strong>；</li>
<li>仓颉检测内存泄露中，若 C 内存在仓颉类中初始化，但没有在仓颉 class 的 <code>~init()</code> 中释放的场景中，会产生<strong>漏报</strong>；</li>
<li>从仓颉堆内存回收到程序结束退出这一段时期程序产生的内存泄露会<strong>漏报</strong>。</li>
</ol>
<h3 id="--sanitizeaddress"><a class="header" href="#--sanitizeaddress"><code>--sanitize=address</code></a></h3>
<p>使能内存安全检测功能。</p>
<p>仓颉的内存安全检测功能是利用 Address Sanitizer 实现。支持仓颉作为主程序和 C 代码作为主程序。</p>
<p>用户使能该功能时，C 代码编译时建议使能 ASan 检测（通过 <code>-fsanitize=address</code> 开启）以获得更精准的检查。</p>
<p>该功能依赖 ASan 运行库，该包由仓颉或者用户系统提供，优先级如下：</p>
<ol>
<li>仓颉提供的 ASan 运行库 <code>$CANGJIE_HOME/lib/&lt;system&gt;_&lt;arch&gt;_llvm/libclang-rt_asan.a</code>；</li>
<li>用户通过 <code>-L</code> ，环境变量 <code>LIBRARY_PATH</code> 或 <code>--toolchain/-B</code> 指定的路径下搜索 ASan 运行库 <code>clang-rt.asan-&lt;arch&gt;.a</code>；</li>
<li>使用 gnu 提供的独立 ASan 运行库 <code>libasan.so</code>。</li>
</ol>
<p><strong>值得注意的是：</strong></p>
<ol>
<li>当用户使用 C 代码作为主程序时，还需要链接 <code>$CANGJIE_HOME/lib/&lt;system&gt;_&lt;arch&gt;_llvm/cjasan_options.o</code> 以防止内存泄露<strong>漏报</strong>的问题；</li>
<li>当用户使用 ASan 的动态链接库时，需要使用 <code>LD_PRELOAD</code> 或 <code>verify_asan_link_order=0</code> 保证 ASan 运行库是第一个被加载的，以保证 ASan 的检测正确地运行；</li>
<li>建议用户使用 <code>ASAN_SYMBOLIZER_PATH=$CANGJIE_HOME/third_party/llvm/bin/llvm-symbolizer</code> 指定 ASan 运行库使用仓颉提供的 symbolizer，以保证函数符号的正常解析。</li>
</ol>
<h2 id="数据竞争检测"><a class="header" href="#数据竞争检测">数据竞争检测</a></h2>
<blockquote>
<p><strong>注意：</strong></p>
<p>当前版本暂不支持本节介绍的数据竞争检测。</p>
</blockquote>
<p><code>cjc</code> 支持数据竞争检测功能，用来检测并发的仓颉程序中存在的数据竞争缺陷。</p>
<p>例如：</p>
<pre><code>main() {
    let x: Box&lt;Int64&gt; = Box&lt;Int64&gt;(0)

    let fut = spawn { =&gt;
        x.value = 11 // data race
    }

    x.value = 10 // data race
    fut.get()
}
</code></pre>
<p>上述代码中同时有两个协程修改 x 的值，而协程之间没有通过锁等同步机制进行保护，因此存在数据竞争的风险。数据竞争检测功能可以帮助用户发现和定位程序中该类数据竞争缺陷，方便用户修补该类代码缺陷。</p>
<h3 id="--sanitizethread"><a class="header" href="#--sanitizethread"><code>--sanitize=thread</code></a></h3>
<p>使能数据竞争检测功能。
开启该编译选项后，在程序运行时如果发生数据竞争，程序会打印出发生数据竞争的代码位置、调用栈和相关的协程信息。</p>
<p>仓颉的数据竞争检测功能是利用 Thread Sanitizer 实现，但是对原始 Thread Sanitizer 进行了修改以适配仓颉的协程并发模型，因此只能检测仓颉侧代码访问仓颉对象时产生的数据竞争，无法检测 C 侧的数据竞争以及 C 侧代码访问仓颉对象时产生的数据竞争。</p>
<p>**值得注意的是，**当用户使用 C 代码作为主程序调用仓颉库时，如果仓颉库开启了 <code>--sanitize=thread</code> 选项，则 C 代码在编译时需要添加以下参数来链接相关依赖：</p>
<pre><code>-L $CANGJIE_HOME/lib/&lt;system&gt;_&lt;arch&gt;_llvm -lcangjie-runtime_tsan -lgcc_s -Wl,--whole-archive -lpthread -l:libclang_rt-tsan.a -Wl,--no-whole-archive -Wl,--dynamic-list=$CANGJIE_HOME/lib/&lt;system&gt;_&lt;arch&gt;_llvm/libclang_rt-tsan.a.syms
</code></pre>
<h2 id="实验性功能选项"><a class="header" href="#实验性功能选项">实验性功能选项</a></h2>
<h3 id="--experimental-frontend"><a class="header" href="#--experimental-frontend"><code>--experimental</code> <sup>[frontend]</sup></a></h3>
<p>启用实验性功能，允许在命令行使用其他实验性功能选项。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>使用实验性功能生成的二进制文件有可能会存在潜在的运行时问题，请注意使用该选项的风险。</p>
</blockquote>
<h2 id="其他功能"><a class="header" href="#其他功能">其他功能</a></h2>
<h3 id="编译器报错信息显示颜色"><a class="header" href="#编译器报错信息显示颜色">编译器报错信息显示颜色</a></h3>
<p>对于 Windows 版本的仓颉编译器，只有运行于 Windows10 version 1511(Build 10586) 或更高版本的系统，编译器报错信息才显示颜色，否则不显示颜色。</p>
<h3 id="设置-build-id"><a class="header" href="#设置-build-id">设置 build-id</a></h3>
<p>通过 <code>--link-options &quot;--build-id=&lt;arg&gt;&quot;</code><sup>1</sup> 可以透传链接器选项以设置 build-id。</p>
<p>编译 Windows 目标时不支持此功能。</p>
<h3 id="设置-rpath"><a class="header" href="#设置-rpath">设置 rpath</a></h3>
<p>通过 <code>--link-options &quot;-rpath=&lt;arg&gt;&quot;</code><sup>1</sup> 可以透传链接器选项以设置 rpath。</p>
<p>编译 Windows 目标时不支持此功能。</p>
<h3 id="增量编译"><a class="header" href="#增量编译">增量编译</a></h3>
<p>通过 <code>--incremental-compile</code><sup>[frontend]</sup>开启增量编译。开启后，<code>cjc</code>会在编译时根据前次编译的缓存文件加快此次编译的速度。</p>
<h2 id="cjc-用到的环境变量"><a class="header" href="#cjc-用到的环境变量"><code>cjc</code> 用到的环境变量</a></h2>
<p>这里介绍一些仓颉编译器在编译代码的过程中可能使用到的环境变量。</p>
<h3 id="tmpdir-或者-tmp"><a class="header" href="#tmpdir-或者-tmp"><code>TMPDIR</code> 或者 <code>TMP</code></a></h3>
<p>仓颉编译器会将编译过程中产生的临时文件放置到临时目录中。默认情况下 <code>Linux</code> 以及 <code>macOS</code> 操作系统会放在 <code>/tmp</code> 目录下；<code>Windows</code> 操作系统会放在 <code>C:\Windows\Temp</code> 目录下。仓颉编译器也支持自行设置临时文件存放目录，<code>Linux</code> 以及 <code>macOS</code> 操作系统上通过设置环境变量 <code>TMPDIR</code> 来更改临时文件目录，<code>Windows</code> 操作系统上通过设置环境变量 <code>TMP</code> 来更改临时文件目录。</p>
<p>例如：
在 Linux shell 中</p>
<pre><code class="language-shell">export TMPDIR=/home/xxxx
</code></pre>
<p>在 Windows cmd 中</p>
<pre><code class="language-shell">set TMP=D:\\xxxx
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-版本工具链的支持与安装"><a class="header" href="#linux-版本工具链的支持与安装">Linux 版本工具链的支持与安装</a></h1>
<p>仓颉工具链当前基于以下 Linux 发行版进行了完整功能测试：
| Linux 发行版 |
| -- |
| SLES 12-SP5 |
| Ubuntu 18.04 |
| Ubuntu 20.04 |
| EulerOS R11 |</p>
<h2 id="适用于各-linux-发行版的仓颉工具链依赖安装命令"><a class="header" href="#适用于各-linux-发行版的仓颉工具链依赖安装命令">适用于各 Linux 发行版的仓颉工具链依赖安装命令</a></h2>
<blockquote>
<p><strong>注意：</strong></p>
<p>当前仓颉工具链依赖的部分工具在一些 Linux 发行版上可能无法通过系统默认软件源直接安装，你可以参考下一节“编译安装依赖工具”进行手动安装。</p>
</blockquote>
<h3 id="sles-12-sp5"><a class="header" href="#sles-12-sp5">SLES 12-SP5</a></h3>
<pre><code class="language-shell">$ zypper install \
         binutils \
         glibc-devel \
         gcc-c++
</code></pre>
<p>此外，还需要安装 OpenSSL 3，安装方法请参考[编译安装依赖工具](## 编译安装依赖工具)。</p>
<h3 id="ubuntu-1804"><a class="header" href="#ubuntu-1804">Ubuntu 18.04</a></h3>
<pre><code class="language-shell">$ apt-get install \
          binutils \
          libc-dev \
          libc++-dev \
          libgcc-7-dev \
</code></pre>
<p>此外，还需要安装 OpenSSL 3，安装方法请参考[编译安装依赖工具](## 编译安装依赖工具)。</p>
<h3 id="ubuntu-2004"><a class="header" href="#ubuntu-2004">Ubuntu 20.04</a></h3>
<pre><code class="language-shell">$ apt-get install \
          binutils \
          libc-dev \
          libc++-dev \
          libgcc-9-dev \
</code></pre>
<p>此外，还需要安装 OpenSSL 3，安装方法请参考[编译安装依赖工具](## 编译安装依赖工具)。</p>
<p><strong>EulerOS R11</strong></p>
<pre><code class="language-shell">$ yum install binutils \
              glibc-devel \
              gcc
</code></pre>
<h3 id="其他-linux-发行版"><a class="header" href="#其他-linux-发行版">其他 Linux 发行版</a></h3>
<p>根据使用的 Linux 发行版的不同，你可能需要参考以上系统的依赖安装命令，使用你的系统包管理工具安装对应依赖。若你使用的系统没有提供相关软件包，你可能需要自行安装链接工具、C 语言开发工具、C++ 开发工具、GCC 编译器、以及 OpenSSL 3 以正常使用仓颉工具链。</p>
<h2 id="编译安装依赖工具"><a class="header" href="#编译安装依赖工具">编译安装依赖工具</a></h2>
<p>当前仓颉工具链中的部分标准库（以及部分工具）使用了 OpenSSL 3 开源软件。对于系统包管理工具未提供 OpenSSL 3 的场景，用户可能需要源码编译安装 OpenSSL 3，本节提供了 OpenSSL 3 源码编译的方法和步骤。</p>
<h3 id="openssl-3"><a class="header" href="#openssl-3">OpenSSL 3</a></h3>
<p>从以下链接可以下载到 OpenSSL 3 的源码：</p>
<ul>
<li>https://www.openssl.org/source/</li>
<li>https://www.openssl.org/source/old/</li>
</ul>
<p>建议使用 openssl-3.0.7 或更高版本。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>请在执行以下编译和安装命令前仔细阅读注意事项，并根据实际情况调整命令。不正确的配置和安装可能会导致系统其他软件不可用。如果在编译安装过程中遇到问题或希望进行额外的安装配置，请参考 OpenSSL 源码中的 <code>INSTALL</code> 文件或 OpenSSL 的 <a href="https://www.openssl.org/docs/faq.html">FAQ</a>。</p>
</blockquote>
<p>此处以 openssl-3.0.7 为例，下载后使用以下命令解压压缩包：</p>
<pre><code>$ tar xf openssl-3.0.7.tar.gz
</code></pre>
<p>解压完成后进入目录：</p>
<pre><code>$ cd openssl-3.0.7
</code></pre>
<p>编译 OpenSSL：</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>如果你的系统已经安装了 OpenSSL，建议使用 <code>--prefix=&lt;path&gt;</code> 选项指定一个自定义安装路径，例如 <code>--prefix=/usr/local/openssl-3.0.7</code> 或你的个人目录。在系统目录已经存在 OpenSSL 的场景下直接使用以下命令编译安装可能会使系统 OpenSSL 被覆盖，并导致依赖系统 OpenSSL 的应用不可用。</p>
</blockquote>
<pre><code>$ ./Configure --libdir=lib
$ make
</code></pre>
<p>测试 OpenSSL：</p>
<pre><code>$ make test
</code></pre>
<p>将 OpenSSL 安装至系统目录（或你先前指定的 <code>--prefix</code> 目录），你可能需要提供 root 权限以成功执行以下命令：</p>
<pre><code>$ make install
</code></pre>
<p>或</p>
<pre><code>$ sudo make install
</code></pre>
<p>如果先前编译 OpenSSL 时没有通过 <code>--prefix</code> 设置自定义安装路径，你的 OpenSSL 安装已经完成了。如果先前通过 <code>--prefix</code> 指定了自定义的安装路径，你还需要设置以下变量，以使仓颉工具链可以找到 OpenSSL 3。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>如果你的系统中原先存在其他版本的 OpenSSL，通过以下方式配置后，除了仓颉工具链外，你的其他编译开发工具默认使用的 OpenSSL 版本也可能受到影响。如果使用其他编译开发工具时出现 OpenSSL 不兼容的情况，请仅为仓颉开发环境配置以下变量。</p>
</blockquote>
<p><em>请将 <code>&lt;prefix&gt;</code> 替换为你指定的自定义安装路径。</em></p>
<pre><code>$ export LIBRARY_PATH=&lt;prefix&gt;/lib:$LIBRARY_PATH
$ export LD_LIBRARY_PATH=&lt;prefix&gt;/lib:$LD_LIBRARY_PATH
</code></pre>
<p>通过以上方式所配置的环境变量仅在当前执行命令的 <code>shell</code> 会话窗口有效。若希望 <code>shell</code> 每次启动时都自动配置，你可以在 <code>$HOME/.bashrc</code>、<code>$HOME/.zshrc</code> 或其他 <code>shell</code> 配置文件（依你的 <code>shell</code> 种类而定）加入以上命令。</p>
<p>若希望配置可以默认对所有用户生效，你可以执行以下命令：</p>
<p><em>请将 <code>&lt;prefix&gt;</code> 替换为你指定的自定义安装路径。</em></p>
<pre><code>$ echo &quot;export LIBRARY_PATH=&lt;prefix&gt;/lib:$LIBRARY_PATH&quot; &gt;&gt; /etc/profile
$ echo &quot;&lt;prefix&gt;/lib&quot; &gt;&gt; /etc/ld.so.conf
$ ldconfig
</code></pre>
<p>执行完毕后重新打开 <code>shell</code> 会话窗口即可生效。</p>
<p>至此，OpenSSL 3 已经成功安装，你可以回到原来的章节继续阅读或尝试运行仓颉编译器了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime-环境变量使用手册"><a class="header" href="#runtime-环境变量使用手册">runtime 环境变量使用手册</a></h1>
<p>本节介绍 <code>runtime</code>（运行时）所提供的环境变量。</p>
<p>在 Linux shell 与 macOS shell 中，您可以使用以下方式设置仓颉运行时提供的环境变量：</p>
<pre><code class="language-shell">$ export VARIABLE=value
</code></pre>
<p>在 Windows cmd 中，您可以使用以下方式设置仓颉运行时提供的环境变量：</p>
<pre><code class="language-shell">&gt; set VARAIBLE=value
</code></pre>
<p>本节后续的示例都为 Linux shell 中的设置方式，若与您的运行平台不符，请根据您的运行平台选择合适的环境变量设置方式。</p>
<h2 id="runtime-初始化可选配置"><a class="header" href="#runtime-初始化可选配置">runtime 初始化可选配置</a></h2>
<p>注意：</p>
<ol>
<li>所有整型参数为 Int64 类型，浮点型参数为 Float64 类型;</li>
<li>所有参数如果未显式规定最大值，默认隐式最大值为该类型最大值;</li>
<li>所有参数若超出范围则设置无效，自动使用默认值。</li>
</ol>
<h3 id="cjheapsize"><a class="header" href="#cjheapsize"><code>cjHeapSize</code></a></h3>
<p>指定仓颉堆的最大值，支持单位为 kb（KB）、mb（MB）、gb（GB），支持设置范围为[4MB, 系统物理内存]，超出范围的设置无效，仍旧使用默认值。若物理内存低于 1GB，默认值为 64 MB，否则为 256 MB。</p>
<p>例如：</p>
<pre><code class="language-shell">export cjHeapSize=32GB
</code></pre>
<h3 id="cjregionsize"><a class="header" href="#cjregionsize"><code>cjRegionSize</code></a></h3>
<p>指定 region 分配器 thread local buffer 的大小，支持设置范围为[4, 2048]，单位为 KB，超出范围的设置无效，仍旧使用默认值。默认值为 1024 KB。</p>
<p>例如：</p>
<pre><code class="language-shell">export cjRegionSize=1024
</code></pre>
<h3 id="cjexemptionthreshold"><a class="header" href="#cjexemptionthreshold"><code>cjExemptionThreshold</code></a></h3>
<p>指定存活 region 的水线值，取值 (0,1]，该值与 region 的大小相乘，若 region 中存活对象数量大于相乘后的值，则该 region 不会被回收（其中死亡对象继续占用内存）。该值指定得越大，region 被回收的概率越大，堆中的碎片空间就越少，但频繁回收 region 也会影响性能。超出范围的设置无效，仍旧使用默认值。默认值为 1024 KB。默认值为 0.8，即 80%。</p>
<p>例如：</p>
<pre><code class="language-shell">export cjExemptionThreshold=0.8
</code></pre>
<h3 id="cjheaputilization"><a class="header" href="#cjheaputilization"><code>cjHeapUtilization</code></a></h3>
<p>指定仓颉堆的利用率，该参数用于 GC 后更新堆水线的参考依据之一，取值 (0, 1]，堆水线是指当堆中对象总大小达到水线值时则进行 GC。该参数指定越小，则更新后的堆水线会越高，则触发 GC 的概率会相对变低。超出范围的设置无效，仍旧使用默认值。默认值为 0.8，即 80%。</p>
<p>例如：</p>
<pre><code class="language-shell">export cjHeapUtilization=0.8
</code></pre>
<h3 id="cjheapgrowth"><a class="header" href="#cjheapgrowth"><code>cjHeapGrowth</code></a></h3>
<p>指定仓颉堆的增长率，该参数用于 GC 后更新堆水线的参考依据之一，取值必须大于 0。增长率的计算方式为 1 + cjHeapGrowth。该参数指定越大，则更新后的堆水线会越高，则触发 GC 的概率会相对变低。默认值为 0.15，表示增长率为 1.15。</p>
<p>例如：</p>
<pre><code class="language-shell">export cjHeapGrowth=0.15
</code></pre>
<h3 id="cjalloctionrate"><a class="header" href="#cjalloctionrate"><code>cjAlloctionRate</code></a></h3>
<p>指定仓颉运行时分配对象的速率，该值必须大于 0，单位为 MB/s，表示每秒可分配对象的数量。默认值为 10240，表示每秒可分配 10240 MB 对象。</p>
<p>例如：</p>
<pre><code class="language-shell">export cjAlloctionRate=10240
</code></pre>
<h3 id="cjalloctionwaittime"><a class="header" href="#cjalloctionwaittime"><code>cjAlloctionWaitTime</code></a></h3>
<p>指定仓颉运行时分配对象时的等待时间，该值必须大于 0，支持单位为 s、ms、us、ns，推荐单位为纳秒（ns）。若本次分配对象距离上一次分配对象的时间间隔小于此值，则将等待。默认值为 1000 ns。</p>
<p>例如：</p>
<pre><code class="language-shell">export cjAlloctionWaitTime=1000ns
</code></pre>
<h3 id="cjgcthreshold"><a class="header" href="#cjgcthreshold"><code>cjGCThreshold</code></a></h3>
<p>指定仓颉堆的参考水线值，支持单位为 kb（KB）、mb（MB）、gb（GB）, 取值必须为大于 0 的整数。当仓颉堆大小超过该值时，触发 GC。默认值为堆大小。</p>
<p>例如：</p>
<pre><code class="language-shell">export cjGCThreshold=20480KB
</code></pre>
<h3 id="cjgarbagethreshold"><a class="header" href="#cjgarbagethreshold"><code>cjGarbageThreshold</code></a></h3>
<p>当 GC 发生时，如果 region 中死亡对象所占比率大于此环境变量，此 region 会被放入回收候选集中，后续可被回收（如果受到其它策略影响也可能不被回收），默认值为 0.5，无量纲，支持设置的区间为[0.0, 1.0]。</p>
<p>例如：</p>
<pre><code class="language-shell">export cjGarbageThreshold=0.5
</code></pre>
<h3 id="cjgcinterval"><a class="header" href="#cjgcinterval"><code>cjGCInterval</code></a></h3>
<p>指定 2 次 GC 的间隔时间值，取值必须大于 0，支持单位为 s、ms、us、ns，推荐单位为毫秒（ms）。若本次 GC 距离上次 GC 的间隔小于此值，则本次 GC 将被忽略。该参数可以控制 GC 的频率。默认值为 150 ms。</p>
<p>例如：</p>
<pre><code class="language-shell">export cjGCInterval=150ms
</code></pre>
<h3 id="cjbackupgcinterval"><a class="header" href="#cjbackupgcinterval"><code>cjBackupGCInterval</code></a></h3>
<p>指定 backup GC 的间隔值，取值必须大于 0，支持单位为 s、ms、us、ns，推荐单位为秒（s），当仓颉运行时在该参数设定时间内未触发 GC，则触发一次 backup GC。默认值为 240 秒，即 4 分钟。</p>
<p>例如：</p>
<pre><code class="language-shell">export cjBackupGCInterval=240s
</code></pre>
<h3 id="cjgcthreads"><a class="header" href="#cjgcthreads"><code>cjGCThreads</code></a></h3>
<p>指定影响 GC 线程数的因数，取值必须大于 0。GC 线程数的计算方式为：(系统支持的并发线程数 / cjGCThreads) - 1。默认值为 8。</p>
<p>例如：</p>
<pre><code class="language-shell">export cjGCThreads=8
</code></pre>
<h3 id="cjprocessornum"><a class="header" href="#cjprocessornum"><code>cjProcessorNum</code></a></h3>
<p>指定仓颉线程的最大并发数，支持设置范围为 (0, CPU 核数 * 2]，超出范围的设置无效，仍旧使用默认值。调用系统 API 获取 cpu 核数，若成功默认值为 cpu 核数，否则默认值为 8。</p>
<p>例如：</p>
<pre><code class="language-shell">export cjProcessorNum=2
</code></pre>
<h3 id="cjstacksize"><a class="header" href="#cjstacksize"><code>cjStackSize</code></a></h3>
<p>指定仓颉线程的栈大小，支持单位为 kb（KB）、mb（MB）、gb（GB），支持设置范围为 Linux 平台下[64KB, 1GB]，Windows 平台下[128KB, 1GB]，超出范围的设置无效，仍旧使用默认值。Linux 平台下默认值为 64KB，Windows 平台下为 128KB。</p>
<p>例如：</p>
<pre><code class="language-shell">export cjStackSize=100kb
</code></pre>
<h3 id="运维日志可选配置"><a class="header" href="#运维日志可选配置">运维日志可选配置</a></h3>
<h4 id="mrt_log_file_size"><a class="header" href="#mrt_log_file_size"><code>MRT_LOG_FILE_SIZE</code></a></h4>
<p>指定 runtime 运维日志的文件大小，默认值为 10 MB，支持单位为 kb（KB）、mb（MB）、gb（GB），设置值需大于 0。</p>
<p>日志大小超过该值时，会重新回到日志开头进行打印。</p>
<p>最终生成日志大小略大于 MRT_LOG_FILE_SIZE。</p>
<p>例如：</p>
<pre><code class="language-shell">export MRT_LOG_FILE_SIZE=100kb
</code></pre>
<h4 id="mrt_log_path"><a class="header" href="#mrt_log_path"><code>MRT_LOG_PATH</code></a></h4>
<p>指定 runtime 运维日志的输出路径，若该环境变量未设置或路径设置失败，则运维日志默认打印到 stdout（标准输出）或 stderr（标准错误）中。</p>
<p>例如：</p>
<pre><code class="language-shell">export MRT_LOG_PATH=/home/cangjie/runtime/runtime_log.txt
</code></pre>
<h4 id="mrt_log_level"><a class="header" href="#mrt_log_level"><code>MRT_LOG_LEVEL</code></a></h4>
<p>指定 runtime 运维日志的最小输出级别，大于等于这个级别的日志会被打印，默认值为 e，支持设置值为[v|d|i|w|e|f|s]。v（VERBOSE）、d（DEBUGY）、i（INFO）、w（WARNING）、e（ERROR）、f（FATAL）、s（FATAL_WITHOUT_ABORT）。</p>
<p>例如：</p>
<pre><code class="language-shell">export MRT_LOG_LEVEL=v
</code></pre>
<h4 id="mrt_report"><a class="header" href="#mrt_report"><code>MRT_REPORT</code></a></h4>
<p>指定 runtime GC 日志的输出路径，若该环境变量未设置或路径设置失败，该日志默认不打印。</p>
<p>例如：</p>
<pre><code class="language-shell">export MRT_REPORT=/home/cangjie/runtime/gc_log.txt
</code></pre>
<h4 id="mrt_log_coroutine"><a class="header" href="#mrt_log_coroutine"><code>MRT_LOG_COROUTINE</code></a></h4>
<p>指定 coroutine 日志的输出路径，若该环境变量未设置或路径设置失败，该日志默认不打印。</p>
<p>例如：</p>
<pre><code class="language-shell">export MRT_LOG_COROUTINE=/home/cangjie/runtime/coroutine_log.txt
</code></pre>
<h4 id="cjheapdumponoom"><a class="header" href="#cjheapdumponoom"><code>cjHeapDumpOnOOM</code></a></h4>
<p>指定是否要在发生堆溢出后输出堆快照文件，默认不开启，支持设置值为[on|off]，设定为 on 时开启功能，设定 off 或者其他值不开启功能。</p>
<p>例如：</p>
<pre><code class="language-shell">export cjHeapDumpOnOOM=on
</code></pre>
<h4 id="cjheapdumplog"><a class="header" href="#cjheapdumplog"><code>cjHeapDumpLog</code></a></h4>
<p>指定输出堆快照文件的路径，注意指定的路径必须存在，且应用执行者对其具有读写权限。如果不指定，堆快照文件将输出到当前执行目录。</p>
<p>例如：</p>
<pre><code class="language-shell">export cjHeapDumpLog=/home/cangjie
</code></pre>
<h3 id="运行环境可选配置"><a class="header" href="#运行环境可选配置">运行环境可选配置</a></h3>
<h4 id="mrt_stack_check"><a class="header" href="#mrt_stack_check"><code>MRT_STACK_CHECK</code></a></h4>
<p>开启 native stack overflow 检查，默认不开启，支持设置值为 1、true、TRUE 开启功能。</p>
<p>例如：</p>
<pre><code class="language-shell">export MRT_STACK_CHECK=true
</code></pre>
<h4 id="cj_sof_size"><a class="header" href="#cj_sof_size"><code>CJ_SOF_SIZE</code></a></h4>
<p>当 StackOverflowError 发生时，将自动进行异常栈折叠方便用户阅读，折叠后栈帧层数默认值是 32。可以通过配置此环境变量控制折叠栈长度，支持设置为 int 范围内的整数。
CJ_SOF_SIZE = 0，打印所有调用栈；
CJ_SOF_SIZE &lt; 0，从栈底开始打印环境变量配置层数；
CJ_SOF_SIZE &gt; 0，从栈顶开始打印环境变量配置层数；
CJ_SOF_SIZE 未配置，默认打印栈顶开始 32 层调用栈；</p>
<p>例如：</p>
<pre><code class="language-shell">export CJ_SOF_SIZE=30
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="关键字"><a class="header" href="#关键字">关键字</a></h1>
<p>关键字是不能作为标识符使用的特殊字符串，仓颉语言的关键字如下表所示：</p>
<div class="table-wrapper"><table><thead><tr><th>关键字</th><th>关键字</th><th>关键字</th></tr></thead><tbody>
<tr><td>as</td><td>abstract</td><td>break</td></tr>
<tr><td>Bool</td><td>case</td><td>catch</td></tr>
<tr><td>class</td><td>const</td><td>continue</td></tr>
<tr><td>Rune</td><td>do</td><td>else</td></tr>
<tr><td>enum</td><td>extend</td><td>for</td></tr>
<tr><td>func</td><td>false</td><td>finally</td></tr>
<tr><td>foreign</td><td>Float16</td><td>Float32</td></tr>
<tr><td>Float64</td><td>if</td><td>in</td></tr>
<tr><td>is</td><td>init</td><td>import</td></tr>
<tr><td>interface</td><td>Int8</td><td>Int16</td></tr>
<tr><td>Int32</td><td>Int64</td><td>IntNative</td></tr>
<tr><td>let</td><td>mut</td><td>main</td></tr>
<tr><td>macro</td><td>match</td><td>Nothing</td></tr>
<tr><td>open</td><td>operator</td><td>override</td></tr>
<tr><td>prop</td><td>public</td><td>package</td></tr>
<tr><td>private</td><td>protected</td><td>quote</td></tr>
<tr><td>redef</td><td>return</td><td>spawn</td></tr>
<tr><td>super</td><td>static</td><td>struct</td></tr>
<tr><td>synchronized</td><td>try</td><td>this</td></tr>
<tr><td>true</td><td>type</td><td>throw</td></tr>
<tr><td>This</td><td>unsafe</td><td>Unit</td></tr>
<tr><td>UInt8</td><td>UInt16</td><td>UInt32</td></tr>
<tr><td>UInt64</td><td>UIntNative</td><td>var</td></tr>
<tr><td>VArray</td><td>where</td><td>while</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="操作符"><a class="header" href="#操作符">操作符</a></h1>
<p>下表列出了仓颉支持的所有操作符的优先级及结合性，其中优先级一栏数值越小，对应操作符的优先级越高。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">操作符</th><th style="text-align: left">优先级</th><th style="text-align: left">含义</th><th style="text-align: left">示例</th><th>结合方向</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>@</code></td><td style="text-align: left">0</td><td style="text-align: left">宏调用</td><td style="text-align: left"><code>@id</code></td><td>右结合</td></tr>
<tr><td style="text-align: left"><code>.</code></td><td style="text-align: left">1</td><td style="text-align: left">成员访问</td><td style="text-align: left"><code>expr.id</code></td><td>左结合</td></tr>
<tr><td style="text-align: left"><code>[]</code></td><td style="text-align: left">1</td><td style="text-align: left">索引</td><td style="text-align: left"><code>expr[expr]</code></td><td>左结合</td></tr>
<tr><td style="text-align: left"><code>()</code></td><td style="text-align: left">1</td><td style="text-align: left">函数调用</td><td style="text-align: left"><code>expr(expr)</code></td><td>左结合</td></tr>
<tr><td style="text-align: left"><code>++</code></td><td style="text-align: left">2</td><td style="text-align: left">自增</td><td style="text-align: left"><code>var++</code></td><td>无</td></tr>
<tr><td style="text-align: left"><code>--</code></td><td style="text-align: left">2</td><td style="text-align: left">自减</td><td style="text-align: left"><code>var--</code></td><td>无</td></tr>
<tr><td style="text-align: left"><code>?</code></td><td style="text-align: left">2</td><td style="text-align: left">问号</td><td style="text-align: left"><code>expr?.id</code>, <code>expr?[expr]</code>, <code>expr?(expr)</code>, <code>expr?{expr}</code></td><td>无</td></tr>
<tr><td style="text-align: left"><code>!</code></td><td style="text-align: left">3</td><td style="text-align: left">按位求反、逻辑非</td><td style="text-align: left"><code>!expr</code></td><td>右结合</td></tr>
<tr><td style="text-align: left"><code>-</code></td><td style="text-align: left">3</td><td style="text-align: left">一元负号</td><td style="text-align: left"><code>-expr</code></td><td>右结合</td></tr>
<tr><td style="text-align: left"><code>**</code></td><td style="text-align: left">4</td><td style="text-align: left">幂运算</td><td style="text-align: left"><code>expr ** expr</code></td><td>右结合</td></tr>
<tr><td style="text-align: left"><code>*</code>, <code>/</code></td><td style="text-align: left">5</td><td style="text-align: left">乘法，除法</td><td style="text-align: left"><code>expr * expr</code>,  <code>expr / expr</code></td><td>左结合</td></tr>
<tr><td style="text-align: left"><code>%</code></td><td style="text-align: left">5</td><td style="text-align: left">取模</td><td style="text-align: left"><code>expr % expr</code></td><td>左结合</td></tr>
<tr><td style="text-align: left"><code>+</code>, <code>-</code></td><td style="text-align: left">6</td><td style="text-align: left">加法，减法</td><td style="text-align: left"><code>expr + expr</code>,  <code>expr - expr</code></td><td>左结合</td></tr>
<tr><td style="text-align: left"><code>&lt;&lt;</code></td><td style="text-align: left">7</td><td style="text-align: left">按位左移</td><td style="text-align: left"><code>expr &lt;&lt; expr</code></td><td>左结合</td></tr>
<tr><td style="text-align: left"><code>&gt;&gt;</code></td><td style="text-align: left">7</td><td style="text-align: left">按位右移</td><td style="text-align: left"><code>expr &gt;&gt; expr</code></td><td>左结合</td></tr>
<tr><td style="text-align: left"><code>..</code></td><td style="text-align: left">8</td><td style="text-align: left">区间操作符</td><td style="text-align: left"><code>expr..expr</code></td><td>无</td></tr>
<tr><td style="text-align: left"><code>..=</code></td><td style="text-align: left">8</td><td style="text-align: left">含步长的区间操作符</td><td style="text-align: left"><code>expr..=expr</code></td><td>无</td></tr>
<tr><td style="text-align: left"><code>&lt;</code></td><td style="text-align: left">9</td><td style="text-align: left">小于</td><td style="text-align: left"><code>expr &lt; expr</code></td><td>无</td></tr>
<tr><td style="text-align: left"><code>&lt;=</code></td><td style="text-align: left">9</td><td style="text-align: left">小于等于</td><td style="text-align: left"><code>expr &lt;= expr</code></td><td>无</td></tr>
<tr><td style="text-align: left"><code>&gt;</code></td><td style="text-align: left">9</td><td style="text-align: left">大于</td><td style="text-align: left"><code>expr &gt; expr</code></td><td>无</td></tr>
<tr><td style="text-align: left"><code>&gt;=</code></td><td style="text-align: left">9</td><td style="text-align: left">大于等于</td><td style="text-align: left"><code>expr &gt;= expr</code></td><td>无</td></tr>
<tr><td style="text-align: left"><code>is</code></td><td style="text-align: left">9</td><td style="text-align: left">类型检查</td><td style="text-align: left"><code>expr is Type</code></td><td>无</td></tr>
<tr><td style="text-align: left"><code>as</code></td><td style="text-align: left">9</td><td style="text-align: left">类型转换</td><td style="text-align: left"><code>expr as Type</code></td><td>无</td></tr>
<tr><td style="text-align: left"><code>==</code></td><td style="text-align: left">10</td><td style="text-align: left">判等</td><td style="text-align: left"><code>expr == expr</code></td><td>无</td></tr>
<tr><td style="text-align: left"><code>!=</code></td><td style="text-align: left">10</td><td style="text-align: left">判不等</td><td style="text-align: left"><code>expr != expr</code></td><td>无</td></tr>
<tr><td style="text-align: left"><code>&amp;</code></td><td style="text-align: left">11</td><td style="text-align: left">按位与</td><td style="text-align: left"><code>expr &amp; expr</code></td><td>左结合</td></tr>
<tr><td style="text-align: left"><code>^</code></td><td style="text-align: left">12</td><td style="text-align: left">按位异或</td><td style="text-align: left"><code>expr ^ expr</code></td><td>左结合</td></tr>
<tr><td style="text-align: left"><code>|</code></td><td style="text-align: left">13</td><td style="text-align: left">按位或</td><td style="text-align: left"><code>expr | expr</code></td><td>左结合</td></tr>
<tr><td style="text-align: left"><code>&amp;&amp;</code></td><td style="text-align: left">14</td><td style="text-align: left">逻辑与</td><td style="text-align: left"><code>expr &amp;&amp; expr</code></td><td>左结合</td></tr>
<tr><td style="text-align: left"><code>||</code></td><td style="text-align: left">15</td><td style="text-align: left">逻辑或</td><td style="text-align: left"><code>expr  || expr</code></td><td>左结合</td></tr>
<tr><td style="text-align: left"><code>??</code></td><td style="text-align: left">16</td><td style="text-align: left">coalescing 操作符</td><td style="text-align: left"><code>expr ?? expr</code></td><td>右结合</td></tr>
<tr><td style="text-align: left"><code>|&gt;</code></td><td style="text-align: left">17</td><td style="text-align: left">pipeline 操作符</td><td style="text-align: left"><code>id |&gt; expr</code></td><td>左结合</td></tr>
<tr><td style="text-align: left"><code>~&gt;</code></td><td style="text-align: left">17</td><td style="text-align: left">composition 操作符</td><td style="text-align: left"><code>expr ~&gt; expr</code></td><td>左结合</td></tr>
<tr><td style="text-align: left"><code>=</code></td><td style="text-align: left">18</td><td style="text-align: left">赋值</td><td style="text-align: left"><code>id = expr</code></td><td>无</td></tr>
<tr><td style="text-align: left"><code>**=</code></td><td style="text-align: left">18</td><td style="text-align: left">复合运算符</td><td style="text-align: left"><code>id **= expr</code></td><td>无</td></tr>
<tr><td style="text-align: left"><code>*=</code></td><td style="text-align: left">18</td><td style="text-align: left">复合运算符</td><td style="text-align: left"><code>id *= expr</code></td><td>无</td></tr>
<tr><td style="text-align: left"><code>/=</code></td><td style="text-align: left">18</td><td style="text-align: left">复合运算符</td><td style="text-align: left"><code>id /= expr</code></td><td>无</td></tr>
<tr><td style="text-align: left"><code>%=</code></td><td style="text-align: left">18</td><td style="text-align: left">复合运算符</td><td style="text-align: left"><code>id %= expr</code></td><td>无</td></tr>
<tr><td style="text-align: left"><code>+=</code></td><td style="text-align: left">18</td><td style="text-align: left">复合运算符</td><td style="text-align: left"><code>id += expr</code></td><td>无</td></tr>
<tr><td style="text-align: left"><code>-=</code></td><td style="text-align: left">18</td><td style="text-align: left">复合运算符</td><td style="text-align: left"><code>id -= expr</code></td><td>无</td></tr>
<tr><td style="text-align: left"><code>&lt;&lt;=</code></td><td style="text-align: left">18</td><td style="text-align: left">复合运算符</td><td style="text-align: left"><code>id &lt;&lt;= expr</code></td><td>无</td></tr>
<tr><td style="text-align: left"><code>&gt;&gt;=</code></td><td style="text-align: left">18</td><td style="text-align: left">复合运算符</td><td style="text-align: left"><code>id &gt;&gt;= expr</code></td><td>无</td></tr>
<tr><td style="text-align: left"><code>&amp;=</code></td><td style="text-align: left">18</td><td style="text-align: left">复合运算符</td><td style="text-align: left"><code>id &amp;= expr</code></td><td>无</td></tr>
<tr><td style="text-align: left"><code>^=</code></td><td style="text-align: left">18</td><td style="text-align: left">复合运算符</td><td style="text-align: left"><code>id ^= expr</code></td><td>无</td></tr>
<tr><td style="text-align: left"><code>|=</code></td><td style="text-align: left">18</td><td style="text-align: left">复合运算符</td><td style="text-align: left"><code>id |= expr</code></td><td>无</td></tr>
<tr><td style="text-align: left"><code>&amp;&amp;=</code></td><td style="text-align: left">18</td><td style="text-align: left">复合运算符</td><td style="text-align: left"><code>id &amp;&amp;= expr</code></td><td>无</td></tr>
<tr><td style="text-align: left"><code>||=</code></td><td style="text-align: left">18</td><td style="text-align: left">复合运算符</td><td style="text-align: left"><code>id ||= expr</code></td><td>无</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="操作符函数"><a class="header" href="#操作符函数">操作符函数</a></h1>
<p>下表列出了仓颉支持的所有操作符函数。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">操作符函数</th><th style="text-align: left">函数签名</th><th style="text-align: left">示例</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>[]</code>   <strong>（索引取值）</strong></td><td style="text-align: left"><code>operator func [](index1: T1, index2: T2, ...): R</code></td><td style="text-align: left"><code>this[index1, index2, ...]</code></td></tr>
<tr><td style="text-align: left"><code>[]</code>   <strong>（索引赋值）</strong></td><td style="text-align: left"><code>operator func [](index1: T1, index2: T2, ..., value!: TN): R</code></td><td style="text-align: left"><code>this[index1, index2, ...] = value</code></td></tr>
<tr><td style="text-align: left"><code>()</code></td><td style="text-align: left"><code>operator func ()(param1: T1, param2: T2, ...): R</code></td><td style="text-align: left"><code>this(param1, param2, ...)</code></td></tr>
<tr><td style="text-align: left"><code>!</code></td><td style="text-align: left"><code>operator func !(): R</code></td><td style="text-align: left"><code>!this</code></td></tr>
<tr><td style="text-align: left"><code>**</code></td><td style="text-align: left"><code>operator func **(other: T): R</code></td><td style="text-align: left"><code>this ** other</code></td></tr>
<tr><td style="text-align: left"><code>*</code></td><td style="text-align: left"><code>operator func *(other: T): R</code></td><td style="text-align: left"><code>this * other</code></td></tr>
<tr><td style="text-align: left"><code>/</code></td><td style="text-align: left"><code>operator func /(other: T): R</code></td><td style="text-align: left"><code>this / other</code></td></tr>
<tr><td style="text-align: left"><code>%</code></td><td style="text-align: left"><code>operator func %(other: T): R</code></td><td style="text-align: left"><code>this % other</code></td></tr>
<tr><td style="text-align: left"><code>+</code></td><td style="text-align: left"><code>operator func +(other: T): R</code></td><td style="text-align: left"><code>this + other</code></td></tr>
<tr><td style="text-align: left"><code>-</code></td><td style="text-align: left"><code>operator func -(other: T): R</code></td><td style="text-align: left"><code>this - other</code></td></tr>
<tr><td style="text-align: left"><code>&lt;&lt;</code></td><td style="text-align: left"><code>operator func &lt;&lt;(other: T): R</code></td><td style="text-align: left"><code>this &lt;&lt; other</code></td></tr>
<tr><td style="text-align: left"><code>&gt;&gt;</code></td><td style="text-align: left"><code>operator func &gt;&gt;(other: T): R</code></td><td style="text-align: left"><code>this &gt;&gt; other</code></td></tr>
<tr><td style="text-align: left"><code>&lt;</code></td><td style="text-align: left"><code>operator func &lt;(other: T): R</code></td><td style="text-align: left"><code>this &lt; other</code></td></tr>
<tr><td style="text-align: left"><code>&lt;=</code></td><td style="text-align: left"><code>operator func &lt;=(other: T): R</code></td><td style="text-align: left"><code>this &lt;= other</code></td></tr>
<tr><td style="text-align: left"><code>&gt;</code></td><td style="text-align: left"><code>operator func &gt;(other: T): R</code></td><td style="text-align: left"><code>this &gt; other</code></td></tr>
<tr><td style="text-align: left"><code>&gt;=</code></td><td style="text-align: left"><code>operator func &gt;=(other: T): R</code></td><td style="text-align: left"><code>this &gt;= other</code></td></tr>
<tr><td style="text-align: left"><code>==</code></td><td style="text-align: left"><code>operator func ==(other: T): R</code></td><td style="text-align: left"><code>this == other</code></td></tr>
<tr><td style="text-align: left"><code>!=</code></td><td style="text-align: left"><code>operator func !=(other: T): R</code></td><td style="text-align: left"><code>this != other</code></td></tr>
<tr><td style="text-align: left"><code>&amp;</code></td><td style="text-align: left"><code>operator func &amp;(other: T): R</code></td><td style="text-align: left"><code>this &amp; other</code></td></tr>
<tr><td style="text-align: left"><code>^</code></td><td style="text-align: left"><code>operator func ^(other: T): R</code></td><td style="text-align: left"><code>this ^ other</code></td></tr>
<tr><td style="text-align: left"><code>|</code></td><td style="text-align: left"><code>operator func |(other: T): R</code></td><td style="text-align: left"><code>this | other</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="tokenkind-类型"><a class="header" href="#tokenkind-类型">TokenKind 类型</a></h1>
<pre><code class="language-cangjie">public enum TokenKind &lt;: ToString {
    DOT|                      /*  &quot;.&quot;           */
    COMMA|                    /*  &quot;,&quot;           */
    LPAREN|                   /*  &quot;(&quot;           */
    RPAREN|                   /*  &quot;)&quot;           */
    LSQUARE|                  /*  &quot;[&quot;           */
    RSQUARE|                  /*  &quot;]&quot;           */
    LCURL|                    /*  &quot;{&quot;           */
    RCURL|                    /*  &quot;}&quot;           */
    EXP|                      /*  &quot;**&quot;          */
    MUL|                      /*  &quot;*&quot;           */
    MOD|                      /*  &quot;%&quot;           */
    DIV|                      /*  &quot;/&quot;           */
    ADD|                      /*  &quot;+&quot;           */
    SUB|                      /*  &quot;-&quot;           */
    INCR|                     /*  &quot;++&quot;          */
    DECR|                     /*  &quot;--&quot;          */
    AND|                      /*  &quot;&amp;&amp;&quot;          */
    OR|                       /*  &quot;||&quot;          */
    COALESCING|               /*  &quot;??&quot;          */
    PIPELINE|                 /*  &quot;|&gt;&quot;          */
    COMPOSITION|              /*  &quot;~&gt;&quot;          */
    NOT|                      /*  &quot;!&quot;           */
    BITAND|                   /*  &quot;&amp;&quot;           */
    BITOR|                    /*  &quot;|&quot;           */
    BITXOR|                   /*  &quot;^&quot;           */
    BITNOT|                   /*  &quot;~&quot;           */
    LSHIFT|                   /*  &quot;&lt;&lt;&quot;          */
    RSHIFT|                   /*  &quot;&gt;&gt;&quot;          */
    COLON|                    /*  &quot;:&quot;           */
    SEMI|                     /*  &quot;;&quot;           */
    ASSIGN|                   /*  &quot;=&quot;           */
    ADD_ASSIGN|               /*  &quot;+=&quot;          */
    SUB_ASSIGN|               /*  &quot;-=&quot;          */
    MUL_ASSIGN|               /*  &quot;*=&quot;          */
    EXP_ASSIGN|               /*  &quot;**=&quot;         */
    DIV_ASSIGN|               /*  &quot;/=&quot;          */
    MOD_ASSIGN|               /*  &quot;%=&quot;          */
    AND_ASSIGN|               /*  &quot;&amp;&amp;=&quot;         */
    OR_ASSIGN|                /*  &quot;||=&quot;         */
    BITAND_ASSIGN|            /*  &quot;&amp;=&quot;          */
    BITOR_ASSIGN|             /*  &quot;|=&quot;          */
    BITXOR_ASSIGN|            /*  &quot;^=&quot;          */
    LSHIFT_ASSIGN|            /*  &quot;&lt;&lt;=&quot;         */
    RSHIFT_ASSIGN|            /*  &quot;&gt;&gt;=&quot;         */
    ARROW|                    /*  &quot;-&gt;&quot;          */
    BACKARROW|                /*  &quot;&lt;-&quot;          */
    DOUBLE_ARROW|             /*  &quot;=&gt;&quot;          */
    RANGEOP|                  /*  &quot;..&quot;          */
    CLOSEDRANGEOP|            /*  &quot;..=&quot;         */
    ELLIPSIS|                 /*  &quot;...&quot;         */
    HASH|                     /*  &quot;#&quot;           */
    AT|                       /*  &quot;@&quot;           */
    QUEST|                    /*  &quot;?&quot;           */
    LT|                       /*  &quot;&lt;&quot;           */
    GT|                       /*  &quot;&gt;&quot;           */
    LE|                       /*  &quot;&lt;=&quot;          */
    GE|                       /*  &quot;&gt;=&quot;          */
    IS|                       /*  &quot;is&quot;          */
    AS|                       /*  &quot;as&quot;          */
    NOTEQ|                    /*  &quot;!=&quot;          */
    EQUAL|                    /*  &quot;==&quot;          */
    WILDCARD|                 /*  &quot;_&quot;           */
    INT8|                     /*  &quot;Int8&quot;        */
    INT16|                    /*  &quot;Int16&quot;       */
    INT32|                    /*  &quot;Int32&quot;       */
    INT64|                    /*  &quot;Int64&quot;       */
    INTNATIVE|                /*  &quot;IntNative&quot;   */
    UINT8|                    /*  &quot;UInt8&quot;       */
    UINT16|                   /*  &quot;UInt16&quot;      */
    UINT32|                   /*  &quot;UInt32&quot;      */
    UINT64|                   /*  &quot;UInt64&quot;      */
    UINTNATIVE|               /*  &quot;UIntNative&quot;  */
    FLOAT16|                  /*  &quot;Float16&quot;     */
    FLOAT32|                  /*  &quot;Float32&quot;     */
    FLOAT64|                  /*  &quot;Float64&quot;     */
    RUNE|                     /*  &quot;Rune&quot;        */
    BOOLEAN|                  /*  &quot;Bool&quot;        */
    NOTHING|                  /*  &quot;Nothing&quot;     */
    UNIT|                     /*  &quot;Unit&quot;        */
    STRUCT|                   /*  &quot;struct&quot;      */
    ENUM|                     /*  &quot;enum&quot;        */
    CFUNC|                    /*  &quot;CFunc&quot;       */
    VARRAY|                   /*  &quot;VArray&quot;      */
    THISTYPE|                 /*  &quot;This&quot;        */
    PACKAGE|                  /*  &quot;package&quot;     */
    IMPORT|                   /*  &quot;import&quot;      */
    CLASS|                    /*  &quot;class&quot;       */
    INTERFACE|                /*  &quot;interface&quot;   */
    FUNC|                     /*  &quot;func&quot;        */
    MACRO|                    /*  &quot;macro&quot;       */
    QUOTE|                    /*  &quot;quote&quot;       */
    DOLLAR|                   /*  &quot;$&quot;           */
    LET|                      /*  &quot;let&quot;         */
    VAR|                      /*  &quot;var&quot;         */
    CONST|                    /*  &quot;const&quot;       */
    TYPE|                     /*  &quot;type&quot;        */
    INIT|                     /*  &quot;init&quot;        */
    THIS|                     /*  &quot;this&quot;        */
    SUPER|                    /*  &quot;super&quot;       */
    IF|                       /*  &quot;if&quot;          */
    ELSE|                     /*  &quot;else&quot;        */
    CASE|                     /*  &quot;case&quot;        */
    TRY|                      /*  &quot;try&quot;         */
    CATCH|                    /*  &quot;catch&quot;       */
    FINALLY|                  /*  &quot;finally&quot;     */
    FOR|                      /*  &quot;for&quot;         */
    DO|                       /*  &quot;do&quot;          */
    WHILE|                    /*  &quot;while&quot;       */
    THROW|                    /*  &quot;throw&quot;       */
    RETURN|                   /*  &quot;return&quot;      */
    CONTINUE|                 /*  &quot;continue&quot;    */
    BREAK|                    /*  &quot;break&quot;       */
    IN|                       /*  &quot;in&quot;          */
    NOT_IN|                   /*  &quot;!in&quot;         */
    MATCH|                    /*  &quot;match&quot;       */
    FROM|                     /*  &quot;from&quot;        */
    WHERE|                    /*  &quot;where&quot;       */
    EXTEND|                   /*  &quot;extend&quot;      */
    WITH|                     /*  &quot;with&quot;        */
    PROP|                     /*  &quot;prop&quot;        */
    STATIC|                   /*  &quot;static&quot;      */
    PUBLIC|                   /*  &quot;public&quot;      */
    PRIVATE|                  /*  &quot;private&quot;     */
    PROTECTED|                /*  &quot;protected&quot;   */
    OVERRIDE|                 /*  &quot;override&quot;    */
    REDEF|                    /*  &quot;redef&quot;       */
    ABSTRACT|                 /*  &quot;abstract&quot;    */
    SEALED|                   /*  &quot;sealed&quot;      */
    OPEN|                     /*  &quot;open&quot;        */
    FOREIGN|                  /*  &quot;foreign&quot;     */
    INOUT|                    /*  &quot;inout&quot;       */
    MUT|                      /*  &quot;mut&quot;         */
    UNSAFE|                   /*  &quot;unsafe&quot;      */
    OPERATOR|                 /*  &quot;operator&quot;    */
    SPAWN|                    /*  &quot;spawn&quot;       */
    SYNCHRONIZED|             /*  &quot;synchronized */
    UPPERBOUND|               /*  &quot;&lt;:&quot;          */
    MAIN|                     /*  &quot;main&quot;        */
    IDENTIFIER|               /*  &quot;x&quot;           */
    INTEGER_LITERAL|          /*  e.g. &quot;1&quot;      */
    FLOAT_LITERAL|            /*  e.g. &quot;'1.0'&quot;  */
    COMMENT|                  /*  e.g. &quot;//xx&quot;     */
    NL|                       /*  newline         */
    END|                      /*  end of file     */
    SENTINEL|                 /*  &quot;;&quot;             */
    RUNE_LITERAL|             /*  e.g. &quot;r'x'&quot;      */
    STRING_LITERAL|           /*  e.g. &quot;&quot;xx&quot;&quot;     */
    JSTRING_LITERAL|          /*  e.g. &quot;J&quot;xx&quot;&quot;     */
    MULTILINE_STRING|         /*  e.g. &quot;&quot;&quot;&quot;aaa&quot;&quot;&quot;&quot;   */
    MULTILINE_RAW_STRING|     /*  e.g. &quot;#&quot;aaa&quot;#&quot;     */
    BOOL_LITERAL|             /*  &quot;true&quot; or &quot;false&quot;  */
    UNIT_LITERAL|             /*  &quot;()&quot;               */
    DOLLAR_IDENTIFIER|        /*  e.g. &quot;$x&quot;          */
    ANNOTATION|               /*  e.g. &quot;@When&quot;       */
    ILLEGAL
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="highlight.js"></script>
        <script src="assets/elasticlunr.js"></script>
        <script src="assets/fzf.umd.js"></script>
        <script src="assets/sidebar.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
