<!DOCTYPE HTML>
<html lang="zh-cn" class="ayu" dir="ltr">
    <head>
            <script type="text/x-mathjax-config">
                MathJax.Hub.Config({
                    showProcessingMessages: false,
                    messageStyle: "none",
                    extensions: ['tex2jax.js'],
                    jax: ['input/TeX', 'output/HTML-CSS'],
                    tex2jax: {
                        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
                        processEscapes: true
                    },
                    "HTML-CSS": { availableFonts: ["STIX", "TeX"] }
                });
            </script>
            
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>类 - 仓颉语言库 API</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../../favicon.svg">
        <link rel="shortcut icon" href="../../../favicon.png">
        <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
        <link rel="stylesheet" href="../../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../highlight.css">
        <link rel="stylesheet" href="../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../../assets/style.css">
        <link rel="stylesheet" href="../../../assets/theme.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('ayu')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../../../libs_overview.html"><strong aria-hidden="true">1.</strong> 仓颉编程语言库 API 概述</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> std 模块</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/std_module_overview.html"><strong aria-hidden="true">2.1.</strong> std 模块概述</a></li><li class="chapter-item "><div><strong aria-hidden="true">2.2.</strong> std.core 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/core/core_package_overview.html"><strong aria-hidden="true">2.2.1.</strong> core 包概述</a></li><li class="chapter-item "><a href="../../../std/core/core_package_api/core_package_funcs.html"><strong aria-hidden="true">2.2.2.</strong> 函数</a></li><li class="chapter-item "><a href="../../../std/core/core_package_api/core_package_types.html"><strong aria-hidden="true">2.2.3.</strong> 类型别名</a></li><li class="chapter-item "><a href="../../../std/core/core_package_api/core_package_intrinsics.html"><strong aria-hidden="true">2.2.4.</strong> 内置类型</a></li><li class="chapter-item "><a href="../../../std/core/core_package_api/core_package_interfaces.html"><strong aria-hidden="true">2.2.5.</strong> 接口</a></li><li class="chapter-item "><a href="../../../std/core/core_package_api/core_package_classes.html"><strong aria-hidden="true">2.2.6.</strong> 类</a></li><li class="chapter-item "><a href="../../../std/core/core_package_api/core_package_enums.html"><strong aria-hidden="true">2.2.7.</strong> 枚举</a></li><li class="chapter-item "><a href="../../../std/core/core_package_api/core_package_structs.html"><strong aria-hidden="true">2.2.8.</strong> 结构体</a></li><li class="chapter-item "><a href="../../../std/core/core_package_api/core_package_exceptions.html"><strong aria-hidden="true">2.2.9.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">2.2.10.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/core/core_samples/core_spawn_sample.html"><strong aria-hidden="true">2.2.10.1.</strong> 仓颉并发编程示例</a></li><li class="chapter-item "><a href="../../../std/core/core_samples/core_cstring_sample.html"><strong aria-hidden="true">2.2.10.2.</strong> 使用 CString 与 C 代码交互示例</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.3.</strong> std.argopt 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/argopt/argopt_package_overview.html"><strong aria-hidden="true">2.3.1.</strong> argopt 包概述</a></li><li class="chapter-item "><a href="../../../std/argopt/argopt_package_api/argopt_package_classes.html"><strong aria-hidden="true">2.3.2.</strong> 类</a></li><li class="chapter-item "><div><strong aria-hidden="true">2.3.3.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/argopt/argopt_samples/long_argument_parse.html"><strong aria-hidden="true">2.3.3.1.</strong> 长命令行参数解析</a></li><li class="chapter-item "><a href="../../../std/argopt/argopt_samples/short_argument_parse.html"><strong aria-hidden="true">2.3.3.2.</strong> 短命令行参数解析</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.4.</strong> std.ast 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/ast/ast_package_overview.html"><strong aria-hidden="true">2.4.1.</strong> ast 包概述</a></li><li class="chapter-item "><a href="../../../std/ast/ast_package_api/ast_package_funcs.html"><strong aria-hidden="true">2.4.2.</strong> 函数</a></li><li class="chapter-item "><a href="../../../std/ast/ast_package_api/ast_package_interfaces.html"><strong aria-hidden="true">2.4.3.</strong> 接口</a></li><li class="chapter-item expanded "><a href="../../../std/ast/ast_package_api/ast_package_classes.html" class="active"><strong aria-hidden="true">2.4.4.</strong> 类</a></li><li class="chapter-item "><a href="../../../std/ast/ast_package_api/ast_package_enums.html"><strong aria-hidden="true">2.4.5.</strong> 枚举</a></li><li class="chapter-item "><a href="../../../std/ast/ast_package_api/ast_package_structs.html"><strong aria-hidden="true">2.4.6.</strong> 结构体</a></li><li class="chapter-item "><a href="../../../std/ast/ast_package_api/ast_package_exceptions.html"><strong aria-hidden="true">2.4.7.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">2.4.8.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/ast/ast_samples/context.html"><strong aria-hidden="true">2.4.8.1.</strong> Macro With Context</a></li><li class="chapter-item "><a href="../../../std/ast/ast_samples/dump.html"><strong aria-hidden="true">2.4.8.2.</strong> 语法树节点打印</a></li><li class="chapter-item "><a href="../../../std/ast/ast_samples/operate.html"><strong aria-hidden="true">2.4.8.3.</strong> 操作 AST 对象示例</a></li><li class="chapter-item "><a href="../../../std/ast/ast_samples/parse.html"><strong aria-hidden="true">2.4.8.4.</strong> 将仓颉源码解析为 AST 对象示例</a></li><li class="chapter-item "><a href="../../../std/ast/ast_samples/report.html"><strong aria-hidden="true">2.4.8.5.</strong> 自定义报错接口</a></li><li class="chapter-item "><a href="../../../std/ast/ast_samples/traverse.html"><strong aria-hidden="true">2.4.8.6.</strong> 自定义访问函数遍历 AST 对象示例</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.5.</strong> std.binary 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/binary/binary_package_overview.html"><strong aria-hidden="true">2.5.1.</strong> binary 包概述</a></li><li class="chapter-item "><a href="../../../std/binary/binary_package_api/binary_package_interfaces.html"><strong aria-hidden="true">2.5.2.</strong> 接口</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.6.</strong> std.collection 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/collection/collection_package_overview.html"><strong aria-hidden="true">2.6.1.</strong> collection 包概述</a></li><li class="chapter-item "><a href="../../../std/collection/collection_package_api/collection_package_function.html"><strong aria-hidden="true">2.6.2.</strong> 函数</a></li><li class="chapter-item "><a href="../../../std/collection/collection_package_api/collection_package_interface.html"><strong aria-hidden="true">2.6.3.</strong> 接口</a></li><li class="chapter-item "><a href="../../../std/collection/collection_package_api/collection_package_class.html"><strong aria-hidden="true">2.6.4.</strong> 类</a></li><li class="chapter-item "><a href="../../../std/collection/collection_package_api/colleciton_package_struct.html"><strong aria-hidden="true">2.6.5.</strong> 结构体</a></li><li class="chapter-item "><a href="../../../std/collection/collection_package_api/collection_package_exception.html"><strong aria-hidden="true">2.6.6.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">2.6.7.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/collection/collection_package_samples/sample_arraylist_append_insert.html"><strong aria-hidden="true">2.6.7.1.</strong> ArrayList 的 append/insert 函数</a></li><li class="chapter-item "><a href="../../../std/collection/collection_package_samples/sample_arraylist_get_set.html"><strong aria-hidden="true">2.6.7.2.</strong> ArrayList 的 get/set 函数</a></li><li class="chapter-item "><a href="../../../std/collection/collection_package_samples/sample_arraylist_remove_clear_slice.html"><strong aria-hidden="true">2.6.7.3.</strong> ArrayList 的 remove/clear/slice 函数</a></li><li class="chapter-item "><a href="../../../std/collection/collection_package_samples/sample_hashmap_get_put_contains.html"><strong aria-hidden="true">2.6.7.4.</strong> Hashmap 的 get/put/contains 函数</a></li><li class="chapter-item "><a href="../../../std/collection/collection_package_samples/sample_hashmap_putall_remove_clear.html"><strong aria-hidden="true">2.6.7.5.</strong> HashMap 的 putAll/remove/clear 函数</a></li><li class="chapter-item "><a href="../../../std/collection/collection_package_samples/sample_hashset_put_iterator_remove.html"><strong aria-hidden="true">2.6.7.6.</strong> HashSet 的 put/iterator/remove 函数</a></li><li class="chapter-item "><a href="../../../std/collection/collection_package_samples/sample_iterator.html"><strong aria-hidden="true">2.6.7.7.</strong> 迭代器操作函数</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.7.</strong> std.collection.concurrent 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/collection_concurrent/collection_concurrent_package_overview.html"><strong aria-hidden="true">2.7.1.</strong> collection.concurrent 包概述</a></li><li class="chapter-item "><a href="../../../std/collection_concurrent/collection_concurrent_package_api/collection_concurrent_interface.html"><strong aria-hidden="true">2.7.2.</strong> 接口</a></li><li class="chapter-item "><a href="../../../std/collection_concurrent/collection_concurrent_package_api/collection_concurrent_class.html"><strong aria-hidden="true">2.7.3.</strong> 类</a></li><li class="chapter-item "><div><strong aria-hidden="true">2.7.4.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/collection_concurrent/collection_concurrent_samples/sample_concurrenthashmap.html"><strong aria-hidden="true">2.7.4.1.</strong> ConcurrentHashMap 使用示例</a></li><li class="chapter-item "><a href="../../../std/collection_concurrent/collection_concurrent_samples/sample_noblocking_queue.html"><strong aria-hidden="true">2.7.4.2.</strong> NonBlockingQueue 使用示例</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.8.</strong> std.console 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/console/console_package_overview.html"><strong aria-hidden="true">2.8.1.</strong> console 包概述</a></li><li class="chapter-item "><a href="../../../std/console/console_package_api/console_package_class.html"><strong aria-hidden="true">2.8.2.</strong> 类</a></li><li class="chapter-item "><div><strong aria-hidden="true">2.8.3.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/console/console_samples/console_sample.html"><strong aria-hidden="true">2.8.3.1.</strong> Console 示例</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.9.</strong> std.convert 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/convert/convert_package_overview.html"><strong aria-hidden="true">2.9.1.</strong> convert 包概述</a></li><li class="chapter-item "><a href="../../../std/convert/convert_package_api/convert_package_interfaces.html"><strong aria-hidden="true">2.9.2.</strong> 接口</a></li><li class="chapter-item "><div><strong aria-hidden="true">2.9.3.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/convert/convert_samples/convert_samples.html"><strong aria-hidden="true">2.9.3.1.</strong> covert 使用示例</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.10.</strong> std.crypto.digest 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/crypto/digest/digest_package_overview.html"><strong aria-hidden="true">2.10.1.</strong> crypto.digest 包概述</a></li><li class="chapter-item "><a href="../../../std/crypto/digest/digest_package_api/digest_package_funcs.html"><strong aria-hidden="true">2.10.2.</strong> 函数</a></li><li class="chapter-item "><a href="../../../std/crypto/digest/digest_package_api/digest_package_interfaces.html"><strong aria-hidden="true">2.10.3.</strong> 接口</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.11.</strong> std.crypto.cipher 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/crypto/cipher/cipher_package_overview.html"><strong aria-hidden="true">2.11.1.</strong> crypto.cipher 包概述</a></li><li class="chapter-item "><a href="../../../std/crypto/cipher/cipher_package_api/cipher_package_interfaces.html"><strong aria-hidden="true">2.11.2.</strong> 接口</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.12.</strong> std.database.sql 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/database_sql/database_sql_package_overview.html"><strong aria-hidden="true">2.12.1.</strong> database.sql 包概述</a></li><li class="chapter-item "><a href="../../../std/database_sql/database_sql_package_api/database_sql_package_interfaces.html"><strong aria-hidden="true">2.12.2.</strong> 接口</a></li><li class="chapter-item "><a href="../../../std/database_sql/database_sql_package_api/database_sql_package_classes.html"><strong aria-hidden="true">2.12.3.</strong> 类</a></li><li class="chapter-item "><a href="../../../std/database_sql/database_sql_package_api/database_sql_package_enums.html"><strong aria-hidden="true">2.12.4.</strong> 枚举</a></li><li class="chapter-item "><a href="../../../std/database_sql/database_sql_package_api/database_sql_package_exceptions.html"><strong aria-hidden="true">2.12.5.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">2.12.6.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/database_sql/database_sql_samples/db_driver.html"><strong aria-hidden="true">2.12.6.1.</strong> 实现数据库驱动查询功能示例</a></li><li class="chapter-item "><a href="../../../std/database_sql/database_sql_samples/db_get_connection.html"><strong aria-hidden="true">2.12.6.2.</strong> 获取数据库连接示例</a></li><li class="chapter-item "><a href="../../../std/database_sql/database_sql_samples/db_modify_table.html"><strong aria-hidden="true">2.12.6.3.</strong> 删除表、创建表示例</a></li><li class="chapter-item "><a href="../../../std/database_sql/database_sql_samples/db_operations.html"><strong aria-hidden="true">2.12.6.4.</strong> 执行数据库操作语句示例</a></li><li class="chapter-item "><a href="../../../std/database_sql/database_sql_samples/db_transactions.html"><strong aria-hidden="true">2.12.6.5.</strong> 执行事务控制语句示例</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.13.</strong> std.ffi.python 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/ffi_python/ffi_python_package_overview.html"><strong aria-hidden="true">2.13.1.</strong> ffi.python 包概述</a></li><li class="chapter-item "><a href="../../../std/ffi_python/ffi_python_package_api/ffi_python_package_constants_vars.html"><strong aria-hidden="true">2.13.2.</strong> 变量&常量</a></li><li class="chapter-item "><a href="../../../std/ffi_python/ffi_python_package_api/ffi_python_package_interface.html"><strong aria-hidden="true">2.13.3.</strong> 接口</a></li><li class="chapter-item "><a href="../../../std/ffi_python/ffi_python_package_api/ffi_python_package_classes.html"><strong aria-hidden="true">2.13.4.</strong> 类</a></li><li class="chapter-item "><a href="../../../std/ffi_python/ffi_python_package_api/ffi_python_package_exception.html"><strong aria-hidden="true">2.13.5.</strong> 异常类</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.14.</strong> std.format 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/format/format_package_overview.html"><strong aria-hidden="true">2.14.1.</strong> format 包概述</a></li><li class="chapter-item "><a href="../../../std/format/format_package_api/format_package_interfaces.html"><strong aria-hidden="true">2.14.2.</strong> 接口</a></li><li class="chapter-item "><div><strong aria-hidden="true">2.14.3.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/format/format_samples/format_samples.html"><strong aria-hidden="true">2.14.3.1.</strong> format 使用示例</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.15.</strong> std.fs 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/fs/fs_package_overview.html"><strong aria-hidden="true">2.15.1.</strong> fs 包概述</a></li><li class="chapter-item "><a href="../../../std/fs/fs_package_api/fs_package_classes.html"><strong aria-hidden="true">2.15.2.</strong> 类</a></li><li class="chapter-item "><a href="../../../std/fs/fs_package_api/fs_package_enums.html"><strong aria-hidden="true">2.15.3.</strong> 枚举</a></li><li class="chapter-item "><a href="../../../std/fs/fs_package_api/fs_package_structs.html"><strong aria-hidden="true">2.15.4.</strong> 结构体</a></li><li class="chapter-item "><a href="../../../std/fs/fs_package_api/fs_package_exceptions.html"><strong aria-hidden="true">2.15.5.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">2.15.6.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/fs/fs_samples/directory_samples.html"><strong aria-hidden="true">2.15.6.1.</strong> Directory 示例</a></li><li class="chapter-item "><a href="../../../std/fs/fs_samples/file_samples.html"><strong aria-hidden="true">2.15.6.2.</strong> File 示例</a></li><li class="chapter-item "><a href="../../../std/fs/fs_samples/fileinfo_samples.html"><strong aria-hidden="true">2.15.6.3.</strong> FileInfo 示例</a></li><li class="chapter-item "><a href="../../../std/fs/fs_samples/path_samples.html"><strong aria-hidden="true">2.15.6.4.</strong> Path 示例</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.16.</strong> std.io 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/io/io_package_overview.html"><strong aria-hidden="true">2.16.1.</strong> io 包概述</a></li><li class="chapter-item "><a href="../../../std/io/io_package_api/io_package_interfaces.html"><strong aria-hidden="true">2.16.2.</strong> 接口</a></li><li class="chapter-item "><a href="../../../std/io/io_package_api/io_package_classes.html"><strong aria-hidden="true">2.16.3.</strong> 类</a></li><li class="chapter-item "><a href="../../../std/io/io_package_api/io_package_enums.html"><strong aria-hidden="true">2.16.4.</strong> 枚举</a></li><li class="chapter-item "><a href="../../../std/io/io_package_api/io_package_exceptions.html"><strong aria-hidden="true">2.16.5.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">2.16.6.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/io/io_samples/buffered_input_stream.html"><strong aria-hidden="true">2.16.6.1.</strong> BufferedInputStream 示例</a></li><li class="chapter-item "><a href="../../../std/io/io_samples/buffered_output_stream.html"><strong aria-hidden="true">2.16.6.2.</strong> BufferedOutputStream 示例</a></li><li class="chapter-item "><a href="../../../std/io/io_samples/byte_array_stream.html"><strong aria-hidden="true">2.16.6.3.</strong> ByteArrayStream 示例</a></li><li class="chapter-item "><a href="../../../std/io/io_samples/chained_input_stream.html"><strong aria-hidden="true">2.16.6.4.</strong> ChainedInputStream 示例</a></li><li class="chapter-item "><a href="../../../std/io/io_samples/multi_output_stream.html"><strong aria-hidden="true">2.16.6.5.</strong> MultiOutputStream 示例</a></li><li class="chapter-item "><a href="../../../std/io/io_samples/string_reader.html"><strong aria-hidden="true">2.16.6.6.</strong> StringReader 示例</a></li><li class="chapter-item "><a href="../../../std/io/io_samples/string_writer.html"><strong aria-hidden="true">2.16.6.7.</strong> StringWriter 示例</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.17.</strong> std.log 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/log/stdlog_package_overview.html"><strong aria-hidden="true">2.17.1.</strong> log 包概述</a></li><li class="chapter-item "><a href="../../../std/log/stdlog_package_api/stdlog_package_interfaces.html"><strong aria-hidden="true">2.17.2.</strong> 接口</a></li><li class="chapter-item "><a href="../../../std/log/stdlog_package_api/stdlog_package_classes.html"><strong aria-hidden="true">2.17.3.</strong> 类</a></li><li class="chapter-item "><a href="../../../std/log/stdlog_package_api/stdlog_package_enums.html"><strong aria-hidden="true">2.17.4.</strong> 枚举</a></li><li class="chapter-item "><div><strong aria-hidden="true">2.17.5.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/log/stdlog_samples/stdlog_sample.html"><strong aria-hidden="true">2.17.5.1.</strong> 日志打印示例</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.18.</strong> std.math 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/math/math_package_overview.html"><strong aria-hidden="true">2.18.1.</strong> math 包概述</a></li><li class="chapter-item "><a href="../../../std/math/math_package_api/math_package_funcs.html"><strong aria-hidden="true">2.18.2.</strong> 函数</a></li><li class="chapter-item "><a href="../../../std/math/math_package_api/math_package_interfaces.html"><strong aria-hidden="true">2.18.3.</strong> 接口</a></li><li class="chapter-item "><div><strong aria-hidden="true">2.18.4.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/math/math_samples/math_basic_operation.html"><strong aria-hidden="true">2.18.4.1.</strong> 数学基础运算示例</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.19.</strong> std.math.numeric 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/math_numeric/math_numeric_package_overview.html"><strong aria-hidden="true">2.19.1.</strong> math.numeric 包概述</a></li><li class="chapter-item "><a href="../../../std/math_numeric/math_numeric_package_api/math_numeric_package_funcs.html"><strong aria-hidden="true">2.19.2.</strong> 函数</a></li><li class="chapter-item "><a href="../../../std/math_numeric/math_numeric_package_api/math_numeric_package_enums.html"><strong aria-hidden="true">2.19.3.</strong> 枚举</a></li><li class="chapter-item "><a href="../../../std/math_numeric/math_numeric_package_api/math_numeric_package_structs.html"><strong aria-hidden="true">2.19.4.</strong> 结构体</a></li><li class="chapter-item "><div><strong aria-hidden="true">2.19.5.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/math_numeric/math_numeric_samples/bigInt_basic_arithmetic.html"><strong aria-hidden="true">2.19.5.1.</strong> BigInt 基础数学运算示例</a></li><li class="chapter-item "><a href="../../../std/math_numeric/math_numeric_samples/bigInt_basic_prop.html"><strong aria-hidden="true">2.19.5.2.</strong> BigInt 基本属性示例</a></li><li class="chapter-item "><a href="../../../std/math_numeric/math_numeric_samples/bigInt_compare_opration.html"><strong aria-hidden="true">2.19.5.3.</strong> BigInt 大小比较示例</a></li><li class="chapter-item "><a href="../../../std/math_numeric/math_numeric_samples/decimal_basic_arithmetic.html"><strong aria-hidden="true">2.19.5.4.</strong> Decimal 基础数学运算示例</a></li><li class="chapter-item "><a href="../../../std/math_numeric/math_numeric_samples/decimal_basic_prop.html"><strong aria-hidden="true">2.19.5.5.</strong> Decimal 基本属性示例</a></li><li class="chapter-item "><a href="../../../std/math_numeric/math_numeric_samples/decimal_compare_opration.html"><strong aria-hidden="true">2.19.5.6.</strong> Decimal 大小比较示例</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.20.</strong> std.objectpool 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/objectpool/objectpool_package_overview.html"><strong aria-hidden="true">2.20.1.</strong> objectpool 包概述</a></li><li class="chapter-item "><a href="../../../std/objectpool/objectpool_package_api/objectpool_package_classes.html"><strong aria-hidden="true">2.20.2.</strong> 类</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.21.</strong> std.os 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/os/os_package_overview.html"><strong aria-hidden="true">2.21.1.</strong> os 包概述</a></li><li class="chapter-item "><a href="../../../std/os/os_package_api/os_package_funcs.html"><strong aria-hidden="true">2.21.2.</strong> 函数</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.22.</strong> std.os.posix 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/os_posix/os_posix_package_overview.html"><strong aria-hidden="true">2.22.1.</strong> os.posix 包概述</a></li><li class="chapter-item "><a href="../../../std/os_posix/os_posix_package_api/os_posix_package_constants_vars.html"><strong aria-hidden="true">2.22.2.</strong> 变量&常量</a></li><li class="chapter-item "><a href="../../../std/os_posix/os_posix_package_api/os_posix_package_funcs.html"><strong aria-hidden="true">2.22.3.</strong> 函数</a></li><li class="chapter-item "><div><strong aria-hidden="true">2.22.4.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/os_posix/os_posix_samples/os_posix_get_file_content_samples.html"><strong aria-hidden="true">2.22.4.1.</strong> 文件内容相关操作</a></li><li class="chapter-item "><a href="../../../std/os_posix/os_posix_samples/os_posix_get_file_info_samples.html"><strong aria-hidden="true">2.22.4.2.</strong> 文件信息相关操作</a></li><li class="chapter-item "><a href="../../../std/os_posix/os_posix_samples/os_posix_get_os_envinfo_samples.html"><strong aria-hidden="true">2.22.4.3.</strong> 获取各类系统信息</a></li><li class="chapter-item "><a href="../../../std/os_posix/os_posix_samples/os_posix_process_samples.html"><strong aria-hidden="true">2.22.4.4.</strong> 进程相关信息操作</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.23.</strong> std.os.process 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/os_process/os_process_package_overview.html"><strong aria-hidden="true">2.23.1.</strong> os.process 包概述</a></li><li class="chapter-item "><a href="../../../std/os_process/os_process_package_api/os_process_package_classes.html"><strong aria-hidden="true">2.23.2.</strong> 类</a></li><li class="chapter-item "><a href="../../../std/os_process/os_process_package_api/os_process_package_enums.html"><strong aria-hidden="true">2.23.3.</strong> 枚举</a></li><li class="chapter-item "><a href="../../../std/os_process/os_process_package_api/os_process_package_exceptions.html"><strong aria-hidden="true">2.23.4.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">2.23.5.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/os_process/os_process_samples/os_process_currentprocess_sample.html"><strong aria-hidden="true">2.23.5.1.</strong> 当前进程相关操作</a></li><li class="chapter-item "><a href="../../../std/os_process/os_process_samples/os_process_rm_file_win_platform_sample.html"><strong aria-hidden="true">2.23.5.2.</strong> Windows 平台子进程结束后删除子进程可执行文件</a></li><li class="chapter-item "><a href="../../../std/os_process/os_process_samples/os_process_sample.html"><strong aria-hidden="true">2.23.5.3.</strong> 任意进程相关操作</a></li><li class="chapter-item "><a href="../../../std/os_process/os_process_samples/os_process_subprocess_sample.html"><strong aria-hidden="true">2.23.5.4.</strong> 子进程相关操作</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.24.</strong> std.overflow 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/overflow/overflow_package_overview.html"><strong aria-hidden="true">2.24.1.</strong> overflow 包概述</a></li><li class="chapter-item "><a href="../../../std/overflow/overflow_package_api/overflow_package_interfaces.html"><strong aria-hidden="true">2.24.2.</strong> 接口</a></li><li class="chapter-item "><a href="../../../std/overflow/overflow_package_api/overflow_package_exceptions.html"><strong aria-hidden="true">2.24.3.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">2.24.4.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/overflow/overflow_samples/option.html"><strong aria-hidden="true">2.24.4.1.</strong> 返回 Option 策略的示例</a></li><li class="chapter-item "><a href="../../../std/overflow/overflow_samples/saturating.html"><strong aria-hidden="true">2.24.4.2.</strong> 饱和策略的示例</a></li><li class="chapter-item "><a href="../../../std/overflow/overflow_samples/throwing.html"><strong aria-hidden="true">2.24.4.3.</strong> 抛出异常策略的示例</a></li><li class="chapter-item "><a href="../../../std/overflow/overflow_samples/wrapping.html"><strong aria-hidden="true">2.24.4.4.</strong> 高位截断策略的示例</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.25.</strong> std.random 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/random/random_package_overview.html"><strong aria-hidden="true">2.25.1.</strong> random 包概述</a></li><li class="chapter-item "><a href="../../../std/random/random_package_api/random_package_classes.html"><strong aria-hidden="true">2.25.2.</strong> 类</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.26.</strong> std.reflect 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/reflect/reflect_package_overview.html"><strong aria-hidden="true">2.26.1.</strong> reflect 包概述</a></li><li class="chapter-item "><a href="../../../std/reflect/reflect_package_api/reflect_package_funcs.html"><strong aria-hidden="true">2.26.2.</strong> 函数</a></li><li class="chapter-item "><a href="../../../std/reflect/reflect_package_api/reflect_package_classes.html"><strong aria-hidden="true">2.26.3.</strong> 类</a></li><li class="chapter-item "><a href="../../../std/reflect/reflect_package_api/reflect_package_enums.html"><strong aria-hidden="true">2.26.4.</strong> 枚举</a></li><li class="chapter-item "><a href="../../../std/reflect/reflect_package_api/reflect_package_exceptions.html"><strong aria-hidden="true">2.26.5.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">2.26.6.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/reflect/reflect_samples/annotation.html"><strong aria-hidden="true">2.26.6.1.</strong> 注解的使用</a></li><li class="chapter-item "><a href="../../../std/reflect/reflect_samples/dynload.html"><strong aria-hidden="true">2.26.6.2.</strong> 动态加载的使用</a></li><li class="chapter-item "><a href="../../../std/reflect/reflect_samples/memberInfo.html"><strong aria-hidden="true">2.26.6.3.</strong> 成员信息的使用</a></li><li class="chapter-item "><a href="../../../std/reflect/reflect_samples/typeInfo.html"><strong aria-hidden="true">2.26.6.4.</strong> TypeInfo 的使用</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.27.</strong> std.regex 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/regex/regex_package_overview.html"><strong aria-hidden="true">2.27.1.</strong> regex 包概述</a></li><li class="chapter-item "><a href="../../../std/regex/regex_package_api/regex_package_classes.html"><strong aria-hidden="true">2.27.2.</strong> 类</a></li><li class="chapter-item "><a href="../../../std/regex/regex_package_api/regex_package_structs.html"><strong aria-hidden="true">2.27.3.</strong> 结构体</a></li><li class="chapter-item "><a href="../../../std/regex/regex_package_api/regex_package_exceptions.html"><strong aria-hidden="true">2.27.4.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">2.27.5.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/regex/regex_samples/regex_sample.html"><strong aria-hidden="true">2.27.5.1.</strong> Regex 示例</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.28.</strong> std.runtime 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/runtime/runtime_package_overview.html"><strong aria-hidden="true">2.28.1.</strong> runtime 包概述</a></li><li class="chapter-item "><a href="../../../std/runtime/runtime_package_api/runtime_package_funcs.html"><strong aria-hidden="true">2.28.2.</strong> 函数</a></li><li class="chapter-item "><a href="../../../std/runtime/runtime_package_api/runtime_package_structs.html"><strong aria-hidden="true">2.28.3.</strong> 结构体</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.29.</strong> std.socket 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/socket/socket_package_overview.html"><strong aria-hidden="true">2.29.1.</strong> socket 包概述</a></li><li class="chapter-item "><a href="../../../std/socket/socket_package_api/socket_package_constants_vars.html"><strong aria-hidden="true">2.29.2.</strong> 变量&常量</a></li><li class="chapter-item "><a href="../../../std/socket/socket_package_api/socket_package_interfaces.html"><strong aria-hidden="true">2.29.3.</strong> 接口</a></li><li class="chapter-item "><a href="../../../std/socket/socket_package_api/socket_package_classes.html"><strong aria-hidden="true">2.29.4.</strong> 类</a></li><li class="chapter-item "><a href="../../../std/socket/socket_package_api/socket_package_enums.html"><strong aria-hidden="true">2.29.5.</strong> 枚举</a></li><li class="chapter-item "><a href="../../../std/socket/socket_package_api/socket_package_structs.html"><strong aria-hidden="true">2.29.6.</strong> 结构体</a></li><li class="chapter-item "><a href="../../../std/socket/socket_package_api/socket_package_exceptions.html"><strong aria-hidden="true">2.29.7.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">2.29.8.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/socket/socket_samples/socket_option.html"><strong aria-hidden="true">2.29.8.1.</strong> 属性配置使用用例</a></li><li class="chapter-item "><a href="../../../std/socket/socket_samples/tcp.html"><strong aria-hidden="true">2.29.8.2.</strong> TCP 使用示例</a></li><li class="chapter-item "><a href="../../../std/socket/socket_samples/udp.html"><strong aria-hidden="true">2.29.8.3.</strong> UDP 使用示例</a></li><li class="chapter-item "><a href="../../../std/socket/socket_samples/unix.html"><strong aria-hidden="true">2.29.8.4.</strong> UNIX 使用示例</a></li><li class="chapter-item "><a href="../../../std/socket/socket_samples/unix_datagram.html"><strong aria-hidden="true">2.29.8.5.</strong> UnixDatagram 使用示例</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.30.</strong> std.sort 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/sort/sort_package_overview.html"><strong aria-hidden="true">2.30.1.</strong> sort 包概述</a></li><li class="chapter-item "><a href="../../../std/sort/sort_package_api/sort_package_funcs.html"><strong aria-hidden="true">2.30.2.</strong> 函数</a></li><li class="chapter-item "><a href="../../../std/sort/sort_package_api/sort_package_interfaces.html"><strong aria-hidden="true">2.30.3.</strong> 接口</a></li><li class="chapter-item "><div><strong aria-hidden="true">2.30.4.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/sort/sort_samples/sort_sample_array.html"><strong aria-hidden="true">2.30.4.1.</strong> 对 Array 进行排序</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.31.</strong> std.sync 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/sync/sync_package_overview.html"><strong aria-hidden="true">2.31.1.</strong> sync 包概述</a></li><li class="chapter-item "><a href="../../../std/sync/sync_package_api/sync_package_constants_vars.html"><strong aria-hidden="true">2.31.2.</strong> 变量&常量</a></li><li class="chapter-item "><a href="../../../std/sync/sync_package_api/sync_package_funcs.html"><strong aria-hidden="true">2.31.3.</strong> 函数</a></li><li class="chapter-item "><a href="../../../std/sync/sync_package_api/sync_package_interfaces.html"><strong aria-hidden="true">2.31.4.</strong> 接口</a></li><li class="chapter-item "><a href="../../../std/sync/sync_package_api/sync_package_classes.html"><strong aria-hidden="true">2.31.5.</strong> 类</a></li><li class="chapter-item "><a href="../../../std/sync/sync_package_api/sync_package_enums.html"><strong aria-hidden="true">2.31.6.</strong> 枚举</a></li><li class="chapter-item "><a href="../../../std/sync/sync_package_api/sync_package_structs.html"><strong aria-hidden="true">2.31.7.</strong> 结构体</a></li><li class="chapter-item "><a href="../../../std/sync/sync_package_api/sync_package_exceptions.html"><strong aria-hidden="true">2.31.8.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">2.31.9.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/sync/sync_samples/sync_samples.html"><strong aria-hidden="true">2.31.9.1.</strong> 示例</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.32.</strong> std.time 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/time/time_package_overview.html"><strong aria-hidden="true">2.32.1.</strong> time 包概述</a></li><li class="chapter-item "><a href="../../../std/time/time_package_api/time_package_interfaces.html"><strong aria-hidden="true">2.32.2.</strong> 接口</a></li><li class="chapter-item "><a href="../../../std/time/time_package_api/time_package_classes.html"><strong aria-hidden="true">2.32.3.</strong> 类</a></li><li class="chapter-item "><a href="../../../std/time/time_package_api/time_package_enums.html"><strong aria-hidden="true">2.32.4.</strong> 枚举</a></li><li class="chapter-item "><a href="../../../std/time/time_package_api/time_package_structs.html"><strong aria-hidden="true">2.32.5.</strong> 结构体</a></li><li class="chapter-item "><a href="../../../std/time/time_package_api/time_package_exceptions.html"><strong aria-hidden="true">2.32.6.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">2.32.7.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/time/time_samples/datetime_compare.html"><strong aria-hidden="true">2.32.7.1.</strong> DateTime 比较</a></li><li class="chapter-item "><a href="../../../std/time/time_samples/datetime_parse.html"><strong aria-hidden="true">2.32.7.2.</strong> DateTime 与 String 类型的转换</a></li><li class="chapter-item "><a href="../../../std/time/time_samples/datetime_prop.html"><strong aria-hidden="true">2.32.7.3.</strong> 获取日期时间信息</a></li><li class="chapter-item "><a href="../../../std/time/time_samples/datetime_tz.html"><strong aria-hidden="true">2.32.7.4.</strong> 同一时间在不同时区的本地时间</a></li><li class="chapter-item "><a href="../../../std/time/time_samples/monotime_test.html"><strong aria-hidden="true">2.32.7.5.</strong> 利用 MonoTime 作计时</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.33.</strong> std.unicode 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/unicode/unicode_package_overview.html"><strong aria-hidden="true">2.33.1.</strong> unicode 包概述</a></li><li class="chapter-item "><a href="../../../std/unicode/unicode_package_api/unicode_package_interfaces.html"><strong aria-hidden="true">2.33.2.</strong> 接口</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.34.</strong> std.unittest 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/unittest/unittest_package_overview.html"><strong aria-hidden="true">2.34.1.</strong> unittest 包概述</a></li><li class="chapter-item "><a href="../../../std/unittest/unittest_package_api/unittest_package_functions.html"><strong aria-hidden="true">2.34.2.</strong> 函数</a></li><li class="chapter-item "><a href="../../../std/unittest/unittest_package_api/unittest_package_interfaces.html"><strong aria-hidden="true">2.34.3.</strong> 接口</a></li><li class="chapter-item "><a href="../../../std/unittest/unittest_package_api/unittest_package_classes.html"><strong aria-hidden="true">2.34.4.</strong> 类</a></li><li class="chapter-item "><a href="../../../std/unittest/unittest_package_api/unittest_package_enums.html"><strong aria-hidden="true">2.34.5.</strong> 枚举</a></li><li class="chapter-item "><a href="../../../std/unittest/unittest_package_api/unittest_package_structs.html"><strong aria-hidden="true">2.34.6.</strong> 结构体</a></li><li class="chapter-item "><div><strong aria-hidden="true">2.34.7.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/unittest/unittest_samples/unittest_getting_started.html"><strong aria-hidden="true">2.34.7.1.</strong> 快速入门</a></li><li class="chapter-item "><a href="../../../std/unittest/unittest_samples/unittest_basics.html"><strong aria-hidden="true">2.34.7.2.</strong> 基础概念</a></li><li class="chapter-item "><a href="../../../std/unittest/unittest_samples/unittest_parameterized_tests.html"><strong aria-hidden="true">2.34.7.3.</strong> 参数化测试</a></li><li class="chapter-item "><a href="../../../std/unittest/unittest_samples/unittest_dynamic_tests.html"><strong aria-hidden="true">2.34.7.4.</strong> 动态测试</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.35.</strong> std.unittest.mock 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/unittest_mock/unittest_mock_package_overview.html"><strong aria-hidden="true">2.35.1.</strong> unittest.mock 包概述</a></li><li class="chapter-item "><a href="../../../std/unittest_mock/unittest_mock_package_api/unittest_mock_package_functions.html"><strong aria-hidden="true">2.35.2.</strong> 函数</a></li><li class="chapter-item "><a href="../../../std/unittest_mock/unittest_mock_package_api/unittest_mock_package_interfaces.html"><strong aria-hidden="true">2.35.3.</strong> 接口</a></li><li class="chapter-item "><a href="../../../std/unittest_mock/unittest_mock_package_api/unittest_mock_package_classes.html"><strong aria-hidden="true">2.35.4.</strong> 类</a></li><li class="chapter-item "><a href="../../../std/unittest_mock/unittest_mock_package_api/unittest_mock_package_enums.html"><strong aria-hidden="true">2.35.5.</strong> 枚举</a></li><li class="chapter-item "><a href="../../../std/unittest_mock/unittest_mock_package_api/unittest_mock_package_macros.html"><strong aria-hidden="true">2.35.6.</strong> 宏</a></li><li class="chapter-item "><div><strong aria-hidden="true">2.35.7.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/unittest_mock/unittest_mock_samples/mock_framework_getting_started.html"><strong aria-hidden="true">2.35.7.1.</strong> 快速入门</a></li><li class="chapter-item "><a href="../../../std/unittest_mock/unittest_mock_samples/mock_framework_basics.html"><strong aria-hidden="true">2.35.7.2.</strong> 基础概念</a></li><li class="chapter-item "><a href="../../../std/unittest_mock/unittest_mock_samples/mock_framework_stubs.html"><strong aria-hidden="true">2.35.7.3.</strong> 桩</a></li><li class="chapter-item "><a href="../../../std/unittest_mock/unittest_mock_samples/mock_framework_verification.html"><strong aria-hidden="true">2.35.7.4.</strong> 验证</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">2.36.</strong> std.unittest.testmacro 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../std/unittest_testmacro/unittest_testmacro_package_overview.html"><strong aria-hidden="true">2.36.1.</strong> unittest.testmacro 包概述</a></li><li class="chapter-item "><a href="../../../std/unittest_testmacro/unittest_testmacro_package_api/unittest_testmacro_package_macros.html"><strong aria-hidden="true">2.36.2.</strong> 宏</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">3.</strong> compress 模块</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../compress/compress_module_overview.html"><strong aria-hidden="true">3.1.</strong> compress 模块概述</a></li><li class="chapter-item "><div><strong aria-hidden="true">3.2.</strong> compress.zlib 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../compress/zlib/zlib_package_overview.html"><strong aria-hidden="true">3.2.1.</strong> zlib 包概述</a></li><li class="chapter-item "><a href="../../../compress/zlib/zlib_package_api/zlib_package_classes.html"><strong aria-hidden="true">3.2.2.</strong> 类</a></li><li class="chapter-item "><a href="../../../compress/zlib/zlib_package_api/zlib_package_enums.html"><strong aria-hidden="true">3.2.3.</strong> 枚举</a></li><li class="chapter-item "><a href="../../../compress/zlib/zlib_package_api/zlib_package_exceptions.html"><strong aria-hidden="true">3.2.4.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">3.2.5.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../compress/zlib/zlib_samples/deflate_compress_decompress.html"><strong aria-hidden="true">3.2.5.1.</strong> Deflate 格式数据的压缩和解压</a></li><li class="chapter-item "><a href="../../../compress/zlib/zlib_samples/gzip_compress_decompress.html"><strong aria-hidden="true">3.2.5.2.</strong> Gzip 格式数据的压缩和解压</a></li></ol></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">4.</strong> crypto 模块</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../crypto/crypto_module_overview.html"><strong aria-hidden="true">4.1.</strong> crypto 模块概述</a></li><li class="chapter-item "><div><strong aria-hidden="true">4.2.</strong> crypto.crypto 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../crypto/crypto/crypto_package_overview.html"><strong aria-hidden="true">4.2.1.</strong> crypto 包概述</a></li><li class="chapter-item "><a href="../../../crypto/crypto/crypto_package_api/crypto_package_classes.html"><strong aria-hidden="true">4.2.2.</strong> 类</a></li><li class="chapter-item "><a href="../../../crypto/crypto/crypto_package_api/crypto_package_structs.html"><strong aria-hidden="true">4.2.3.</strong> 结构体</a></li><li class="chapter-item "><a href="../../../crypto/crypto/crypto_package_api/crypto_package_exceptions.html"><strong aria-hidden="true">4.2.4.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">4.2.5.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../crypto/crypto/crypto_samples/sample_secure_random.html"><strong aria-hidden="true">4.2.5.1.</strong> SecureRandom 使用</a></li><li class="chapter-item "><a href="../../../crypto/crypto/crypto_samples/sample_crypto.html"><strong aria-hidden="true">4.2.5.2.</strong> SM4 使用</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">4.3.</strong> crypto.digest 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../crypto/digest/digest_package_overview.html"><strong aria-hidden="true">4.3.1.</strong> digest 包概述</a></li><li class="chapter-item "><a href="../../../crypto/digest/digest_package_api/digest_package_classes.html"><strong aria-hidden="true">4.3.2.</strong> 类</a></li><li class="chapter-item "><a href="../../../crypto/digest/digest_package_api/digest_package_structs.html"><strong aria-hidden="true">4.3.3.</strong> 结构体</a></li><li class="chapter-item "><a href="../../../crypto/digest/digest_package_api/digest_package_exceptions.html"><strong aria-hidden="true">4.3.4.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">4.3.5.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../crypto/digest/digest_samples/sample_digest.html"><strong aria-hidden="true">4.3.5.1.</strong> digest 使用</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">4.4.</strong> crypto.keys 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../crypto/keys/keys_package_overview.html"><strong aria-hidden="true">4.4.1.</strong> keys 包概述</a></li><li class="chapter-item "><a href="../../../crypto/keys/keys_package_api/keys_package_classes.html"><strong aria-hidden="true">4.4.2.</strong> 类</a></li><li class="chapter-item "><a href="../../../crypto/keys/keys_package_api/keys_package_enums.html"><strong aria-hidden="true">4.4.3.</strong> 枚举</a></li><li class="chapter-item "><a href="../../../crypto/keys/keys_package_api/keys_package_structs.html"><strong aria-hidden="true">4.4.4.</strong> 结构体</a></li><li class="chapter-item "><div><strong aria-hidden="true">4.4.5.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../crypto/keys/keys_samples/sample_keys.html"><strong aria-hidden="true">4.4.5.1.</strong> keys 使用</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">4.5.</strong> crypto.x509 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../crypto/x509/x509_package_overview.html"><strong aria-hidden="true">4.5.1.</strong> x509 包概述</a></li><li class="chapter-item "><a href="../../../crypto/x509/x509_package_api/x509_package_type.html"><strong aria-hidden="true">4.5.2.</strong> 类型别名</a></li><li class="chapter-item "><a href="../../../crypto/x509/x509_package_api/x509_package_interfaces.html"><strong aria-hidden="true">4.5.3.</strong> 接口</a></li><li class="chapter-item "><a href="../../../crypto/x509/x509_package_api/x509_package_classes.html"><strong aria-hidden="true">4.5.4.</strong> 类</a></li><li class="chapter-item "><a href="../../../crypto/x509/x509_package_api/x509_package_enums.html"><strong aria-hidden="true">4.5.5.</strong> 枚举</a></li><li class="chapter-item "><a href="../../../crypto/x509/x509_package_api/x509_package_structs.html"><strong aria-hidden="true">4.5.6.</strong> 结构体</a></li><li class="chapter-item "><a href="../../../crypto/x509/x509_package_api/x509_package_exceptions.html"><strong aria-hidden="true">4.5.7.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">4.5.8.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../crypto/x509/x509_samples/sample_x509.html"><strong aria-hidden="true">4.5.8.1.</strong> x509 使用</a></li></ol></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">5.</strong> encoding 模块</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../encoding/encoding_module_overview.html"><strong aria-hidden="true">5.1.</strong> encoding 模块概述</a></li><li class="chapter-item "><div><strong aria-hidden="true">5.2.</strong> encoding.base64 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../encoding/base64/base64_package_overview.html"><strong aria-hidden="true">5.2.1.</strong> base64 包概述</a></li><li class="chapter-item "><a href="../../../encoding/base64/base64_package_api/base64_package_funcs.html"><strong aria-hidden="true">5.2.2.</strong> 函数</a></li><li class="chapter-item "><div><strong aria-hidden="true">5.2.3.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../encoding/base64/base64_samples/base64.html"><strong aria-hidden="true">5.2.3.1.</strong> Byte 数组和 Base64 互转</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">5.3.</strong> encoding.hex 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../encoding/hex/hex_package_overview.html"><strong aria-hidden="true">5.3.1.</strong> hex 包概述</a></li><li class="chapter-item "><a href="../../../encoding/hex/hex_package_api/hex_package_funcs.html"><strong aria-hidden="true">5.3.2.</strong> 函数</a></li><li class="chapter-item "><div><strong aria-hidden="true">5.3.3.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../encoding/hex/hex_samples/hex.html"><strong aria-hidden="true">5.3.3.1.</strong> Byte 数组和 Hex 互转</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">5.4.</strong> encoding.json 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../encoding/json/json_package_overview.html"><strong aria-hidden="true">5.4.1.</strong> json 包概述</a></li><li class="chapter-item "><a href="../../../encoding/json/json_package_api/encoding_json_package_interfaces.html"><strong aria-hidden="true">5.4.2.</strong> 接口</a></li><li class="chapter-item "><a href="../../../encoding/json/json_package_api/encoding_json_package_classes.html"><strong aria-hidden="true">5.4.3.</strong> 类</a></li><li class="chapter-item "><a href="../../../encoding/json/json_package_api/encoding_json_package_enums.html"><strong aria-hidden="true">5.4.4.</strong> 枚举</a></li><li class="chapter-item "><a href="../../../encoding/json/json_package_api/encoding_json_package_exceptions.html"><strong aria-hidden="true">5.4.5.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">5.4.6.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../encoding/json/json_samples/json_array_sample.html"><strong aria-hidden="true">5.4.6.1.</strong> JsonArray 使用示例</a></li><li class="chapter-item "><a href="../../../encoding/json/json_samples/json_value_sample.html"><strong aria-hidden="true">5.4.6.2.</strong> JsonValue 和 String 互相转换</a></li><li class="chapter-item "><a href="../../../encoding/json/json_samples/to_json_sample.html"><strong aria-hidden="true">5.4.6.3.</strong> JsonValue 与 DataModel 的转换</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">5.5.</strong> encoding.json.stream 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../encoding/json_stream/json_stream_package_overview.html"><strong aria-hidden="true">5.5.1.</strong> json.stream 包概述</a></li><li class="chapter-item "><a href="../../../encoding/json_stream/json_stream_package_api/encoding_json_stream_package_interfaces.html"><strong aria-hidden="true">5.5.2.</strong> 接口</a></li><li class="chapter-item "><a href="../../../encoding/json_stream/json_stream_package_api/encoding_json_stream_package_classes.html"><strong aria-hidden="true">5.5.3.</strong> 类</a></li><li class="chapter-item "><a href="../../../encoding/json_stream/json_stream_package_api/encoding_json_stream_package_enums.html"><strong aria-hidden="true">5.5.4.</strong> 枚举</a></li><li class="chapter-item "><a href="../../../encoding/json_stream/json_stream_package_api/encoding_json_stream_package_structs.html"><strong aria-hidden="true">5.5.5.</strong> 结构体</a></li><li class="chapter-item "><div><strong aria-hidden="true">5.5.6.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../encoding/json_stream/json_stream_samples/sample_json_reader.html"><strong aria-hidden="true">5.5.6.1.</strong> 使用 Json Stream 进行反序列化</a></li><li class="chapter-item "><a href="../../../encoding/json_stream/json_stream_samples/sample_json_writer.html"><strong aria-hidden="true">5.5.6.2.</strong> 使用 Json Stream 进行序列化</a></li><li class="chapter-item "><a href="../../../encoding/json_stream/json_stream_samples/sample_json_writeconfig.html"><strong aria-hidden="true">5.5.6.3.</strong> WriteConfig 使用示例</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">5.6.</strong> encoding.url 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../encoding/url/url_package_overview.html"><strong aria-hidden="true">5.6.1.</strong> url 包概述</a></li><li class="chapter-item "><a href="../../../encoding/url/url_package_api/url_package_classes.html"><strong aria-hidden="true">5.6.2.</strong> 类</a></li><li class="chapter-item "><a href="../../../encoding/url/url_package_api/url_package_exceptions.html"><strong aria-hidden="true">5.6.3.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">5.6.4.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../encoding/url/url_samples/form.html"><strong aria-hidden="true">5.6.4.1.</strong> Form 的构造使用</a></li><li class="chapter-item "><a href="../../../encoding/url/url_samples/url_parse.html"><strong aria-hidden="true">5.6.4.2.</strong> URL 解析函数 parse 的使用</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">5.7.</strong> encoding.xml 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../encoding/xml/xml_package_overview.html"><strong aria-hidden="true">5.7.1.</strong> xml 包概述</a></li><li class="chapter-item "><a href="../../../encoding/xml/xml_package_api/xml_package_interfaces.html"><strong aria-hidden="true">5.7.2.</strong> 接口</a></li><li class="chapter-item "><a href="../../../encoding/xml/xml_package_api/xml_package_classes.html"><strong aria-hidden="true">5.7.3.</strong> 类</a></li><li class="chapter-item "><a href="../../../encoding/xml/xml_package_api/xml_package_exceptions.html"><strong aria-hidden="true">5.7.4.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">5.7.5.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../encoding/xml/xml_samples/xml_dom_mode.html"><strong aria-hidden="true">5.7.5.1.</strong> Xml DOM 模式使用</a></li><li class="chapter-item "><a href="../../../encoding/xml/xml_samples/xml_sax_mode.html"><strong aria-hidden="true">5.7.5.2.</strong> Xml SAX 解析模式使用</a></li></ol></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">6.</strong> fuzz 模块</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../fuzz/fuzz_module_overview.html"><strong aria-hidden="true">6.1.</strong> fuzz 模块概述</a></li><li class="chapter-item "><div><strong aria-hidden="true">6.2.</strong> fuzz.fuzz 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../fuzz/fuzz/fuzz_package_overview.html"><strong aria-hidden="true">6.2.1.</strong> fuzz 包概述</a></li><li class="chapter-item "><a href="../../../fuzz/fuzz/fuzz_package_api/fuzz_package_constants_vars.html"><strong aria-hidden="true">6.2.2.</strong> 常量变量</a></li><li class="chapter-item "><a href="../../../fuzz/fuzz/fuzz_package_api/fuzz_package_classes.html"><strong aria-hidden="true">6.2.3.</strong> 类</a></li><li class="chapter-item "><a href="../../../fuzz/fuzz/fuzz_package_api/fuzz_package_exceptions.html"><strong aria-hidden="true">6.2.4.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">6.2.5.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../fuzz/fuzz/fuzz_samples/basic_fuzzing_test.html"><strong aria-hidden="true">6.2.5.1.</strong> 测试猜测字符功能</a></li><li class="chapter-item "><a href="../../../fuzz/fuzz/fuzz_samples/cj-fuzz_cjvm_backend.html"><strong aria-hidden="true">6.2.5.2.</strong> cjvm 使用 cj-fuzz 功能</a></li><li class="chapter-item "><a href="../../../fuzz/fuzz/fuzz_samples/dataprovider_usage.html"><strong aria-hidden="true">6.2.5.3.</strong> 使用 DataProvider 功能进行测试</a></li><li class="chapter-item "><a href="../../../fuzz/fuzz/fuzz_samples/fake_coverage_usage.html"><strong aria-hidden="true">6.2.5.4.</strong> 使用 FakeCoverage 避免 DataProvider 模式下 Fuzz 异常终止</a></li><li class="chapter-item "><a href="../../../fuzz/fuzz/fuzz_samples/print_cj-fuzz_usage.html"><strong aria-hidden="true">6.2.5.5.</strong> 打印 fuzz 使用方法</a></li><li class="chapter-item "><a href="../../../fuzz/fuzz/fuzz_samples/print_coverage.html"><strong aria-hidden="true">6.2.5.6.</strong> 实验性特性-覆盖率信息打印</a></li><li class="chapter-item "><a href="../../../fuzz/fuzz/fuzz_samples/stack_backtrace_missing_solution.html"><strong aria-hidden="true">6.2.5.7.</strong> 栈回溯缺失的处理方案</a></li></ol></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">7.</strong> log 模块</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../log/log_module_overview.html"><strong aria-hidden="true">7.1.</strong> log 模块概述</a></li><li class="chapter-item "><div><strong aria-hidden="true">7.2.</strong> log 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../log/log/log_package_overview.html"><strong aria-hidden="true">7.2.1.</strong> log 包概述</a></li><li class="chapter-item "><a href="../../../log/log/log_package_api/log_package_types.html"><strong aria-hidden="true">7.2.2.</strong> 类型别名</a></li><li class="chapter-item "><a href="../../../log/log/log_package_api/log_package_funcs.html"><strong aria-hidden="true">7.2.3.</strong> 函数</a></li><li class="chapter-item "><a href="../../../log/log/log_package_api/log_package_interfaces.html"><strong aria-hidden="true">7.2.4.</strong> 接口</a></li><li class="chapter-item "><a href="../../../log/log/log_package_api/log_package_classes.html"><strong aria-hidden="true">7.2.5.</strong> 类</a></li><li class="chapter-item "><a href="../../../log/log/log_package_api/log_package_structs.html"><strong aria-hidden="true">7.2.6.</strong> 结构体</a></li><li class="chapter-item "><a href="../../../log/log/log_package_api/log_package_exceptions.html"><strong aria-hidden="true">7.2.7.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">7.2.8.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../log/log/log_samples/log_sample.html"><strong aria-hidden="true">7.2.8.1.</strong> 日志打印示例</a></li></ol></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">8.</strong> net 模块</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../net/net_module_overview.html"><strong aria-hidden="true">8.1.</strong> net 模块概述</a></li><li class="chapter-item "><div><strong aria-hidden="true">8.2.</strong> net.http 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../net/http/http_package_overview.html"><strong aria-hidden="true">8.2.1.</strong> http 包概述</a></li><li class="chapter-item "><a href="../../../net/http/http_package_api/http_package_funcs.html"><strong aria-hidden="true">8.2.2.</strong> 函数</a></li><li class="chapter-item "><a href="../../../net/http/http_package_api/http_package_interfaces.html"><strong aria-hidden="true">8.2.3.</strong> 接口</a></li><li class="chapter-item "><a href="../../../net/http/http_package_api/http_package_classes.html"><strong aria-hidden="true">8.2.4.</strong> 类</a></li><li class="chapter-item "><a href="../../../net/http/http_package_api/http_package_enums.html"><strong aria-hidden="true">8.2.5.</strong> 枚举</a></li><li class="chapter-item "><a href="../../../net/http/http_package_api/http_package_structs.html"><strong aria-hidden="true">8.2.6.</strong> 结构体</a></li><li class="chapter-item "><a href="../../../net/http/http_package_api/http_package_exceptions.html"><strong aria-hidden="true">8.2.7.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">8.2.8.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../net/http/http_samples/http_client.html"><strong aria-hidden="true">8.2.8.1.</strong> client</a></li><li class="chapter-item "><a href="../../../net/http/http_samples/cookie.html"><strong aria-hidden="true">8.2.8.2.</strong> cookie</a></li><li class="chapter-item "><a href="../../../net/http/http_samples/log.html"><strong aria-hidden="true">8.2.8.3.</strong> log</a></li><li class="chapter-item "><a href="../../../net/http/http_samples/http_server.html"><strong aria-hidden="true">8.2.8.4.</strong> server</a></li><li class="chapter-item "><a href="../../../net/http/http_samples/webSocket.html"><strong aria-hidden="true">8.2.8.5.</strong> webSocket</a></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">8.3.</strong> net.tls 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../net/tls/tls_package_overview.html"><strong aria-hidden="true">8.3.1.</strong> tls 包概述</a></li><li class="chapter-item "><a href="../../../net/tls/tls_package_api/tls_package_classes.html"><strong aria-hidden="true">8.3.2.</strong> 类</a></li><li class="chapter-item "><a href="../../../net/tls/tls_package_api/tls_package_enums.html"><strong aria-hidden="true">8.3.3.</strong> 枚举</a></li><li class="chapter-item "><a href="../../../net/tls/tls_package_api/tls_package_structs.html"><strong aria-hidden="true">8.3.4.</strong> 结构体</a></li><li class="chapter-item "><a href="../../../net/tls/tls_package_api/tls_package_exceptions.html"><strong aria-hidden="true">8.3.5.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">8.3.6.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../net/tls/tls_samples/cert_key.html"><strong aria-hidden="true">8.3.6.1.</strong> 服务端证书及公钥在一份文件中</a></li><li class="chapter-item "><a href="../../../net/tls/tls_samples/client.html"><strong aria-hidden="true">8.3.6.2.</strong> 客户端示例</a></li><li class="chapter-item "><a href="../../../net/tls/tls_samples/hot_update_cert.html"><strong aria-hidden="true">8.3.6.3.</strong> 证书热更新</a></li><li class="chapter-item "><a href="../../../net/tls/tls_samples/server.html"><strong aria-hidden="true">8.3.6.4.</strong> 服务端示例</a></li></ol></li></ol></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">9.</strong> serialization 模块</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../serialization/serialization_module_overview.html"><strong aria-hidden="true">9.1.</strong> serialization 模块概述</a></li><li class="chapter-item "><div><strong aria-hidden="true">9.2.</strong> serialization.serialization 包</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../serialization/serialization/serialization_package_overview.html"><strong aria-hidden="true">9.2.1.</strong> serialization 包概述</a></li><li class="chapter-item "><a href="../../../serialization/serialization/serialization_package_api/serialization_package_functions.html"><strong aria-hidden="true">9.2.2.</strong> 函数</a></li><li class="chapter-item "><a href="../../../serialization/serialization/serialization_package_api/serialization_package_interfaces.html"><strong aria-hidden="true">9.2.3.</strong> 接口</a></li><li class="chapter-item "><a href="../../../serialization/serialization/serialization_package_api/serialization_package_classes.html"><strong aria-hidden="true">9.2.4.</strong> 类</a></li><li class="chapter-item "><a href="../../../serialization/serialization/serialization_package_api/serialization_package_exceptions.html"><strong aria-hidden="true">9.2.5.</strong> 异常类</a></li><li class="chapter-item "><div><strong aria-hidden="true">9.2.6.</strong> 示例教程</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../serialization/serialization/serialization_samples/serialize_and_deserialize_class.html"><strong aria-hidden="true">9.2.6.1.</strong> class 序列化和反序列化</a></li><li class="chapter-item "><a href="../../../serialization/serialization/serialization_samples/serialize_hashmap_and_hashset.html"><strong aria-hidden="true">9.2.6.2.</strong> HashSet 和 HashMap 序列化</a></li></ol></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">仓颉语言库 API</h1>

                    <div class="right-buttons">
                        <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="类"><a class="header" href="#类">类</a></h1>
<h2 id="class-annotation"><a class="header" href="#class-annotation">class Annotation</a></h2>
<pre><code class="language-cangjie">public class Annotation &lt;: Node {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示编译器内置的注解节点。</p>
<p>一个 <a href="ast_package_classes.html#class-annotation">Annotation</a> 节点：<code>@CallingConv[xxx]</code>, <code>@Attribute[xxx]</code>, <code>@When[condition]</code>等。</p>
<p>类型：<a href="ast_package_classes.html#class-refexpr">RefExpr</a></p>
<h3 id="prop-arguments"><a class="header" href="#prop-arguments">prop arguments</a></h3>
<pre><code class="language-cangjie">public mut prop arguments: ArrayList&lt;Argument&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-annotation">Annotation</a> 中的参数序列，如 @CallingConv[xxx] 中的 <code>xxx</code>。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-argument">Argument</a>&gt;</p>
<h3 id="prop-at"><a class="header" href="#prop-at">prop at</a></h3>
<pre><code class="language-cangjie">public mut prop at: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-annotation">Annotation</a> 节点中的 <code>@</code> 操作符。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-attributes"><a class="header" href="#prop-attributes">prop attributes</a></h3>
<pre><code class="language-cangjie">public mut prop attributes: Tokens
</code></pre>
<p>功能：获取或设置 <code>Attribute</code> 中设置的属性值，仅用于 @Attribute，如 @Attribute[xxx] 中的 <code>xxx</code>。</p>
<p>类型：<a href="ast_package_classes.html#class-tokens">Tokens</a></p>
<h3 id="prop-condition"><a class="header" href="#prop-condition">prop condition</a></h3>
<pre><code class="language-cangjie">public mut prop condition: Expr
</code></pre>
<p>功能：获取或设置条件编译中的条件表达式，用于 @When，如 @When[xxx] 中的 <code>xxx</code>。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当 <a href="ast_package_classes.html#class-annotation">Annotation</a> 节点中没有条件表达式时，抛出异常。</li>
</ul>
<h3 id="prop-identifier"><a class="header" href="#prop-identifier">prop identifier</a></h3>
<pre><code class="language-cangjie">public mut prop identifier: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-annotation">Annotation</a> 节点的标识符，如 @CallingConv[xxx] 中的 <code>CallingConv</code>。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init"><a class="header" href="#init">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-annotation">Annotation</a> 对象。</p>
<h3 id="inittoken"><a class="header" href="#inittoken">init(Token)</a></h3>
<pre><code class="language-cangjie">public init(input: Token)
</code></pre>
<p>功能：根据输入的词法单元，构造一个 <a href="ast_package_classes.html#class-annotation">Annotation</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_structs.html#struct-token">Token</a> - 将要构造 <a href="ast_package_classes.html#class-annotation">Annotation</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-annotation">Annotation</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-argument"><a class="header" href="#class-argument">class Argument</a></h2>
<pre><code class="language-cangjie">public class Argument &lt;: Node {
    public init()
}
</code></pre>
<p>功能：表示函数调用的实参节点。</p>
<p>例如 <code>foo(arg:value)</code> 中的 <code>arg:value</code>。</p>
<h3 id="prop-colon"><a class="header" href="#prop-colon">prop colon</a></h3>
<pre><code class="language-cangjie">public mut prop colon: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-argument">Argument</a> 节点中的操作符 <code>:</code>，可能为 <a href="ast_package_enums.html#illegal">ILLEGAL</a> 的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-expr"><a class="header" href="#prop-expr">prop expr</a></h3>
<pre><code class="language-cangjie">public mut prop expr: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-argument">Argument</a> 节点中的表达式，如 <code>arg:value</code> 中的 <code>value</code>。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<h3 id="prop-identifier-1"><a class="header" href="#prop-identifier-1">prop identifier</a></h3>
<pre><code class="language-cangjie">public mut prop identifier: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-argument">Argument</a> 节点中的标识符，如 <code>arg:value</code> 中的 <code>arg</code>，可能为 <a href="ast_package_enums.html#illegal">ILLEGAL</a> 的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-keyword"><a class="header" href="#prop-keyword">prop keyword</a></h3>
<pre><code class="language-cangjie">public mut prop keyword: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-argument">Argument</a> 节点中的关键字 <code>inout</code>，可能为 <a href="ast_package_enums.html#illegal">ILLEGAL</a> 的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-1"><a class="header" href="#init-1">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-argument">Argument</a> 对象。</p>
<h2 id="class-arrayliteral"><a class="header" href="#class-arrayliteral">class ArrayLiteral</a></h2>
<pre><code class="language-cangjie">public class ArrayLiteral &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示 <a href="../../core/core_package_api/core_package_structs.html#struct-arrayt">Array</a> 字面量节点。</p>
<p><a href="ast_package_classes.html#class-arrayliteral">ArrayLiteral</a> 节点：使用格式 <code>[element1, element2, ... , elementN]</code> 表示， 每个 <code>element</code> 是一个表达式。</p>
<h3 id="prop-elements"><a class="header" href="#prop-elements">prop elements</a></h3>
<pre><code class="language-cangjie">public mut prop elements: ArrayList&lt;Expr&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-arrayliteral">ArrayLiteral</a> 中的表达式列表。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-expr">Expr</a>&gt;</p>
<h3 id="prop-lsquare"><a class="header" href="#prop-lsquare">prop lSquare</a></h3>
<pre><code class="language-cangjie">public mut prop lSquare: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-arrayliteral">ArrayLiteral</a> 中的左中括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-rsquare"><a class="header" href="#prop-rsquare">prop rSquare</a></h3>
<pre><code class="language-cangjie">public mut prop rSquare: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-arrayliteral">ArrayLiteral</a> 中的右中括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-2"><a class="header" href="#init-2">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-arrayliteral">ArrayLiteral</a> 对象。</p>
<h3 id="inittokens"><a class="header" href="#inittokens">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-arrayliteral">ArrayLiteral</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-arrayliteral">ArrayLiteral</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-arrayliteral">ArrayLiteral</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-asexpr"><a class="header" href="#class-asexpr">class AsExpr</a></h2>
<pre><code class="language-cangjie">public class AsExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示一个类型检查表达式。</p>
<p>一个 <a href="ast_package_classes.html#class-asexpr">AsExpr</a> 表达式：<code>e as T</code>，类型为 <a href="../../core/core_package_api/core_package_enums.html#enum-optiont">Option</a>&lt;T&gt;。其中 e 可以是任何类型的表达式，T 可以是任何类型。</p>
<h3 id="prop-expr-1"><a class="header" href="#prop-expr-1">prop expr</a></h3>
<pre><code class="language-cangjie">public mut prop expr: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-asexpr">AsExpr</a> 节点中的表达式节点。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<h3 id="prop-keyword-1"><a class="header" href="#prop-keyword-1">prop keyword</a></h3>
<pre><code class="language-cangjie">public mut prop keyword: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-asexpr">AsExpr</a> 节点中的 <code>as</code> 操作符。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-shifttype"><a class="header" href="#prop-shifttype">prop shiftType</a></h3>
<pre><code class="language-cangjie">public mut prop shiftType: TypeNode
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-asexpr">AsExpr</a> 节点中的目标类型。</p>
<p>类型：<a href="ast_package_classes.html#class-typenode">TypeNode</a></p>
<h3 id="init-3"><a class="header" href="#init-3">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-asexpr">AsExpr</a> 对象。</p>
<h3 id="inittokens-1"><a class="header" href="#inittokens-1">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-asexpr">AsExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-asexpr">AsExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-asexpr">AsExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-assignexpr"><a class="header" href="#class-assignexpr">class AssignExpr</a></h2>
<pre><code class="language-cangjie">public class AssignExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示赋值表达式节点。</p>
<p>用于将左操作数的值修改为右操作数的值。一个 <a href="ast_package_classes.html#class-assignexpr">AssignExpr</a> 节点：<code>a = b</code>。</p>
<h3 id="prop-assign"><a class="header" href="#prop-assign">prop assign</a></h3>
<pre><code class="language-cangjie">public mut prop assign: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-assignexpr">AssignExpr</a> 节点中的 <code>=</code> 操作符。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-leftexpr"><a class="header" href="#prop-leftexpr">prop leftExpr</a></h3>
<pre><code class="language-cangjie">public mut prop leftExpr: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-assignexpr">AssignExpr</a> 节点中的左操作数。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<h3 id="prop-rightexpr"><a class="header" href="#prop-rightexpr">prop rightExpr</a></h3>
<pre><code class="language-cangjie">public mut prop rightExpr: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-assignexpr">AssignExpr</a> 节点中的右操作数。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<h3 id="init-4"><a class="header" href="#init-4">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-assignexpr">AssignExpr</a> 对象。</p>
<h3 id="inittokens-2"><a class="header" href="#inittokens-2">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-assignexpr">AssignExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-assignexpr">AssignExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-assignexpr">AssignExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-binaryexpr"><a class="header" href="#class-binaryexpr">class BinaryExpr</a></h2>
<pre><code class="language-cangjie">public class BinaryExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示一个二元操作表达式节点。</p>
<p>一个 <a href="ast_package_classes.html#class-binaryexpr">BinaryExpr</a> 节点：<code>a + b</code>, <code>a - b</code> 等。</p>
<h3 id="prop-leftexpr-1"><a class="header" href="#prop-leftexpr-1">prop leftExpr</a></h3>
<pre><code class="language-cangjie">public mut prop leftExpr: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-binaryexpr">BinaryExpr</a> 节点中操作符左侧的表达式节点。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<h3 id="prop-op"><a class="header" href="#prop-op">prop op</a></h3>
<pre><code class="language-cangjie">public mut prop op: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-binaryexpr">BinaryExpr</a> 节点中的二元操作符。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-rightexpr-1"><a class="header" href="#prop-rightexpr-1">prop rightExpr</a></h3>
<pre><code class="language-cangjie">public mut prop rightExpr: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-binaryexpr">BinaryExpr</a> 节点中操作符右侧的表达式节点。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<h3 id="init-5"><a class="header" href="#init-5">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-binaryexpr">BinaryExpr</a> 对象。</p>
<h3 id="inittokens-3"><a class="header" href="#inittokens-3">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-binaryexpr">BinaryExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-binaryexpr">BinaryExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-binaryexpr">BinaryExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-block"><a class="header" href="#class-block">class Block</a></h2>
<pre><code class="language-cangjie">public class Block &lt;: Expr {
    public init()
}
</code></pre>
<p>功能：表示块节点。</p>
<p><a href="ast_package_classes.html#class-block">Block</a> 由一对匹配的大括号及其中可选的表达式声明序列组成的结构，简称 “块”。</p>
<h3 id="prop-lbrace"><a class="header" href="#prop-lbrace">prop lBrace</a></h3>
<pre><code class="language-cangjie">public mut prop lBrace: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-block">Block</a> 的左大括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-nodes"><a class="header" href="#prop-nodes">prop nodes</a></h3>
<pre><code class="language-cangjie">public mut prop nodes: ArrayList&lt;Node&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-block">Block</a> 中的表达式或声明序列。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-node">Node</a>&gt;</p>
<h3 id="prop-rbrace"><a class="header" href="#prop-rbrace">prop rBrace</a></h3>
<pre><code class="language-cangjie">public mut prop rBrace: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-block">Block</a> 的右大括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-6"><a class="header" href="#init-6">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-block">Block</a> 对象。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p><a href="ast_package_classes.html#class-block">Block</a> 节点无法脱离表达式或声明节点单独存在，因此不提供其他的构造函数。</p>
</blockquote>
<h2 id="class-body"><a class="header" href="#class-body">class Body</a></h2>
<pre><code class="language-cangjie">public class Body &lt;: Node {
    public init()
}
</code></pre>
<p>功能：表示 Class 类型、 Struct 类型、 Interface 类型以及扩展中由 <code>{}</code> 和内部的一组声明节点组成的结构。</p>
<h3 id="prop-decls"><a class="header" href="#prop-decls">prop decls</a></h3>
<pre><code class="language-cangjie">public mut prop decls: ArrayList&lt;Decl&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-body">Body</a> 内的声明节点集合。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-decl">Decl</a>&gt;</p>
<h3 id="prop-lbrace-1"><a class="header" href="#prop-lbrace-1">prop lBrace</a></h3>
<pre><code class="language-cangjie">public mut prop lBrace: Token
</code></pre>
<p>功能：获取或设置 <code>{</code> 词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-rbrace-1"><a class="header" href="#prop-rbrace-1">prop rBrace</a></h3>
<pre><code class="language-cangjie">public mut prop rBrace: Token
</code></pre>
<p>功能：获取或设置 <code>}</code> 词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-7"><a class="header" href="#init-7">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-body">Body</a> 对象。</p>
<h2 id="class-callexpr"><a class="header" href="#class-callexpr">class CallExpr</a></h2>
<pre><code class="language-cangjie">public class CallExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示函数调用节点节点。</p>
<p>一个 <a href="ast_package_classes.html#class-callexpr">CallExpr</a> 节点包括一个表达式后面紧跟参数列表，例如 <code>foo(100)</code>。</p>
<h3 id="prop-arguments-1"><a class="header" href="#prop-arguments-1">prop arguments</a></h3>
<pre><code class="language-cangjie">public mut prop arguments: ArrayList&lt;Argument&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-callexpr">CallExpr</a> 节点中函数参数。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-argument">Argument</a>&gt;</p>
<h3 id="prop-callfunc"><a class="header" href="#prop-callfunc">prop callFunc</a></h3>
<pre><code class="language-cangjie">public mut prop callFunc: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-callexpr">CallExpr</a> 节点中的函数调用节点。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<h3 id="prop-lparen"><a class="header" href="#prop-lparen">prop lParen</a></h3>
<pre><code class="language-cangjie">public mut prop lParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-callexpr">CallExpr</a> 节点中的左括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-rparen"><a class="header" href="#prop-rparen">prop rParen</a></h3>
<pre><code class="language-cangjie">public mut prop rParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-callexpr">CallExpr</a> 节点中的右括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-8"><a class="header" href="#init-8">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-callexpr">CallExpr</a> 对象。</p>
<h3 id="inittokens-4"><a class="header" href="#inittokens-4">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-callexpr">CallExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-callexpr">CallExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-callexpr">CallExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-classdecl"><a class="header" href="#class-classdecl">class ClassDecl</a></h2>
<pre><code class="language-cangjie">public class ClassDecl &lt;: Decl {
    public init()
    public init(inputs: Tokens)
}
</code></pre>
<p>功能：类定义节点。</p>
<p>类的定义使用 <code>class</code> 关键字，定义依次为：可缺省的修饰符、class 关键字、class 名、可选的类型参数、是否指定父类或父接口、可选的泛型约束、类体的定义。</p>
<h3 id="prop-body"><a class="header" href="#prop-body">prop body</a></h3>
<pre><code class="language-cangjie">public mut prop body: Body
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-classdecl">ClassDecl</a> 节点的类体。</p>
<p>类型：<a href="ast_package_classes.html#class-body">Body</a></p>
<h3 id="prop-supertypes"><a class="header" href="#prop-supertypes">prop superTypes</a></h3>
<pre><code class="language-cangjie">public mut prop superTypes: ArrayList&lt;TypeNode&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-classdecl">ClassDecl</a> 节点的父类或者父接口。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-typenode">TypeNode</a>&gt;</p>
<h3 id="prop-upperbound"><a class="header" href="#prop-upperbound">prop upperBound</a></h3>
<pre><code class="language-cangjie">public mut prop upperBound: Token
</code></pre>
<p>功能：获取或设置 <code>&lt;:</code> 操作符。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-9"><a class="header" href="#init-9">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-classdecl">ClassDecl</a> 对象。</p>
<h3 id="inittokens-5"><a class="header" href="#inittokens-5">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(inputs: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-classdecl">ClassDecl</a> 对象。</p>
<p>参数：</p>
<ul>
<li>inputs: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-classdecl">ClassDecl</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-classdecl">ClassDecl</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-constpattern"><a class="header" href="#class-constpattern">class ConstPattern</a></h2>
<pre><code class="language-cangjie">public class ConstPattern &lt;: Pattern {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示常量模式节点。</p>
<p>常量模式可以是整数字面量、字符字节字面量、浮点数字面量、字符字面量、布尔字面量、字符串字面量等字面量，如 <code>case 1 =&gt; 0</code> 中的 <code>1</code>。</p>
<h3 id="prop-litconstexpr"><a class="header" href="#prop-litconstexpr">prop litConstExpr</a></h3>
<pre><code class="language-cangjie">public mut prop litConstExpr: LitConstExpr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-constpattern">ConstPattern</a> 节点中的字面量表达式。</p>
<p>类型：<a href="ast_package_classes.html#class-litconstexpr">LitConstExpr</a></p>
<h3 id="init-10"><a class="header" href="#init-10">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-constpattern">ConstPattern</a> 对象。</p>
<h3 id="inittokens-6"><a class="header" href="#inittokens-6">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-constpattern">ConstPattern</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-constpattern">ConstPattern</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-constpattern">ConstPattern</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-constructor"><a class="header" href="#class-constructor">class Constructor</a></h2>
<pre><code class="language-cangjie">public class Constructor &lt;: Node {
    public init()
}
</code></pre>
<p>功能：表示 <code>enum</code> 类型中的 <a href="ast_package_classes.html#class-constructor">Constructor</a> 节点。</p>
<p>一个 <a href="ast_package_classes.html#class-constructor">Constructor</a> 节点：enum TimeUnit { Year | Month(<a href="../../core/core_package_api/core_package_intrinsics.html#float32">Float32</a>, <a href="../../core/core_package_api/core_package_intrinsics.html#float32">Float32</a>)} 中的 Year 和 Month(<a href="../../core/core_package_api/core_package_intrinsics.html#float32">Float32</a>, <a href="../../core/core_package_api/core_package_intrinsics.html#float32">Float32</a>)。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p><a href="ast_package_classes.html#class-constructor">Constructor</a> 可以没有参数，也可以有一组不同类型的参数。</p>
</blockquote>
<h3 id="prop-identifier-2"><a class="header" href="#prop-identifier-2">prop identifier</a></h3>
<pre><code class="language-cangjie">public mut prop identifier: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-constructor">Constructor</a> 的标识符词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-lparen-1"><a class="header" href="#prop-lparen-1">prop lParen</a></h3>
<pre><code class="language-cangjie">public mut prop lParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-constructor">Constructor</a> 节点中的左括号词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-rparen-1"><a class="header" href="#prop-rparen-1">prop rParen</a></h3>
<pre><code class="language-cangjie">public mut prop rParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-constructor">Constructor</a> 节点中的右括号词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-typearguments"><a class="header" href="#prop-typearguments">prop typeArguments</a></h3>
<pre><code class="language-cangjie">public mut prop typeArguments: ArrayList&lt;TypeNode&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-constructor">Constructor</a> 节点可选的参数类型节点的集合。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-typenode">TypeNode</a>&gt;</p>
<h3 id="init-11"><a class="header" href="#init-11">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-constructor">Constructor</a> 对象。</p>
<h2 id="class-decl"><a class="header" href="#class-decl">class Decl</a></h2>
<pre><code class="language-cangjie">public open class Decl &lt;: Node
</code></pre>
<p>功能：所有声明节点的父类，继承自 <a href="ast_package_classes.html#class-node">Node</a> 节点，提供了所有声明节点的通用接口。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>类定义、接口定义、函数定义、变量定义、枚举定义、结构体定义、扩展定义、类型别名定义、宏定义等都属于 <a href="ast_package_classes.html#class-decl">Decl</a> 节点。</p>
</blockquote>
<h3 id="prop-annotations"><a class="header" href="#prop-annotations">prop annotations</a></h3>
<pre><code class="language-cangjie">public mut prop annotations: ArrayList&lt;Annotation&gt;
</code></pre>
<p>功能：获取或设置作用于 <a href="ast_package_classes.html#class-decl">Decl</a> 节点的注解列表。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-annotation">Annotation</a>&gt;</p>
<h3 id="prop-genericconstraint"><a class="header" href="#prop-genericconstraint">prop genericConstraint</a></h3>
<pre><code class="language-cangjie">public mut prop genericConstraint: ArrayList&lt;GenericConstraint&gt;
</code></pre>
<p>功能：获取或设置定义节点的泛型约束，可能为空，如 <code>func foo&lt;T&gt;() where T &lt;: Comparable&lt;T&gt; {}</code> 中的 <code>where T &lt;: Comparable&lt;T&gt;</code>。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-genericconstraint">GenericConstraint</a>&gt;</p>
<h3 id="prop-genericparam"><a class="header" href="#prop-genericparam">prop genericParam</a></h3>
<pre><code class="language-cangjie">public mut prop genericParam: GenericParam
</code></pre>
<p>功能：获取或设置形参列表，类型形参列表由 <code>&lt;&gt;</code> 括起，多个类型形参之间用逗号分隔。</p>
<p>类型：<a href="ast_package_classes.html#class-genericparam">GenericParam</a></p>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当节点未定义类型形参列表时，抛出异常。</li>
</ul>
<h3 id="prop-identifier-3"><a class="header" href="#prop-identifier-3">prop identifier</a></h3>
<pre><code class="language-cangjie">public open mut prop identifier: Token
</code></pre>
<p>功能：获取或设置定义节点的标识符，如 <code>class foo {}</code> 中的 <code>foo</code>。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-keyword-2"><a class="header" href="#prop-keyword-2">prop keyword</a></h3>
<pre><code class="language-cangjie">public mut prop keyword: Token
</code></pre>
<p>功能：获取或设置定义节点的关键字。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-modifiers"><a class="header" href="#prop-modifiers">prop modifiers</a></h3>
<pre><code class="language-cangjie">public mut prop modifiers: ArrayList&lt;Modifier&gt;
</code></pre>
<p>功能：获取或设置修饰节点的修饰符列表。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-modifier">Modifier</a>&gt;</p>
<h3 id="func-getattrs"><a class="header" href="#func-getattrs">func getAttrs()</a></h3>
<pre><code class="language-cangjie">public func getAttrs(): Tokens
</code></pre>
<p>功能：获取当前节点的属性（一般通过内置的 <code>Attribute</code> 来设置某个声明设置属性值）。</p>
<p>返回值：</p>
<ul>
<li><a href="ast_package_classes.html#class-tokens">Tokens</a> - 当前节点的属性。</li>
</ul>
<h3 id="func-hasattrstring"><a class="header" href="#func-hasattrstring">func hasAttr(String)</a></h3>
<pre><code class="language-cangjie">public func hasAttr(attr: String): Bool
</code></pre>
<p>功能：判断当前节点是否具有某个属性（一般通过内置的 <code>Attribute</code> 来设置某个声明的属性值）。</p>
<p>参数：</p>
<ul>
<li>attr: <a href="../../core/core_package_api/core_package_structs.html#struct-string">String</a> - 将要判断是否存在于该节点的属性。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="../../core/core_package_api/core_package_intrinsics.html#bool">Bool</a> - 当前节点具有该属性时，返回 true；反之，返回 false。</li>
</ul>
<h2 id="class-dowhileexpr"><a class="header" href="#class-dowhileexpr">class DoWhileExpr</a></h2>
<pre><code class="language-cangjie">public class DoWhileExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示 <code>do-while</code> 表达式。</p>
<h3 id="prop-block"><a class="header" href="#prop-block">prop block</a></h3>
<pre><code class="language-cangjie">public mut prop block: Block
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-dowhileexpr">DoWhileExpr</a> 中的块表达式。</p>
<p>类型：<a href="ast_package_classes.html#class-block">Block</a></p>
<h3 id="prop-condition-1"><a class="header" href="#prop-condition-1">prop condition</a></h3>
<pre><code class="language-cangjie">public mut prop condition: Expr
</code></pre>
<p>功能：获取或设置关键字 <a href="ast_package_classes.html#class-dowhileexpr">DoWhileExpr</a> 中的条件表达式。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<h3 id="prop-keywordd"><a class="header" href="#prop-keywordd">prop keywordD</a></h3>
<pre><code class="language-cangjie">public mut prop keywordD: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-dowhileexpr">DoWhileExpr</a> 节点中 <code>do</code> 关键字，其中 keywordD 中的 D 为关键字 <code>do</code> 的首字母大写，代表关键字 <code>do</code> 。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-keywordw"><a class="header" href="#prop-keywordw">prop keywordW</a></h3>
<pre><code class="language-cangjie">public mut prop keywordW: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-dowhileexpr">DoWhileExpr</a> 节点中 <code>while</code> 关键字，其中 keywordW 中的 W 为关键字 <code>while</code> 的首字母大写，代表关键字 <code>while</code> 。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-lparen-2"><a class="header" href="#prop-lparen-2">prop lParen</a></h3>
<pre><code class="language-cangjie">public mut prop lParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-dowhileexpr">DoWhileExpr</a> 中 <code>while</code> 关键字之后的左括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-rparen-2"><a class="header" href="#prop-rparen-2">prop rParen</a></h3>
<pre><code class="language-cangjie">public mut prop rParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-dowhileexpr">DoWhileExpr</a> 中 <code>while</code> 关键字之后的右括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-12"><a class="header" href="#init-12">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-dowhileexpr">DoWhileExpr</a> 对象。</p>
<h3 id="inittokens-7"><a class="header" href="#inittokens-7">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-dowhileexpr">DoWhileExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-dowhileexpr">DoWhileExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-dowhileexpr">DoWhileExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-enumdecl"><a class="header" href="#class-enumdecl">class EnumDecl</a></h2>
<pre><code class="language-cangjie">public class EnumDecl &lt;: Decl {
    public init()
    public init(inputs: Tokens)
}
</code></pre>
<p>功能：表示一个 <code>Enum</code> 定义节点。</p>
<p>Enum 的定义使用 <code>enum</code> 关键字，定义依次为：可缺省的修饰符、enum 关键字、enum 名、可选的类型参数、是否指定父接口、可选的泛型约束、enum 体的定义。</p>
<h3 id="prop-constructors"><a class="header" href="#prop-constructors">prop constructors</a></h3>
<pre><code class="language-cangjie">public mut prop constructors: ArrayList&lt;Constructor&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-enumdecl">EnumDecl</a> 节点内 constructor 的成员。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-constructor">Constructor</a>&gt;</p>
<h3 id="prop-decls-1"><a class="header" href="#prop-decls-1">prop decls</a></h3>
<pre><code class="language-cangjie">public mut prop decls: ArrayList&lt;Decl&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-enumdecl">EnumDecl</a> 节点内除 constructor 的其它成员。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-decl">Decl</a>&gt;</p>
<h3 id="prop-lbrace-2"><a class="header" href="#prop-lbrace-2">prop lBrace</a></h3>
<pre><code class="language-cangjie">public mut prop lBrace: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-enumdecl">EnumDecl</a> 节点的 <code>{</code> 词法单元类型。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-rbrace-2"><a class="header" href="#prop-rbrace-2">prop rBrace</a></h3>
<pre><code class="language-cangjie">public mut prop rBrace: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-enumdecl">EnumDecl</a> 节点的 <code>}</code> 词法单元类型。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-supertypes-1"><a class="header" href="#prop-supertypes-1">prop superTypes</a></h3>
<pre><code class="language-cangjie">public mut prop superTypes: ArrayList&lt;TypeNode&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-enumdecl">EnumDecl</a> 节点的父接口。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-typenode">TypeNode</a>&gt;</p>
<h3 id="prop-upperbound-1"><a class="header" href="#prop-upperbound-1">prop upperBound</a></h3>
<pre><code class="language-cangjie">public mut prop upperBound: Token
</code></pre>
<p>功能：获取或设置 <code>&lt;:</code> 操作符。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-13"><a class="header" href="#init-13">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-enumdecl">EnumDecl</a> 对象。</p>
<h3 id="inittokens-8"><a class="header" href="#inittokens-8">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(inputs: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-enumdecl">EnumDecl</a> 对象。</p>
<p>参数：</p>
<ul>
<li>inputs: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-enumdecl">EnumDecl</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-enumdecl">EnumDecl</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-enumpattern"><a class="header" href="#class-enumpattern">class EnumPattern</a></h2>
<pre><code class="language-cangjie">public class EnumPattern &lt;: Pattern {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示 enum 模式节点。</p>
<p>用于匹配 enum 的 <code>constructor</code>， 如 <code>case Year(n) =&gt; 1</code> 中的 <code>Year(n)</code>。</p>
<h3 id="prop-constructor"><a class="header" href="#prop-constructor">prop constructor</a></h3>
<pre><code class="language-cangjie">public mut prop constructor: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-enumpattern">EnumPattern</a> 节点中的构造器表达式节点。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<h3 id="prop-lparen-3"><a class="header" href="#prop-lparen-3">prop lParen</a></h3>
<pre><code class="language-cangjie">public mut prop lParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-enumpattern">EnumPattern</a> 节点中的左括号的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-patterns"><a class="header" href="#prop-patterns">prop patterns</a></h3>
<pre><code class="language-cangjie">public mut prop patterns: ArrayList&lt;Pattern&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-enumpattern">EnumPattern</a> 节点中有参构造器内的模式节点列表。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-pattern">Pattern</a>&gt;</p>
<h3 id="prop-rparen-3"><a class="header" href="#prop-rparen-3">prop rParen</a></h3>
<pre><code class="language-cangjie">public mut prop rParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-enumpattern">EnumPattern</a> 节点中的右括号的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-14"><a class="header" href="#init-14">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-enumpattern">EnumPattern</a> 对象。</p>
<h3 id="inittokens-9"><a class="header" href="#inittokens-9">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-enumpattern">EnumPattern</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-enumpattern">EnumPattern</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-enumpattern">EnumPattern</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-excepttypepattern"><a class="header" href="#class-excepttypepattern">class ExceptTypePattern</a></h2>
<pre><code class="language-cangjie">public class ExceptTypePattern &lt;: Pattern {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示一个用于异常模式状态下的节点。</p>
<p>例如 <code>e: Exception1 | Exception2</code>。</p>
<h3 id="prop-colon-1"><a class="header" href="#prop-colon-1">prop colon</a></h3>
<pre><code class="language-cangjie">public mut prop colon: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-excepttypepattern">ExceptTypePattern</a> 节点中的 <code>:</code> 操作符的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-pattern"><a class="header" href="#prop-pattern">prop pattern</a></h3>
<pre><code class="language-cangjie">public mut prop pattern: Pattern
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-excepttypepattern">ExceptTypePattern</a> 节点中的模式节点。</p>
<p>类型：<a href="ast_package_classes.html#class-pattern">Pattern</a></p>
<h3 id="prop-types"><a class="header" href="#prop-types">prop types</a></h3>
<pre><code class="language-cangjie">public mut prop types: ArrayList&lt;TypeNode&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-excepttypepattern">ExceptTypePattern</a> 节点中有类型列表。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-typenode">TypeNode</a>&gt;</p>
<h3 id="init-15"><a class="header" href="#init-15">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-excepttypepattern">ExceptTypePattern</a> 对象。</p>
<h3 id="inittokens-10"><a class="header" href="#inittokens-10">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-excepttypepattern">ExceptTypePattern</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-excepttypepattern">ExceptTypePattern</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-excepttypepattern">ExceptTypePattern</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-expr"><a class="header" href="#class-expr">class Expr</a></h2>
<pre><code class="language-cangjie">public open class Expr &lt;: Node
</code></pre>
<p>功能：所有表达式节点的父类，继承自 <a href="ast_package_classes.html#class-node">Node</a> 节点。</p>
<p>表达式节点的 <code>toTokens</code> 方法会根据操作符优先级添加括号，例如已有一个 <a href="ast_package_classes.html#class-binaryexpr">BinaryExpr</a> 节点 a <em>b, 用户将左表达式内容 a 修改为 a + 1，修改后 <code>toTokens</code> 方法会为左表达式添加括号，<code>toTokens</code> 输出为 (a + 1)</em> b。</p>
<h2 id="class-extenddecl"><a class="header" href="#class-extenddecl">class ExtendDecl</a></h2>
<pre><code class="language-cangjie">public class ExtendDecl &lt;: Decl {
    public init()
    public init(inputs: Tokens)
}
</code></pre>
<p>功能：表示一个扩展定义节点。</p>
<p>扩展的定义使用 <code>extend</code> 关键字，扩展定义依次为：extend 关键字、扩展类型、是否指定父接口、可选的泛型约束、扩展体的定义。</p>
<h3 id="prop-body-1"><a class="header" href="#prop-body-1">prop body</a></h3>
<pre><code class="language-cangjie">public mut prop body: Body
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-extenddecl">ExtendDecl</a> 节点的类体。</p>
<p>类型：<a href="ast_package_classes.html#class-body">Body</a></p>
<h3 id="prop-extendtype"><a class="header" href="#prop-extendtype">prop extendType</a></h3>
<pre><code class="language-cangjie">public mut prop extendType: TypeNode
</code></pre>
<p>功能：获取或设置被扩展的类型。</p>
<p>类型：<a href="ast_package_classes.html#class-typenode">TypeNode</a></p>
<h3 id="prop-identifier-4"><a class="header" href="#prop-identifier-4">prop identifier</a></h3>
<pre><code class="language-cangjie">public override mut prop identifier: Token
</code></pre>
<p>功能：<a href="ast_package_classes.html#class-extenddecl">ExtendDecl</a> 节点继承 <a href="ast_package_classes.html#class-decl">Decl</a> 节点，但是不支持 <code>identifier</code> 属性，使用时会抛出异常。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当使用 <code>identifier</code> 属性时，抛出异常。</li>
</ul>
<h3 id="prop-supertypes-2"><a class="header" href="#prop-supertypes-2">prop superTypes</a></h3>
<pre><code class="language-cangjie">public mut prop superTypes: ArrayList&lt;TypeNode&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-extenddecl">ExtendDecl</a> 节点的父接口。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-typenode">TypeNode</a>&gt;</p>
<h3 id="prop-upperbound-2"><a class="header" href="#prop-upperbound-2">prop upperBound</a></h3>
<pre><code class="language-cangjie">public mut prop upperBound: Token
</code></pre>
<p>功能：获取或设置 <code>&lt;:</code> 操作符。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-16"><a class="header" href="#init-16">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-extenddecl">ExtendDecl</a> 对象。</p>
<h3 id="inittokens-11"><a class="header" href="#inittokens-11">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(inputs: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-extenddecl">ExtendDecl</a> 对象。</p>
<p>参数：</p>
<ul>
<li>inputs: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-extenddecl">ExtendDecl</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-extenddecl">ExtendDecl</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-forinexpr"><a class="header" href="#class-forinexpr">class ForInExpr</a></h2>
<pre><code class="language-cangjie">public class ForInExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示 <code>for-in</code> 表达式。</p>
<p><a href="ast_package_classes.html#class-forinexpr">ForInExpr</a> 类型中，关键字 <code>for</code> 之后是 <a href="ast_package_classes.html#class-pattern">Pattern</a>, 此后是一个 <code>in</code> 关键字和表达式节点，最后是一个执行循环体 <a href="ast_package_classes.html#class-block">Block</a>。</p>
<h3 id="prop-block-1"><a class="header" href="#prop-block-1">prop block</a></h3>
<pre><code class="language-cangjie">public mut prop block: Block
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-forinexpr">ForInExpr</a> 中的循环体。</p>
<p>类型：<a href="ast_package_classes.html#class-block">Block</a></p>
<h3 id="prop-expr-2"><a class="header" href="#prop-expr-2">prop expr</a></h3>
<pre><code class="language-cangjie">public mut prop expr: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-forinexpr">ForInExpr</a> 中的表达式。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<h3 id="prop-keywordf"><a class="header" href="#prop-keywordf">prop keywordF</a></h3>
<pre><code class="language-cangjie">public mut prop keywordF: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-forinexpr">ForInExpr</a> 中的关键字 <code>for</code>。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-keywordi"><a class="header" href="#prop-keywordi">prop keywordI</a></h3>
<pre><code class="language-cangjie">public mut prop keywordI: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-forinexpr">ForInExpr</a> 中的关键字 <code>in</code>。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-keywordw-1"><a class="header" href="#prop-keywordw-1">prop keywordW</a></h3>
<pre><code class="language-cangjie">public mut prop keywordW: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-forinexpr">ForInExpr</a> 中的关键字 <code>where</code>。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-lparen-4"><a class="header" href="#prop-lparen-4">prop lParen</a></h3>
<pre><code class="language-cangjie">public mut prop lParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-forinexpr">ForInExpr</a> 中关键字 <code>for</code> 后的左括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-pattern-1"><a class="header" href="#prop-pattern-1">prop pattern</a></h3>
<pre><code class="language-cangjie">public mut prop pattern: Pattern
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-forinexpr">ForInExpr</a> 中的 <a href="ast_package_classes.html#class-pattern">Pattern</a> 节点。</p>
<p>类型：<a href="ast_package_classes.html#class-pattern">Pattern</a></p>
<h3 id="prop-patternguard"><a class="header" href="#prop-patternguard">prop patternGuard</a></h3>
<pre><code class="language-cangjie">public mut prop patternGuard: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-forinexpr">ForInExpr</a> 中的 <code>patternGuard</code> 条件表达式。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当 <a href="ast_package_classes.html#class-forinexpr">ForInExpr</a> 节点中不存在 <code>patternGuard</code> 表达式时，抛出异常。</li>
</ul>
<h3 id="prop-rparen-4"><a class="header" href="#prop-rparen-4">prop rParen</a></h3>
<pre><code class="language-cangjie">public mut prop rParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-forinexpr">ForInExpr</a> 中的右括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-17"><a class="header" href="#init-17">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-forinexpr">ForInExpr</a> 对象。</p>
<h3 id="inittokens-12"><a class="header" href="#inittokens-12">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-forinexpr">ForInExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-forinexpr">ForInExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-forinexpr">ForInExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-funcdecl"><a class="header" href="#class-funcdecl">class FuncDecl</a></h2>
<pre><code class="language-cangjie">public class FuncDecl &lt;: Decl {
    public init()
    public init(inputs: Tokens)
}
</code></pre>
<p>功能：表示一个函数定义节点。</p>
<p>由可选的函数修饰符，关键字 <code>func</code> ，函数名，可选的类型形参列表，函数参数，可缺省的函数返回类型来定义一个函数，函数定义时必须有函数体，函数体是一个块。</p>
<h3 id="prop-block-2"><a class="header" href="#prop-block-2">prop block</a></h3>
<pre><code class="language-cangjie">public mut prop block: Block
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-funcdecl">FuncDecl</a> 节点的函数体。</p>
<p>类型：<a href="ast_package_classes.html#class-block">Block</a></p>
<h3 id="prop-colon-2"><a class="header" href="#prop-colon-2">prop colon</a></h3>
<pre><code class="language-cangjie">public mut prop colon: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-funcdecl">FuncDecl</a> 节点的冒号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-decltype"><a class="header" href="#prop-decltype">prop declType</a></h3>
<pre><code class="language-cangjie">public mut prop declType: TypeNode
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-funcdecl">FuncDecl</a> 节点的函数返回类型。</p>
<p>类型：<a href="ast_package_classes.html#class-typenode">TypeNode</a></p>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当 <a href="ast_package_classes.html#class-funcdecl">FuncDecl</a> 节点的函数返回类型是一个缺省值时，抛出异常。</li>
</ul>
<h3 id="prop-funcparams"><a class="header" href="#prop-funcparams">prop funcParams</a></h3>
<pre><code class="language-cangjie">public mut prop funcParams: ArrayList&lt;FuncParam&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-funcdecl">FuncDecl</a> 节点的函数参数。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-funcparam">FuncParam</a>&gt;</p>
<h3 id="prop-lparen-5"><a class="header" href="#prop-lparen-5">prop lParen</a></h3>
<pre><code class="language-cangjie">public mut prop lParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-funcdecl">FuncDecl</a> 节点的左括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-overloadop"><a class="header" href="#prop-overloadop">prop overloadOp</a></h3>
<pre><code class="language-cangjie">public mut prop overloadOp: Tokens
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-funcdecl">FuncDecl</a> 节点的重载操作符。</p>
<p>类型：<a href="ast_package_classes.html#class-tokens">Tokens</a></p>
<h3 id="prop-rparen-5"><a class="header" href="#prop-rparen-5">prop rParen</a></h3>
<pre><code class="language-cangjie">public mut prop rParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-funcdecl">FuncDecl</a> 节点的右括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-18"><a class="header" href="#init-18">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-funcdecl">FuncDecl</a> 对象。</p>
<h3 id="inittokens-13"><a class="header" href="#inittokens-13">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(inputs: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-funcdecl">FuncDecl</a> 对象。</p>
<p>参数：</p>
<ul>
<li>inputs: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-funcdecl">FuncDecl</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-funcdecl">FuncDecl</a> 节点时，抛出异常。</li>
</ul>
<h3 id="func-isconst"><a class="header" href="#func-isconst">func isConst()</a></h3>
<pre><code class="language-cangjie">public func isConst(): Bool
</code></pre>
<p>功能：判断是否是一个 <code>Const</code> 类型的节点。</p>
<p>返回值：</p>
<ul>
<li><a href="../../core/core_package_api/core_package_intrinsics.html#bool">Bool</a> - 是一个 <code>Const</code> 类型的节点返回 true；反之，返回 false。</li>
</ul>
<h2 id="class-funcparam"><a class="header" href="#class-funcparam">class FuncParam</a></h2>
<pre><code class="language-cangjie">public open class FuncParam &lt;: Decl {
    public init()
    public init(inputs: Tokens)
}
</code></pre>
<p>功能：表示函数参数节点，包括非命名参数和命名参数。</p>
<p>一个 <a href="ast_package_classes.html#class-funcparam">FuncParam</a> 节点： <code>func foo(a: Int64, b: Float64) {...}</code> 中的 <code>a: Int64</code> 和 <code>b: Float64</code>。</p>
<h3 id="prop-assign-1"><a class="header" href="#prop-assign-1">prop assign</a></h3>
<pre><code class="language-cangjie">public mut prop assign: Token
</code></pre>
<p>功能：获取或设置具有默认值的函数参数中的 <code>=</code>。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-colon-3"><a class="header" href="#prop-colon-3">prop colon</a></h3>
<pre><code class="language-cangjie">public mut prop colon: Token
</code></pre>
<p>功能：获取或设置置形参中的 <code>:</code>。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-expr-3"><a class="header" href="#prop-expr-3">prop expr</a></h3>
<pre><code class="language-cangjie">public mut prop expr: Expr
</code></pre>
<p>功能：获取或设置具有默认值的函数参数的变量初始化节点。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当函数参数没有进行初始化时，抛出异常。</li>
</ul>
<h3 id="prop-not"><a class="header" href="#prop-not">prop not</a></h3>
<pre><code class="language-cangjie">public mut prop not: Token
</code></pre>
<p>功能：获取或设置命名形参中的 <code>!</code>。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-paramtype"><a class="header" href="#prop-paramtype">prop paramType</a></h3>
<pre><code class="language-cangjie">public mut prop paramType: TypeNode
</code></pre>
<p>功能：获取或设置函数参数的类型。</p>
<p>类型：<a href="ast_package_classes.html#class-typenode">TypeNode</a></p>
<h3 id="init-19"><a class="header" href="#init-19">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-funcparam">FuncParam</a> 对象。</p>
<h3 id="inittokens-14"><a class="header" href="#inittokens-14">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-funcparam">FuncParam</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-funcparam">FuncParam</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-funcparam">FuncParam</a> 节点时，抛出异常。</li>
</ul>
<h3 id="func-ismemberparam"><a class="header" href="#func-ismemberparam">func isMemberParam()</a></h3>
<pre><code class="language-cangjie">public func isMemberParam(): Bool
</code></pre>
<p>功能：当前的函数参数是否是主构造函数中的参数。</p>
<p>返回值：</p>
<ul>
<li><a href="../../core/core_package_api/core_package_intrinsics.html#bool">Bool</a> - 布尔类型，如果是主构造函数中的参数，返回 <code>true</code>。</li>
</ul>
<h2 id="class-functype"><a class="header" href="#class-functype">class FuncType</a></h2>
<pre><code class="language-cangjie">public class FuncType &lt;: TypeNode {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示函数类型节点。</p>
<p>由函数的参数类型和返回类型组成，参数类型与返回类型之间用 <code>-&gt;</code> 分隔，如：<code>(Int32) -&gt; Unit</code>。</p>
<h3 id="prop-arrow"><a class="header" href="#prop-arrow">prop arrow</a></h3>
<pre><code class="language-cangjie">public mut prop arrow: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-functype">FuncType</a> 节点参数类型与返回类型之间的 <code>-&gt;</code>的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-keyword-3"><a class="header" href="#prop-keyword-3">prop keyword</a></h3>
<pre><code class="language-cangjie">public mut prop keyword: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-functype">FuncType</a> 节点的中的关键字 <code>CFunc</code> 的词法单元，若不是一个 <code>CFunc</code> 类型，则获取一个 <a href="ast_package_enums.html#illegal">ILLEGAL</a> 的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-lparen-6"><a class="header" href="#prop-lparen-6">prop lParen</a></h3>
<pre><code class="language-cangjie">public mut prop lParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-functype">FuncType</a> 节点的左括号的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-rparen-6"><a class="header" href="#prop-rparen-6">prop rParen</a></h3>
<pre><code class="language-cangjie">public mut prop rParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-functype">FuncType</a> 节点的右括号的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-returntype"><a class="header" href="#prop-returntype">prop returnType</a></h3>
<pre><code class="language-cangjie">public mut prop returnType: TypeNode
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-functype">FuncType</a> 返回类型节点。</p>
<p>类型：<a href="ast_package_classes.html#class-typenode">TypeNode</a></p>
<h3 id="prop-types-1"><a class="header" href="#prop-types-1">prop types</a></h3>
<pre><code class="language-cangjie">public mut prop types: ArrayList&lt;TypeNode&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-functype">FuncType</a> 节点中函数的参数类型列表。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-typenode">TypeNode</a>&gt;</p>
<h3 id="init-20"><a class="header" href="#init-20">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-functype">FuncType</a> 对象。</p>
<h3 id="inittokens-15"><a class="header" href="#inittokens-15">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-functype">FuncType</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-functype">FuncType</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-functype">FuncType</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-genericconstraint"><a class="header" href="#class-genericconstraint">class GenericConstraint</a></h2>
<pre><code class="language-cangjie">public class GenericConstraint &lt;: Node {
    public init()
}
</code></pre>
<p>功能：表示一个泛型约束节点。</p>
<p>一个 <a href="ast_package_classes.html#class-genericconstraint">GenericConstraint</a> 节点：<code>interface Enumerable&lt;U&gt; where U &lt;: Bounded {}</code> 中的 <code>where where U &lt;: Bounded</code>。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>通过 <code>where</code> 之后的 <code>&lt;:</code> 运算符来声明，由一个下界与一个上界来组成。其中 <code>&lt;:</code> 左边称为约束的下界，下界只能为类型变元。<code>&lt;:</code> 右边称为约束上界，约束上界可以为类型。</p>
</blockquote>
<h3 id="prop-keyword-4"><a class="header" href="#prop-keyword-4">prop keyword</a></h3>
<pre><code class="language-cangjie">public mut prop keyword: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-genericconstraint">GenericConstraint</a> 节点中关键字 <code>where</code> 词法单元，可能为 <a href="ast_package_enums.html#illegal">ILLEGAL</a> 的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-typeargument"><a class="header" href="#prop-typeargument">prop typeArgument</a></h3>
<pre><code class="language-cangjie">public mut prop typeArgument: TypeNode
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-genericconstraint">GenericConstraint</a> 节点中的约束下界。</p>
<p>类型：<a href="ast_package_classes.html#class-typenode">TypeNode</a></p>
<h3 id="prop-upperbound-3"><a class="header" href="#prop-upperbound-3">prop upperBound</a></h3>
<pre><code class="language-cangjie">public mut prop upperBound: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-genericconstraint">GenericConstraint</a> 节点中的 <code>&lt;:</code> 运算符。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-upperbounds"><a class="header" href="#prop-upperbounds">prop upperBounds</a></h3>
<pre><code class="language-cangjie">public mut prop upperBounds: ArrayList&lt;TypeNode&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-genericconstraint">GenericConstraint</a> 节点约束上界的 <a href="ast_package_classes.html#class-typenode">TypeNode</a> 类型节点的集合。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-typenode">TypeNode</a>&gt;</p>
<h3 id="init-21"><a class="header" href="#init-21">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-genericconstraint">GenericConstraint</a> 对象。</p>
<h2 id="class-genericparam"><a class="header" href="#class-genericparam">class GenericParam</a></h2>
<pre><code class="language-cangjie">public class GenericParam &lt;: Node {
    public init()
    public init(parameters: Tokens)
}
</code></pre>
<p>功能：表示一个类型形参节点。</p>
<p>一个 <a href="ast_package_classes.html#class-genericparam">GenericParam</a> 节点：<code>&lt;T1, T2, T3&gt;</code>。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>类型形参用 <code>&lt;&gt;</code> 括起并用 <code>,</code> 分隔多个类型形参名称。</p>
</blockquote>
<h3 id="prop-langle"><a class="header" href="#prop-langle">prop lAngle</a></h3>
<pre><code class="language-cangjie">public mut prop lAngle: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-genericparam">GenericParam</a> 节点中的左尖括号词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-parameters"><a class="header" href="#prop-parameters">prop parameters</a></h3>
<pre><code class="language-cangjie">public mut prop parameters: Tokens
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-genericparam">GenericParam</a> 节点中的类型形参的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型，可能为空，如 <code>&lt;T1, T2, T3&gt;</code> 中的 <code>T1</code> <code>T2</code> 和 <code>T3</code>。</p>
<p>类型：<a href="ast_package_classes.html#class-tokens">Tokens</a></p>
<h3 id="prop-rangle"><a class="header" href="#prop-rangle">prop rAngle</a></h3>
<pre><code class="language-cangjie">public mut prop rAngle: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-genericparam">GenericParam</a> 节点中的右尖括号词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-22"><a class="header" href="#init-22">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-genericparam">GenericParam</a> 对象。</p>
<h3 id="inittokens-16"><a class="header" href="#inittokens-16">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(parameters: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-genericparam">GenericParam</a> 对象。</p>
<p>参数：</p>
<ul>
<li>parameters: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-genericparam">GenericParam</a> 的类型形参的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<h2 id="class-ifexpr"><a class="header" href="#class-ifexpr">class IfExpr</a></h2>
<pre><code class="language-cangjie">public class IfExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示条件表达式。</p>
<p>可以根据判定条件是否成立来决定执行哪条代码分支。一个 <a href="ast_package_classes.html#class-ifexpr">IfExpr</a> 节点中 <code>if</code> 是关键字，<code>if</code> 之后是一个小括号，小括号内可以是一个表达式或者一个 <code>let</code> 声明的解构匹配，接着是一个 <a href="ast_package_classes.html#class-block">Block</a>，<a href="ast_package_classes.html#class-block">Block</a> 之后是可选的 <code>else</code> 分支。 <code>else</code> 分支以 <code>else</code> 关键字开始，后接新的 <code>if</code> 表达式或一个 <a href="ast_package_classes.html#class-block">Block</a>。</p>
<h3 id="prop-condition-2"><a class="header" href="#prop-condition-2">prop condition</a></h3>
<pre><code class="language-cangjie">public mut prop condition: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-ifexpr">IfExpr</a> 节点中的 <code>if</code> 后的条件表达式。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<h3 id="prop-elseexpr"><a class="header" href="#prop-elseexpr">prop elseExpr</a></h3>
<pre><code class="language-cangjie">public mut prop elseExpr: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-ifexpr">IfExpr</a> 节点中 <code>else</code> 分支节点。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当前 <a href="ast_package_classes.html#class-ifexpr">IfExpr</a> 节点没有 else 分支节点。</li>
</ul>
<h3 id="prop-ifblock"><a class="header" href="#prop-ifblock">prop ifBlock</a></h3>
<pre><code class="language-cangjie">public mut prop ifBlock: Block
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-ifexpr">IfExpr</a> 节点中的 <code>if</code> 后的 block 节点。</p>
<p>类型：<a href="ast_package_classes.html#class-block">Block</a></p>
<h3 id="prop-keyworde"><a class="header" href="#prop-keyworde">prop keywordE</a></h3>
<pre><code class="language-cangjie">public mut prop keywordE: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-ifexpr">IfExpr</a> 节点中 <code>else</code> 关键字。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-keywordi-1"><a class="header" href="#prop-keywordi-1">prop keywordI</a></h3>
<pre><code class="language-cangjie">public mut prop keywordI: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-ifexpr">IfExpr</a> 节点中的 <code>if</code> 关键字。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-lparen-7"><a class="header" href="#prop-lparen-7">prop lParen</a></h3>
<pre><code class="language-cangjie">public mut prop lParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-ifexpr">IfExpr</a> 节点中的 <code>if</code> 后的左括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-rparen-7"><a class="header" href="#prop-rparen-7">prop rParen</a></h3>
<pre><code class="language-cangjie">public mut prop rParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-ifexpr">IfExpr</a> 节点中的 <code>if</code> 后的右括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-23"><a class="header" href="#init-23">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-ifexpr">IfExpr</a> 对象。</p>
<h3 id="inittokens-17"><a class="header" href="#inittokens-17">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-ifexpr">IfExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-ifexpr">IfExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-ifexpr">IfExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-importlist"><a class="header" href="#class-importlist">class ImportList</a></h2>
<pre><code class="language-cangjie">public class ImportList &lt;: Node {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示包导入节点。</p>
<p>一个 <a href="ast_package_classes.html#class-importlist">ImportList</a> 节点: <code>import module.package.foo as bar</code>。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>导入节点以可选的访问性修饰符（<code>public/protected/internal/private</code>）加关键字 <code>import</code> 开头。以 <code>import pkga.pkgb.item</code> 为例，<code>pkga.pkgb</code> 为导入的顶级定义或声明所在的包的名字，<code>item</code> 为导入的顶级定义或声明。</p>
</blockquote>
<h3 id="prop-modifier"><a class="header" href="#prop-modifier">prop modifier</a></h3>
<pre><code class="language-cangjie">public mut prop modifier: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-importlist">ImportList</a> 节点中的修饰符，可能为 <a href="ast_package_enums.html#illegal">ILLEGAL</a> 的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-keywordi-2"><a class="header" href="#prop-keywordi-2">prop keywordI</a></h3>
<pre><code class="language-cangjie">public mut prop keywordI: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-importlist">ImportList</a> 节点中的 <code>import</code> 关键字的词法单元，<code>I</code> 为关键字首字母。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-content"><a class="header" href="#prop-content">prop content</a></h3>
<pre><code class="language-cangjie">public mut prop content: ImportContent
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-importlist">ImportList</a> 节点中的被导入的具体项。如 <code>import a.b.c</code> 中的 <code>a.b.c</code> 部分。</p>
<p>类型：<a href="ast_package_classes.html#class-importcontent">ImportContent</a></p>
<h3 id="init-24"><a class="header" href="#init-24">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-importlist">ImportList</a> 对象。</p>
<h3 id="inittokens-18"><a class="header" href="#inittokens-18">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-importlist">ImportList</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-importlist">ImportList</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>) 序列。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-importlist">ImportList</a> 节点时，抛出异常。</li>
</ul>
<h3 id="func-isimportmulti"><a class="header" href="#func-isimportmulti">func isImportMulti()</a></h3>
<pre><code class="language-cangjie">public func isImportMulti(): Bool
</code></pre>
<p>功能：判断 <a href="ast_package_classes.html#class-importlist">ImportList</a> 节点是否导入了多个顶级定义或声明。</p>
<p>返回值：</p>
<ul>
<li><a href="../../core/core_package_api/core_package_intrinsics.html#bool">Bool</a> - 如果 <a href="ast_package_classes.html#class-importlist">ImportList</a> 节点导入了多个顶级定义或声明，返回 true；反之，返回 false。</li>
</ul>
<h2 id="class-importcontent"><a class="header" href="#class-importcontent">class ImportContent</a></h2>
<pre><code class="language-cangjie">public class ImportContent &lt;: Node {
    public init()
}
</code></pre>
<h3 id="prop-importkind"><a class="header" href="#prop-importkind">prop importKind</a></h3>
<pre><code class="language-cangjie">public mut prop importKind: ImportKind
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-importcontent">ImportContent</a> 节点中导入类型。</p>
<p>类型：<a href="ast_package_enums.html#enum-importkind">ImportKind</a></p>
<h3 id="prop-prefixpaths"><a class="header" href="#prop-prefixpaths">prop prefixPaths</a></h3>
<pre><code class="language-cangjie">public mut prop prefixPaths: Tokens
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-importcontent">ImportContent</a> 节点中完整包名的前缀部分的词法单元序列，可能为空。如 <code>import a.b.c</code> 中的 <code>a</code> 和 <code>b</code>。</p>
<p>类型：<a href="ast_package_classes.html#class-tokens">Tokens</a></p>
<h3 id="prop-prefixdots"><a class="header" href="#prop-prefixdots">prop prefixDots</a></h3>
<pre><code class="language-cangjie">public mut prop prefixDots: Tokens
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-importcontent">ImportContent</a> 节点中完整包名中用于分隔每层子包的词法单元序列，可能为空。如 <code>import a.b.c</code> 中的两个 <code>.</code>。</p>
<p>类型：<a href="ast_package_classes.html#class-tokens">Tokens</a></p>
<h3 id="prop-identifier-5"><a class="header" href="#prop-identifier-5">prop identifier</a></h3>
<pre><code class="language-cangjie">public mut prop identifier: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-importcontent">ImportContent</a> 节点中被导入的项，它可能是包中的顶层定义或声明，也可能是子包的名字。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-importalias"><a class="header" href="#prop-importalias">prop importAlias</a></h3>
<pre><code class="language-cangjie">public mut prop importAlias: Tokens
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-importcontent">ImportContent</a> 节点中导入的定义或声明的别名词法单元序列，只有 <code>importKind</code> 为 <code>ImportKind.Alias</code> 时非空。如：<code>import packageName.xxx as yyy</code> 中的 <code>as yyy</code>。</p>
<p>类型：<a href="ast_package_classes.html#class-tokens">Tokens</a></p>
<h3 id="prop-lbrace-3"><a class="header" href="#prop-lbrace-3">prop lBrace</a></h3>
<pre><code class="language-cangjie">public mut prop lBrace: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-importcontent">ImportContent</a> 节点中的 <code>{</code> 操作符词法单元，只有 <code>importKind</code> 为 <code>ImportKind.Multi</code> 时非空。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-items"><a class="header" href="#prop-items">prop items</a></h3>
<pre><code class="language-cangjie">public mut prop items: ArrayList&lt;ImportContent&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-importcontent">ImportContent</a> 节点中被导入的所有项，只有 <code>importKind</code> 为 <code>ImportKind.Multi</code> 时非空。</p>
<p>类型：ArrayList&lt;<a href="ast_package_classes.html#class-importcontent">ImportContent</a>&gt;</p>
<h3 id="prop-commas"><a class="header" href="#prop-commas">prop commas</a></h3>
<pre><code class="language-cangjie">public mut prop commas: Tokens
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-importcontent">ImportContent</a> 节点中的 <code>,</code> 操作符词法单元序列，只有 <code>importKind</code> 为 <code>ImportKind.Multi</code> 时非空。</p>
<p>类型：<a href="ast_package_classes.html#class-tokens">Tokens</a></p>
<h3 id="prop-rbrace-3"><a class="header" href="#prop-rbrace-3">prop rBrace</a></h3>
<pre><code class="language-cangjie">public mut prop rBrace: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-importcontent">ImportContent</a> 节点中的 <code>}</code> 操作符词法单元，只有 <code>importKind</code> 为 <code>ImportKind.Multi</code> 时非空。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-25"><a class="header" href="#init-25">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-importcontent">ImportContent</a> 对象。</p>
<h2 id="func-isimportalias"><a class="header" href="#func-isimportalias">func isImportAlias()</a></h2>
<pre><code class="language-cangjie">public func isImportAlias(): Bool
</code></pre>
<p>功能：判断 <a href="ast_package_classes.html#class-importcontent">ImportContent</a> 节点是否对导入项取了别名。</p>
<p>返回值：</p>
<ul>
<li><a href="../../core/core_package_api/core_package_intrinsics.html#bool">Bool</a> - <a href="ast_package_classes.html#class-importcontent">ImportContent</a> 节点是否对导入项取了别名。</li>
</ul>
<h2 id="func-isimportall"><a class="header" href="#func-isimportall">func isImportAll()</a></h2>
<pre><code class="language-cangjie">public func isImportAll(): Bool
</code></pre>
<p>功能：判断 <a href="ast_package_classes.html#class-importcontent">ImportContent</a> 节点是否为全导入。</p>
<p>返回值：</p>
<ul>
<li><a href="../../core/core_package_api/core_package_intrinsics.html#bool">Bool</a> - <a href="ast_package_classes.html#class-importcontent">ImportContent</a> 节点是否为全导入。</li>
</ul>
<h2 id="func-isimportmulti-1"><a class="header" href="#func-isimportmulti-1">func isImportMulti()</a></h2>
<pre><code class="language-cangjie">public func isImportMulti(): Bool
</code></pre>
<p>功能：判断 <a href="ast_package_classes.html#class-importcontent">ImportContent</a> 节点是否导入了多个顶级定义或声明。</p>
<p>返回值：</p>
<ul>
<li><a href="../../core/core_package_api/core_package_intrinsics.html#bool">Bool</a> - <a href="ast_package_classes.html#class-importcontent">ImportContent</a> 节点是否导入了多个顶级定义或声明。</li>
</ul>
<h2 id="func-isimportsingle"><a class="header" href="#func-isimportsingle">func isImportSingle()</a></h2>
<pre><code class="language-cangjie">public func isImportSingle(): Bool
</code></pre>
<p>功能：判断 <a href="ast_package_classes.html#class-importcontent">ImportContent</a> 节点是否为单导入。</p>
<p>返回值：</p>
<ul>
<li><a href="../../core/core_package_api/core_package_intrinsics.html#bool">Bool</a> - <a href="ast_package_classes.html#class-importcontent">ImportContent</a> 节点是否为单导入。</li>
</ul>
<h2 id="class-incordecexpr"><a class="header" href="#class-incordecexpr">class IncOrDecExpr</a></h2>
<pre><code class="language-cangjie">public class IncOrDecExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示包含自增操作符（<code>++</code>）或自减操作符（<code>--</code>）的表达式。</p>
<h3 id="prop-expr-4"><a class="header" href="#prop-expr-4">prop expr</a></h3>
<pre><code class="language-cangjie">public mut prop expr: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-incordecexpr">IncOrDecExpr</a> 中的表达式。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<h3 id="prop-op-1"><a class="header" href="#prop-op-1">prop op</a></h3>
<pre><code class="language-cangjie">public mut prop op: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-incordecexpr">IncOrDecExpr</a> 中的操作符。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-26"><a class="header" href="#init-26">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-incordecexpr">IncOrDecExpr</a> 对象。</p>
<h3 id="inittokens-19"><a class="header" href="#inittokens-19">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-incordecexpr">IncOrDecExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-incordecexpr">IncOrDecExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-incordecexpr">IncOrDecExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-interfacedecl"><a class="header" href="#class-interfacedecl">class InterfaceDecl</a></h2>
<pre><code class="language-cangjie">public class InterfaceDecl &lt;: Decl {
    public init()
    public init(inputs: Tokens)
}
</code></pre>
<p>功能：表示接口定义节点。</p>
<p>接口的定义使用 <code>interface</code> 关键字，接口定义依次为：可缺省的修饰符、interface 关键字、接口名、可选的类型参数、是否指定父接口、可选的泛型约束、接口体的定义。</p>
<h3 id="prop-body-2"><a class="header" href="#prop-body-2">prop body</a></h3>
<pre><code class="language-cangjie">public mut prop body: Body
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-interfacedecl">InterfaceDecl</a> 节点的类体。</p>
<p>类型：<a href="ast_package_classes.html#class-body">Body</a></p>
<h3 id="prop-supertypes-3"><a class="header" href="#prop-supertypes-3">prop superTypes</a></h3>
<pre><code class="language-cangjie">public mut prop superTypes: ArrayList&lt;TypeNode&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-interfacedecl">InterfaceDecl</a> 节点的父接口。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-typenode">TypeNode</a>&gt;</p>
<h3 id="prop-upperbound-4"><a class="header" href="#prop-upperbound-4">prop upperBound</a></h3>
<pre><code class="language-cangjie">public mut prop upperBound: Token
</code></pre>
<p>功能：获取或设置 <code>&lt;:</code> 操作符。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-27"><a class="header" href="#init-27">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-interfacedecl">InterfaceDecl</a> 对象。</p>
<h3 id="inittokens-20"><a class="header" href="#inittokens-20">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(inputs: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-interfacedecl">InterfaceDecl</a> 对象。</p>
<p>参数：</p>
<ul>
<li>inputs: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-interfacedecl">InterfaceDecl</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-interfacedecl">InterfaceDecl</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-isexpr"><a class="header" href="#class-isexpr">class IsExpr</a></h2>
<pre><code class="language-cangjie">public class IsExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示一个类型检查表达式。</p>
<p>一个 <a href="ast_package_classes.html#class-isexpr">IsExpr</a> 表达式：<code>e is T</code>，类型为 <a href="../../core/core_package_api/core_package_intrinsics.html#bool">Bool</a>。其中 e 可以是任何类型的表达式，T 可以是任何类型。</p>
<h3 id="prop-expr-5"><a class="header" href="#prop-expr-5">prop expr</a></h3>
<pre><code class="language-cangjie">public mut prop expr: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-isexpr">IsExpr</a> 节点中的表达式节点。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<h3 id="prop-keyword-5"><a class="header" href="#prop-keyword-5">prop keyword</a></h3>
<pre><code class="language-cangjie">public mut prop keyword: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-isexpr">IsExpr</a> 节点中的 <code>is</code> 操作符。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-shifttype-1"><a class="header" href="#prop-shifttype-1">prop shiftType</a></h3>
<pre><code class="language-cangjie">public mut prop shiftType: TypeNode
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-isexpr">IsExpr</a> 节点中的目标类型。</p>
<p>类型：<a href="ast_package_classes.html#class-typenode">TypeNode</a></p>
<h3 id="init-28"><a class="header" href="#init-28">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-isexpr">IsExpr</a> 对象。</p>
<h3 id="inittokens-21"><a class="header" href="#inittokens-21">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-isexpr">IsExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-isexpr">IsExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-isexpr">IsExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-jumpexpr"><a class="header" href="#class-jumpexpr">class JumpExpr</a></h2>
<pre><code class="language-cangjie">public class JumpExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示循环表达式的循环体中的 <code>break</code> 和 <code>continue</code>。</p>
<h3 id="prop-keyword-6"><a class="header" href="#prop-keyword-6">prop keyword</a></h3>
<pre><code class="language-cangjie">public mut prop keyword: Token
</code></pre>
<p>功能：获取或设置关键字。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-29"><a class="header" href="#init-29">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-jumpexpr">JumpExpr</a> 对象。</p>
<h3 id="inittokens-22"><a class="header" href="#inittokens-22">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-jumpexpr">JumpExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-jumpexpr">JumpExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-jumpexpr">JumpExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-lambdaexpr"><a class="header" href="#class-lambdaexpr">class LambdaExpr</a></h2>
<pre><code class="language-cangjie">public class LambdaExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示 <code>Lambda</code> 表达式，是一个匿名的函数。</p>
<p>一个 <a href="ast_package_classes.html#class-lambdaexpr">LambdaExpr</a> 节点有两种形式，一种是有形参的，例如 <code>{a: Int64 =&gt; e1; e2 }</code>，另一种是无形参的，例如 <code>{ =&gt; e1; e2 }</code>。</p>
<h3 id="prop-doublearrow"><a class="header" href="#prop-doublearrow">prop doubleArrow</a></h3>
<pre><code class="language-cangjie">public mut prop doubleArrow: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-lambdaexpr">LambdaExpr</a> 中的 <code>=&gt;</code>。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-funcparams-1"><a class="header" href="#prop-funcparams-1">prop funcParams</a></h3>
<pre><code class="language-cangjie">public mut prop funcParams:  ArrayList&lt;FuncParam&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-lambdaexpr">LambdaExpr</a> 中的参数列表。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-funcparam">FuncParam</a>&gt;</p>
<h3 id="prop-lbrace-4"><a class="header" href="#prop-lbrace-4">prop lBrace</a></h3>
<pre><code class="language-cangjie">public mut prop lBrace: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-lambdaexpr">LambdaExpr</a> 中的左大括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-nodes-1"><a class="header" href="#prop-nodes-1">prop nodes</a></h3>
<pre><code class="language-cangjie">public mut prop nodes: ArrayList&lt;Node&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-lambdaexpr">LambdaExpr</a> 中的表达式或声明节点。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-node">Node</a>&gt;</p>
<h3 id="prop-rbrace-4"><a class="header" href="#prop-rbrace-4">prop rBrace</a></h3>
<pre><code class="language-cangjie">public mut prop rBrace: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-lambdaexpr">LambdaExpr</a> 中的右大括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-30"><a class="header" href="#init-30">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-lambdaexpr">LambdaExpr</a> 对象。</p>
<h3 id="inittokens-23"><a class="header" href="#inittokens-23">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-lambdaexpr">LambdaExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-lambdaexpr">LambdaExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-lambdaexpr">LambdaExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-letpatternexpr"><a class="header" href="#class-letpatternexpr">class LetPatternExpr</a></h2>
<pre><code class="language-cangjie">public class LetPatternExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示 <code>let</code> 声明的解构匹配节点。</p>
<p>一个 <a href="ast_package_classes.html#class-letpatternexpr">LetPatternExpr</a> 节点：<code>if (let Some(v) &lt;- x)</code> 中的 <code>let Some(v) &lt;- x</code>。</p>
<h3 id="prop-backarrow"><a class="header" href="#prop-backarrow">prop backArrow</a></h3>
<pre><code class="language-cangjie">public mut prop backArrow: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-letpatternexpr">LetPatternExpr</a> 节点中 <code>&lt;-</code> 操作符。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-expr-6"><a class="header" href="#prop-expr-6">prop expr</a></h3>
<pre><code class="language-cangjie">public mut prop expr: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-letpatternexpr">LetPatternExpr</a> 节点中 <code>&lt;-</code> 操作符之后的表达式。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<h3 id="prop-keyword-7"><a class="header" href="#prop-keyword-7">prop keyword</a></h3>
<pre><code class="language-cangjie">public mut prop keyword: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-letpatternexpr">LetPatternExpr</a> 节点中 <code>let</code> 关键字。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-pattern-2"><a class="header" href="#prop-pattern-2">prop pattern</a></h3>
<pre><code class="language-cangjie">public mut prop pattern: Pattern
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-letpatternexpr">LetPatternExpr</a> 节点中 <code>let</code> 之后的 pattern。</p>
<p>类型：<a href="ast_package_classes.html#class-pattern">Pattern</a></p>
<h3 id="init-31"><a class="header" href="#init-31">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-letpatternexpr">LetPatternExpr</a> 对象。</p>
<h3 id="inittokens-24"><a class="header" href="#inittokens-24">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-letpatternexpr">LetPatternExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-letpatternexpr">LetPatternExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-letpatternexpr">LetPatternExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-litconstexpr"><a class="header" href="#class-litconstexpr">class LitConstExpr</a></h2>
<pre><code class="language-cangjie">public class LitConstExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示一个常量表达式节点。</p>
<p>一个 <a href="ast_package_classes.html#class-litconstexpr">LitConstExpr</a> 表达式：<code>&quot;abc&quot;</code>，<code>123</code> 等。</p>
<h3 id="prop-literal"><a class="header" href="#prop-literal">prop literal</a></h3>
<pre><code class="language-cangjie">public mut prop literal: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-litconstexpr">LitConstExpr</a> 节点中的字面量。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-32"><a class="header" href="#init-32">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-litconstexpr">LitConstExpr</a> 对象。</p>
<h3 id="inittokens-25"><a class="header" href="#inittokens-25">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-litconstexpr">LitConstExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-litconstexpr">LitConstExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-parenexpr">ParenExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-macrodecl"><a class="header" href="#class-macrodecl">class MacroDecl</a></h2>
<pre><code class="language-cangjie">public class MacroDecl &lt;: Decl {
    public init()
    public init(inputs: Tokens)
}
</code></pre>
<p>功能：表示一个宏定义节点。</p>
<p>一个 <a href="ast_package_classes.html#class-macrodecl">MacroDecl</a> 节点：<code>public macro M(input: Tokens): Tokens {...}</code>。</p>
<h3 id="prop-block-3"><a class="header" href="#prop-block-3">prop block</a></h3>
<pre><code class="language-cangjie">public mut prop block: Block
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-macrodecl">MacroDecl</a> 节点的函数体。</p>
<p>类型：<a href="ast_package_classes.html#class-block">Block</a></p>
<h3 id="prop-colon-4"><a class="header" href="#prop-colon-4">prop colon</a></h3>
<pre><code class="language-cangjie">public mut prop colon: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-macrodecl">MacroDecl</a> 节点的冒号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-decltype-1"><a class="header" href="#prop-decltype-1">prop declType</a></h3>
<pre><code class="language-cangjie">public mut prop declType: TypeNode
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-macrodecl">MacroDecl</a> 节点的函数返回类型。</p>
<p>类型：<a href="ast_package_classes.html#class-typenode">TypeNode</a></p>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当 <a href="ast_package_classes.html#class-macrodecl">MacroDecl</a> 节点的函数返回类型是一个缺省值时，抛出异常。</li>
</ul>
<h3 id="prop-funcparams-2"><a class="header" href="#prop-funcparams-2">prop funcParams</a></h3>
<pre><code class="language-cangjie">public mut prop funcParams: ArrayList&lt;FuncParam&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-macrodecl">MacroDecl</a> 节点的参数。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-funcparam">FuncParam</a>&gt;</p>
<h3 id="prop-lparen-8"><a class="header" href="#prop-lparen-8">prop lParen</a></h3>
<pre><code class="language-cangjie">public mut prop lParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-macrodecl">MacroDecl</a> 节点的左小括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-rparen-8"><a class="header" href="#prop-rparen-8">prop rParen</a></h3>
<pre><code class="language-cangjie">public mut prop rParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-macrodecl">MacroDecl</a> 节点的右小括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-33"><a class="header" href="#init-33">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-macrodecl">MacroDecl</a> 对象。</p>
<h3 id="inittokens-26"><a class="header" href="#inittokens-26">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(inputs: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-macrodecl">MacroDecl</a> 对象。</p>
<p>参数：</p>
<ul>
<li>inputs: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-macrodecl">MacroDecl</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-macrodecl">MacroDecl</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-macroexpanddecl"><a class="header" href="#class-macroexpanddecl">class MacroExpandDecl</a></h2>
<pre><code class="language-cangjie">public class MacroExpandDecl &lt;: Decl {
    public init()
    public init(inputs: Tokens)
}
</code></pre>
<p>功能：表示宏调用节点。</p>
<p>一个 <a href="ast_package_classes.html#class-macroexpanddecl">MacroExpandDecl</a> 节点： <code>@M class A {}</code>。</p>
<h3 id="prop-fullidentifier"><a class="header" href="#prop-fullidentifier">prop fullIdentifier</a></h3>
<pre><code class="language-cangjie">public mut prop fullIdentifier: Token
</code></pre>
<p>功能：获取或设置宏调用节点的完整标识符。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-lparen-9"><a class="header" href="#prop-lparen-9">prop lParen</a></h3>
<pre><code class="language-cangjie">public mut prop lParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-macroexpanddecl">MacroExpandDecl</a> 属性宏调用的左小括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-lsquare-1"><a class="header" href="#prop-lsquare-1">prop lSquare</a></h3>
<pre><code class="language-cangjie">public mut prop lSquare: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-macroexpanddecl">MacroExpandDecl</a> 属性宏调用的左中括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-macroattrs"><a class="header" href="#prop-macroattrs">prop macroAttrs</a></h3>
<pre><code class="language-cangjie">public mut prop macroAttrs: Tokens
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-macroexpanddecl">MacroExpandDecl</a> 属性宏调用的输入。</p>
<p>类型：<a href="ast_package_classes.html#class-tokens">Tokens</a></p>
<h3 id="prop-macroinputdecl"><a class="header" href="#prop-macroinputdecl">prop macroInputDecl</a></h3>
<pre><code class="language-cangjie">public mut prop macroInputDecl: Decl
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-macroexpanddecl">MacroExpandDecl</a> 中的声明节点。</p>
<p>类型：<a href="ast_package_classes.html#class-decl">Decl</a></p>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当 <a href="ast_package_classes.html#class-macrodecl">MacroDecl</a> 节点中没有声明节点时，抛出异常。</li>
</ul>
<h3 id="prop-macroinputs"><a class="header" href="#prop-macroinputs">prop macroInputs</a></h3>
<pre><code class="language-cangjie">public mut prop macroInputs: Tokens
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-macroexpanddecl">MacroExpandDecl</a> 宏调用的输入。</p>
<p>类型：<a href="ast_package_classes.html#class-tokens">Tokens</a></p>
<h3 id="prop-rparen-9"><a class="header" href="#prop-rparen-9">prop rParen</a></h3>
<pre><code class="language-cangjie">public mut prop rParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-macroexpanddecl">MacroExpandDecl</a> 宏调用的右小括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-rsquare-1"><a class="header" href="#prop-rsquare-1">prop rSquare</a></h3>
<pre><code class="language-cangjie">public mut prop rSquare: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-macroexpanddecl">MacroExpandDecl</a> 属性宏调用的右中括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-34"><a class="header" href="#init-34">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-macroexpanddecl">MacroExpandDecl</a> 对象。</p>
<h3 id="inittokens-27"><a class="header" href="#inittokens-27">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(inputs: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-macroexpanddecl">MacroExpandDecl</a> 对象。</p>
<p>参数：</p>
<ul>
<li>inputs: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-macroexpanddecl">MacroExpandDecl</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-macroexpanddecl">MacroExpandDecl</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-macroexpandexpr"><a class="header" href="#class-macroexpandexpr">class MacroExpandExpr</a></h2>
<pre><code class="language-cangjie">public class MacroExpandExpr &lt;: Expr {
    public init()
    public init(inputs: Tokens)
}
</code></pre>
<p>功能：表示宏调用节点。</p>
<p>一个 <a href="ast_package_classes.html#class-macroexpandexpr">MacroExpandExpr</a> 节点： <code>@M (a is Int64)</code>。</p>
<h3 id="prop-at-1"><a class="header" href="#prop-at-1">prop at</a></h3>
<pre><code class="language-cangjie">public mut prop at: Token
</code></pre>
<p>功能：获取或设置宏调用节点的关键字 <a href="../../collection/collection_package_api/collection_package_function.html#func-attint64">at</a>。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-identifier-6"><a class="header" href="#prop-identifier-6">prop identifier</a></h3>
<pre><code class="language-cangjie">public mut prop identifier: Token
</code></pre>
<p>功能：获取或设置宏调用节点的标识符。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-lparen-10"><a class="header" href="#prop-lparen-10">prop lParen</a></h3>
<pre><code class="language-cangjie">public mut prop lParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-macroexpandexpr">MacroExpandExpr</a> 属性宏调用的左小括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-lsquare-2"><a class="header" href="#prop-lsquare-2">prop lSquare</a></h3>
<pre><code class="language-cangjie">public mut prop lSquare: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-macroexpandexpr">MacroExpandExpr</a> 属性宏调用的左中括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-macroattrs-1"><a class="header" href="#prop-macroattrs-1">prop macroAttrs</a></h3>
<pre><code class="language-cangjie">public mut prop macroAttrs: Tokens
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-macroexpandexpr">MacroExpandExpr</a> 属性宏调用的输入。</p>
<p>类型：<a href="ast_package_classes.html#class-tokens">Tokens</a></p>
<h3 id="prop-macroinputs-1"><a class="header" href="#prop-macroinputs-1">prop macroInputs</a></h3>
<pre><code class="language-cangjie">public mut prop macroInputs: Tokens
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-macroexpandexpr">MacroExpandExpr</a> 宏调用的输入。</p>
<p>类型：<a href="ast_package_classes.html#class-tokens">Tokens</a></p>
<h3 id="prop-rparen-10"><a class="header" href="#prop-rparen-10">prop rParen</a></h3>
<pre><code class="language-cangjie">public mut prop rParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-macroexpandexpr">MacroExpandExpr</a> 宏调用的右小括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-rsquare-2"><a class="header" href="#prop-rsquare-2">prop rSquare</a></h3>
<pre><code class="language-cangjie">public mut prop rSquare: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-macroexpandexpr">MacroExpandExpr</a> 属性宏调用的右中括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-35"><a class="header" href="#init-35">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-macroexpandexpr">MacroExpandExpr</a> 对象。</p>
<h3 id="inittokens-28"><a class="header" href="#inittokens-28">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-macroexpandexpr">MacroExpandExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-macroexpandexpr">MacroExpandExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-macroexpandexpr">MacroExpandExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-macroexpandparam"><a class="header" href="#class-macroexpandparam">class MacroExpandParam</a></h2>
<pre><code class="language-cangjie">public class MacroExpandParam &lt;: FuncParam {
    public init()
}
</code></pre>
<p>功能：表示宏调用节点。</p>
<p>一个 <a href="ast_package_classes.html#class-macroexpanddecl">MacroExpandDecl</a> 节点： <code>func foo (@M a: Int64)</code> 中的 <code>@M a: Int64</code>。</p>
<h3 id="prop-fullidentifier-1"><a class="header" href="#prop-fullidentifier-1">prop fullIdentifier</a></h3>
<pre><code class="language-cangjie">public mut prop fullIdentifier: Token
</code></pre>
<p>功能：获取或设置宏调用节点的完整标识符。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-lparen-11"><a class="header" href="#prop-lparen-11">prop lParen</a></h3>
<pre><code class="language-cangjie">public mut prop lParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-macroexpandparam">MacroExpandParam</a> 属性宏调用的左小括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-lsquare-3"><a class="header" href="#prop-lsquare-3">prop lSquare</a></h3>
<pre><code class="language-cangjie">public mut prop lSquare: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-macroexpandparam">MacroExpandParam</a> 属性宏调用的左中括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-macroattrs-2"><a class="header" href="#prop-macroattrs-2">prop macroAttrs</a></h3>
<pre><code class="language-cangjie">public mut prop macroAttrs: Tokens
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-macroexpandparam">MacroExpandParam</a> 属性宏调用的输入。</p>
<p>类型：<a href="ast_package_classes.html#class-tokens">Tokens</a></p>
<h3 id="prop-macroinputdecl-1"><a class="header" href="#prop-macroinputdecl-1">prop macroInputDecl</a></h3>
<pre><code class="language-cangjie">public mut prop macroInputDecl: Decl
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-macroexpandparam">MacroExpandParam</a> 中的声明节点。</p>
<p>类型：<a href="ast_package_classes.html#class-decl">Decl</a></p>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当 <a href="ast_package_classes.html#class-macroexpandparam">MacroExpandParam</a> 节点中没有声明节点时，抛出异常。</li>
</ul>
<h3 id="prop-macroinputs-2"><a class="header" href="#prop-macroinputs-2">prop macroInputs</a></h3>
<pre><code class="language-cangjie">public mut prop macroInputs: Tokens
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-macroexpandparam">MacroExpandParam</a> 宏调用的输入。</p>
<p>类型：<a href="ast_package_classes.html#class-tokens">Tokens</a></p>
<h3 id="prop-rparen-11"><a class="header" href="#prop-rparen-11">prop rParen</a></h3>
<pre><code class="language-cangjie">public mut prop rParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-macroexpandparam">MacroExpandParam</a> 宏调用的右小括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-rsquare-3"><a class="header" href="#prop-rsquare-3">prop rSquare</a></h3>
<pre><code class="language-cangjie">public mut prop rSquare: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-macroexpandparam">MacroExpandParam</a> 属性宏调用的右中括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-36"><a class="header" href="#init-36">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-macroexpandparam">MacroExpandParam</a> 对象。</p>
<h2 id="class-macromessage"><a class="header" href="#class-macromessage">class MacroMessage</a></h2>
<pre><code class="language-cangjie">public class MacroMessage
</code></pre>
<p>功能：记录内层宏发送的信息。</p>
<h3 id="func-getboolstring"><a class="header" href="#func-getboolstring">func getBool(String)</a></h3>
<pre><code class="language-cangjie">public func getBool(key: String): Bool
</code></pre>
<p>功能：获取对应 key 值的 <a href="../../core/core_package_api/core_package_intrinsics.html#bool">Bool</a> 类型信息。</p>
<p>参数：</p>
<ul>
<li>key: <a href="../../core/core_package_api/core_package_structs.html#struct-string">String</a> - 用于检索的关键字的名字。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="../../core/core_package_api/core_package_intrinsics.html#bool">Bool</a> - 返回存在 key 值对应的 <a href="../../core/core_package_api/core_package_intrinsics.html#bool">Bool</a> 类型的信息。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="../../core/core_package_api/core_package_exceptions.html#class-exception">Exception</a> - 当不存在 key 值对应的 <a href="../../core/core_package_api/core_package_intrinsics.html#bool">Bool</a> 类型的信息时，抛出异常。</li>
</ul>
<h3 id="func-getint64string"><a class="header" href="#func-getint64string">func getInt64(String)</a></h3>
<pre><code class="language-cangjie">public func getInt64(key: String): Int64
</code></pre>
<p>功能：获取对应 key 值的 <a href="../../core/core_package_api/core_package_intrinsics.html#int64">Int64</a> 类型信息。</p>
<p>参数：</p>
<ul>
<li>key: <a href="../../core/core_package_api/core_package_structs.html#struct-string">String</a> - 用于检索的关键字的名字。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="../../core/core_package_api/core_package_intrinsics.html#int64">Int64</a> - 返回存在 key 值对应的 <a href="../../core/core_package_api/core_package_intrinsics.html#int64">Int64</a> 类型的信息。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="../../core/core_package_api/core_package_exceptions.html#class-exception">Exception</a> - 当不存在 key 值对应的 <a href="../../core/core_package_api/core_package_intrinsics.html#int64">Int64</a> 类型的信息时，抛出异常。</li>
</ul>
<h3 id="func-getstringstring"><a class="header" href="#func-getstringstring">func getString(String)</a></h3>
<pre><code class="language-cangjie">public func getString(key: String): String
</code></pre>
<p>功能：获取对应 key 值的 <a href="../../core/core_package_api/core_package_structs.html#struct-string">String</a> 类型信息。</p>
<p>参数：</p>
<ul>
<li>key: <a href="../../core/core_package_api/core_package_structs.html#struct-string">String</a> - 用于检索的关键字的名字。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="../../core/core_package_api/core_package_structs.html#struct-string">String</a> - 返回存在 key 值对应的 <a href="../../core/core_package_api/core_package_structs.html#struct-string">String</a> 类型的信息。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="../../core/core_package_api/core_package_exceptions.html#class-exception">Exception</a> - 当不存在 key 值对应的 <a href="../../core/core_package_api/core_package_structs.html#struct-string">String</a> 类型的信息时，抛出异常。</li>
</ul>
<h3 id="func-hasitemstring"><a class="header" href="#func-hasitemstring">func hasItem(String)</a></h3>
<pre><code class="language-cangjie">public func hasItem(key: String): Bool
</code></pre>
<p>功能：检查是否有 key 值对应的相关信息。</p>
<p>参数：</p>
<ul>
<li>key: <a href="../../core/core_package_api/core_package_structs.html#struct-string">String</a> - 用于检索的关键字名字。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="../../core/core_package_api/core_package_intrinsics.html#bool">Bool</a> - 若存在 key 值对应的相关信息，返回 true；反之，返回 false。</li>
</ul>
<h2 id="class-maindecl"><a class="header" href="#class-maindecl">class MainDecl</a></h2>
<pre><code class="language-cangjie">public class MainDecl &lt;: Decl {
    public init()
    public init(inputs: Tokens)
}
</code></pre>
<p>功能：表示一个 <code>main</code> 函数定义节点。</p>
<p>一个 <a href="ast_package_classes.html#class-maindecl">MainDecl</a> 节点：<code>main() {}</code>。</p>
<h3 id="prop-block-4"><a class="header" href="#prop-block-4">prop block</a></h3>
<pre><code class="language-cangjie">public mut prop block: Block
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-maindecl">MainDecl</a> 节点的函数体。</p>
<p>类型：<a href="ast_package_classes.html#class-block">Block</a></p>
<h3 id="prop-colon-5"><a class="header" href="#prop-colon-5">prop colon</a></h3>
<pre><code class="language-cangjie">public mut prop colon: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-maindecl">MainDecl</a> 节点的冒号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-decltype-2"><a class="header" href="#prop-decltype-2">prop declType</a></h3>
<pre><code class="language-cangjie">public mut prop declType: TypeNode
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-maindecl">MainDecl</a> 节点的函数返回类型。</p>
<p>类型：<a href="ast_package_classes.html#class-typenode">TypeNode</a></p>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当 <a href="ast_package_classes.html#class-maindecl">MainDecl</a> 节点的函数返回类型是一个缺省值时，抛出异常。</li>
</ul>
<h3 id="prop-funcparams-3"><a class="header" href="#prop-funcparams-3">prop funcParams</a></h3>
<pre><code class="language-cangjie">public mut prop funcParams: ArrayList&lt;FuncParam&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-maindecl">MainDecl</a> 节点的函数参数。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-funcparam">FuncParam</a>&gt;</p>
<h3 id="prop-lparen-12"><a class="header" href="#prop-lparen-12">prop lParen</a></h3>
<pre><code class="language-cangjie">public mut prop lParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-maindecl">MainDecl</a> 节点的左括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-rparen-12"><a class="header" href="#prop-rparen-12">prop rParen</a></h3>
<pre><code class="language-cangjie">public mut prop rParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-maindecl">MainDecl</a> 节点的右括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-37"><a class="header" href="#init-37">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-maindecl">MainDecl</a> 对象。</p>
<h3 id="inittokens-29"><a class="header" href="#inittokens-29">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(inputs: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-maindecl">MainDecl</a> 对象。</p>
<p>参数：</p>
<ul>
<li>inputs: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-maindecl">MainDecl</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-maindecl">MainDecl</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-matchcase"><a class="header" href="#class-matchcase">class MatchCase</a></h2>
<pre><code class="language-cangjie">public class MatchCase &lt;: Node {
    public init()
}
</code></pre>
<p>功能：表示一个 <a href="ast_package_classes.html#class-matchcase">MatchCase</a> 类型。</p>
<p>一个 <a href="ast_package_classes.html#class-matchcase">MatchCase</a> 节点：<code>case failScore where score &gt; 0 =&gt; 0</code>。</p>
<blockquote>
<p><strong>说明：</strong></p>
<ul>
<li><a href="ast_package_classes.html#class-matchcase">MatchCase</a> 以关键字 <code>case</code> 开头，后跟 <a href="ast_package_classes.html#class-expr">Expr</a> 或者一个或多个由 <code>|</code> 分隔的相同种类的 <code>pattern</code>，一个可选的 <code>patternguard</code>，一个 <code>=&gt;</code> 和一系列声明或表达式。</li>
<li>该节点与 <a href="ast_package_classes.html#class-matchexpr">MatchExpr</a> 存在强绑定关系。</li>
</ul>
</blockquote>
<h3 id="prop-arrow-1"><a class="header" href="#prop-arrow-1">prop arrow</a></h3>
<pre><code class="language-cangjie">public mut prop arrow: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-matchcase">MatchCase</a> 中的 <code>=&gt;</code> 操作符的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-block-5"><a class="header" href="#prop-block-5">prop block</a></h3>
<pre><code class="language-cangjie">public mut prop block: Block
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-matchcase">MatchCase</a> 中的一系列声明或表达式节点。</p>
<p>类型：<a href="ast_package_classes.html#class-block">Block</a></p>
<h3 id="prop-expr-7"><a class="header" href="#prop-expr-7">prop expr</a></h3>
<pre><code class="language-cangjie">public mut prop expr: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-matchcase">MatchCase</a> 中位于 case 后的表达式节点。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当 <a href="ast_package_classes.html#class-matchcase">MatchCase</a> 节点中不存在表达式节点时，抛出异常。</li>
</ul>
<h3 id="prop-keywordc"><a class="header" href="#prop-keywordc">prop keywordC</a></h3>
<pre><code class="language-cangjie">public mut prop keywordC: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-matchcase">MatchCase</a> 内的 <code>case</code> 关键字的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-keywordw-2"><a class="header" href="#prop-keywordw-2">prop keywordW</a></h3>
<pre><code class="language-cangjie">public mut prop keywordW: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-matchcase">MatchCase</a> 中可选的关键字 <code>where</code> 的词法单元，可能为 <a href="ast_package_enums.html#illegal">ILLEGAL</a> 的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-patternguard-1"><a class="header" href="#prop-patternguard-1">prop patternGuard</a></h3>
<pre><code class="language-cangjie">public mut prop patternGuard: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-matchcase">MatchCase</a> 中可选的 pattern guard 表达式节点。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当 <a href="ast_package_classes.html#class-matchcase">MatchCase</a> 节点中不存在 pattern guard 表达式时，抛出异常。</li>
</ul>
<h3 id="prop-patterns-1"><a class="header" href="#prop-patterns-1">prop patterns</a></h3>
<pre><code class="language-cangjie">public mut prop patterns: ArrayList&lt;Pattern&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-matchcase">MatchCase</a> 中位于 case 后的 <code>pattern</code> 列表。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-pattern">Pattern</a>&gt;</p>
<h3 id="init-38"><a class="header" href="#init-38">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-matchcase">MatchCase</a> 对象。</p>
<h2 id="class-matchexpr"><a class="header" href="#class-matchexpr">class MatchExpr</a></h2>
<pre><code class="language-cangjie">public class MatchExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示模式匹配表达式实现模式匹配。</p>
<p>模式匹配表达式分为带 selector 的 <code>match</code> 表达式和不带 selector 的 <code>match</code> 表达式。</p>
<h3 id="prop-keyword-8"><a class="header" href="#prop-keyword-8">prop keyword</a></h3>
<pre><code class="language-cangjie">public mut prop keyword: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-matchexpr">MatchExpr</a> 节点中 <code>match</code> 关键字。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-lbrace-5"><a class="header" href="#prop-lbrace-5">prop lBrace</a></h3>
<pre><code class="language-cangjie">public mut prop lBrace: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-matchexpr">MatchExpr</a> 之后的左大括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-lparen-13"><a class="header" href="#prop-lparen-13">prop lParen</a></h3>
<pre><code class="language-cangjie">public mut prop lParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-matchexpr">MatchExpr</a> 之后的左括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-matchcases"><a class="header" href="#prop-matchcases">prop matchCases</a></h3>
<pre><code class="language-cangjie">public mut prop matchCases: ArrayList&lt;MatchCase&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-matchexpr">MatchExpr</a> 内的 <code>matchCase</code>, <code>matchCase</code> 以关键字 <code>case</code> 开头，后跟一个或者多个由 <a href="ast_package_classes.html#class-pattern">Pattern</a> 或 <a href="ast_package_classes.html#class-expr">Expr</a>节点，具体见 <a href="ast_package_classes.html#class-matchcase">MatchCase</a>。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-matchcase">MatchCase</a>&gt;</p>
<h3 id="prop-rbrace-5"><a class="header" href="#prop-rbrace-5">prop rBrace</a></h3>
<pre><code class="language-cangjie">public mut prop rBrace: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-matchexpr">MatchExpr</a> 之后的右大括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-rparen-13"><a class="header" href="#prop-rparen-13">prop rParen</a></h3>
<pre><code class="language-cangjie">public mut prop rParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-matchexpr">MatchExpr</a> 之后的右括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-selector"><a class="header" href="#prop-selector">prop selector</a></h3>
<pre><code class="language-cangjie">public mut prop selector: Expr
</code></pre>
<p>功能：获取或设置关键字 <code>match</code> 之后的 <a href="ast_package_classes.html#class-expr">Expr</a>。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当该表达式是一个不带 selector 的 <code>match</code> 表达式时，抛出异常。</li>
</ul>
<h3 id="init-39"><a class="header" href="#init-39">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-matchexpr">MatchExpr</a> 对象。</p>
<h3 id="inittokens-30"><a class="header" href="#inittokens-30">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-matchexpr">MatchExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-matchexpr">MatchExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-matchexpr">MatchExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-memberaccess"><a class="header" href="#class-memberaccess">class MemberAccess</a></h2>
<pre><code class="language-cangjie">public class MemberAccess &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示成员访问表达式。</p>
<p>可以用于访问 class、interface、struct 等类型的成员。一个 <a href="ast_package_classes.html#class-memberaccess">MemberAccess</a> 节点的形式为 <code>T.a</code>，<code>T</code> 为成员访问表达式的主体，<code>a</code> 表示成员的名字。</p>
<h3 id="prop-baseexpr"><a class="header" href="#prop-baseexpr">prop baseExpr</a></h3>
<pre><code class="language-cangjie">public mut prop baseExpr: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-memberaccess">MemberAccess</a> 节点的成员访问表达式主体。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<h3 id="prop-dot"><a class="header" href="#prop-dot">prop dot</a></h3>
<pre><code class="language-cangjie">public mut prop dot: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-memberaccess">MemberAccess</a> 节点中的 <code>.</code>。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-field"><a class="header" href="#prop-field">prop field</a></h3>
<pre><code class="language-cangjie">public mut prop field: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-memberaccess">MemberAccess</a> 节点成员的名字。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-langle-1"><a class="header" href="#prop-langle-1">prop lAngle</a></h3>
<pre><code class="language-cangjie">public mut prop lAngle: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-memberaccess">MemberAccess</a> 节点中的左尖括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-rangle-1"><a class="header" href="#prop-rangle-1">prop rAngle</a></h3>
<pre><code class="language-cangjie">public mut prop rAngle: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-memberaccess">MemberAccess</a> 节点中的右尖括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-typearguments-1"><a class="header" href="#prop-typearguments-1">prop typeArguments</a></h3>
<pre><code class="language-cangjie">public mut prop typeArguments: ArrayList&lt;TypeNode&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-memberaccess">MemberAccess</a> 节点中的实例化类型。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-typenode">TypeNode</a>&gt;</p>
<h3 id="init-40"><a class="header" href="#init-40">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-memberaccess">MemberAccess</a> 对象。</p>
<h3 id="inittokens-31"><a class="header" href="#inittokens-31">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-memberaccess">MemberAccess</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-memberaccess">MemberAccess</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-memberaccess">MemberAccess</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-modifier"><a class="header" href="#class-modifier">class Modifier</a></h2>
<pre><code class="language-cangjie">public class Modifier &lt;: Node {
    public init()
    public init(keyword: Token)
}
</code></pre>
<p>功能：表示该定义具备某些特性，通常放在定义处的最前端。</p>
<p>一个 <a href="ast_package_classes.html#class-modifier">Modifier</a> 节点：<code>public func foo()</code> 中的 <code>public</code>。</p>
<h3 id="prop-keywordtoken"><a class="header" href="#prop-keywordtoken">prop keyword(Token)</a></h3>
<pre><code class="language-cangjie">public mut prop keyword: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-modifier">Modifier</a> 节点中的修饰符词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-41"><a class="header" href="#init-41">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-modifier">Modifier</a> 对象。</p>
<h3 id="inittoken-1"><a class="header" href="#inittoken-1">init(Token)</a></h3>
<pre><code class="language-cangjie">public init(keyword: Token)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-modifier">Modifier</a> 对象。</p>
<p>参数：</p>
<ul>
<li>keyword: <a href="ast_package_structs.html#struct-token">Token</a> - 将要构造 <a href="ast_package_classes.html#class-modifier">Modifier</a> 类型的词法单元。</li>
</ul>
<h2 id="class-node"><a class="header" href="#class-node">class Node</a></h2>
<pre><code class="language-cangjie">sealed abstract class Node &lt;: ToTokens
</code></pre>
<p>功能：所有仓颉语法树节点的父类。</p>
<p>该类提供了所有数据类型通用的操作接口。</p>
<h3 id="prop-beginpos"><a class="header" href="#prop-beginpos">prop beginPos</a></h3>
<pre><code class="language-cangjie">public mut prop beginPos: Position
</code></pre>
<p>功能：获取或设置当前节点的起始的位置信息。</p>
<p>类型：<a href="ast_package_structs.html#struct-position">Position</a></p>
<h3 id="prop-endpos"><a class="header" href="#prop-endpos">prop endPos</a></h3>
<pre><code class="language-cangjie">public mut prop endPos: Position
</code></pre>
<p>功能：获取或设置当前节点的终止的位置信息。</p>
<p>类型：<a href="ast_package_structs.html#struct-position">Position</a></p>
<h3 id="func-dump"><a class="header" href="#func-dump">func dump()</a></h3>
<pre><code class="language-cangjie">public func dump(): Unit
</code></pre>
<p>功能：将当前语法树节点转为为树形结构的形态并进行打印。</p>
<p>语法树节点的树形结构将按照以下形式进行输出：</p>
<ul>
<li><code>-</code> 字符串：表示当前节点的公共属性， 如 <code>-keyword</code> , <code>-identifier</code>。</li>
<li>节点属性后紧跟该节点的具体类型， 如 <code>-declType: PrimitiveType</code> 表示节点类型是一个 <a href="ast_package_classes.html#class-primitivetype">PrimitiveType</a> 节点。</li>
<li>每个类型使用大括号表示类型的作用区间。</li>
</ul>
<p>语法树输出的详细格式请参考示例代码中<a href="../ast_samples/dump.html">语法树节点打印</a>的内容。</p>
<h3 id="func-totokens"><a class="header" href="#func-totokens">func toTokens()</a></h3>
<pre><code class="language-cangjie">public func toTokens(): Tokens
</code></pre>
<p>功能：将语法树节点转化为 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型。</p>
<p>返回值：</p>
<ul>
<li><a href="ast_package_classes.html#class-tokens">Tokens</a> - 转化后的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型节点。</li>
</ul>
<h3 id="func-traversevisitor"><a class="header" href="#func-traversevisitor">func traverse(Visitor)</a></h3>
<pre><code class="language-cangjie">public func traverse(v: Visitor): Unit
</code></pre>
<p>功能：遍历当前语法树节点及其子节点。若提前终止遍历子节点的行为，可重写 <code>visit</code> 函数并调用 <code>breakTraverse</code> 函数提前终止遍历行为，详细见 示例代码中 <a href="../ast_samples/traverse.html">自定义访问函数遍历 AST 对象示例</a> 的内容。</p>
<p>参数：</p>
<ul>
<li>v: <a href="ast_package_classes.html#class-visitor">Visitor</a> - <a href="ast_package_classes.html#class-visitor">Visitor</a> 类型的实例。</li>
</ul>
<h2 id="class-optionalexpr"><a class="header" href="#class-optionalexpr">class OptionalExpr</a></h2>
<pre><code class="language-cangjie">public class OptionalExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示一个带有问号操作符的表达式节点。</p>
<p>一个 <a href="ast_package_classes.html#class-optionalexpr">OptionalExpr</a> 节点：<code>a?.b, a?(b), a?[b]</code> 中的 <code>a?</code>。</p>
<h3 id="prop-baseexpr-1"><a class="header" href="#prop-baseexpr-1">prop baseExpr</a></h3>
<pre><code class="language-cangjie">public mut prop baseExpr: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-optionalexpr">OptionalExpr</a> 的表达式节点。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<h3 id="prop-quest"><a class="header" href="#prop-quest">prop quest</a></h3>
<pre><code class="language-cangjie">public mut prop quest: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-optionalexpr">OptionalExpr</a> 中的问号操作符。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-42"><a class="header" href="#init-42">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-optionalexpr">OptionalExpr</a> 对象。</p>
<h3 id="inittokens-32"><a class="header" href="#inittokens-32">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-optionalexpr">OptionalExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-optionalexpr">OptionalExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-optionalexpr">OptionalExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-packageheader"><a class="header" href="#class-packageheader">class PackageHeader</a></h2>
<pre><code class="language-cangjie">public class PackageHeader &lt;: Node {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示包声明节点。</p>
<p>一个 <a href="ast_package_classes.html#class-packageheader">PackageHeader</a> 节点: <code>package define</code> 或者 <code>macro package define</code>。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>包声明以关键字 <code>package</code> 或 <code>macro package</code> 开头，后面紧跟包名，且包声明必须在源文件的首行。</p>
</blockquote>
<h3 id="prop-accessible"><a class="header" href="#prop-accessible">prop accessible</a></h3>
<pre><code class="language-cangjie">public mut prop accessible: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-packageheader">PackageHeader</a> 节点中的访问性修饰符的词法单元，可能为 <a href="ast_package_enums.html#illegal">ILLEGAL</a> 的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-keywordm"><a class="header" href="#prop-keywordm">prop keywordM</a></h3>
<pre><code class="language-cangjie">public mut prop keywordM: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-packageheader">PackageHeader</a> 节点中的 <code>macro</code> 关键字的词法单元（<code>M</code> 为关键字首字母，下同），可能为 <a href="ast_package_enums.html#illegal">ILLEGAL</a> 的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-keywordp"><a class="header" href="#prop-keywordp">prop keywordP</a></h3>
<pre><code class="language-cangjie">public mut prop keywordP: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-packageheader">PackageHeader</a> 节点中的 <code>package</code> 关键字的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-prefixpaths-1"><a class="header" href="#prop-prefixpaths-1">prop prefixPaths</a></h3>
<pre><code class="language-cangjie">public mut prop prefixPaths: Tokens
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-packageheader">PackageHeader</a> 节点中完整包名的前缀部分的词法单元序列，可能为空。如 <code>package a.b.c</code> 中的 <code>a</code> 和 <code>b</code>。</p>
<p>类型：<a href="ast_package_classes.html#class-tokens">Tokens</a></p>
<h3 id="prop-prefixdots-1"><a class="header" href="#prop-prefixdots-1">prop prefixDots</a></h3>
<pre><code class="language-cangjie">public mut prop prefixDots: Tokens
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-packageheader">PackageHeader</a> 节点中完整包名中用于分隔每层子包的词法单元序列，可能为空。如 <code>package a.b.c</code> 中的两个 <code>.</code>。</p>
<p>类型：<a href="ast_package_classes.html#class-tokens">Tokens</a></p>
<h3 id="prop-packageidentifier"><a class="header" href="#prop-packageidentifier">prop packageIdentifier</a></h3>
<pre><code class="language-cangjie">public mut prop packageIdentifier: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-packageheader">PackageHeader</a> 节点中当前包的名字，如果当前包为 root 包，即为完整包名，若当前包为子包，则为最后一个 <code>.</code> 后的名字。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-43"><a class="header" href="#init-43">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-packageheader">PackageHeader</a> 对象。</p>
<h3 id="inittokens-33"><a class="header" href="#inittokens-33">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-packageheader">PackageHeader</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-packageheader">PackageHeader</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>) 序列。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-packageheader">PackageHeader</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-parenexpr"><a class="header" href="#class-parenexpr">class ParenExpr</a></h2>
<pre><code class="language-cangjie">public class ParenExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示一个括号表达式节点，是指使用圆括号括起来的表达式。</p>
<p>一个 <a href="ast_package_classes.html#class-parenexpr">ParenExpr</a> 节点：<code>(1 + 2)</code>。</p>
<h3 id="prop-lparen-14"><a class="header" href="#prop-lparen-14">prop lParen</a></h3>
<pre><code class="language-cangjie">public mut prop lParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-parenexpr">ParenExpr</a> 节点中的左括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-parenthesizedexpr"><a class="header" href="#prop-parenthesizedexpr">prop parenthesizedExpr</a></h3>
<pre><code class="language-cangjie">public mut prop parenthesizedExpr: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-parenexpr">ParenExpr</a> 节点中由圆括号括起来的子表达式。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<h3 id="prop-rparen-14"><a class="header" href="#prop-rparen-14">prop rParen</a></h3>
<pre><code class="language-cangjie">public mut prop rParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-parenexpr">ParenExpr</a> 节点中的右括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-44"><a class="header" href="#init-44">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-parenexpr">ParenExpr</a> 对象。</p>
<h3 id="inittokens-34"><a class="header" href="#inittokens-34">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-parenexpr">ParenExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-parenexpr">ParenExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-parenexpr">ParenExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-parentype"><a class="header" href="#class-parentype">class ParenType</a></h2>
<pre><code class="language-cangjie">public class ParenType &lt;: TypeNode {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示括号类型节点。</p>
<p>例如 <code>var a: (Int64)</code> 中的 <code>(Int64)</code>。</p>
<h3 id="prop-lparen-15"><a class="header" href="#prop-lparen-15">prop lParen</a></h3>
<pre><code class="language-cangjie">public mut prop lParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-parentype">ParenType</a> 节点中的左括号词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-parenthesizedtype"><a class="header" href="#prop-parenthesizedtype">prop parenthesizedType</a></h3>
<pre><code class="language-cangjie">public mut prop parenthesizedType: TypeNode
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-parentype">ParenType</a> 节点中括起来的类型，如 <code>(Int64)</code> 中的 <a href="../../core/core_package_api/core_package_intrinsics.html#int64">Int64</a>。</p>
<p>类型：<a href="ast_package_classes.html#class-typenode">TypeNode</a></p>
<h3 id="prop-rparen-15"><a class="header" href="#prop-rparen-15">prop rParen</a></h3>
<pre><code class="language-cangjie">public mut prop rParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-parentype">ParenType</a> 节点中的右括号词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-45"><a class="header" href="#init-45">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-parentype">ParenType</a> 对象。</p>
<h3 id="inittokens-35"><a class="header" href="#inittokens-35">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-parentype">ParenType</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-parentype">ParenType</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-parentype">ParenType</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-pattern"><a class="header" href="#class-pattern">class Pattern</a></h2>
<pre><code class="language-cangjie">public open class Pattern &lt;: Node
</code></pre>
<p>功能：所有模式匹配节点的父类，继承自 <a href="ast_package_classes.html#class-node">Node</a> 节点。</p>
<h2 id="class-prefixtype"><a class="header" href="#class-prefixtype">class PrefixType</a></h2>
<pre><code class="language-cangjie">public class PrefixType &lt;: TypeNode {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示带问号的前缀类型节点。</p>
<p>例如 <code>var a : ?A</code> 中的 <code>?A</code>。</p>
<h3 id="prop-basetype"><a class="header" href="#prop-basetype">prop baseType</a></h3>
<pre><code class="language-cangjie">public mut prop baseType: TypeNode
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-prefixtype">PrefixType</a> 节点中的类型节点，如 <code>var a: ?A</code> 中的 <code>A</code>。</p>
<p>类型：<a href="ast_package_classes.html#class-typenode">TypeNode</a></p>
<h3 id="prop-prefixops"><a class="header" href="#prop-prefixops">prop prefixOps</a></h3>
<pre><code class="language-cangjie">public mut prop prefixOps: Tokens
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-prefixtype">PrefixType</a> 节点中前缀操作符集合。</p>
<p>类型：<a href="ast_package_classes.html#class-tokens">Tokens</a></p>
<h3 id="init-46"><a class="header" href="#init-46">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-prefixtype">PrefixType</a> 对象。</p>
<h3 id="inittokens-36"><a class="header" href="#inittokens-36">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-prefixtype">PrefixType</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-prefixtype">PrefixType</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-prefixtype">PrefixType</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-primaryctordecl"><a class="header" href="#class-primaryctordecl">class PrimaryCtorDecl</a></h2>
<pre><code class="language-cangjie">public class PrimaryCtorDecl &lt;: Decl {
    public init()
    public init(inputs: Tokens)
}
</code></pre>
<p>功能：表示一个主构造函数节点。</p>
<p>主构造函数节点由修饰符，主构造函数名，形参列表和主构造函数体构成。</p>
<h3 id="prop-block-6"><a class="header" href="#prop-block-6">prop block</a></h3>
<pre><code class="language-cangjie">public mut prop block: Block
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-primaryctordecl">PrimaryCtorDecl</a> 节点的主构造函数体。</p>
<p>类型：<a href="ast_package_classes.html#class-block">Block</a></p>
<h3 id="prop-funcparams-4"><a class="header" href="#prop-funcparams-4">prop funcParams</a></h3>
<pre><code class="language-cangjie">public mut prop funcParams: ArrayList&lt;FuncParam&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-primaryctordecl">PrimaryCtorDecl</a> 节点的参数。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-funcparam">FuncParam</a>&gt;</p>
<h3 id="prop-lparen-16"><a class="header" href="#prop-lparen-16">prop lParen</a></h3>
<pre><code class="language-cangjie">public mut prop lParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-primaryctordecl">PrimaryCtorDecl</a> 节点的左括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-rparen-16"><a class="header" href="#prop-rparen-16">prop rParen</a></h3>
<pre><code class="language-cangjie">public mut prop rParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-primaryctordecl">PrimaryCtorDecl</a> 节点的右括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-47"><a class="header" href="#init-47">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-primaryctordecl">PrimaryCtorDecl</a> 对象。</p>
<h3 id="inittokens-37"><a class="header" href="#inittokens-37">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(inputs: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-primaryctordecl">PrimaryCtorDecl</a> 对象。</p>
<p>参数：</p>
<ul>
<li>inputs: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-primaryctordecl">PrimaryCtorDecl</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-primaryctordecl">PrimaryCtorDecl</a> 节点时，抛出异常。</li>
</ul>
<h3 id="func-isconst-1"><a class="header" href="#func-isconst-1">func isConst()</a></h3>
<pre><code class="language-cangjie">public func isConst(): Bool
</code></pre>
<p>功能：判断是否是一个 <code>Const</code> 类型的节点。</p>
<p>返回值：</p>
<ul>
<li><a href="../../core/core_package_api/core_package_intrinsics.html#bool">Bool</a> - 当前节点为 <code>Const</code> 类型的节点时，返回 true；反之，返回 false。</li>
</ul>
<h2 id="class-primitivetype"><a class="header" href="#class-primitivetype">class PrimitiveType</a></h2>
<pre><code class="language-cangjie">public class PrimitiveType &lt;: TypeNode {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示一个基本类型节点。</p>
<p>例如数值类型，<a href="../../core/core_package_api/core_package_intrinsics.html#rune">Rune</a> 类型，布尔类型等。</p>
<h3 id="prop-keyword-9"><a class="header" href="#prop-keyword-9">prop keyword</a></h3>
<pre><code class="language-cangjie">public mut prop keyword: Token
</code></pre>
<p>功能：获取或设置构造 <a href="ast_package_classes.html#class-primitivetype">PrimitiveType</a> 类型的关键字，如 <a href="../../core/core_package_api/core_package_intrinsics.html#int8">Int8</a>。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-48"><a class="header" href="#init-48">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-primitivetype">PrimitiveType</a> 对象。</p>
<h3 id="inittokens-38"><a class="header" href="#inittokens-38">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-primitivetype">PrimitiveType</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-primitivetype">PrimitiveType</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-primitivetype">PrimitiveType</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-primitivetypeexpr"><a class="header" href="#class-primitivetypeexpr">class PrimitiveTypeExpr</a></h2>
<pre><code class="language-cangjie">public class PrimitiveTypeExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示基本类型表达式节点。</p>
<p><a href="ast_package_classes.html#class-primitivetypeexpr">PrimitiveTypeExpr</a> 节点：编译器内置的基本类型作为表达式出现在节点中。如 <a href="../../core/core_package_api/core_package_intrinsics.html#int64">Int64</a>.toSting() 中的 <a href="../../core/core_package_api/core_package_intrinsics.html#int64">Int64</a>。</p>
<h3 id="prop-keyword-10"><a class="header" href="#prop-keyword-10">prop keyword</a></h3>
<pre><code class="language-cangjie">public mut prop keyword: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-primitivetypeexpr">PrimitiveTypeExpr</a> 中的基本类型关键字。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-49"><a class="header" href="#init-49">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-primitivetypeexpr">PrimitiveTypeExpr</a> 对象。</p>
<h3 id="inittokens-39"><a class="header" href="#inittokens-39">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-primitivetypeexpr">PrimitiveTypeExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-primitivetypeexpr">PrimitiveTypeExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-primitivetypeexpr">PrimitiveTypeExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-program"><a class="header" href="#class-program">class Program</a></h2>
<pre><code class="language-cangjie">public class Program &lt;: Node {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示一个仓颉源码文件节点。</p>
<p>一个仓颉源码文件节点主要包括包定义节点，包导入节点和 TopLevel 作用域内的所有声明节点。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>任何一个仓颉源码文件都可以被解析为一个 <a href="ast_package_classes.html#class-program">Program</a> 类型。</p>
</blockquote>
<h3 id="prop-decls-2"><a class="header" href="#prop-decls-2">prop decls</a></h3>
<pre><code class="language-cangjie">public mut prop decls: ArrayList&lt;Decl&gt;
</code></pre>
<p>功能：获取或设置仓颉源码文件中 TopLevel 作用域内定义的声明节点列表。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-decl">Decl</a>&gt;</p>
<h3 id="prop-importlists"><a class="header" href="#prop-importlists">prop importLists</a></h3>
<pre><code class="language-cangjie">public mut prop importLists: ArrayList&lt;ImportList&gt;
</code></pre>
<p>功能：获取或设置仓颉源码文件中包导入节点 <a href="ast_package_classes.html#class-importlist">ImportList</a> 的列表。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-importlist">ImportList</a>&gt;</p>
<h3 id="prop-packageheader"><a class="header" href="#prop-packageheader">prop packageHeader</a></h3>
<pre><code class="language-cangjie">public mut prop packageHeader: PackageHeader
</code></pre>
<p>功能：获取或设置仓颉源码文件中包的声明节点 <a href="ast_package_classes.html#class-packageheader">PackageHeader</a>。</p>
<p>类型：<a href="ast_package_classes.html#class-packageheader">PackageHeader</a></p>
<h3 id="init-50"><a class="header" href="#init-50">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-program">Program</a> 对象。</p>
<h3 id="inittokens-40"><a class="header" href="#inittokens-40">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-program">Program</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-program">Program</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>) 序列。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为一个文件节点时，抛出异常。</li>
</ul>
<h2 id="class-propdecl"><a class="header" href="#class-propdecl">class PropDecl</a></h2>
<pre><code class="language-cangjie">public class PropDecl &lt;: Decl {
    public init()
    public init(inputs: Tokens)
}
</code></pre>
<p>功能：表示一个属性定义节点。</p>
<p>一个 <a href="ast_package_classes.html#class-propdecl">PropDecl</a> 节点：<code>prop var X: Int64 { get() { 0 } }</code>。</p>
<h3 id="prop-colon-6"><a class="header" href="#prop-colon-6">prop colon</a></h3>
<pre><code class="language-cangjie">public mut prop colon: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-propdecl">PropDecl</a> 节点的冒号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-decltype-3"><a class="header" href="#prop-decltype-3">prop declType</a></h3>
<pre><code class="language-cangjie">public mut prop declType : TypeNode
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-propdecl">PropDecl</a> 节点的返回类型。</p>
<p>类型：<a href="ast_package_classes.html#class-typenode">TypeNode</a></p>
<h3 id="prop-getter"><a class="header" href="#prop-getter">prop getter</a></h3>
<pre><code class="language-cangjie">public mut prop getter: FuncDecl
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-propdecl">PropDecl</a> 节点的 getter 函数。</p>
<p>类型：<a href="ast_package_classes.html#class-funcdecl">FuncDecl</a></p>
<p>异常：</p>
<p>-<a href="ast_package_exceptions.html#class-astexception">ASTException</a>：当 <a href="ast_package_classes.html#class-propdecl">PropDecl</a> 节点不存在 getter 函数时，抛出异常。</p>
<h3 id="prop-lbrace-6"><a class="header" href="#prop-lbrace-6">prop lBrace</a></h3>
<pre><code class="language-cangjie">public mut prop lBrace: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-propdecl">PropDecl</a> 节点的左大括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-rbrace-6"><a class="header" href="#prop-rbrace-6">prop rBrace</a></h3>
<pre><code class="language-cangjie">public mut prop rBrace: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-propdecl">PropDecl</a> 节点的右大括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-setter"><a class="header" href="#prop-setter">prop setter</a></h3>
<pre><code class="language-cangjie">public mut prop setter: FuncDecl
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-propdecl">PropDecl</a> 节点的 setter 函数。</p>
<p>类型：<a href="ast_package_classes.html#class-funcdecl">FuncDecl</a></p>
<p>异常：</p>
<p>-<a href="ast_package_exceptions.html#class-astexception">ASTException</a>：当 <a href="ast_package_classes.html#class-propdecl">PropDecl</a> 节点不存在 setter 函数时，抛出异常。</p>
<h3 id="init-51"><a class="header" href="#init-51">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-propdecl">PropDecl</a> 对象。</p>
<h3 id="inittokens-41"><a class="header" href="#inittokens-41">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(inputs: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-propdecl">PropDecl</a> 对象。</p>
<p>参数：</p>
<ul>
<li>inputs: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-propdecl">PropDecl</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-propdecl">PropDecl</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-qualifiedtype"><a class="header" href="#class-qualifiedtype">class QualifiedType</a></h2>
<pre><code class="language-cangjie">public class QualifiedType &lt;: TypeNode {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示一个用户自定义成员类型。</p>
<p>例如 <code>var a : T.a</code> 中的 <code>T.a</code>, 其中 T 是包名，a 是从 T 包中导入的类型。</p>
<h3 id="prop-basetype-1"><a class="header" href="#prop-basetype-1">prop baseType</a></h3>
<pre><code class="language-cangjie">public mut prop baseType: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-qualifiedtype">QualifiedType</a> 节点的成员访问类型主体，如 <code>var a : T.a</code> 中的 <code>T</code>。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<h3 id="prop-dot-1"><a class="header" href="#prop-dot-1">prop dot</a></h3>
<pre><code class="language-cangjie">public mut prop dot: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-qualifiedtype">QualifiedType</a> 节点中的 <code>.</code> 。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-identifier-7"><a class="header" href="#prop-identifier-7">prop identifier</a></h3>
<pre><code class="language-cangjie">public mut prop identifier: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-qualifiedtype">QualifiedType</a> 节点成员的标识符，如 <code>var a : T.a</code> 中的 <code>a</code>。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-langle-2"><a class="header" href="#prop-langle-2">prop lAngle</a></h3>
<pre><code class="language-cangjie">public mut prop lAngle: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-qualifiedtype">QualifiedType</a> 节点中的左尖括号词法单元，可能为 <a href="ast_package_enums.html#illegal">ILLEGAL</a> 的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-rangle-2"><a class="header" href="#prop-rangle-2">prop rAngle</a></h3>
<pre><code class="language-cangjie">public mut prop rAngle: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-qualifiedtype">QualifiedType</a> 节点中的右尖括号词法单元，可能为 <a href="ast_package_enums.html#illegal">ILLEGAL</a> 的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-typearguments-2"><a class="header" href="#prop-typearguments-2">prop typeArguments</a></h3>
<pre><code class="language-cangjie">public mut prop typeArguments: ArrayList&lt;TypeNode&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-qualifiedtype">QualifiedType</a> 节点中的实例化类型的列表，如 <code>T.a&lt;Int32&gt;</code> 中的 <a href="../../core/core_package_api/core_package_intrinsics.html#int32">Int32</a>，列表可能为空。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-typenode">TypeNode</a>&gt;</p>
<h3 id="init-52"><a class="header" href="#init-52">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-qualifiedtype">QualifiedType</a> 对象。</p>
<h3 id="inittokens-42"><a class="header" href="#inittokens-42">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-qualifiedtype">QualifiedType</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-qualifiedtype">QualifiedType</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-qualifiedtype">QualifiedType</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-quoteexpr"><a class="header" href="#class-quoteexpr">class QuoteExpr</a></h2>
<pre><code class="language-cangjie">public class QuoteExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示 <code>quote</code> 表达式节点。</p>
<p>一个 <a href="ast_package_classes.html#class-quoteexpr">QuoteExpr</a> 节点： <code>quote(var ident = 0)</code>。</p>
<h3 id="prop-exprs"><a class="header" href="#prop-exprs">prop exprs</a></h3>
<pre><code class="language-cangjie">public mut prop exprs: ArrayList&lt;Expr&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-quoteexpr">QuoteExpr</a> 中由 <code>()</code> 括起的内部引用表达式节点。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-expr">Expr</a>&gt;</p>
<h3 id="prop-keyword-11"><a class="header" href="#prop-keyword-11">prop keyword</a></h3>
<pre><code class="language-cangjie">public mut prop keyword: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-quoteexpr">QuoteExpr</a> 的通配符关键字。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-lparen-17"><a class="header" href="#prop-lparen-17">prop lParen</a></h3>
<pre><code class="language-cangjie">public mut prop lParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-quoteexpr">QuoteExpr</a> 中的左括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-rparen-17"><a class="header" href="#prop-rparen-17">prop rParen</a></h3>
<pre><code class="language-cangjie">public mut prop rParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-quoteexpr">QuoteExpr</a> 中的右括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-53"><a class="header" href="#init-53">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-quoteexpr">QuoteExpr</a> 对象。</p>
<h3 id="inittokens-43"><a class="header" href="#inittokens-43">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-quoteexpr">QuoteExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-quoteexpr">QuoteExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-quoteexpr">QuoteExpr</a> 节点。</li>
</ul>
<h2 id="class-quotetoken"><a class="header" href="#class-quotetoken">class QuoteToken</a></h2>
<pre><code class="language-cangjie">public class QuoteToken &lt;: Expr
</code></pre>
<p>功能：表示 <code>quote</code> 表达式节点内任意合法的 <code>token</code>。</p>
<h3 id="prop-tokens"><a class="header" href="#prop-tokens">prop tokens</a></h3>
<pre><code class="language-cangjie">public mut prop tokens: Tokens
</code></pre>
<p>功能：获取 <a href="ast_package_classes.html#class-quotetoken">QuoteToken</a> 内的 <a href="ast_package_classes.html#class-tokens">Tokens</a>。</p>
<p>类型：<a href="ast_package_classes.html#class-tokens">Tokens</a></p>
<h2 id="class-rangeexpr"><a class="header" href="#class-rangeexpr">class RangeExpr</a></h2>
<pre><code class="language-cangjie">public class RangeExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示包含区间操作符的表达式。</p>
<p><a href="ast_package_classes.html#class-rangeexpr">RangeExpr</a> 节点：存在两种 <a href="../../core/core_package_api/core_package_structs.html#struct-ranget-where-t--countablet--comparablet--equatablet">Range</a> 操作符：<code>..</code> 和 <code>..=</code>，分别用于创建左闭右开和左闭右闭的 <a href="../../core/core_package_api/core_package_structs.html#struct-ranget-where-t--countablet--comparablet--equatablet">Range</a> 实例。它们的使用方式分别为 <code>start..end:step</code> 和 <code>start..=end:step</code>。</p>
<h3 id="prop-colon-7"><a class="header" href="#prop-colon-7">prop colon</a></h3>
<pre><code class="language-cangjie">public mut prop colon: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-rangeexpr">RangeExpr</a> 中的 <code>:</code> 操作符。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-end"><a class="header" href="#prop-end">prop end</a></h3>
<pre><code class="language-cangjie">public mut prop end: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-rangeexpr">RangeExpr</a> 中的终止值。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 终止表达式省略。只有在 <a href="../../core/core_package_api/core_package_structs.html#struct-ranget-where-t--countablet--comparablet--equatablet">Range</a>&lt;<a href="../../core/core_package_api/core_package_intrinsics.html#int64">Int64</a>&gt; 类型的实例用在下标操作符 <code>[]</code> 为空的场景。</li>
</ul>
<h3 id="prop-op-2"><a class="header" href="#prop-op-2">prop op</a></h3>
<pre><code class="language-cangjie">public mut prop op: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-rangeexpr">RangeExpr</a> 中的 <a href="../../core/core_package_api/core_package_structs.html#struct-ranget-where-t--countablet--comparablet--equatablet">Range</a> 的操作符。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-start"><a class="header" href="#prop-start">prop start</a></h3>
<pre><code class="language-cangjie">public mut prop start: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-rangeexpr">RangeExpr</a> 中的起始值。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 起始表达式省略。只有在 <a href="../../core/core_package_api/core_package_structs.html#struct-ranget-where-t--countablet--comparablet--equatablet">Range</a>&lt;<a href="../../core/core_package_api/core_package_intrinsics.html#int64">Int64</a>&gt; 类型的实例用在下标操作符 <code>[]</code> 为空的场景。</li>
</ul>
<h3 id="prop-step"><a class="header" href="#prop-step">prop step</a></h3>
<pre><code class="language-cangjie">public mut prop step: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-rangeexpr">RangeExpr</a> 中序列中前后两个元素之间的差值。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当 <a href="ast_package_classes.html#class-rangeexpr">RangeExpr</a> 中未设置序列前后两个元素之间的差值时，抛出异常。</li>
</ul>
<h3 id="init-54"><a class="header" href="#init-54">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-rangeexpr">RangeExpr</a> 对象。</p>
<h3 id="inittokens-44"><a class="header" href="#inittokens-44">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-rangeexpr">RangeExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-rangeexpr">RangeExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-rangeexpr">RangeExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-refexpr"><a class="header" href="#class-refexpr">class RefExpr</a></h2>
<pre><code class="language-cangjie">public class RefExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示一个使用自定义类型节点相关的表达式节点。</p>
<p>一个 <a href="ast_package_classes.html#class-refexpr">RefExpr</a> 节点：<code>var ref = refNode + 1</code> 中的 <code>refNode</code> 是一个 <a href="ast_package_classes.html#class-refexpr">RefExpr</a>。</p>
<h3 id="prop-identifier-8"><a class="header" href="#prop-identifier-8">prop identifier</a></h3>
<pre><code class="language-cangjie">public mut prop identifier: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-refexpr">RefExpr</a> 节点中的自定义类型的标识符。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-langle-3"><a class="header" href="#prop-langle-3">prop lAngle</a></h3>
<pre><code class="language-cangjie">public mut prop lAngle: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-refexpr">RefExpr</a> 节点中的左尖括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-rangle-3"><a class="header" href="#prop-rangle-3">prop rAngle</a></h3>
<pre><code class="language-cangjie">public mut prop rAngle: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-refexpr">RefExpr</a> 节点中的右尖括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-typearguments-3"><a class="header" href="#prop-typearguments-3">prop typeArguments</a></h3>
<pre><code class="language-cangjie">public mut prop typeArguments: ArrayList&lt;TypeNode&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-refexpr">RefExpr</a> 节点中的实例化类型。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-typenode">TypeNode</a>&gt;</p>
<h3 id="init-55"><a class="header" href="#init-55">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-refexpr">RefExpr</a> 对象。</p>
<h3 id="inittokens-45"><a class="header" href="#inittokens-45">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-refexpr">RefExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-refexpr">RefExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-refexpr">RefExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-reftype"><a class="header" href="#class-reftype">class RefType</a></h2>
<pre><code class="language-cangjie">public class RefType &lt;: TypeNode {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示一个用户自定义类型节点。</p>
<p>例如 <code>var a : A = A()</code> 中的 <code>A</code>。</p>
<h3 id="prop-identifier-9"><a class="header" href="#prop-identifier-9">prop identifier</a></h3>
<pre><code class="language-cangjie">public mut prop identifier: Token
</code></pre>
<p>功能：获取或设置构造 <a href="ast_package_classes.html#class-reftype">RefType</a> 类型的关键字，如 <code>var a : A = A()</code> 中的 <code>A</code>。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-langle-4"><a class="header" href="#prop-langle-4">prop lAngle</a></h3>
<pre><code class="language-cangjie">public mut prop lAngle: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-reftype">RefType</a> 节点中的左尖括号词法单元，可能为 <a href="ast_package_enums.html#illegal">ILLEGAL</a> 的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-rangle-4"><a class="header" href="#prop-rangle-4">prop rAngle</a></h3>
<pre><code class="language-cangjie">public mut prop rAngle: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-reftype">RefType</a> 节点中的右尖括号词法单元，可能为 <a href="ast_package_enums.html#illegal">ILLEGAL</a> 的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-typearguments-4"><a class="header" href="#prop-typearguments-4">prop typeArguments</a></h3>
<pre><code class="language-cangjie">public mut prop typeArguments: ArrayList&lt;TypeNode&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-reftype">RefType</a> 节点中的实例化类型的列表，可能为空，如 <code>var a : Array&lt;Int32&gt;</code> 中的 <a href="../../core/core_package_api/core_package_intrinsics.html#int32">Int32</a>。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-typenode">TypeNode</a>&gt;</p>
<h3 id="init-56"><a class="header" href="#init-56">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-reftype">RefType</a> 对象。</p>
<h3 id="inittokens-46"><a class="header" href="#inittokens-46">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-reftype">RefType</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-reftype">RefType</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-reftype">RefType</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-returnexpr"><a class="header" href="#class-returnexpr">class ReturnExpr</a></h2>
<pre><code class="language-cangjie">public class ReturnExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示 <code>return</code> 表达式节点。</p>
<p>一个 <a href="ast_package_classes.html#class-returnexpr">ReturnExpr</a> 节点：<code>return 1</code>。</p>
<h3 id="prop-expr-8"><a class="header" href="#prop-expr-8">prop expr</a></h3>
<pre><code class="language-cangjie">public mut prop expr: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-returnexpr">ReturnExpr</a> 节点中的表达式节点。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当 <a href="ast_package_classes.html#class-returnexpr">ReturnExpr</a> 节点没有表达式时，抛出异常。</li>
</ul>
<h3 id="prop-keyword-12"><a class="header" href="#prop-keyword-12">prop keyword</a></h3>
<pre><code class="language-cangjie">public mut prop keyword: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-returnexpr">ReturnExpr</a> 节点中的关键字。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-57"><a class="header" href="#init-57">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-returnexpr">ReturnExpr</a> 对象。</p>
<h3 id="inittokens-47"><a class="header" href="#inittokens-47">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-returnexpr">ReturnExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-returnexpr">ReturnExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-returnexpr">ReturnExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-spawnexpr"><a class="header" href="#class-spawnexpr">class SpawnExpr</a></h2>
<pre><code class="language-cangjie">public class SpawnExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示 <code>Spawn</code> 表达式。</p>
<p>一个 <a href="ast_package_classes.html#class-spawnexpr">SpawnExpr</a> 节点由 <code>spawn</code> 关键字和一个不包含形参的闭包组成，例如：<code>spawn { add(1, 2) }</code>。</p>
<h3 id="prop-keyword-13"><a class="header" href="#prop-keyword-13">prop keyword</a></h3>
<pre><code class="language-cangjie">public mut prop keyword: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-spawnexpr">SpawnExpr</a> 中的 <code>spawn</code> 关键字。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-lparen-18"><a class="header" href="#prop-lparen-18">prop lParen</a></h3>
<pre><code class="language-cangjie">public mut prop lParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-spawnexpr">SpawnExpr</a> 中的左括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-lambdaexpr"><a class="header" href="#prop-lambdaexpr">prop lambdaExpr</a></h3>
<pre><code class="language-cangjie">public mut prop lambdaExpr: LambdaExpr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-spawnexpr">SpawnExpr</a> 中的不含形参的闭包。</p>
<p>类型：<a href="ast_package_classes.html#class-lambdaexpr">LambdaExpr</a></p>
<h3 id="prop-rparen-18"><a class="header" href="#prop-rparen-18">prop rParen</a></h3>
<pre><code class="language-cangjie">public mut prop rParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-spawnexpr">SpawnExpr</a> 中的右括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-threadcontext"><a class="header" href="#prop-threadcontext">prop threadContext</a></h3>
<pre><code class="language-cangjie">public mut prop threadContext: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-spawnexpr">SpawnExpr</a> 中的线程上下文环境表达式。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当 <a href="ast_package_classes.html#class-spawnexpr">SpawnExpr</a> 中不含有上下文表达式时，抛出异常。</li>
</ul>
<h3 id="init-58"><a class="header" href="#init-58">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-spawnexpr">SpawnExpr</a> 对象。</p>
<h3 id="inittokens-48"><a class="header" href="#inittokens-48">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-spawnexpr">SpawnExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-spawnexpr">SpawnExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-spawnexpr">SpawnExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-structdecl"><a class="header" href="#class-structdecl">class StructDecl</a></h2>
<pre><code class="language-cangjie">public class StructDecl &lt;: Decl {
    public init()
    public init(inputs: Tokens)
}
</code></pre>
<p>功能：表示一个 <code>Struct</code> 节点。</p>
<p>Struct 的定义使用 <code>struct</code> 关键字，定义依次为：可缺省的修饰符、struct 关键字、struct 名、可选的类型参数、是否指定父接口、可选的泛型约束、struct 体的定义。</p>
<h3 id="prop-body-3"><a class="header" href="#prop-body-3">prop body</a></h3>
<pre><code class="language-cangjie">public mut prop body: Body
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-structdecl">StructDecl</a> 节点的类体。</p>
<p>类型：<a href="ast_package_classes.html#class-body">Body</a></p>
<h3 id="prop-supertypes-4"><a class="header" href="#prop-supertypes-4">prop superTypes</a></h3>
<pre><code class="language-cangjie">public mut prop superTypes: ArrayList&lt;TypeNode&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-structdecl">StructDecl</a> 节点的父接口。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-typenode">TypeNode</a>&gt;</p>
<h3 id="prop-upperbound-5"><a class="header" href="#prop-upperbound-5">prop upperBound</a></h3>
<pre><code class="language-cangjie">public mut prop upperBound: Token
</code></pre>
<p>功能：获取或设置 <code>&lt;:</code> 操作符。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-59"><a class="header" href="#init-59">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-structdecl">StructDecl</a> 对象。</p>
<h3 id="inittokens-49"><a class="header" href="#inittokens-49">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(inputs: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-structdecl">StructDecl</a> 对象。</p>
<p>参数：</p>
<ul>
<li>inputs: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-structdecl">StructDecl</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-structdecl">StructDecl</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-subscriptexpr"><a class="header" href="#class-subscriptexpr">class SubscriptExpr</a></h2>
<pre><code class="language-cangjie">public class SubscriptExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示索引访问表达式。</p>
<p><a href="ast_package_classes.html#class-subscriptexpr">SubscriptExpr</a> 节点：用于那些支持索引访问的类型（包括 <a href="../../core/core_package_api/core_package_structs.html#struct-arrayt">Array</a> 类型和 <code>Tuple</code> 类型）通过下标来访问其具体位置的元素，如 <code>arr[0]</code>。</p>
<h3 id="prop-baseexpr-2"><a class="header" href="#prop-baseexpr-2">prop baseExpr</a></h3>
<pre><code class="language-cangjie">public mut prop baseExpr: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-subscriptexpr">SubscriptExpr</a> 中的表达式。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<h3 id="prop-indexlist"><a class="header" href="#prop-indexlist">prop indexList</a></h3>
<pre><code class="language-cangjie">public mut prop indexList: ArrayList&lt;Expr&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-subscriptexpr">SubscriptExpr</a> 中的索引表达式序列。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-expr">Expr</a>&gt;</p>
<h3 id="prop-lsquare-4"><a class="header" href="#prop-lsquare-4">prop lSquare</a></h3>
<pre><code class="language-cangjie">public mut prop lSquare: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-subscriptexpr">SubscriptExpr</a> 中的左中括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-rsquare-4"><a class="header" href="#prop-rsquare-4">prop rSquare</a></h3>
<pre><code class="language-cangjie">public mut prop rSquare: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-subscriptexpr">SubscriptExpr</a> 中的右中括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-60"><a class="header" href="#init-60">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-subscriptexpr">SubscriptExpr</a> 对象。</p>
<h3 id="inittokens-50"><a class="header" href="#inittokens-50">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-subscriptexpr">SubscriptExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-subscriptexpr">SubscriptExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-subscriptexpr">SubscriptExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-synchronizedexpr"><a class="header" href="#class-synchronizedexpr">class SynchronizedExpr</a></h2>
<pre><code class="language-cangjie">public class SynchronizedExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示 <code>synchronized</code> 表达式。</p>
<p>一个 <a href="ast_package_classes.html#class-synchronizedexpr">SynchronizedExpr</a> 节点由 <code>synchronized</code> 关键字和 <code>StructuredMutex</code> 对以及后面的代码块组成, 例如 <code>synchronized(m) { foo() }</code>。</p>
<h3 id="prop-block-7"><a class="header" href="#prop-block-7">prop block</a></h3>
<pre><code class="language-cangjie">public mut prop block: Block
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-synchronizedexpr">SynchronizedExpr</a> 修饰的代码块。</p>
<p>类型：<a href="ast_package_classes.html#class-block">Block</a></p>
<h3 id="prop-keyword-14"><a class="header" href="#prop-keyword-14">prop keyword</a></h3>
<pre><code class="language-cangjie">public mut prop keyword: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-synchronizedexpr">SynchronizedExpr</a> 中的 <code>synchronized</code> 关键字。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-lparen-19"><a class="header" href="#prop-lparen-19">prop lParen</a></h3>
<pre><code class="language-cangjie">public mut prop lParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-synchronizedexpr">SynchronizedExpr</a> 中的左括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-rparen-19"><a class="header" href="#prop-rparen-19">prop rParen</a></h3>
<pre><code class="language-cangjie">public mut prop rParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-synchronizedexpr">SynchronizedExpr</a> 中的右括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-structuredmutex"><a class="header" href="#prop-structuredmutex">prop structuredMutex</a></h3>
<pre><code class="language-cangjie">public mut prop structuredMutex: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-synchronizedexpr">SynchronizedExpr</a> 中的 <code>StructuredMutex</code> 的对象。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<h3 id="init-61"><a class="header" href="#init-61">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-synchronizedexpr">SynchronizedExpr</a> 对象。</p>
<h3 id="inittokens-51"><a class="header" href="#inittokens-51">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-synchronizedexpr">SynchronizedExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-synchronizedexpr">SynchronizedExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-synchronizedexpr">SynchronizedExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-thistype"><a class="header" href="#class-thistype">class ThisType</a></h2>
<pre><code class="language-cangjie">public class ThisType &lt;: TypeNode {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示 <code>This</code> 类型节点。</p>
<h3 id="prop-keyword-15"><a class="header" href="#prop-keyword-15">prop keyword</a></h3>
<pre><code class="language-cangjie">public mut prop keyword: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-thistype">ThisType</a> 节点关键字 <code>This</code> 的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-62"><a class="header" href="#init-62">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-thistype">ThisType</a> 对象。</p>
<h3 id="inittokens-52"><a class="header" href="#inittokens-52">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-thistype">ThisType</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-thistype">ThisType</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-thistype">ThisType</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-throwexpr"><a class="header" href="#class-throwexpr">class ThrowExpr</a></h2>
<pre><code class="language-cangjie">public class ThrowExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示 <code>throw</code> 表达式节点。</p>
<p>一个 <a href="ast_package_classes.html#class-throwexpr">ThrowExpr</a> 节点：<code>throw Exception()</code>。</p>
<h3 id="prop-expr-9"><a class="header" href="#prop-expr-9">prop expr</a></h3>
<pre><code class="language-cangjie">public mut prop expr: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-throwexpr">ThrowExpr</a> 节点中的表达式节点。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<h3 id="prop-keyword-16"><a class="header" href="#prop-keyword-16">prop keyword</a></h3>
<pre><code class="language-cangjie">public mut prop keyword: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-throwexpr">ThrowExpr</a> 节点中的关键字。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-63"><a class="header" href="#init-63">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-throwexpr">ThrowExpr</a> 对象。</p>
<h3 id="inittokens-53"><a class="header" href="#inittokens-53">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-throwexpr">ThrowExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-throwexpr">ThrowExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-throwexpr">ThrowExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-tokens"><a class="header" href="#class-tokens">class Tokens</a></h2>
<pre><code class="language-cangjie">public open class Tokens &lt;: ToString &amp; Iterable&lt;Token&gt; {
    public init()
    public init(tokArray: Array&lt;Token&gt;)
    public init(tokArrayList: ArrayList&lt;Token&gt;)
}
</code></pre>
<p>功能：对 <a href="ast_package_structs.html#struct-token">Token</a> 序列进行封装的类型。</p>
<h3 id="prop-size"><a class="header" href="#prop-size">prop size</a></h3>
<pre><code class="language-cangjie">public prop size: Int64
</code></pre>
<p>功能：获取 <a href="ast_package_classes.html#class-tokens">Tokens</a> 对象中 <a href="ast_package_structs.html#struct-token">Token</a> 类型的数量。</p>
<p>类型：<a href="../../core/core_package_api/core_package_intrinsics.html#int64">Int64</a></p>
<h3 id="init-64"><a class="header" href="#init-64">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 对象。</p>
<h3 id="initarraytoken"><a class="header" href="#initarraytoken">init(Array&lt;Token&gt;)</a></h3>
<pre><code class="language-cangjie">public init(tokArray: Array&lt;Token&gt;)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-tokens">Tokens</a> 对象。</p>
<p>参数：</p>
<ul>
<li>tokArray: <a href="../../core/core_package_api/core_package_structs.html#struct-arrayt">Array</a>&lt;<a href="ast_package_structs.html#struct-token">Token</a>&gt; - 一组包含 <a href="ast_package_structs.html#struct-token">Token</a> 的 <a href="../../core/core_package_api/core_package_structs.html#struct-arrayt">Array</a> 类型。</li>
</ul>
<h3 id="initarraylisttoken"><a class="header" href="#initarraylisttoken">init(ArrayList&lt;Token&gt;)</a></h3>
<pre><code class="language-cangjie">public init(tokArrayList: ArrayList&lt;Token&gt;)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-tokens">Tokens</a> 对象。</p>
<p>参数：</p>
<ul>
<li>tokArrayList: <a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_structs.html#struct-token">Token</a>&gt; - 一组包含 <a href="ast_package_structs.html#struct-token">Token</a> 的 <a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a> 类型。</li>
</ul>
<h3 id="func-appendnode"><a class="header" href="#func-appendnode">func append(Node)</a></h3>
<pre><code class="language-cangjie">public func append(node: Node): Tokens
</code></pre>
<p>功能：将当前的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 与传入节点所转换得到的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 进行拼接。</p>
<p>参数：</p>
<ul>
<li>node: <a href="ast_package_classes.html#class-node">Node</a> - 待拼接的 <a href="ast_package_classes.html#class-node">Node</a> 对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="ast_package_classes.html#class-tokens">Tokens</a> - 拼接后的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型。</li>
</ul>
<h3 id="func-appendtoken"><a class="header" href="#func-appendtoken">func append(Token)</a></h3>
<pre><code class="language-cangjie">public func append(token: Token): Tokens
</code></pre>
<p>功能：将当前的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 与传入的 <a href="ast_package_structs.html#struct-token">Token</a> 进行拼接。</p>
<p>参数：</p>
<ul>
<li>token: <a href="ast_package_structs.html#struct-token">Token</a> - 待拼接的 <a href="ast_package_structs.html#struct-token">Token</a> 对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="ast_package_classes.html#class-tokens">Tokens</a> - 拼接后的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型。</li>
</ul>
<h3 id="func-appendtokens"><a class="header" href="#func-appendtokens">func append(Tokens)</a></h3>
<pre><code class="language-cangjie">public func append(tokens: Tokens): Tokens
</code></pre>
<p>功能：在当前的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 后追加传入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 进行拼接（该接口性能较其他拼接函数表现更好）。</p>
<p>参数：</p>
<ul>
<li>tokens: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 待拼接的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="ast_package_classes.html#class-tokens">Tokens</a> - 拼接后的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型。</li>
</ul>
<h3 id="func-concattokens"><a class="header" href="#func-concattokens">func concat(Tokens)</a></h3>
<pre><code class="language-cangjie">public func concat(tokens: Tokens): Tokens
</code></pre>
<p>功能：将当前的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 与传入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 进行拼接。</p>
<p>参数：</p>
<ul>
<li>tokens: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 待拼接的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="ast_package_classes.html#class-tokens">Tokens</a> - 拼接后的 <a href="ast_package_classes.html#class-tokens">Tokens</a>。</li>
</ul>
<h3 id="func-dump-1"><a class="header" href="#func-dump-1">func dump()</a></h3>
<pre><code class="language-cangjie">public func dump(): Unit
</code></pre>
<p>功能：将 <a href="ast_package_classes.html#class-tokens">Tokens</a> 内所有 <a href="ast_package_structs.html#struct-token">Token</a> 的信息打印出来。</p>
<h3 id="func-getint64"><a class="header" href="#func-getint64">func get(Int64)</a></h3>
<pre><code class="language-cangjie">public open func get(index: Int64): Token
</code></pre>
<p>功能：通过索引值获取 <a href="ast_package_structs.html#struct-token">Token</a> 元素。</p>
<p>参数：</p>
<ul>
<li>index: <a href="../../core/core_package_api/core_package_intrinsics.html#int64">Int64</a> - 待索引的数值。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="ast_package_structs.html#struct-token">Token</a> - 指定索引的 <a href="ast_package_structs.html#struct-token">Token</a>。</li>
</ul>
<h3 id="func-iterator"><a class="header" href="#func-iterator">func iterator()</a></h3>
<pre><code class="language-cangjie">public func iterator(): TokensIterator
</code></pre>
<p>功能：获取 <a href="ast_package_classes.html#class-tokens">Tokens</a> 对象中的一个迭代器对象。</p>
<p>返回值：</p>
<ul>
<li><a href="ast_package_classes.html#class-tokensiterator">TokensIterator</a> - <a href="ast_package_classes.html#class-tokens">Tokens</a> 对象的迭代器对象。</li>
</ul>
<h3 id="func-removeint64"><a class="header" href="#func-removeint64">func remove(Int64)</a></h3>
<pre><code class="language-cangjie">public func remove(index: Int64): Tokens
</code></pre>
<p>功能：删除指定位置的 <a href="ast_package_structs.html#struct-token">Token</a> 对象。</p>
<p>参数：</p>
<ul>
<li>index: <a href="../../core/core_package_api/core_package_intrinsics.html#int64">Int64</a> - 被删除的 <a href="ast_package_structs.html#struct-token">Token</a> 的索引。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="ast_package_classes.html#class-tokens">Tokens</a> - 删除指定位置的 <a href="ast_package_structs.html#struct-token">Token</a> 后的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 对象。</li>
</ul>
<h3 id="func-tostring"><a class="header" href="#func-tostring">func toString()</a></h3>
<pre><code class="language-cangjie">public func toString(): String
</code></pre>
<p>功能：将 <a href="ast_package_classes.html#class-tokens">Tokens</a> 转化为 <a href="../../core/core_package_api/core_package_structs.html#struct-string">String</a> 类型。</p>
<h3 id="operator-func-token"><a class="header" href="#operator-func-token">operator func +(Token)</a></h3>
<pre><code class="language-cangjie">public operator func +(token: Token): Tokens
</code></pre>
<p>功能：使用当前 <a href="ast_package_structs.html#struct-token">Token</a> 与另一个 <a href="ast_package_structs.html#struct-token">Token</a> 相加以获取新的 <a href="ast_package_classes.html#class-tokens">Tokens</a>。</p>
<p>参数：</p>
<ul>
<li>token: <a href="ast_package_structs.html#struct-token">Token</a> - 待操作的另一个 <a href="ast_package_structs.html#struct-token">Token</a> 对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="ast_package_classes.html#class-tokens">Tokens</a> - 新拼接 <a href="ast_package_classes.html#class-tokens">Tokens</a> 后的词法单元集合。</li>
</ul>
<h3 id="operator-func-tokens"><a class="header" href="#operator-func-tokens">operator func +(Tokens)</a></h3>
<pre><code class="language-cangjie">public operator func +(tokens: Tokens): Tokens
</code></pre>
<p>功能：使用当前 <a href="ast_package_structs.html#struct-token">Token</a> 与 <a href="ast_package_classes.html#class-tokens">Tokens</a> 相加以获取新的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型。</p>
<p>参数：</p>
<ul>
<li>tokens: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 待操作的一组 <a href="ast_package_classes.html#class-tokens">Tokens</a> 对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="ast_package_classes.html#class-tokens">Tokens</a> - 新拼接 <a href="ast_package_classes.html#class-tokens">Tokens</a> 后的词法单元集合。</li>
</ul>
<h3 id="operator-func-int64"><a class="header" href="#operator-func-int64">operator func [](Int64)</a></h3>
<pre><code class="language-cangjie">public operator func [](index: Int64): Token
</code></pre>
<p>功能：操作符重载，通过索引值获取对应 <a href="ast_package_structs.html#struct-token">Token</a>。</p>
<p>参数：</p>
<ul>
<li>index: <a href="../../core/core_package_api/core_package_intrinsics.html#int64">Int64</a> - 待索引的数值。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="ast_package_structs.html#struct-token">Token</a> - 返回索引对应的 <a href="ast_package_structs.html#struct-token">Token</a>。</li>
</ul>
<h3 id="operator-func-rangeint64"><a class="header" href="#operator-func-rangeint64">operator func [](Range&lt;Int64&gt;)</a></h3>
<pre><code class="language-cangjie">public operator func [](range: Range&lt;Int64&gt;): Tokens
</code></pre>
<p>功能：操作符重载，通过 <code>range</code> 获取对应 <a href="ast_package_classes.html#class-tokens">Tokens</a> 切片。</p>
<p>参数：</p>
<ul>
<li>range: <a href="../../core/core_package_api/core_package_structs.html#struct-ranget-where-t--countablet--comparablet--equatablet">Range</a>&lt;<a href="../../core/core_package_api/core_package_intrinsics.html#int64">Int64</a>&gt; - 待索引的切片范围。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="ast_package_classes.html#class-tokens">Tokens</a> - 返回切片索引对应的 <a href="ast_package_classes.html#class-tokens">Tokens</a>。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="../../core/core_package_api/core_package_exceptions.html#class-illegalargumentexception">IllegalArgumentException</a> - 当 <code>range.step</code> 不等于 1 时，抛出异常。</li>
<li><a href="../../core/core_package_api/core_package_exceptions.html#class-indexoutofboundsexception">IndexOutOfBoundsException</a> - 当 range 无效时，抛出异常。</li>
</ul>
<h2 id="class-tokensiterator"><a class="header" href="#class-tokensiterator">class TokensIterator</a></h2>
<pre><code class="language-cangjie">public class TokensIterator &lt;: Iterator&lt;Token&gt; {
    public init(tokens: Tokens)
}
</code></pre>
<p>功能：实现 <a href="ast_package_classes.html#class-tokens">Tokens</a> 的迭代器功能。</p>
<h3 id="inittokens-54"><a class="header" href="#inittokens-54">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(tokens: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-tokensiterator">TokensIterator</a> 对象。</p>
<p>参数：</p>
<ul>
<li>tokens: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 传入 <a href="ast_package_classes.html#class-tokens">Tokens</a>。</li>
</ul>
<h3 id="func-iterator-1"><a class="header" href="#func-iterator-1">func iterator()</a></h3>
<pre><code class="language-cangjie">public func iterator(): Iterator&lt;Token&gt;
</code></pre>
<p>功能：获取当前迭代器实例。</p>
<p>返回值：</p>
<ul>
<li><a href="../../core/core_package_api/core_package_classes.html#class-iteratort">Iterator</a>&lt;<a href="ast_package_structs.html#struct-token">Token</a>&gt; - 当前迭代器实例。</li>
</ul>
<h3 id="func-next"><a class="header" href="#func-next">func next()</a></h3>
<pre><code class="language-cangjie">public func next(): Option&lt;Token&gt;
</code></pre>
<p>功能：获取迭代器中的下一个值。</p>
<p>返回值：</p>
<ul>
<li><a href="../../core/core_package_api/core_package_enums.html#enum-optiont">Option</a>&lt;<a href="ast_package_structs.html#struct-token">Token</a>&gt; - 返回 <a href="../../core/core_package_api/core_package_enums.html#enum-optiont">Option</a>&lt;<a href="ast_package_structs.html#struct-token">Token</a>&gt; 类型，当遍历结束后，返回 None。</li>
</ul>
<h3 id="func-peek"><a class="header" href="#func-peek">func peek()</a></h3>
<pre><code class="language-cangjie">public func peek(): Option&lt;Token&gt;
</code></pre>
<p>功能：获取迭代器中的当前值。</p>
<p>返回值：</p>
<ul>
<li><a href="../../core/core_package_api/core_package_enums.html#enum-optiont">Option</a>&lt;<a href="ast_package_structs.html#struct-token">Token</a>&gt; - 返回 <a href="../../core/core_package_api/core_package_enums.html#enum-optiont">Option</a>&lt;<a href="ast_package_structs.html#struct-token">Token</a>&gt; 类型，当遍历结束后，返回 None。</li>
</ul>
<h3 id="func-seeingtokenkind"><a class="header" href="#func-seeingtokenkind">func seeing(TokenKind)</a></h3>
<pre><code class="language-cangjie">public func seeing(kind: TokenKind): Bool
</code></pre>
<p>功能：判断当前节点的 <a href="ast_package_structs.html#struct-token">Token</a> 类型是否是传入的类型。</p>
<p>参数：</p>
<ul>
<li>kind: <a href="ast_package_enums.html#enum-tokenkind">TokenKind</a> - 需要判断的 <a href="ast_package_enums.html#enum-tokenkind">TokenKind</a> 类型。</li>
</ul>
<p>返回值：</p>
<ul>
<li><a href="../../core/core_package_api/core_package_intrinsics.html#bool">Bool</a> - 如果当前节点的 <a href="ast_package_enums.html#enum-tokenkind">TokenKind</a> 与传入类型相同，返回 true，否则返回 false。</li>
</ul>
<h2 id="class-trailingclosureexpr"><a class="header" href="#class-trailingclosureexpr">class TrailingClosureExpr</a></h2>
<pre><code class="language-cangjie">public class TrailingClosureExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示尾随 <code>Lambda</code> 节点。</p>
<p>一个 <a href="ast_package_classes.html#class-trailingclosureexpr">TrailingClosureExpr</a> 节点将 lambda 表达式放在函数调用的尾部，括号外面，如 <code>f(a){ i =&gt; i * i }</code>。</p>
<h3 id="prop-expr-10"><a class="header" href="#prop-expr-10">prop expr</a></h3>
<pre><code class="language-cangjie">public mut prop expr: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-trailingclosureexpr">TrailingClosureExpr</a> 中的表达式。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<h3 id="prop-lambdaexpr-1"><a class="header" href="#prop-lambdaexpr-1">prop lambdaExpr</a></h3>
<pre><code class="language-cangjie">public mut prop lambdaExpr: LambdaExpr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-trailingclosureexpr">TrailingClosureExpr</a> 中的尾随 lambda。</p>
<p>类型：<a href="ast_package_classes.html#class-lambdaexpr">LambdaExpr</a></p>
<h3 id="init-65"><a class="header" href="#init-65">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-trailingclosureexpr">TrailingClosureExpr</a> 对象。</p>
<h3 id="inittokens-55"><a class="header" href="#inittokens-55">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-trailingclosureexpr">TrailingClosureExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-trailingclosureexpr">TrailingClosureExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-trailingclosureexpr">TrailingClosureExpr</a> 节点。</li>
</ul>
<h2 id="class-tryexpr"><a class="header" href="#class-tryexpr">class TryExpr</a></h2>
<pre><code class="language-cangjie">public class TryExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示 <code>try</code> 表达式节点。</p>
<p><code>try</code> 表达式包括三个部分：<code>try</code> 块，<code>catch</code> 块和 <code>finally</code> 块。</p>
<h3 id="prop-catchblocks"><a class="header" href="#prop-catchblocks">prop catchBlocks</a></h3>
<pre><code class="language-cangjie">public mut prop catchBlocks: ArrayList&lt;Block&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-tryexpr">TryExpr</a> 中的 Catch 块。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-block">Block</a>&gt;</p>
<h3 id="prop-catchpatterns"><a class="header" href="#prop-catchpatterns">prop catchPatterns</a></h3>
<pre><code class="language-cangjie">public mut prop catchPatterns: ArrayList&lt;Pattern&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-tryexpr">TryExpr</a> 中通过模式匹配的方式匹配待捕获的异常序列。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-pattern">Pattern</a>&gt;</p>
<h3 id="prop-finallyblock"><a class="header" href="#prop-finallyblock">prop finallyBlock</a></h3>
<pre><code class="language-cangjie">public mut prop finallyBlock: Block
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-tryexpr">TryExpr</a> 中的关键字 <code>Finally</code> 块。</p>
<p>类型：<a href="ast_package_classes.html#class-block">Block</a></p>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当 <a href="ast_package_classes.html#class-tryexpr">TryExpr</a> 节点无 <code>Finally</code> 块节点时，抛出异常。</li>
</ul>
<h3 id="prop-keywordf-1"><a class="header" href="#prop-keywordf-1">prop keywordF</a></h3>
<pre><code class="language-cangjie">public mut prop keywordF: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-tryexpr">TryExpr</a> 中的 <code>finally</code> 关键字。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-keywordt"><a class="header" href="#prop-keywordt">prop keywordT</a></h3>
<pre><code class="language-cangjie">public mut prop keywordT: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-tryexpr">TryExpr</a> 中的 <code>try</code> 关键字。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-keywordsc"><a class="header" href="#prop-keywordsc">prop keywordsC</a></h3>
<pre><code class="language-cangjie">public mut prop keywordsC: Tokens
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-tryexpr">TryExpr</a> 中的关键字 <code>catch</code>。</p>
<p>类型：<a href="ast_package_classes.html#class-tokens">Tokens</a></p>
<h3 id="prop-resourcespec"><a class="header" href="#prop-resourcespec">prop resourceSpec</a></h3>
<pre><code class="language-cangjie">public mut prop resourceSpec: ArrayList&lt;VarDecl&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-tryexpr">TryExpr</a> 中 Try-with-resources 类型表达式的实例化对象序列。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-vardecl">VarDecl</a>&gt;</p>
<h3 id="prop-tryblock"><a class="header" href="#prop-tryblock">prop tryBlock</a></h3>
<pre><code class="language-cangjie">public mut prop tryBlock: Block
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-tryexpr">TryExpr</a> 中由表达式与声明组成的块。</p>
<p>类型：<a href="ast_package_classes.html#class-block">Block</a></p>
<h3 id="init-66"><a class="header" href="#init-66">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-tryexpr">TryExpr</a> 对象。</p>
<h3 id="inittokens-56"><a class="header" href="#inittokens-56">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-tryexpr">TryExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-tryexpr">TryExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-tryexpr">TryExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-tupleliteral"><a class="header" href="#class-tupleliteral">class TupleLiteral</a></h2>
<pre><code class="language-cangjie">public class TupleLiteral &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示元组字面量节点。</p>
<p><a href="ast_package_classes.html#class-tupleliteral">TupleLiteral</a> 节点：使用格式 <code>(expr1, expr2, ... , exprN)</code> 表示，每个 <code>expr</code> 是一个表达式。</p>
<h3 id="prop-elements-1"><a class="header" href="#prop-elements-1">prop elements</a></h3>
<pre><code class="language-cangjie">public mut prop elements: ArrayList&lt;Expr&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-tupleliteral">TupleLiteral</a> 中的表达式列表。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-expr">Expr</a>&gt;</p>
<h3 id="prop-lparen-20"><a class="header" href="#prop-lparen-20">prop lParen</a></h3>
<pre><code class="language-cangjie">public mut prop lParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-tupleliteral">TupleLiteral</a> 中的左括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-rparen-20"><a class="header" href="#prop-rparen-20">prop rParen</a></h3>
<pre><code class="language-cangjie">public mut prop rParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-tupleliteral">TupleLiteral</a> 中的右括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-67"><a class="header" href="#init-67">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-tupleliteral">TupleLiteral</a> 对象。</p>
<h3 id="inittokens-57"><a class="header" href="#inittokens-57">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-tupleliteral">TupleLiteral</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-tupleliteral">TupleLiteral</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-tupleliteral">TupleLiteral</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-tuplepattern"><a class="header" href="#class-tuplepattern">class TuplePattern</a></h2>
<pre><code class="language-cangjie">public class TuplePattern &lt;: Pattern {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示 Tuple 模式节点。</p>
<p>用于 <code>tuple</code> 值的匹配，如 <code>case (&quot;Bob&quot;, age) =&gt; 1</code> 中的 <code>(&quot;Bob&quot;, age)</code>。</p>
<h3 id="prop-lparen-21"><a class="header" href="#prop-lparen-21">prop lParen</a></h3>
<pre><code class="language-cangjie">public mut prop lParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-tuplepattern">TuplePattern</a> 节点中的左括号的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-patterns-2"><a class="header" href="#prop-patterns-2">prop patterns</a></h3>
<pre><code class="language-cangjie">public mut prop patterns: ArrayList&lt;Pattern&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-tuplepattern">TuplePattern</a> 节点中的一组 <a href="ast_package_classes.html#class-pattern">Pattern</a> 节点。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-pattern">Pattern</a>&gt;</p>
<h3 id="prop-rparen-21"><a class="header" href="#prop-rparen-21">prop rParen</a></h3>
<pre><code class="language-cangjie">public mut prop rParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-tuplepattern">TuplePattern</a> 节点中的右括号的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-68"><a class="header" href="#init-68">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-tuplepattern">TuplePattern</a> 对象。</p>
<h3 id="inittokens-58"><a class="header" href="#inittokens-58">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-tuplepattern">TuplePattern</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-tuplepattern">TuplePattern</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-tuplepattern">TuplePattern</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-tupletype"><a class="header" href="#class-tupletype">class TupleType</a></h2>
<pre><code class="language-cangjie">public class TupleType &lt;: TypeNode {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示元组类型节点。</p>
<p>例如 <code>var a : (Int64, Int32)</code> 中的 <code>(Int64, Int32)</code>。</p>
<h3 id="prop-lparen-22"><a class="header" href="#prop-lparen-22">prop lParen</a></h3>
<pre><code class="language-cangjie">public mut prop lParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-tupletype">TupleType</a> 节点中的左括号词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-rparen-22"><a class="header" href="#prop-rparen-22">prop rParen</a></h3>
<pre><code class="language-cangjie">public mut prop rParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-tupletype">TupleType</a> 节点中的右括号词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-types-2"><a class="header" href="#prop-types-2">prop types</a></h3>
<pre><code class="language-cangjie">public mut prop types: ArrayList&lt;TypeNode&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-tupletype">TupleType</a> 节点中的类型节点列表。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-typenode">TypeNode</a>&gt;</p>
<h3 id="init-69"><a class="header" href="#init-69">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-tupletype">TupleType</a> 对象。</p>
<h3 id="inittokens-59"><a class="header" href="#inittokens-59">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-tupletype">TupleType</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-tupletype">TupleType</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-tupletype">TupleType</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-typealiasdecl"><a class="header" href="#class-typealiasdecl">class TypeAliasDecl</a></h2>
<pre><code class="language-cangjie">public class TypeAliasDecl &lt;: Decl {
    public init()
    public init(inputs: Tokens)
}
</code></pre>
<p>功能：表示类型别名节点。</p>
<p>一个 <a href="ast_package_classes.html#class-typealiasdecl">TypeAliasDecl</a> 节点： <code>type Point2D = Float64</code>。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>该节点中 <code>type</code> 作为关键字，紧跟任意的合法标识符，其后的 <code>type</code> 是任意的 top-level 可见的类型，标识符和 <code>type</code> 之间使用 <code>=</code> 进行连接。</p>
</blockquote>
<h3 id="prop-aliastype"><a class="header" href="#prop-aliastype">prop aliasType</a></h3>
<pre><code class="language-cangjie">public mut prop aliasType: TypeNode
</code></pre>
<p>功能：获取或设置将要别名的类型。</p>
<p>类型：<a href="ast_package_classes.html#class-typenode">TypeNode</a></p>
<h3 id="prop-assign-2"><a class="header" href="#prop-assign-2">prop assign</a></h3>
<pre><code class="language-cangjie">public mut prop assign: Token
</code></pre>
<p>功能：获取或设置标识符和 <code>type</code> 之间的 <code>=</code>。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-70"><a class="header" href="#init-70">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-typealiasdecl">TypeAliasDecl</a> 对象。</p>
<h3 id="inittokens-60"><a class="header" href="#inittokens-60">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(inputs: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-typealiasdecl">TypeAliasDecl</a> 对象。</p>
<p>参数：</p>
<ul>
<li>inputs: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-typealiasdecl">TypeAliasDecl</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-typealiasdecl">TypeAliasDecl</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-typeconvexpr"><a class="header" href="#class-typeconvexpr">class TypeConvExpr</a></h2>
<pre><code class="language-cangjie">public class TypeConvExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示类型转换表达式。</p>
<p>用于实现若干数值类型间的转换。一个 <a href="ast_package_classes.html#class-typeconvexpr">TypeConvExpr</a> 节点：<code>Int8(32)</code>。</p>
<h3 id="prop-expr-11"><a class="header" href="#prop-expr-11">prop expr</a></h3>
<pre><code class="language-cangjie">public mut prop expr: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-typeconvexpr">TypeConvExpr</a> 中进行类型转化的原始表达式。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<h3 id="prop-lparen-23"><a class="header" href="#prop-lparen-23">prop lParen</a></h3>
<pre><code class="language-cangjie">public mut prop lParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-typeconvexpr">TypeConvExpr</a> 中的左括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-rparen-23"><a class="header" href="#prop-rparen-23">prop rParen</a></h3>
<pre><code class="language-cangjie">public mut prop rParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-typeconvexpr">TypeConvExpr</a> 中的右括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-targettype"><a class="header" href="#prop-targettype">prop targetType</a></h3>
<pre><code class="language-cangjie">public mut prop targetType: PrimitiveType
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-typeconvexpr">TypeConvExpr</a> 中将要转换到的目标类型。</p>
<p>类型：<a href="ast_package_classes.html#class-primitivetype">PrimitiveType</a></p>
<h3 id="init-71"><a class="header" href="#init-71">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-typeconvexpr">TypeConvExpr</a> 对象。</p>
<h3 id="inittokens-61"><a class="header" href="#inittokens-61">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-typeconvexpr">TypeConvExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-typeconvexpr">TypeConvExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-typeconvexpr">TypeConvExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-typenode"><a class="header" href="#class-typenode">class TypeNode</a></h2>
<pre><code class="language-cangjie">public open class TypeNode &lt;: Node
</code></pre>
<p>功能：所有类型节点的父类，继承自 <a href="ast_package_classes.html#class-node">Node</a>。</p>
<h3 id="prop-typeparametername"><a class="header" href="#prop-typeparametername">prop typeParameterName</a></h3>
<pre><code class="language-cangjie">public mut prop typeParameterName: Token
</code></pre>
<p>功能：获取或设置类型节点的参数，如：<code>(p1:Int64, p2:Int64)</code> 中的 <code>p1</code> 和 <code>p2</code>，可能为 <a href="ast_package_enums.html#illegal">ILLEGAL</a> 的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h2 id="class-typepattern"><a class="header" href="#class-typepattern">class TypePattern</a></h2>
<pre><code class="language-cangjie">public class TypePattern &lt;: Pattern {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示类型模式节点。</p>
<p>用于判断一个值的运行时类型是否是某个类型的子类型，如 <code>case b: Base =&gt; 0</code> 中的 <code>b: Base</code>。</p>
<h3 id="prop-colon-8"><a class="header" href="#prop-colon-8">prop colon</a></h3>
<pre><code class="language-cangjie">public mut prop colon: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-typepattern">TypePattern</a> 节点中的 <code>:</code> 操作符的词法单元节点。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-pattern-3"><a class="header" href="#prop-pattern-3">prop pattern</a></h3>
<pre><code class="language-cangjie">public mut prop pattern: Pattern
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-typepattern">TypePattern</a> 节点中的模式节点。</p>
<p>类型：<a href="ast_package_classes.html#class-pattern">Pattern</a></p>
<h3 id="prop-patterntype"><a class="header" href="#prop-patterntype">prop patternType</a></h3>
<pre><code class="language-cangjie">public mut prop patternType: TypeNode
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-typepattern">TypePattern</a> 节点中的待匹配的模式类型节点。</p>
<p>类型：<a href="ast_package_classes.html#class-typenode">TypeNode</a></p>
<h3 id="init-72"><a class="header" href="#init-72">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-typepattern">TypePattern</a> 对象。</p>
<h3 id="inittokens-62"><a class="header" href="#inittokens-62">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-typepattern">TypePattern</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-typepattern">TypePattern</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-typepattern">TypePattern</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-unaryexpr"><a class="header" href="#class-unaryexpr">class UnaryExpr</a></h2>
<pre><code class="language-cangjie">public class UnaryExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示一个一元操作表达式节点。</p>
<h3 id="prop-expr-12"><a class="header" href="#prop-expr-12">prop expr</a></h3>
<pre><code class="language-cangjie">public mut prop expr: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-unaryexpr">UnaryExpr</a> 节点中的操作数。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<h3 id="prop-op-3"><a class="header" href="#prop-op-3">prop op</a></h3>
<pre><code class="language-cangjie">public mut prop op: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-unaryexpr">UnaryExpr</a> 节点中的一元操作符。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-73"><a class="header" href="#init-73">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-unaryexpr">UnaryExpr</a> 对象。</p>
<h3 id="inittokens-63"><a class="header" href="#inittokens-63">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-unaryexpr">UnaryExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-unaryexpr">UnaryExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-unaryexpr">UnaryExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-varrayexpr"><a class="header" href="#class-varrayexpr">class VArrayExpr</a></h2>
<pre><code class="language-cangjie">public class VArrayExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示 <code>VArray</code> 的实例节点。</p>
<p>一个 <a href="ast_package_classes.html#class-varrayexpr">VArrayExpr</a> 节点：<code>let arr: VArray&lt;Int64, $5&gt; = VArray&lt;Int64, $5&gt; { i =&gt; i}</code> 中的 <code>VArray&lt;Int64, $5&gt; { i =&gt; i}</code>。</p>
<h3 id="prop-arguments-2"><a class="header" href="#prop-arguments-2">prop arguments</a></h3>
<pre><code class="language-cangjie">public mut prop arguments: ArrayList&lt;Argument&gt;
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-varrayexpr">VArrayExpr</a> 中的中的初始化参数序列。</p>
<p>类型：<a href="../../collection/collection_package_api/collection_package_class.html#class-arraylistt">ArrayList</a>&lt;<a href="ast_package_classes.html#class-argument">Argument</a>&gt;</p>
<h3 id="prop-lparen-24"><a class="header" href="#prop-lparen-24">prop lParen</a></h3>
<pre><code class="language-cangjie">public mut prop lParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-varrayexpr">VArrayExpr</a> 中的左括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-rparen-24"><a class="header" href="#prop-rparen-24">prop rParen</a></h3>
<pre><code class="language-cangjie">public mut prop rParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-varrayexpr">VArrayExpr</a> 中的右括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-varraytype"><a class="header" href="#prop-varraytype">prop vArrayType</a></h3>
<pre><code class="language-cangjie">public mut prop vArrayType: VArrayType
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-varrayexpr">VArrayExpr</a> 的 VArray 类型节点。</p>
<p>类型：<a href="ast_package_classes.html#class-varraytype">VArrayType</a></p>
<h3 id="init-74"><a class="header" href="#init-74">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-varrayexpr">VArrayExpr</a> 对象。</p>
<h3 id="inittokens-64"><a class="header" href="#inittokens-64">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-varrayexpr">VArrayExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-varrayexpr">VArrayExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-varrayexpr">VArrayExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-varraytype"><a class="header" href="#class-varraytype">class VArrayType</a></h2>
<pre><code class="language-cangjie">public class VArrayType &lt;: TypeNode {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示 <code>VArray</code> 类型节点。</p>
<p>使用泛型 <code>VArray&lt;T, size: Int64&gt;</code> 表示 <code>VArray</code> 类型。</p>
<h3 id="prop-dollar"><a class="header" href="#prop-dollar">prop dollar</a></h3>
<pre><code class="language-cangjie">public mut prop dollar: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-varraytype">VArrayType</a> 节点中的操作符 <code>$</code> 的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-elementty"><a class="header" href="#prop-elementty">prop elementTy</a></h3>
<pre><code class="language-cangjie">public mut prop elementTy: TypeNode
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-varraytype">VArrayType</a> 节点中的类型变元节点，如 <code>VArray&lt;Int16, $0&gt;</code> 中的 <a href="../../core/core_package_api/core_package_intrinsics.html#int16">Int16</a>。</p>
<p>类型：<a href="ast_package_classes.html#class-typenode">TypeNode</a></p>
<h3 id="prop-keyword-17"><a class="header" href="#prop-keyword-17">prop keyword</a></h3>
<pre><code class="language-cangjie">public mut prop keyword: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-varraytype">VArrayType</a> 节点的关键字 <code>VArray</code> 的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-langle-5"><a class="header" href="#prop-langle-5">prop lAngle</a></h3>
<pre><code class="language-cangjie">public mut prop lAngle: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-varraytype">VArrayType</a> 节点左尖括号的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-rangle-5"><a class="header" href="#prop-rangle-5">prop rAngle</a></h3>
<pre><code class="language-cangjie">public mut prop rAngle: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-varraytype">VArrayType</a> 节点右尖括号的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-size-1"><a class="header" href="#prop-size-1">prop size</a></h3>
<pre><code class="language-cangjie">public mut prop size: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-varraytype">VArrayType</a> 节点中类型长度的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-75"><a class="header" href="#init-75">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-varraytype">VArrayType</a> 对象。</p>
<h3 id="inittokens-65"><a class="header" href="#inittokens-65">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-varraytype">VArrayType</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-varraytype">VArrayType</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-varraytype">VArrayType</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-vardecl"><a class="header" href="#class-vardecl">class VarDecl</a></h2>
<pre><code class="language-cangjie">public class VarDecl &lt;: Decl {
    public init()
    public init(inputs: Tokens)
}
</code></pre>
<p>功能：表示变量定义节点。</p>
<p>一个 <a href="ast_package_classes.html#class-vardecl">VarDecl</a> 节点: <code>var a: String</code>，<code>var b: Int64 = 1</code>。</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>变量的定义主要包括如下几个部分：修饰符、关键字、patternsMaybeIrrefutable、变量类型和变量初始值。</p>
</blockquote>
<h3 id="prop-assign-3"><a class="header" href="#prop-assign-3">prop assign</a></h3>
<pre><code class="language-cangjie">public mut prop assign: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-vardecl">VarDecl</a> 节点中的赋值操作符的位置信息。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-colon-9"><a class="header" href="#prop-colon-9">prop colon</a></h3>
<pre><code class="language-cangjie">public mut prop colon: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-vardecl">VarDecl</a> 节点中的冒号位置信息。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-decltype-4"><a class="header" href="#prop-decltype-4">prop declType</a></h3>
<pre><code class="language-cangjie">public mut prop declType: TypeNode
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-vardecl">VarDecl</a> 节点的变量类型。</p>
<p>类型：<a href="ast_package_classes.html#class-typenode">TypeNode</a></p>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当 <a href="ast_package_classes.html#class-vardecl">VarDecl</a> 节点没有声明变量类型时，抛出异常。</li>
</ul>
<h3 id="prop-expr-13"><a class="header" href="#prop-expr-13">prop expr</a></h3>
<pre><code class="language-cangjie">public mut prop expr: Expr
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-vardecl">VarDecl</a> 节点的变量初始化节点。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当 <a href="ast_package_classes.html#class-vardecl">VarDecl</a> 节点没有对变量进行初始化时，抛出异常。</li>
</ul>
<h3 id="prop-pattern-4"><a class="header" href="#prop-pattern-4">prop pattern</a></h3>
<pre><code class="language-cangjie">public mut prop pattern: Pattern
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-vardecl">VarDecl</a> 节点的 pattern 节点。</p>
<p>类型：<a href="ast_package_classes.html#class-pattern">Pattern</a></p>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当 <a href="ast_package_classes.html#class-vardecl">VarDecl</a> 节点没有声明 pattern 节点时，抛出异常。</li>
</ul>
<h3 id="init-76"><a class="header" href="#init-76">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-vardecl">VarDecl</a> 对象。</p>
<h3 id="inittokens-66"><a class="header" href="#inittokens-66">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(inputs: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-vardecl">VarDecl</a> 对象。</p>
<p>参数：</p>
<ul>
<li>inputs: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-vardecl">VarDecl</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-vardecl">VarDecl</a> 节点时，抛出异常。</li>
</ul>
<h3 id="func-isconst-2"><a class="header" href="#func-isconst-2">func isConst()</a></h3>
<pre><code class="language-cangjie">public func isConst(): Bool
</code></pre>
<p>功能：判断是否是一个 <code>Const</code> 类型的节点。</p>
<p>返回值：</p>
<ul>
<li><a href="../../core/core_package_api/core_package_intrinsics.html#bool">Bool</a> - 是一个 <code>Const</code> 类型的节点返回 true；反之，返回 false。</li>
</ul>
<h2 id="class-varorenumpattern"><a class="header" href="#class-varorenumpattern">class VarOrEnumPattern</a></h2>
<pre><code class="language-cangjie">public class VarOrEnumPattern &lt;: Pattern {
    public init()
    public init(identifier: Token)
}
</code></pre>
<p>功能：表示当模式的标识符为 <code>Enum</code> 构造器时的节点。</p>
<p>例如 <code>case RED</code> 中的 <code>RED</code> 为 <code>Enum</code> 构造器。</p>
<h3 id="prop-identifier-10"><a class="header" href="#prop-identifier-10">prop identifier</a></h3>
<pre><code class="language-cangjie">public mut prop identifier: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-varorenumpattern">VarOrEnumPattern</a> 节点中的标识符的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-77"><a class="header" href="#init-77">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-varorenumpattern">VarOrEnumPattern</a> 对象。</p>
<h3 id="inittokens-67"><a class="header" href="#inittokens-67">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(identifier: Token)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-varorenumpattern">VarOrEnumPattern</a> 对象。</p>
<p>参数：</p>
<ul>
<li>identifier: <a href="ast_package_structs.html#struct-token">Token</a> - 当将要构造 <a href="ast_package_classes.html#class-varorenumpattern">VarOrEnumPattern</a> 类型的词法单元。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-varorenumpattern">VarOrEnumPattern</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-varpattern"><a class="header" href="#class-varpattern">class VarPattern</a></h2>
<pre><code class="language-cangjie">public class VarPattern &lt;: Pattern {
    public init()
    public init(identifier: Token)
}
</code></pre>
<p>功能：表示绑定模式节点。</p>
<p>使用一个合法的标识符表示，一般适用于声明节点中，如 <code>case n =&gt; 0</code> 中的 <code>n</code>。</p>
<h3 id="prop-identifier-11"><a class="header" href="#prop-identifier-11">prop identifier</a></h3>
<pre><code class="language-cangjie">public mut prop identifier: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-varpattern">VarPattern</a> 节点中的标识符符的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-78"><a class="header" href="#init-78">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-varpattern">VarPattern</a> 对象。</p>
<h3 id="inittokens-68"><a class="header" href="#inittokens-68">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(identifier: Token)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-varpattern">VarPattern</a> 对象。</p>
<p>参数：</p>
<ul>
<li>identifier: <a href="ast_package_structs.html#struct-token">Token</a> - 将要构造 <a href="ast_package_classes.html#class-varpattern">VarPattern</a> 类型的词法单元。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-varpattern">VarPattern</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-visitor"><a class="header" href="#class-visitor">class Visitor</a></h2>
<pre><code class="language-cangjie">public open abstract class Visitor
</code></pre>
<p>功能：一个抽象类，其内部默认定义了访问不同类型 AST 节点访问（visit）函数。</p>
<blockquote>
<p><strong>说明：</strong></p>
<ul>
<li><code>visit</code> 函数搭配 <code>traverse</code> 一起使用，可实现对节点的访问和修改, 所有 <code>visit</code> 函数都有默认为空的实现，可以按需实现需要的 <code>visit</code> 方法。</li>
<li>该类需要被继承使用，并允许子类重新定义访问函数。</li>
</ul>
</blockquote>
<h3 id="func-breaktraverse"><a class="header" href="#func-breaktraverse">func breakTraverse()</a></h3>
<pre><code class="language-cangjie">public func breakTraverse(): Unit
</code></pre>
<p>功能：用于重写 <code>visit</code> 函数中，通过调用该函数来终止继续遍历子节点的行为。</p>
<h2 id="class-whileexpr"><a class="header" href="#class-whileexpr">class WhileExpr</a></h2>
<pre><code class="language-cangjie">public class WhileExpr &lt;: Expr {
    public init()
    public init(input: Tokens)
}
</code></pre>
<p>功能：表示 <code>while</code> 表达式。</p>
<p><code>while</code> 是关键字，<code>while</code> 之后是一个小括号，小括号内可以是一个表达式或者一个 <code>let</code> 声明的解构匹配，接着是一个 <a href="ast_package_classes.html#class-block">Block</a> 节点。</p>
<h3 id="prop-block-8"><a class="header" href="#prop-block-8">prop block</a></h3>
<pre><code class="language-cangjie">public mut prop block: Block
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-whileexpr">WhileExpr</a> 中的块节点。</p>
<p>类型：<a href="ast_package_classes.html#class-block">Block</a></p>
<h3 id="prop-condition-3"><a class="header" href="#prop-condition-3">prop condition</a></h3>
<pre><code class="language-cangjie">public mut prop condition: Expr
</code></pre>
<p>功能：获取或设置关键字 <a href="ast_package_classes.html#class-whileexpr">WhileExpr</a> 中的条件表达式。</p>
<p>类型：<a href="ast_package_classes.html#class-expr">Expr</a></p>
<h3 id="prop-keyword-18"><a class="header" href="#prop-keyword-18">prop keyword</a></h3>
<pre><code class="language-cangjie">public mut prop keyword: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-whileexpr">WhileExpr</a> 节点中 <code>while</code> 关键字。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-lparen-25"><a class="header" href="#prop-lparen-25">prop lParen</a></h3>
<pre><code class="language-cangjie">public mut prop lParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-whileexpr">WhileExpr</a> 中 <code>while</code> 关键字之后的左括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="prop-rparen-25"><a class="header" href="#prop-rparen-25">prop rParen</a></h3>
<pre><code class="language-cangjie">public mut prop rParen: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-whileexpr">WhileExpr</a> 中 <code>while</code> 关键字之后的右括号。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-79"><a class="header" href="#init-79">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-whileexpr">WhileExpr</a> 对象。</p>
<h3 id="inittokens-69"><a class="header" href="#inittokens-69">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(input: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-whileexpr">WhileExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>input: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-whileexpr">WhileExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-whileexpr">WhileExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-wildcardexpr"><a class="header" href="#class-wildcardexpr">class WildcardExpr</a></h2>
<pre><code class="language-cangjie">public class WildcardExpr &lt;: Expr {
    public init()
    public init(keyword: Tokens)
}
</code></pre>
<p>功能：表示通配符表达式节点。</p>
<h3 id="prop-keyword-19"><a class="header" href="#prop-keyword-19">prop keyword</a></h3>
<pre><code class="language-cangjie">public mut prop keyword: Token
</code></pre>
<p>功能：获取 <a href="ast_package_classes.html#class-wildcardexpr">WildcardExpr</a> 的通配符关键字。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-80"><a class="header" href="#init-80">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-wildcardexpr">WildcardExpr</a> 对象。</p>
<h3 id="inittokens-70"><a class="header" href="#inittokens-70">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(keyword: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-wildcardexpr">WildcardExpr</a> 对象。</p>
<p>参数：</p>
<ul>
<li>keyword: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-wildcardexpr">WildcardExpr</a> 类型的词法单元集合 (<a href="ast_package_classes.html#class-tokens">Tokens</a>)。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-wildcardexpr">WildcardExpr</a> 节点时，抛出异常。</li>
</ul>
<h2 id="class-wildcardpattern"><a class="header" href="#class-wildcardpattern">class WildcardPattern</a></h2>
<pre><code class="language-cangjie">public class WildcardPattern &lt;: Pattern {
    public init()
    public init(keyword: Tokens)
}
</code></pre>
<p>功能：表示通配符模式节点。</p>
<p>使用下划线 <code>_</code> 表示，可以匹配任意值。</p>
<h3 id="prop-wildcard"><a class="header" href="#prop-wildcard">prop wildcard</a></h3>
<pre><code class="language-cangjie">public mut prop wildcard: Token
</code></pre>
<p>功能：获取或设置 <a href="ast_package_classes.html#class-wildcardpattern">WildcardPattern</a> 节点中的 <code>_</code> 操作符的词法单元。</p>
<p>类型：<a href="ast_package_structs.html#struct-token">Token</a></p>
<h3 id="init-81"><a class="header" href="#init-81">init()</a></h3>
<pre><code class="language-cangjie">public init()
</code></pre>
<p>功能：构造一个默认的 <a href="ast_package_classes.html#class-wildcardpattern">WildcardPattern</a> 对象。</p>
<h3 id="inittokens-71"><a class="header" href="#inittokens-71">init(Tokens)</a></h3>
<pre><code class="language-cangjie">public init(keyword: Tokens)
</code></pre>
<p>功能：构造一个 <a href="ast_package_classes.html#class-wildcardpattern">WildcardPattern</a> 对象。</p>
<p>参数：</p>
<ul>
<li>keyword: <a href="ast_package_classes.html#class-tokens">Tokens</a> - 将要构造 <a href="ast_package_classes.html#class-wildcardpattern">WildcardPattern</a> 类型的词法单元集合（<a href="ast_package_classes.html#class-tokens">Tokens</a>）。</li>
</ul>
<p>异常：</p>
<ul>
<li><a href="ast_package_exceptions.html#class-astexception">ASTException</a> - 当输入的 <a href="ast_package_classes.html#class-tokens">Tokens</a> 类型无法构造为 <a href="ast_package_classes.html#class-wildcardpattern">WildcardPattern</a> 节点时，抛出异常。</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../std/ast/ast_package_api/ast_package_interfaces.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../../std/ast/ast_package_api/ast_package_enums.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../std/ast/ast_package_api/ast_package_interfaces.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../../std/ast/ast_package_api/ast_package_enums.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../../elasticlunr.min.js"></script>
        <script src="../../../mark.min.js"></script>
        <script src="../../../searcher.js"></script>

        <script src="../../../clipboard.min.js"></script>
        <script src="../../../highlight.js"></script>
        <script src="../../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../../highlight.js"></script>
        <script src="../../../assets/elasticlunr.js"></script>
        <script src="../../../assets/fzf.umd.js"></script>
        <script src="../../../assets/sidebar.js"></script>


    </div>
    </body>
</html>
