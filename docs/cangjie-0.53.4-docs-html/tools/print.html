<!DOCTYPE HTML>
<html lang="zh-cn" class="ayu" dir="ltr">
    <head>
            <script type="text/x-mathjax-config">
                MathJax.Hub.Config({
                    showProcessingMessages: false,
                    messageStyle: "none",
                    extensions: ['tex2jax.js'],
                    jax: ['input/TeX', 'output/HTML-CSS'],
                    tex2jax: {
                        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
                        processEscapes: true
                    },
                    "HTML-CSS": { availableFonts: ["STIX", "TeX"] }
                });
            </script>
            
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>仓颉语言工具使用指南</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="assets/style.css">
        <link rel="stylesheet" href="assets/theme.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('ayu')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="source_zh_cn/IDE/user_manual_community.html"><strong aria-hidden="true">1.</strong> IDE 插件使用指南</a></li><li class="chapter-item "><a href="source_zh_cn/tools/user_manual_cjnative.html"><strong aria-hidden="true">2.</strong> 命令行工具使用指南</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="source_zh_cn/tools/cjpm_manual_cjnative_community.html"><strong aria-hidden="true">2.1.</strong> 包管理工具</a></li><li class="chapter-item "><a href="source_zh_cn/tools/cjdb_manual_cjnative.html"><strong aria-hidden="true">2.2.</strong> 调试工具</a></li><li class="chapter-item "><a href="source_zh_cn/tools/cjlint_manual_community.html"><strong aria-hidden="true">2.3.</strong> 静态检查工具</a></li><li class="chapter-item "><a href="source_zh_cn/tools/cjfmt_manual.html"><strong aria-hidden="true">2.4.</strong> 格式化工具</a></li><li class="chapter-item "><a href="source_zh_cn/tools/cjcov_manual_cjnative.html"><strong aria-hidden="true">2.5.</strong> 覆盖率工具</a></li><li class="chapter-item "><a href="source_zh_cn/tools/cjprof_manual_cjnative.html"><strong aria-hidden="true">2.6.</strong> 性能分析工具</a></li><li class="chapter-item "><a href="source_zh_cn/tools/cjdoc_manual.html"><strong aria-hidden="true">2.7.</strong> API文档生成工具</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">仓颉语言工具使用指南</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="仓颉语言-ide-插件使用指南"><a class="header" href="#仓颉语言-ide-插件使用指南">仓颉语言 IDE 插件使用指南</a></h1>
<h2 id="功能简介"><a class="header" href="#功能简介">功能简介</a></h2>
<p>仓颉语言提供了 Visual Studio Code（简称 VSCode） 插件，通过在 VSCode 中安装仓颉插件和仓颉 SDK，可以为开发者提供语言服务、工程管理、编译构建、调试服务、格式化、静态检查、代码覆盖率统计的功能。本文档介绍如何在 VSCode 中安装仓颉插件，以及如何使用插件提供的功能。</p>
<h2 id="安装指导"><a class="header" href="#安装指导">安装指导</a></h2>
<p>请按照如下指导，根据实际情况下载并安装不同平台的 VSCode（建议使用 1.67 及更新版本的 VSCode）。</p>
<h3 id="windows-平台"><a class="header" href="#windows-平台">Windows 平台</a></h3>
<ol>
<li>下载 <a href="https://code.visualstudio.com/updates">Windows 版本 VSCode</a> 。</li>
<li>按照安装包导引，将 VSCode 安装在自定义路径中，然后启动。</li>
</ol>
<h3 id="linux-平台"><a class="header" href="#linux-平台">Linux 平台</a></h3>
<p>下载 <a href="https://code.visualstudio.com/updates">Linux 版本 VSCode</a> 。</p>
<h3 id="macos-平台"><a class="header" href="#macos-平台">macOS 平台</a></h3>
<p>下载 <a href="https://code.visualstudio.com/updates">macOS 版本 VSCode</a> 。</p>
<h4 id="本地安装"><a class="header" href="#本地安装">本地安装</a></h4>
<ol>
<li>
<p>解压下载的压缩包（例如 VSCode-linux-x64）并存放到自定义位置。</p>
</li>
<li>
<p>使用如下命令给 code 增加可执行权限。</p>
<pre><code class="language-shell">chmod 777 ./VSCode-linux-x64/code
chmod 777 ./VSCode-linux-x64/bin/code
</code></pre>
</li>
<li>
<p>使用如下命令启动 VSCode 。</p>
<pre><code class="language-shell">./VSCode-linux-x64/bin/code
</code></pre>
</li>
</ol>
<h4 id="远程安装"><a class="header" href="#远程安装">远程安装</a></h4>
<ol>
<li>
<p>使用 Remote - SSH 远程连接 VSCode 。</p>
</li>
<li>
<p>搜索 Remote - SSH，单击 ”安装“。</p>
<p><img src="source_zh_cn/IDE/figures/remotessh1.png" alt="remotessh1" /></p>
</li>
<li>
<p>使用 Remote - SSH 进行远程工作，VSCode 会自动在远程主机上安装 server，linux_arm64 暂时只支持使用 Remote - SSH 的方式进行操作。</p>
</li>
</ol>
<h3 id="安装仓颉插件"><a class="header" href="#安装仓颉插件">安装仓颉插件</a></h3>
<p>首先，请在仓颉官方渠道（Gitee）根据平台架构下载相应安装包，交付内容为压缩包：<code>Cangjie-vscode-version.tar.gz</code>。</p>
<p>下载成功后，将其解压得到文件夹：Cangjie-vscode-version。该文件夹下有下列的内容</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">解压后生成文件与文件夹</th><th style="text-align: center">文件功能</th></tr></thead><tbody>
<tr><td style="text-align: center">.vsix 文件</td><td style="text-align: center">插件端</td></tr>
</tbody></table>
</div>
<h4 id="vscode-安装本地插件"><a class="header" href="#vscode-安装本地插件">VSCode 安装本地插件</a></h4>
<p>按照下图所示操作，打开文件资源管理器对话框，找到要安装的插件.vsix，点击确定即可安装。</p>
<p><img src="source_zh_cn/IDE/figures/setupVsix.png" alt="setupVsix" /></p>
<p>已经安装的插件可以在 INSTALLED 目录下查看</p>
<p><img src="source_zh_cn/IDE/figures/checkVsix.png" alt="checkVsix" /></p>
<h3 id="安装仓颉-sdk"><a class="header" href="#安装仓颉-sdk">安装仓颉 SDK</a></h3>
<p>仓颉 SDK 主要提供了 cjpm、cjc、cjfmt 等命令行工具，正确安装并配置仓颉 SDK 后，可使用工程管理、编译构建、格式化、静态检查和覆盖率统计等功能，开发者可以通过两种方式下载 SDK：</p>
<ul>
<li>在官网下载 SDK 安装包，并在本地安装部署仓颉 SDK。</li>
<li>仓颉插件提供了仓颉 SDK 最新版本下载和更新功能，开发者可以在 VSCode 界面完成最新版本仓颉 SDK 的下载和本地环境部署。</li>
</ul>
<h4 id="离线手动安装和更新仓颉-sdk"><a class="header" href="#离线手动安装和更新仓颉-sdk">离线手动安装和更新仓颉 SDK</a></h4>
<p>开发者可以自行前往官网，手动下载需要的 SDK 版本，并在本地完成 SDK 路径配置。</p>
<h5 id="windows-平台-1"><a class="header" href="#windows-平台-1">Windows 平台</a></h5>
<p>Windows 平台的 SDK 下载内容为：<code>Cangjie-version-windows_x64.exe</code>或<code>Cangjie-version-windows_x64.zip</code>。将其下载后内容放置在本地平台中。</p>
<p>Windows 版本的目录结构如下：</p>
<p><img src="source_zh_cn/IDE/figures/WindowsSDK.png" alt="WindowsSDK" /></p>
<h5 id="linux-平台-1"><a class="header" href="#linux-平台-1">Linux 平台</a></h5>
<p>linux_x64 平台的 SDK 下载内容为：<code>Cangjie-version-linux_x64.tar.gz</code>。
linux_aarch64 平台的 SDK 下载内容为：<code>Cangjie-version-linux_aarch64.tar.gz</code>。</p>
<p>将其下载后内容放置在本地环境中。linux 版本的目录结构如下：</p>
<p><img src="source_zh_cn/IDE/figures/sdk_path.png" alt="sdk_path" /></p>
<h5 id="macos-平台-1"><a class="header" href="#macos-平台-1">macOS 平台</a></h5>
<p>mac_x86_64 平台的 SDK 下载内容为：<code>Cangjie-version-darwin_x64.tar.gz</code>。
mac_aarch64 平台的 SDK 下载内容为：<code>Cangjie-version-darwin_aarch64.tar.gz</code>。</p>
<p>将其下载后内容放置在本地环境中。mac 版本的目录结构如下：</p>
<p><img src="source_zh_cn/IDE/figures/macSdk.png" alt="sdk_path" /></p>
<h5 id="sdk-路径配置"><a class="header" href="#sdk-路径配置">SDK 路径配置</a></h5>
<p>安装完 Cangjie 插件后，即可配置 SDK 的路径。点击左下角齿轮图标，选择设置选项：</p>
<p><img src="source_zh_cn/IDE/figures/setVS.png" alt="setVS" /></p>
<p>或直接右键点击插件，选择 Extension Settings，进入配置页面：</p>
<p><img src="source_zh_cn/IDE/figures/openSetting.png" alt="openSetting" /></p>
<p>在搜索栏输入 cangjie, 然后选择侧边栏的 Cangjie Language Support 选项。</p>
<p><strong>SDK 路径配置</strong></p>
<ol>
<li>
<p>找到 Cangjie Sdk: Option 选项，选择后端类型为 CJNative（默认是此选项）</p>
</li>
<li>
<p>找到 Cangjie Sdk Path: CJNative Backend 选项，输入 CJNative 后端 SDK 文件所在绝对路径</p>
</li>
<li>
<p>重启 VScode 生效</p>
</li>
</ol>
<p><img src="source_zh_cn/IDE/figures/llvmSdkPathSetCommunity.png" alt="CJNativeSdkPathSet" /></p>
<h4 id="插件安装和更新仓颉-sdk"><a class="header" href="#插件安装和更新仓颉-sdk">插件安装和更新仓颉 SDK</a></h4>
<p>仓颉插件提供了仓颉 SDK 最新版本的下载与更新功能，开发者只需在 VSCode 界面即可完成仓颉 SDK 对应平台最新版本的下载更新与本地环境部署。</p>
<h5 id="触发更新提示"><a class="header" href="#触发更新提示">触发更新提示</a></h5>
<p>当开发者进行如下操作时，仓颉插件会通过设置页面配置的仓颉 SDK 路径，获取对应 SDK 的版本信息，从而判断本地仓颉 SDK 是否为最新版本：</p>
<ul>
<li>
<p>在 VSCode 界面打开仓颉源文件。</p>
</li>
<li>
<p>通过快捷键  &quot;Ctrl + Shift + P&quot;（mac 上快捷键为 &quot;Command + Shift + P&quot;） 调出 VSCode 的命令面板，然后选择 &quot;Cangjie: Install/Update Latest SDK&quot; 命令。</p>
<p><img src="source_zh_cn/IDE/figures/commandNoSdk.png" alt="commandNoSdk" /></p>
</li>
</ul>
<p>当本地 VSCode 没有配置仓颉 SDK 或者仓颉 SDK 非最新版本时，VSCode 界面右下角会弹出安装或更新提示。</p>
<h5 id="安装仓颉-sdk-1"><a class="header" href="#安装仓颉-sdk-1">安装仓颉 SDK</a></h5>
<ol>
<li>
<p>如果希望直接安装最新版本 SDK，可以在更新提示框点击 “ Install “ 按钮。</p>
<p><img src="source_zh_cn/IDE/figures/buttonOnlyInstall.png" alt="buttonOnlyInstall" /></p>
</li>
<li>
<p>在弹出的窗口中选择下载和安装路径（注意路径不能存在名为 <code>cangjie</code> 的文件夹）并单击 &quot;Choose the SDK install path&quot; 确定。</p>
<p><img src="source_zh_cn/IDE/figures/buttomInstall.png" alt="buttomInstall" /></p>
</li>
<li>
<p>完成路径选择后，仓颉 SDK 开始下载：</p>
<p><img src="source_zh_cn/IDE/figures/onInstall.png" alt="onInstall" /></p>
</li>
<li>
<p>下载完成后，会自动配置仓颉 SDK 的安装路径。</p>
<p><img src="source_zh_cn/IDE/figures/installDone.png" alt="installDone" /></p>
</li>
<li>
<p>配置完成后，您可以使用最新版本的仓颉 SDK 进行本地开发。</p>
</li>
</ol>
<h2 id="使用限制"><a class="header" href="#使用限制">使用限制</a></h2>
<p>使用 VSCode 打开一个文件夹，将其中的仓颉源码分为两部分：一部分是顶层 src 目录下的仓颉源码，另一部分是非 src 目录下的仓颉源码。仓颉语言服务支持的目录结构如下：</p>
<p><img src="source_zh_cn/IDE/figures/dir.png" alt="dir" /></p>
<p><strong>限制一</strong></p>
<p>语言服务插件仅为用户打开的文件夹下仓颉源码提供语言服务。以用户打开的文件夹为仓颉项目的根目录 PROJECTROOT（如果用户没有明确指定模块名称，默认将 PROJECTROOT 目录名称作为模块名，以方便用户导入 src 下的包），PROJECTROOT/src 为 src 下仓颉源码（支持语言服务）；除了 src 下的仓颉源码，PROJECTROOT 下的所有源码称为非 src 下仓颉源码（支持语言服务）；PROJECTROOT 之外的仓颉源码称为外部源码（暂不支持语言服务）。</p>
<p><strong>限制二</strong></p>
<p>非 src 下每个文件夹都作为一个包，包名的声明和包的编译方式与 src 下顶层包（即 default 包）处理方式保持一致。非 src 下的仓颉源码可以导入标准库的包以及 src 下用户自定义的包，非 src 下的包无法被其他包导入。</p>
<p><strong>限制三</strong></p>
<p>Linux 、 Windows 、 macOS 平台下均需要先设置 Cangjie SDK 路径。</p>
<h2 id="语言服务"><a class="header" href="#语言服务">语言服务</a></h2>
<h3 id="功能简介-1"><a class="header" href="#功能简介-1">功能简介</a></h3>
<p>语言服务工具为开发者提供如下功能：语法高亮、自动补全、定义跳转、查找引用、诊断报错、选中高亮、悬浮提示、签名帮助、重命名等。</p>
<h3 id="使用说明"><a class="header" href="#使用说明">使用说明</a></h3>
<h4 id="语法高亮介绍及使用"><a class="header" href="#语法高亮介绍及使用">语法高亮介绍及使用</a></h4>
<p>VSCode 打开 Cangjie 工程中的.cj 文件，即可看到效果，VSCode 不同主题显示的代码高亮颜色不同，如下所示的 dark+ 主题：关键字显示粉色，函数定义、引用符号为黄色，函数形参、变量符号为蓝色，注释为绿色等。</p>
<p><img src="source_zh_cn/IDE/figures/sema.png" alt="sema" /></p>
<h4 id="自动补全介绍及使用"><a class="header" href="#自动补全介绍及使用">自动补全介绍及使用</a></h4>
<p>VSCode 打开 Cangjie 工程中的.cj 文件，输入关键字、变量或 “.” 符号，在光标右侧提示候选内容，如下所示，可以用上下方向键快速选择想要的内容（注：需要切换为系统默认输入法），回车补全。</p>
<p><img src="source_zh_cn/IDE/figures/complete1.png" alt="compelte1" /></p>
<p><img src="source_zh_cn/IDE/figures/complete2.png" alt="complete2" /></p>
<p>对于带参数的函数或者泛型提供模块化补齐，即当函数有参数或者带泛型的时候，选择函数补齐项之后会出现参数格式化补齐，如下图，填充数值之后按 tab 可以切换到下一个参数补齐直至模块化补齐结束，或者按 Esc 可以提前退出除当前选中模块外，其余模块的模块化补齐。</p>
<p><img src="source_zh_cn/IDE/figures/completeFormat.png" alt="completeFormat" /></p>
<h4 id="定义跳转介绍及使用"><a class="header" href="#定义跳转介绍及使用">定义跳转介绍及使用</a></h4>
<p>VSCode 打开 Cangjie 工程中的.cj 文件，鼠标悬停在目标上方 Ctrl + 单击鼠标左键触发定义跳转；或使用鼠标右键单击目标符号，选择 “Go to Definition” 执行定义跳转；或快捷键 F12 执行定义跳转，光标跳到定义处符号左端。</p>
<p><img src="source_zh_cn/IDE/figures/definition.png" alt="definition" /></p>
<blockquote>
<p>注意事项</p>
<ul>
<li>在符号使用的地方使用定义跳转会跳转到符号定义处，支持跨文件跳转</li>
<li>在符号定义处使用定义跳转，如果此符号没被引用过，光标会跳转到符号左端</li>
<li>如果符号在其他地方被引用，会触发查找引用</li>
</ul>
</blockquote>
<h4 id="跨语言跳转介绍和使用"><a class="header" href="#跨语言跳转介绍和使用">跨语言跳转介绍和使用</a></h4>
<p>语言服务插件支持 Cangjie 语言到 C 语言的跳转功能，VSCode 打开 Cangjie 工程中的.cj 文件，鼠标悬停在 Cangjie 互操作函数上方 Ctrl + 单击鼠标左键触发定义跳转；或使用鼠标右键单击目标符号，选择 “Go to Definition” 执行定义跳转；或快捷键 F12 执行定义跳转，光标跳到 C 语言定义处符号左端。</p>
<h5 id="前置条件"><a class="header" href="#前置条件">前置条件</a></h5>
<ul>
<li>本地安装华为自研 C++ 插件；</li>
<li>在 Cangjie 插件上设置需要跳转的 C 语言源码存放目录；</li>
<li>在当前工程下创建 build 文件夹，存放 compile_commands.json 文件 (该文件可通过 cmake 命令生成) 用于创建指定文件夹的索引文件。</li>
</ul>
<h5 id="跳转效果"><a class="header" href="#跳转效果">跳转效果</a></h5>
<p>foreign 函数会在用户设置的目录下查找对应的 C 语言函数，若找到则跳转至 C 源码的函数位置；除上述场景外均保持插件原有的定义跳转。</p>
<p><img src="source_zh_cn/IDE/figures/crossJump.png" alt="crossJump" /></p>
<h4 id="查找引用介绍及使用"><a class="header" href="#查找引用介绍及使用">查找引用介绍及使用</a></h4>
<p>VSCode 打开 Cangjie 工程中的.cj 文件，使用鼠标右键单击目标符号，选择 “Find All References” 执行符号引用预览，单击预览条目，可以跳转到对应引用处。</p>
<p><img src="source_zh_cn/IDE/figures/reference.png" alt="reference" /></p>
<h4 id="诊断报错介绍及使用"><a class="header" href="#诊断报错介绍及使用">诊断报错介绍及使用</a></h4>
<p>VSCode 打开 Cangjie 工程中的.cj 文件，当源码文件出现不符合 Cangjie 语法或语义规则的代码时，会在相关代码段出现红色波浪下划线，如下图所示，当鼠标悬停在上面，可以提示相应的报错信息，修改正确后，诊断报错自行消失。</p>
<p><img src="source_zh_cn/IDE/figures/diag.png" alt="diag" /></p>
<h4 id="选中高亮介绍及使用"><a class="header" href="#选中高亮介绍及使用">选中高亮介绍及使用</a></h4>
<p>VSCode 打开 Cangjie 工程中的.cj 文件，光标定位在一个变量或函数名处，当前文件中该变量的声明处以及其使用处都会高亮显示。</p>
<p><img src="source_zh_cn/IDE/figures/docHighlight.png" alt="docHighlight" /></p>
<h4 id="悬浮提示介绍及使用"><a class="header" href="#悬浮提示介绍及使用">悬浮提示介绍及使用</a></h4>
<p>VSCode 打开 Cangjie 工程中的.cj 文件，光标悬浮在变量处，可以提示出类型信息；悬浮在函数名处，可以提示出函数原型。</p>
<p><img src="source_zh_cn/IDE/figures/hover1.png" alt="hover1" /></p>
<h4 id="定义搜索介绍及使用"><a class="header" href="#定义搜索介绍及使用">定义搜索介绍及使用</a></h4>
<p>VSCode 打开 Cangjie 工程中的任意.cj 文件，按住<code>Ctrl + T</code> 后会出现搜索框，输入想要搜索的符号定义名，会显示出符合条件的搜索结果，单击搜索结果的条目，可以跳转到定义的对应位置处。</p>
<p><img src="source_zh_cn/IDE/figures/searchsymbol_open.png" alt="searchsymbol_open" /></p>
<p>目前支持搜索的定义类型如下表格：</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>class</td><td>interface</td><td>enum</td><td>struct</td></tr>
<tr><td>typealias</td><td>toplevel 的函数</td><td>toplevel 的变量</td><td>prop</td></tr>
<tr><td>enum 构造器</td><td>成员函数</td><td>成员变量</td><td></td></tr>
</tbody></table>
</div>
<h4 id="重命名介绍及使用"><a class="header" href="#重命名介绍及使用">重命名介绍及使用</a></h4>
<p>VSCode 打开 Cangjie 工程中的.cj 文件，光标定位在想要修改的用户自定义编写名称上，右键选择 Rename Symbol 或者快捷键 F2 方式打开重命名编辑框。</p>
<p><img src="source_zh_cn/IDE/figures/prepareRename.png" alt="prepareRename" /></p>
<p>编辑完毕回车完成重命名的实现。</p>
<p><img src="source_zh_cn/IDE/figures/onRename.png" alt="onRename" /></p>
<p>目前重命名支持的用户自定义类型如下：</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>class 类名称</td><td>struct 结构体名称</td><td>interface 接口名称</td><td>enum 枚举名称</td><td>func 函数名称</td></tr>
<tr><td>type 别名名称</td><td>&lt;T&gt;泛型名称</td><td>变量名称</td><td>自定义宏名称</td><td></td></tr>
</tbody></table>
</div>
<h4 id="大纲视图显示介绍及使用"><a class="header" href="#大纲视图显示介绍及使用">大纲视图显示介绍及使用</a></h4>
<p>VSCode 打开 Cangjie 工程中的任意.cj 文件，在 OUTLINE 视图中显示当前文件的符号，目前支持两层结构的显示（第一层主要为 toplevel 中定义的声明，第二层主要为构造器及成员）。</p>
<p><img src="source_zh_cn/IDE/figures/outline.png" alt="outline" /></p>
<p>目前支持大纲视图显示的符号类型如下表格：</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>class</td><td>interface</td><td>enum</td><td>struct</td></tr>
<tr><td>typealias</td><td>toplevel 的函数</td><td>toplevel 的变量</td><td>prop</td></tr>
<tr><td>enum 构造器</td><td>成员函数</td><td>成员变量</td><td></td></tr>
</tbody></table>
</div>
<h4 id="面包屑导航介绍及使用"><a class="header" href="#面包屑导航介绍及使用">面包屑导航介绍及使用</a></h4>
<p>VSCode 打开 Cangjie 工程中的任意.cj 文件，在面包屑导航中显示某个符号当前所处的位置以及该符号在整个工程中的位置路径。</p>
<p><img src="source_zh_cn/IDE/figures/Breadcrumb.png" alt="Breadcrumb" /></p>
<p>目前支持面包屑导航的符号类型如下表格：</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>class</td><td>interface</td><td>enum</td><td>struct</td></tr>
<tr><td>typealias</td><td>toplevel 的函数</td><td>toplevel 的变量</td><td>prop</td></tr>
<tr><td>enum 构造器</td><td>成员函数</td><td>成员变量</td><td></td></tr>
</tbody></table>
</div>
<h4 id="签名帮助介绍及使用"><a class="header" href="#签名帮助介绍及使用">签名帮助介绍及使用</a></h4>
<p>VSCode 在输入左括号和逗号时会触发签名帮助，触发后只要还在函数参数范围内提示框会一直随光标移动（可与补全共存），如下图，会给用户提供当前函数参数信息，以及高亮当前函数位置参数帮助用户补充参数。</p>
<p><img src="source_zh_cn/IDE/figures/signaturehelp.png" alt="signaturehelp" /></p>
<h4 id="显示类型层次结构介绍及使用"><a class="header" href="#显示类型层次结构介绍及使用">显示类型层次结构介绍及使用</a></h4>
<p>VSCode 打开 Cangjie 工程中的 <code>.cj</code> 文件，光标定位在 <code>class/interface/enum/struct</code> 的名字上，右键选择 <code>Show Type Hierarchy</code> ，在左侧就会显示该类型层次结构。</p>
<p><img src="source_zh_cn/IDE/figures/typeHierarchy1.png" alt="typeHierarchy" /></p>
<p>点击下拉框可以继续显示，</p>
<p><img src="source_zh_cn/IDE/figures/typeHierarchy2.png" alt="typeHierarchy" /></p>
<p>在箭头所示位置可以在显示子类和父类之间切换。</p>
<p><img src="source_zh_cn/IDE/figures/typeHierarchy3.png" alt="typeHierarchy" /></p>
<h4 id="调用类型层次结构介绍及使用"><a class="header" href="#调用类型层次结构介绍及使用">调用类型层次结构介绍及使用</a></h4>
<p>VSCode 打开 Cangjie 工程中的 <code>.cj</code> 文件，光标定位在函数的名字上，右键选择 <code>Show Call Hierarchy</code> ，在左侧就会显示该函数的调用类型层次结构。</p>
<p><img src="source_zh_cn/IDE/figures/callHierarchy1.png" alt="callHierarchy" /></p>
<p>点击下拉框可以继续显示</p>
<p><img src="source_zh_cn/IDE/figures/callHierarchy2.png" alt="callHierarchy" /></p>
<p>通过点击标识位置可以在显示调用函数和被调用函数之间切换。</p>
<p><img src="source_zh_cn/IDE/figures/callHierarchy3.png" alt="callHierarchy" /></p>
<h2 id="工程管理"><a class="header" href="#工程管理">工程管理</a></h2>
<p>工程目录：</p>
<p>Project_name：用户输入的名称</p>
<p>│   └── src：代码目录</p>
<p>│      ├── main.cj：源码文件</p>
<p>│   ├── cjpm.toml：默认的 cjpm.toml 配置文件</p>
<h3 id="通过-vscode-命令面板创建仓颉工程"><a class="header" href="#通过-vscode-命令面板创建仓颉工程">通过 VSCode 命令面板创建仓颉工程</a></h3>
<p>在 VSCode 中按 &quot;F1&quot; 或者 &quot;Ctrl + Shift + P&quot;（mac 上快捷键为 &quot;Command + Shift + P&quot;） 打开命令面板，然后按照以下步骤创建仓颉工程：</p>
<p><strong>第一步：选择创建 Cangjie 工程命令</strong></p>
<p><img src="source_zh_cn/IDE/figures/createProject_1.png" alt="createProject_1" /></p>
<p><strong>第二步：选择 Cangjie 后端</strong></p>
<p><img src="source_zh_cn/IDE/figures/createProject_7_community.png" alt="createProject_7" /></p>
<p><strong>第二步：选择 Cangjie 工程模板</strong></p>
<p><img src="source_zh_cn/IDE/figures/createProject_2.png" alt="createProject_2" /></p>
<p><strong>第三步：选择工程路径</strong></p>
<p><img src="source_zh_cn/IDE/figures/createProject_3.png" alt="createProject_3" /></p>
<p><strong>第四步：输入工程名称</strong></p>
<p><img src="source_zh_cn/IDE/figures/createProject_4.png" alt="createProject_4" /></p>
<p><strong>第五步：创建完成并打开</strong></p>
<p><img src="source_zh_cn/IDE/figures/createProject_5.png" alt="createProject_5" /></p>
<h3 id="通过可视化界面创建仓颉工程"><a class="header" href="#通过可视化界面创建仓颉工程">通过可视化界面创建仓颉工程</a></h3>
<p><strong>第一步：打开命令面板选择可视化创建 Cangjie 工程命令</strong></p>
<p><img src="source_zh_cn/IDE/figures/createProjectView_1.png" alt="createProjectView_1" /></p>
<p><strong>第二步：打开可视化创建 Cangjie 工程界面</strong></p>
<p><img src="source_zh_cn/IDE/figures/createProjectView_2.png" alt="createProjectView_2" /></p>
<p><strong>第三步：选择工程类型</strong></p>
<p><img src="source_zh_cn/IDE/figures/createProjectView_4.png" alt="createProjectView_4" /></p>
<p><strong>第四步：点击选择工程路径</strong></p>
<p><img src="source_zh_cn/IDE/figures/createProject_3.png" alt="createProject_3" /></p>
<p><strong>第五步：输入工程名称</strong></p>
<p><img src="source_zh_cn/IDE/figures/createProjectView_3.png" alt="createProjectView_3" /></p>
<p><strong>第六步：点击 Confirm 创建工程</strong></p>
<p><img src="source_zh_cn/IDE/figures/createProject_5.png" alt="createProject_5" /></p>
<h2 id="编译构建"><a class="header" href="#编译构建">编译构建</a></h2>
<p><strong>注</strong>：VSCode 中可视化方式提供的仓颉功能编译构建能力依赖 cjpm 工具，该工具要求打开的仓颉工程的模块内必须包含规范的 cjpm.toml 文件。若没有该文件仍想执行工程的编译构建，可在终端使用 cjc 命令。</p>
<p>在 VSCode 中提供<strong>四种</strong>方式来实现 Cangjie 工程的编译构建方式。</p>
<h3 id="编译构建方式"><a class="header" href="#编译构建方式">编译构建方式</a></h3>
<h4 id="在命令面板执行命令"><a class="header" href="#在命令面板执行命令">在命令面板执行命令</a></h4>
<p>打开命令面板，通过分类词<code>Cangjie</code>来快速找到如下编译相关命令：</p>
<ul>
<li>
<p><code>Parallelled Build</code> 并行编译</p>
<p><img src="source_zh_cn/IDE/figures/paralleledBuild.png" alt="paralleledBuild" /></p>
<p>执行并行编译后，在工程文件夹下会生成<code>target</code>目录，<code>target</code>目录下有一个 <code>release</code> 文件夹，<code>release</code> 文件夹下包含三个目录：<code>.build-logs</code> 目录、<code>bin</code>目录、工程名同名的目录。<code>bin</code>目录下存放可执行文件（可执行文件只有在<code>cjpm.toml</code>的<code>output-type</code>为<code>executable</code>时才会生成），工程名同名目录下存放编译的中间产物。</p>
<p>在 output Panel 上会打印编译成功与否</p>
</li>
<li>
<p><code>Build With Verbose</code> 编译并展示编译日志</p>
<p><img src="source_zh_cn/IDE/figures/verbose.png" alt="verbose" /></p>
<p>该编译参数除了执行编译外，还会打印编译日志</p>
</li>
<li>
<p><code>Build With Debug</code>   可生成 debug 版本的目标文件</p>
<p>该命令的编译结果中带有 debug 信息，供调试使用</p>
</li>
<li>
<p><code>Build With Coverage</code> 可生成覆盖率信息</p>
<p>该命令在编译结果中带有覆盖率的信息</p>
</li>
<li>
<p><code>Build With Alias</code>   编译并指定输出可执行文件的名称</p>
<p><img src="source_zh_cn/IDE/figures/alias.png" alt="alias" /></p>
<p>执行该命令，按下回车后，会弹出一个输入栏，需要用户为工程的编译结果赋予一个新的名字。该命令只对<code>cjpm.toml</code>的<code>output-type</code>为<code>executable</code>时有效。如输入的是<code>hello</code>，则编译后的二进制文件如下：</p>
<p><img src="source_zh_cn/IDE/figures/aliasHello.png" alt="aliasHello" /></p>
</li>
<li>
<p><code>Build With Increment</code>  增量编译</p>
<p>用来指定增量编译</p>
</li>
<li>
<p><code>Build With CustomizedOption</code> 按条件透传 <code>cjpm.toml</code> 中的命令。</p>
<p><img src="source_zh_cn/IDE/figures/cndOption.png" alt="cndOption.png" /></p>
<p>使用该选项需要先在 cjpm.toml 中配置<code>customized-option</code>字段。然后在命令面板输入<code>Build With CustomizedOption</code>,回车后可以选择需要的参数，参数可多选，选择后回车即可。</p>
<p><img src="source_zh_cn/IDE/figures/chooseOption.png" alt="chooseOption.png" /></p>
<p>若没有在 cjpm.toml 中配置 <code>customized-option</code> 字段，并执行了该条命令，插件会提示用户先配置改字段</p>
<p><img src="source_zh_cn/IDE/figures/noOption.png" alt="noOption.png" /></p>
</li>
<li>
<p><code>Build With TargetDir</code> 编译并在指定路径生成编译产物</p>
<p>选择该命令执行后，可指定编译产物的输出路径，默认不作输入操作则以 cjpm.toml 中的<code>target-dir</code>字段为路径。</p>
<p><img src="source_zh_cn/IDE/figures/setOutputDir.png" alt="setOutputDir" /></p>
<p>当输入的编译产物路径与 cjpm.toml 中的<code>target-dir</code>字段不同时，会弹出提示是否覆盖 cjpm.toml 中的<code>target-dir</code>字段，若选择 Yes 覆盖，则会将 cjpm.toml 中<code>target-dir</code>字段覆盖成输入的值。</p>
<p><img src="source_zh_cn/IDE/figures/isChangeOutput.png" alt="isChangeOutput" /></p>
<p>该执行命令执行成功后，会在指定的路径下生成编译产物。</p>
</li>
<li>
<p><code>Build With Jobs</code> 执行编译之前自定义最大并发度</p>
<p>支持通过执行该命令在编译之前自定义最大并发度，输入参数为任意数字，设置范围为 (0, cpu 核数 * 2]。</p>
<p>当在输入框输入非数字时，会终止操作，并提示用户输入数字内容：Invaild input! The input should be number.</p>
<p>当在输入框输入的范围超出所支持的范围 (0, cpu 核数 * 2] 时，会默认采用 cpu 核数，并提示超出可选范围的 warning 信息。</p>
</li>
<li>
<p><code>Build With CodeCheck</code> 执行编译的时候进行 CodeCheck 静态代码检查</p>
<p>执行该命令编译工程时，会对当前工程进行 CodeCheck 静态代码检查，如果检查到【要求】级别的代码规范违规，则编译失败，检查到【建议】级别的违规仅告警，正常完成编译。</p>
</li>
<li>
<p><code>Build With MultiParameter</code> 多参数编译</p>
<p>仓颉工程的编译可以叠加多个参数，在命令面板搜索到<code>Build With MultiParameter</code>命令后，选择需要叠加的参数，其中--target 参数会根据 cjpm.toml 中的<code>cross-compile-configuration</code>字段的设置来决定是否显示，如果用户没有配置<code>cross-compile-configuration</code>的内容，则<code>--target</code>参数选项会隐藏；<code>--&lt;customized-option&gt;</code>参数会根据 cjpm.toml 中的<code>customized-option</code>字段的设置来决定是否显示，如果用户没有配置<code>customized-option</code>的内容，则--<customized-option> 参数选项会隐藏。</p>
<p><img src="source_zh_cn/IDE/figures/multiBuild.png" alt="multi" /></p>
<p>将用户想叠加的参数勾选，然后按回车键或者点击 ok 按钮。用户也可点击界面中的向左箭头，重新选择编译参数</p>
<p>如果叠加的参数中选择了<code>cjpm build -o</code>，那么需要用户输入一个别名字符串然后按回车键执行叠加命令操作</p>
<p><img src="source_zh_cn/IDE/figures/aliasString.png" alt="aliasString" /></p>
<p>如果叠加参数中选择了<code>cjpm build --target=&lt;name&gt;</code>,那么用户可以选择一个想要交叉编译的平台</p>
<p><img src="source_zh_cn/IDE/figures/buildTarget.png" alt="buildTarget" /></p>
<p>如果叠加参数中选择了<code>cjpm build --&lt;customized-option&gt;</code>,那么用户可以选择透传参数</p>
<p><img src="source_zh_cn/IDE/figures/addOption.png" alt="addOption.png" /></p>
<p>叠加命令的编译结果就是这些命令分别执行的总和。</p>
</li>
<li>
<p><code>Update Cjpm.toml</code> 更新 cjpm.lock 文件</p>
<p>在修改完 cjpm.toml 文件后需要执行该命令，更新 cjpm.lock 文件。如果是通过 UI 界面修改的 cjpm.toml 文件的话，用户不需要手动执行该操作</p>
</li>
<li>
<p><code>Execute Test File</code>  用于编译单元测试产物并执行对应的单元测试用例，并直接打印测试结果</p>
</li>
<li>
<p><code>Test With NoRun</code>  用于编译对应测试产物</p>
</li>
<li>
<p><code>Test With SkipBuild</code>  测试产物存在的前提下，用于执行对应测试产物</p>
</li>
<li>
<p><code>Test With Jobs</code> 执行单元测试之前自定义最大并发度，操作与 <code>Build With Jobs</code> 相同</p>
</li>
<li>
<p><code>Test With MultiParameter</code> 多参数执行仓颉工程的单元测试</p>
<p>在选择该条命令后，首先输入指定待测试的包路径，若不需要指定，则直接按 Enter 键</p>
<p><img src="source_zh_cn/IDE/figures/testPath.png" alt="testPath" /></p>
<p>此步骤可通过输入多个包的路径并用空格分隔，可以实现多包并发单元测试</p>
<p><img src="source_zh_cn/IDE/figures/testPathMultiPath.png" alt="testPathMultiPath" /></p>
<p>然后选择要叠加的参数</p>
<p><img src="source_zh_cn/IDE/figures/testParams.png" alt="testParams" /></p>
<p>如果选择了<code>--filter=&lt;value&gt;</code>参数，则还需要输入对应的过滤测试子集的表达式</p>
<p><img src="source_zh_cn/IDE/figures/testReg.png" alt="testReg" /></p>
<p>输入过滤测试子集的表达式后便能执行 cjpm test 的完整命令。执行结果会在 output 面板输出</p>
<p>若是在 cjpm.toml 中配置了<code>cross-compile-configuration</code>和<code>customized-option</code>则可选择的参数会有<code>--target=&lt;name&gt;</code>和<code>--&lt;customized-option&gt;</code></p>
<p><img src="source_zh_cn/IDE/figures/testParamsPlus.png" alt="testParamsPlus" /></p>
<p>如果选择了<code>--target=&lt;name&gt;</code>参数，则还需要选择对应的平台</p>
<p><img src="source_zh_cn/IDE/figures/crossCompileTarget.png" alt="crossCompileTarget" /></p>
<p><code>--target</code>暂时只支持在 SUSE 平台下选择<code>aarch64-hm-gnu</code>使用</p>
<p>如果选择了<code>--&lt;customized-option&gt;</code>参数，则还需要选择条件选项</p>
<p><img src="source_zh_cn/IDE/figures/condition.png" alt="condition" /></p>
</li>
<li>
<p><code>Clean Build Result</code> 清除编译结果（工程目录下的 build 目录）</p>
</li>
<li>
<p><code>Check Circular Dependencies</code> 检测文件依赖</p>
</li>
<li>
<p><code>Edit Configuration (UI)</code> 打开 UI 配置界面</p>
</li>
</ul>
<h4 id="在终端进行执行编译构建命令"><a class="header" href="#在终端进行执行编译构建命令">在终端进行执行编译构建命令</a></h4>
<p>提供用户在 VSCode 的终端面板直接使用编译构建命令（cjpm）对仓颉工程进行编译构建。但需要用户做如下操作：</p>
<p>关闭新建的工程，重新打开 VSCode（reload 不行）</p>
<p>然后可以在终端执行 cjpm 的操作了</p>
<p><img src="source_zh_cn/IDE/figures/cpm.png" alt="cjpm" /></p>
<h4 id="点击运行按钮运行工程"><a class="header" href="#点击运行按钮运行工程">点击运行按钮运行工程</a></h4>
<p>用户可以点击 cj 文件编辑区的运行按钮来运行整个仓颉工程</p>
<p><img src="source_zh_cn/IDE/figures/runCode.png" alt="runCode" /></p>
<p>若整个工程中配置的<code>output-type</code>为<code>executable</code>时会在终端面板打印运行结果，否则只会显示编译的结果。</p>
<p>点击运行按钮执行的编译过程是结合当前的 cjpm.toml 和 cjpm_build_args.json 的配置来进行的</p>
<h4 id="点击锤子按钮编译工程"><a class="header" href="#点击锤子按钮编译工程">点击锤子按钮编译工程</a></h4>
<p>用户可以点击 cj 文件编辑区的锤子按钮编译整个仓颉工程</p>
<p><img src="source_zh_cn/IDE/figures/hammerButton.png" alt="hammerButton" /></p>
<p>点击锤子按钮执行的编译过程与运行按钮一致，也是结合当前的 cjpm.toml 和 cjpm_build_args.json 的配置来进行的；不同的是若整个工程中配置的<code>output-type</code>为<code>executable</code>，运行按钮在编译完成后再运行整个工程，而锤子按钮只会编译工程，无后续运行动作。</p>
<h3 id="可视化配置编译构建参数"><a class="header" href="#可视化配置编译构建参数">可视化配置编译构建参数</a></h3>
<p>在编译构建的过程中需要配置工程目录中的 toml 和 json 文件，cjpm.toml 和 cjpm_build_args.json 对这两个文件，可以直接修改 toml 和 json 文件本身，也可以点击编辑按钮或者在命令面板执行<code>Edit Configuration (UI)</code>命令打开可视化编辑的 UI 界面。</p>
<p><img src="source_zh_cn/IDE/figures/editone.png" alt="editone" /></p>
<p><img src="source_zh_cn/IDE/figures/editTwo.png" alt="editTwo" /></p>
<p>编译构建参数的 UI 界面如下：</p>
<p><img src="source_zh_cn/IDE/figures/ui.png" alt="ui" /></p>
<p>左边有两个的蓝色的链接，点击后可跳转到对应的 toml 或者 json 文件。</p>
<p>右边的上半部分是对工程文件中<code>.vscode</code>目录下的 cjpm_build_args.json 的配置，通过复选框或者输入框的形式确定编译要使用的参数，修改后会同步到 cjpm_build_args.json 文件中。</p>
<p>右边的下半部分是对工程中的 cjpm.toml 文件的配置，对于输入框形式的配置，用户输入内容且光标不在输入框后便生效到 cjpm.toml 文件中。</p>
<blockquote>
<p>注意：</p>
<p>当仓颉工程中的 cjpm.toml 文件和参数配置界面同时在 VSCode 的编辑区显示时（如下图），对 toml 文件的修改不会同步到 UI 界面上。</p>
</blockquote>
<p><img src="source_zh_cn/IDE/figures/showTogether.png" alt="showTogether" /></p>
<p>对于构建参数<code>cross-compile-configuration</code>,可以通过点击<code>Add Configuration</code> 按钮添加选项</p>
<p><img src="source_zh_cn/IDE/figures/addConfiguration.png" alt="addConfiguration" /></p>
<p>然后在 key 和 compile-option 处填写对应的内容，点击红色圆圈圈出来的对钩按钮（也称为提交按钮）与 cjpm.toml 保持同步，点击提交按钮后，该按钮会隐藏，若用户再次修改某个字段的内容，直接点击该字段进行修改，修改完后按回车键便可以与 cjpm.toml 保持同步；若想删除该条配置，用户只需点击该条选项的叉号按钮。</p>
<p>添加的配置在不填写第一个字段<strong>key</strong>就直接回车或者按提交按钮，会提醒用户必须要填写第一个字段，该场景下提交的内容不会同步到 cjpm.toml 中。在 UI 界面目前不会直接删除该条配置，用户刷新 UI 界面后会自动删除，内容与 cjpm.toml 保持一致。<code>package-configuration</code>和<code>cross-compile-configuration</code>类似，如下显示为<code>package-configuration</code>新增配置时第一个字段为空的场景。</p>
<p><img src="source_zh_cn/IDE/figures/noKey.png" alt="noKey.png" /></p>
<p>对于<code>package-configuration</code>参数，其添加和修改方式与<code>cross-compile-configuration</code>大致一致，其中<code>output-type</code>字段为下拉框选项，其可选的类型有 executable、static、dynamic、null。新添加的配置，该字段被初始化为 null，用户可以根据自己的需要选择。当选择为 null 时，该字段同步到 cjpm.toml 后会删除该字段。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>在 UI 界面配置 cjpm.toml 的内容时，只有对于<code>customized-option</code>参数中配置的--cfg 中路径中的<code>=</code>需要转义，其他不需要添加转义符号，但直接在 cjpm.toml 中填写时，需要加转义符号。如在给 package-configuration 字段的 p1 配置 compile-option 时，在 UI 界面对--link-options 设置内容时只需要加引号即可，即<code>--link-options=&quot;-rpath=xxx&quot;</code>，而在 toml 文件中，需要填写<code>--link-options=\&quot;-rpath=xxx\&quot;</code>。在 UI 界面对<code>customized-option</code>参数配置的--cfg 路径中包含<code>=</code>时，<code>=</code>需要转义，即<code>--cfg=&quot;D:/projects/cang\=jie&quot;</code>，而在 toml 文件中，需要填写<code>--cfg=\&quot;D:/projects/cang\\=jie\&quot;</code>。</p>
</blockquote>
<p>对于<code>customized-option</code>参数，其添加修改方式与<code>cross-compile-configuration</code>一致。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>customized-option 的条件不能设置内置的条件（@When[os == &quot;Linux&quot;] 不能作为 customized-option 的条件，即&quot;cfg1&quot; : &quot;--cfg =&quot;os=Linux&quot;&quot;是不允许的），只能添加用户自定义条件。具体可以参考 Cangjie &gt; Language Guide 文档的 <a href="source_zh_cn/IDE/../../../user_manual/source_zh_cn/Chapter_20_conditional-compilation.html"><code>条件编译</code></a> 章节。</p>
</blockquote>
<h3 id="三方库便捷导入"><a class="header" href="#三方库便捷导入">三方库便捷导入</a></h3>
<h4 id="三方库导入方式"><a class="header" href="#三方库导入方式">三方库导入方式</a></h4>
<p><strong>注</strong> ：三方库便捷导入的方式只适用于当前打开的仓颉工程的主 module，其他子 module 想要使用这种方式导入外部库的话，可以单独以工程的方式打开使用</p>
<p>在仓颉工程中，可以导入外部的三方库，且可以在 cjpm.toml 中进行配置，他们分别是</p>
<p><code>dependencies</code>： 当前仓颉模块依赖项目，里面配置了当前构建所需要的其它模块的信息，包含版本号、路径。这两个选项必须全部配置且不为空，否则会执行失败并报错。在使用过程中，优先使用此方式进行项目依赖导入。</p>
<p><code>dev-dependencies</code>: 使用方式与 <code>dependencies</code> 保持一致，具有与 <code>dependencies</code> 字段相同的格式。它用于指定仅在开发过程中使用的依赖项，而不是构建主项目所需的依赖项，例如仅在测试中使用的依赖项。如果开发者是库作者，则应将此字段用于此库的下游用户不需要使用的依赖项。</p>
<p><code>bin-dependencies</code> ：非特殊需求场景下，建议使用 <code>dependencies</code>的方式导入依赖。目前插件仅支持本地的 <code>bin-dependencies</code> 配置。</p>
<p>当前仓颉模块依赖的已编译好的 <code>package</code>。其有两种导入形式。以导入下述的 <code>pro0</code> 模块和 <code>pro1</code> 模块的三个包来举例说明。</p>
<pre><code class="language-text">├── test
│   └── pro0
│       ├── libpro0_xoo.so
│       └── xoo.cjo
│       ├── libpro0_yoo.so
│       └── yoo.cjo
│   └── pro1
│       ├── libpro1_zoo.so
│       └── zoo.cjo
└── src
    └── main.cj
├── cjpm.toml
</code></pre>
<p>方式一，通过 <code>package-option</code> 导入：</p>
<pre><code class="language-text">[target]
    [target.x86_64-w64-mingw32]
        [target.x86_64-w64-mingw32.bin-dependencies]
            [target.x86_64-w64-mingw32.bin-dependencies.package-option]
                pro0_xoo = &quot;./test/pro0/xoo.cjo&quot;
                pro0_yoo = &quot;./test/pro0/yoo.cjo&quot;
                pro1_zoo = &quot;./test/pro1/zoo.cjo&quot;
</code></pre>
<p>这个选项是个 <code>map</code> 结构，<code>pro0_xoo</code> 名称作为 <code>key</code>，与 <code>libpro0_xoo.so</code> 相对应，前端文件 <code>cjo</code> 的路径作为 <code>value</code>，对应于该 <code>cjo</code> 的 <code>.a</code> 或 <code>.so</code> 需放置在相同路径下，且对应的 cjo 模块文件必须与模块名来源文件放置在相同的文件夹下，该文件夹下不能有任何其他的文件或者文件夹。</p>
<p>方式二，通过 <code>path-option</code> 导入：</p>
<pre><code class="language-text">[target]
    [target.x86_64-w64-mingw32]
        [target.x86_64-w64-mingw32.bin-dependencies]
            path-option = [&quot;./test/pro0&quot;, &quot;./test/pro1&quot;]
</code></pre>
<p>这个选项是个字符串数组结构，每个元素代表待导入的路径名称。<code>cjpm</code> 会自动导入该路径下所有符合规则的仓颉库包，这里的合规性是指库名称的格式为 <code>模块名_包名</code>。库名称不满足该规则的包只能通过 <code>package-option</code> 选项进行导入。</p>
<p>注意，如果同时通过 <code>package-option</code> 和 <code>path-option</code> 导入了相同的包，则 <code>package-option</code> 字段的优先级更高。</p>
<p>对应 IDE 上，其在导航栏视图中的呈现形式如下：</p>
<p><img src="source_zh_cn/IDE/figures/packageRequires.png" alt="packageRequires" /></p>
<p>用户可以在其对应的导入方式子目录下导入或者工程需要的模块</p>
<p>其在 UI 界面的显示如下：</p>
<p><img src="source_zh_cn/IDE/figures/packageRequireUI.png" alt="packageRequireUI" /></p>
<p><code>ffi</code>：当前仓颉模块外部依赖 <code>c</code> 库。里面配置了依赖该库所需要的信息，包含名称、路径字段</p>
<p>为方便用户添加这几类外部库 ，在 IDE 的资源管理器的视图栏添加了<code>CANGJIE LIBRARY</code>栏</p>
<p>​    在工程初始化后，用户便可以通过点击分类栏的加号按钮<strong>添加</strong>对应的三方库。</p>
<p><img src="source_zh_cn/IDE/figures/extraLibAdd.png" alt="extraLibAdd.png" /></p>
<p><img src="source_zh_cn/IDE/figures/addrequire.png" alt="addrequire" /></p>
<p>也可以通过点击三方库上的减号删除对应的库</p>
<p><img src="source_zh_cn/IDE/figures/deleLib.png" alt="deleLib" /></p>
<p>用户还可以点击视图栏的编辑按钮，打开三方库导入的可视化界面来导入或者删除三方库</p>
<p><img src="source_zh_cn/IDE/figures/configLib.png" alt="configLib" /></p>
<p><img src="source_zh_cn/IDE/figures/uiLib.png" alt="uiLib" /></p>
<p>以上的删除和添加操作都会同步到工程的 module.json 中。</p>
<h4 id="三方库导入限制"><a class="header" href="#三方库导入限制">三方库导入限制</a></h4>
<ul>
<li>项目中需要链接动态库（ c 库、仓颉库）时 ，运行时会加载不到，需自行设置 LD_LIBRARY_PATH ，执行下 export LD_LIBRARY_PATH=xxx:$LD_LIBRARY_PATH；主要的影响就是可以编译构建时会构建失败，需要用户自己设置 LD_LIBRARY_PATH。</li>
<li>cjpm.toml 中修改的内容不会直接修改 treeView 和 UI 界面，需要用户更新一下，即重新点击 treeView 或者 UI 界面。</li>
<li>treeView 中在库分类处添加外部库，且此时库分类目录是关闭状态，则添加后需要自己打开目录查看。</li>
<li>UI 界面的字段暂不支持 hover 显示内容的功能。</li>
<li>在 UI 界面非用户添加的外部库，其路径与 cjpm.toml 保持一致。用户添加的库显示绝对路径。treeView 的路径均显示绝对路径。</li>
</ul>
<h2 id="调试服务"><a class="header" href="#调试服务">调试服务</a></h2>
<h3 id="功能简介-2"><a class="header" href="#功能简介-2">功能简介</a></h3>
<p>仓颉编程语言提供了可视化调试服务，方便用户调试仓颉程序。该插件提供了如下功能：</p>
<ul>
<li>Launch: 启动调试进程</li>
<li>Attach: 附加到已启动的进程</li>
<li>支持源码断点、函数断点、数据断点、汇编断点</li>
<li>支持源码内单步调试、运行到光标处、步入、步出、继续、暂停、重启、停止调试</li>
<li>支持汇编内单步、步入、步出</li>
<li>支持表达式求值</li>
<li>支持变量查看和修改</li>
<li>支持在调试控制台中查看变量</li>
<li>支持查看被调试程序的输出信息</li>
<li>支持反向调试</li>
<li>支持 unittest 的运行和调试</li>
</ul>
<h3 id="使用说明-1"><a class="header" href="#使用说明-1">使用说明</a></h3>
<blockquote>
<p>说明：</p>
<ul>
<li>如果您是第一次使用 VSCode 调试功能，可以查看 VSCode 调试服务使用手册  https://code.visualstudio.com/docs/editor/debugging 。</li>
<li>调试服务当前支持 Windows 和 Linux 版本的 VSCode 中安装使用。</li>
<li>受调试器限制，循环代码中存在条件断点时，执行 PAUSE 操作可能导致后续调试无法进行。</li>
<li>VARIABLES 视图修改变量时，不会触发存在依赖关系的变量的刷新。</li>
<li>调试服务依赖仓颉 SDK 包内 liblldb 动态库文件，请提前配置仓颉 SDK 路径。SDK 配置方式请参考本手册 ”安装说明“ 目录下 ”插件安装与环境配置“。</li>
</ul>
</blockquote>
<h4 id="启动调试"><a class="header" href="#启动调试">启动调试</a></h4>
<h5 id="launch"><a class="header" href="#launch">Launch</a></h5>
<blockquote>
<p>说明：</p>
<p>创建仓颉工程请参考本手册 ”工程管理“ 模块介绍。</p>
</blockquote>
<ul>
<li>
<p>launch 模式仓颉工程调试</p>
<ol>
<li>未创建 launch.json 文件时，点击 &quot;Run and Debug&quot; &gt; &quot;Cangjie(cjdb) Debug&quot; 启动调试。</li>
<li>已创建 launch.json 文件时，在 launch.json 文件中点击 &quot;Add Configuration...&quot; &gt; &quot;Cangjie Debug (CJNative) : launch&quot; &gt; &quot;Build And Debug Cangjie Project&quot; 添加调试配置，选择添加的配置启动调试。</li>
</ol>
</li>
<li>
<p>launch 模式单文件调试</p>
<p>针对单文件调试，可以选中需要调试的仓颉源文件，右键选择 “Cangjie: Build and Debug File” ，该操作会生成编译配置文件 task.json 和编译脚本，并且会根据  task.json 配置执行脚本，编译出可调试的二进制文件，然后启动调试。</p>
<p><img src="source_zh_cn/IDE/figures/start_community.PNG" alt="start" /></p>
</li>
<li>
<p>launch 模式调试手动编译的可执行文件</p>
<ol>
<li>使用 cjc 编译器或 cjpm 手动编译出可调试的二进制文件。</li>
<li>点击 &quot;Run and Debug&quot; &gt; &quot;Cangjie(cjdb) Debug&quot; &gt; &quot;Cangjie (CJNative): launch&quot; &gt; &quot;Choose Executable File Later&quot; 启动调试。</li>
</ol>
</li>
<li>
<p>launch debugMacro 模式仓颉工程调试宏展开后的代码</p>
<p>调试宏展开后的代码文件（<code>.marcocall</code>为后缀的文件），此时宏对应的原文件无法调试。</p>
</li>
<li>
<p>launch 模式调试远程进程（支持 Linux 远程到 Linux）</p>
<p>launch 模式下调试远程进程时，调试服务会将本地编译的二进制文件推送到远程平台，然后调试远程平台的二进制文件。</p>
<ol>
<li>在远程平台启动 lldb-server（lldb-server 建议使用 cjdb 自带 lldb-server，路径/cangjie/third_party/llvm/lldb/bin/lldb-server）,启动命令 <code>/**/**/cangjie/third_party/llvm/lldb/bin/lldb-server p --listen &quot;*:1234&quot; --server</code></li>
<li>在本地机器使用 cjc 编译器或 cjpm 手动编译出可调试的二进制文件。</li>
<li>单击 &quot;Run and Debug&quot; 按钮启动调试。</li>
</ol>
<p>launch.json 配置示例</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;Cangjie Debug (cjdb): test&quot;,
  &quot;program&quot;: &quot;/**/**/test&quot;,
  &quot;request&quot;: &quot;launch&quot;,
  &quot;type&quot;: &quot;cangjieDebug&quot;,
  &quot;externalConsole&quot;: false,
  &quot;remote&quot;: true,
  &quot;remoteCangjieSdkPath&quot;: &quot;/**/**/cangjie&quot;,
  &quot;remoteFilePath&quot;: &quot;/**/**/test&quot;,
  &quot;remoteAddress&quot;: &quot;1.1.1.1:1234&quot;,
  &quot;remotePlatform&quot;: &quot;remote-linux&quot;
}
</code></pre>
</li>
<li>
<p>配置属性：</p>
<div class="table-wrapper"><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody>
<tr><td>program</td><td>string</td><td>被调试进程的全路径，该文件将推送到远程平台，例如：/home/cangjieProject/build/bin/main</td></tr>
<tr><td>remote</td><td>boolean</td><td>启动远程 launch 进程，remote 为 true</td></tr>
<tr><td>remoteCangjieSdkPath</td><td>string</td><td>远程平台仓颉 SDK 路径</td></tr>
<tr><td>remoteFilePath</td><td>string</td><td>远程平台存放推送文件的全路径，请确保路径 /home/test/ 合法且存在，<code>main</code> 为推送到远程的文件名，例如：/home/cangjieProject/build/bin/main</td></tr>
<tr><td>remoteAddress</td><td>string</td><td>被调试进程所在的机器 IP 和 lldb-server 监听的端口号，数据格式：ip:port</td></tr>
<tr><td>remotePlatform</td><td>string</td><td>远程的平台，仅支持 remote-linux（远程 linux 平台）</td></tr>
<tr><td>env</td><td>object</td><td>为被调试程序设置运行时的环境变量，该配置将覆盖系统环境变量，如需在系统配置基础上追加配置，在配置项结尾增加 ${env:PATH}。例如：&quot;PATH&quot;:&quot;/home/user/bin: ${env:PATH}&quot;, &quot;LD_LIBRARY_PATH&quot;:&quot;/home/user/bin:${env:LD_LIBRARY_PATH}&quot;。</td></tr>
</tbody></table>
</div></li>
</ul>
<h5 id="attach"><a class="header" href="#attach">Attach</a></h5>
<ul>
<li>
<p>attach 模式调试本地进程</p>
<ol>
<li>在 launch.json 文件中点击 &quot;Add Configuration...&quot; &gt; &quot;Cangjie Debug (CJNative) : attach&quot; 添加调试配置，选择添加的配置启动调试</li>
<li>在弹出界面选择要调试的进程即可启动调试
<img src="source_zh_cn/IDE/figures/attachSelectProcess.png" alt="attachSelectProcess" /></li>
</ol>
</li>
<li>
<p>attach 模式调试远程进程</p>
<ol>
<li>在本地机器编译出可调试二进制文件并将该文件拷贝到远程机器。</li>
<li>在远程机器启动 lldb-server（lldb-server 建议使用 cjdb 自带 lldb-server，路径/cangjie/third_party/llvm/lldb/bin/lldb-server）,启动命令 <code>/**/**/cangjie/third_party/llvm/lldb/bin/lldb-server p --listen &quot;*:1234&quot; --server</code></li>
<li>在远程机器启动被调试的二进制文件</li>
<li>在本地机器配置 launch.json 文件，并启动调试</li>
</ol>
<p>launch.json 配置属性：</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;Cangjie Debug (cjdb): test&quot;,
  &quot;processId&quot;: &quot;8888&quot;,
  &quot;program&quot;: &quot;/**/**/test&quot;,
  &quot;request&quot;: &quot;attach&quot;,
  &quot;type&quot;: &quot;cangjieDebug&quot;,
  &quot;remote&quot;: true,
  &quot;remoteAddress&quot;: &quot;1.1.1.1:1234&quot;,
  &quot;remotePlatform&quot;: &quot;remote-linux&quot;
}
</code></pre>
</li>
<li>
<p>配置属性：</p>
<div class="table-wrapper"><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody>
<tr><td>processId</td><td>string</td><td>被调试进程的 pid（配置 pid 时优先 attach pid，未配置 pid 则 attach program）</td></tr>
<tr><td>program</td><td>string</td><td>被调试进程的全路径，例如：/home/cangjieProject/build/bin/main</td></tr>
<tr><td>remote</td><td>boolean</td><td>attach 本机器进程，remote 为 false；若 attach 远程进程，将 remote 设置为 true</td></tr>
<tr><td>remoteAddress</td><td>string</td><td>远程调试时被调试进程所在的机器 IP 和 lldb-server 监听的端口号，数据格式：ip:port</td></tr>
<tr><td>remotePlatform</td><td>string</td><td>远程调试时远程的平台，仅支持 remote-linux（远程 linux 平台）</td></tr>
</tbody></table>
</div></li>
</ul>
<h4 id="调试信息查看"><a class="header" href="#调试信息查看">调试信息查看</a></h4>
<p>当进程处于 stopped 状态时，可以在 VSCode 界面左侧查看断点、当前线程、堆栈信息和变量，并支持编辑断点和修改变量，您也可以在 Editor 窗口 将鼠标悬浮于变量名称上查看变量值。支持在<code>TERMINAL</code>窗口查看被调试程序的输出信息。
<img src="source_zh_cn/IDE/figures/debugInfo.png" alt="debugInfo" /></p>
<h4 id="表达式求值"><a class="header" href="#表达式求值">表达式求值</a></h4>
<blockquote>
<p>说明：</p>
<p>表达式暂不支持元组类型和基础 Collection 类型。</p>
</blockquote>
<ul>
<li>您可以在 WATCH 窗口添加按钮或空白处双击键入表达式。</li>
<li>您可以在 Debug Console 窗口键入表达式。</li>
<li>您可以在 Editor 窗口 双击选中变量，右键选择 Evaluate in Debug Console。</li>
</ul>
<h4 id="程序控制"><a class="header" href="#程序控制">程序控制</a></h4>
<ul>
<li>您可以单击顶部调试工具栏上的图标控制程序，包括单步执行、步入、步出、继续、暂停、重启或停止程序。
<img src="source_zh_cn/IDE/figures/debugControl1.png" alt="debugControl1.png" />
<img src="source_zh_cn/IDE/figures/debugControl2.png" alt="debugControl2.png" /></li>
<li>您可以在鼠标光标处点击右键选择 <code>运行到光标处</code>。
<img src="source_zh_cn/IDE/figures/runToCursor.png" alt="runToCursor" /></li>
<li>您可以在源码视图右键选择<code>Open Disassembly View</code>进入汇编视图。
<img src="source_zh_cn/IDE/figures/openDisassemblyView.png" alt="openDisassemblyView" /></li>
</ul>
<h4 id="调试控制台"><a class="header" href="#调试控制台">调试控制台</a></h4>
<blockquote>
<p>说明：</p>
<p>cjdb 介绍请查看本手册内 ”仓颉语言命令行工具使用指南“ 目录下 ”仓颉语言调试工具使用指南“</p>
</blockquote>
<h5 id="执行-cjdb-命令"><a class="header" href="#执行-cjdb-命令">执行 cjdb 命令</a></h5>
<p>您可以在 “调试控制台” 中输入 cjdb 命令来调试程序，命令必须遵循以下格式：</p>
<p>命令必须以 <code>-exec</code> 开头，要执行的子命令必须是正确的 cjdb 命令。</p>
<p>使用 cjdb 命令 <code>n</code>  执行单步调试的示例如下：</p>
<pre><code class="language-shell">-exec n
</code></pre>
<p><img src="source_zh_cn/IDE/figures/debugconsoleCjdbcommand.png" alt="debugconsoleCjdbcommand" /></p>
<h5 id="查看变量"><a class="header" href="#查看变量">查看变量</a></h5>
<p>您可以在 “调试控制台” 中输入变量名称查看变量值：</p>
<p><img src="source_zh_cn/IDE/figures/debugconsoleVariable.png" alt="debugconsoleVariable" /></p>
<h4 id="反向调试"><a class="header" href="#反向调试">反向调试</a></h4>
<blockquote>
<p>说明：</p>
<ul>
<li>反向调试基于记录重放，开启反向调试功能后，调试服务会记录用户正向调试的所有停止点（断点+单步），以及停止点的线程、堆栈、变量等调试信息。进入反向调试模式，支持查看历史记录点的调试信息。</li>
</ul>
</blockquote>
<h5 id="配置"><a class="header" href="#配置">配置</a></h5>
<p>您可以通过点击左下角齿轮图标，选择设置选项，在搜索栏输入 cangjie，找到 Reverse Debug 选项，勾选 <code>Enable reverse debug</code>，开启程序调试历史停止点信息的自动记录，同时可以配置自动记录的线程个数、堆栈个数、变量作用域、复杂类型变量子变量的展开层数和子变量个数，配置修改后，需要重新启动仓颉调试。</p>
<p><img src="source_zh_cn/IDE/figures/reverseDebugConfig.png" alt="reverseDebugConfig" /></p>
<h5 id="工具栏"><a class="header" href="#工具栏">工具栏</a></h5>
<p>您可以单击顶部调试工具栏上的时钟图标进入反向调试模式，使用工具栏上正反向继续、正反向单步控制程序，查看历史记录的线程、堆栈、变量信息，如下图：</p>
<p><img src="source_zh_cn/IDE/figures/reverseDebugOpen.png" alt="reverseDebugOpen" /></p>
<p>您可以单击顶部调试工具栏上的方块图标退出反向调试模式，调试会回到正向调试的最后停止点，如下图：</p>
<p><img src="source_zh_cn/IDE/figures/reverseDebugClose.png" alt="reverseDebugClose" /></p>
<h5 id="反向断点"><a class="header" href="#反向断点">反向断点</a></h5>
<blockquote>
<p>说明：</p>
<ul>
<li>反向断点是一种特殊的源码断点（Log Point），正向调试过程中不会停止，也不会输出自动生成的 Log Message（用于标记反向断点）。</li>
<li>在正向调试时，用户提前设置反向断点，调试服务后台会记录进程走过的反向断点的调试信息。</li>
<li>在进入反向调试模式时，反向断点会作为停止点（断点型），可以查看该断点处的线程堆栈变量等调试信息。</li>
<li>在进入反向调试模式时，不支持设置反向断点。</li>
</ul>
</blockquote>
<p>反向断点设置方式：</p>
<ol>
<li>
<p>在仓颉源文件编辑器视图内右键选择 <code>Cangjie: Add Reverse Breakpoint</code> 为光标所在行设置一个反向断点；
<img src="source_zh_cn/IDE/figures/lineReverseBreakpoint.png" alt="lineReverseBreakpoint" /></p>
</li>
<li>
<p>在仓颉源文件上右键选择 <code>Cangjie: Add Auto Reverse Breakpoints</code> 插件会分析该文件内函数的入口和出口位置并自动设置反向断点；
<img src="source_zh_cn/IDE/figures/fileReverseBreakpoint.png" alt="fileReverseBreakpoint" /></p>
</li>
<li>
<p>在文件夹上右键选择 <code>Cangjie: Add Auto Reverse Breakpoints</code> 插件会分析该文件夹内仓颉源文件中的函数的入口和出口位置并自动设置反向断点。
<img src="source_zh_cn/IDE/figures/folderReverseBreakpoint.png" alt="folderReverseBreakpoint" /></p>
</li>
</ol>
<h5 id="时间线"><a class="header" href="#时间线">时间线</a></h5>
<blockquote>
<p>说明：</p>
<ul>
<li>时间线展示了反向调试模式下记录的所有停止点（断点+单步），通过时间线拖拽，可以查看历史停止点的信息。</li>
</ul>
</blockquote>
<p>时间线入口位于 VSCode 右下方区域，您可以在右下方的 Tab 标签行右键将时间线 Cangjie Debug Timeline 开启或隐藏，也可以在 View 菜单中选择 Open View 开启，如下图：</p>
<p><img src="source_zh_cn/IDE/figures/debugTimelineShow.png" alt="debugTimelineShow.png" /></p>
<ol>
<li>主时间线上有左右游标，您可以分别拖动左右游标选出某一段时间区域；在选中一段区域之后，鼠标放在选中区域上方时会变为手的形状，此时您可以左右拖动此区域；</li>
<li>将鼠标放在主时间线上，鼠标变为十字光标的形状，此时按住鼠标往前或往后拖动，您可以将鼠标滑过的区域设为新的时间区域；</li>
<li>您可以通过 Ctrl + 鼠标滚轮的方式，放大和缩小选中区域；</li>
<li>每条时间线标识一个仓颉线程或者系统线程；如下图：</li>
</ol>
<p><img src="source_zh_cn/IDE/figures/debugTimelineOperation.png" alt="debugTimelineOperation.png" /></p>
<p>您可以点击时间线上的记录点， editor 界面同步刷新（定位到源码的行），调试信息界面同步刷新（展示该记录点的线程、栈帧和变量）。</p>
<h4 id="unittest-运行和调试"><a class="header" href="#unittest-运行和调试">unittest 运行和调试</a></h4>
<h5 id="前置条件-1"><a class="header" href="#前置条件-1">前置条件</a></h5>
<p>模块的单元测试代码应采用如下结构，其中 xxx.cj 表示该包的源码，对应单元测试代码文件命名应以 _test.cj 结尾。具体单元测试代码的写法可参考标准库用户手册。</p>
<pre><code class="language-plain">    │    └── src
    │        ├── koo
    │        │         ├── koo.cj
    │        │         └── koo_test.cj
    │        ├── zoo
    │        │         ├── zoo.cj
    │        │         └── zoo_test.cj
    │        ├── main.cj
    │        └── main_test.cj
    │    ├── cjpm.toml
</code></pre>
<h5 id="使用方式"><a class="header" href="#使用方式">使用方式</a></h5>
<ol>
<li>点击<code>@Test/@TestCase</code>声明行上的 &quot;<code>run</code>&quot; 按钮，运行该单元测试类/单元测试 case；</li>
<li>点击<code>@Test/@TestCase</code>声明行上的 &quot;<code>debug</code>&quot; 按钮，调试该单元测试类/单元测试 case；</li>
</ol>
<p><img src="source_zh_cn/IDE/figures/unittest.png" alt="unittest" /></p>
<h2 id="格式化"><a class="header" href="#格式化">格式化</a></h2>
<p>针对仓颉文件，在 VSCode 的代码编辑区右键选择 [Cangjie] Format 或者用快捷键 Ctrl+Alt+F 执行格式化命令，可以对当前仓颉文件进行格式化。如下图：</p>
<p><img src="source_zh_cn/IDE/figures/cjfmt.png" alt="cjfmt" /></p>
<p>针对仓颉项目，支持在 VSCode 的资源管理器中选择文件或者文件夹右键执行 [Cangjie] Format 命令，对选择的文件或者文件夹进行格式化。如下图：</p>
<p><img src="source_zh_cn/IDE/figures/cjfmtFolder.png" alt="cjfmtFolder" /></p>
<h2 id="静态检查"><a class="header" href="#静态检查">静态检查</a></h2>
<p>IDE 中的静态检查功能基于静态检查工具 cjlint，该功能可以识别代码中不符合编程规范的问题，帮助开发者发现代码中的漏洞，写出满足 Clean Source 要求的仓颉代码。</p>
<blockquote>
<p>说明：</p>
<p>​       静态检查目前只能检测工程目录 src 文件夹下的所有仓颉文件。</p>
</blockquote>
<p>静态检查的入口有两处:</p>
<ul>
<li>
<p>在 VSCode 的代码编辑区右键选择 [Cangjie] CodeCheck 或者用快捷键 Ctrl+Alt+C 执行静态检查命令 。如下图：</p>
<p><img src="source_zh_cn/IDE/figures/cjlint.png" alt="cjlint" /></p>
</li>
<li>
<p>在 VSCode 的资源管理器处右键选择 [Cangjie] CodeCheck 执行静态检查命令。如下图：</p>
<p><img src="source_zh_cn/IDE/figures/cjlintFolder.png" alt="cjlintFolder" /></p>
</li>
</ul>
<p>执行静态检查命令后，如果有不符合编码规范的问题会展示在右侧的表格中，点击表格中的文件链接，可以跳转到问题代码所在文件的行列：</p>
<p><img src="source_zh_cn/IDE/figures/cjlintResult.png" alt="cjlintResult" /></p>
<h2 id="覆盖率统计"><a class="header" href="#覆盖率统计">覆盖率统计</a></h2>
<p>覆盖率统计功能用于生成仓颉语言程序的覆盖率报告。</p>
<p>覆盖率统计的入口有两处:</p>
<ul>
<li>
<p>在 VSCode 的代码编辑区右键选择 [Cangjie] Coverage 或者用快捷键 Ctrl+Alt+G 执行生成当前仓颉文件覆盖率报告的命令。如下图：</p>
<p><img src="source_zh_cn/IDE/figures/cjcov.png" alt="cjcov" /></p>
</li>
<li>
<p>在 VSCode 的资源管理器中选择文件或者文件夹右键执行 [Cangjie] Coverage 命令，对选择的文件或者文件夹生成覆盖率报告。如下图：</p>
<p><img src="source_zh_cn/IDE/figures/cjcovFolder.png" alt="cjcovFolder" /></p>
</li>
</ul>
<p><em>注意：当选择的文件夹中不含有仓颉文件时，将不会生成覆盖率报告。</em></p>
<p>在生成的覆盖率报告页面，点击文件名可以查看点击文件的覆盖率详情：</p>
<p><img src="source_zh_cn/IDE/figures/cjcovResult.png" alt="cjcovResult" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="仓颉语言命令行工具使用指南"><a class="header" href="#仓颉语言命令行工具使用指南">仓颉语言命令行工具使用指南</a></h1>
<p>仓颉语言提供了一系列命令行工具供开发者使用。在成功安装仓颉工具链后，即可根据手册说明使用这些命令行工具。仓颉工具链安装说明详见<a href="source_zh_cn/tools/../../../AI/source_zh_cn/Chapter_02_Getting_Started.html">入门指南</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命令行模式编译"><a class="header" href="#命令行模式编译">命令行模式编译</a></h1>
<h2 id="功能简介-3"><a class="header" href="#功能简介-3">功能简介</a></h2>
<p><code>CJPM（Cangjie Package Manager）</code> 是仓颉语言的官方包管理工具，用于管理、维护仓颉项目的模块系统，并且提供简易统一的编译入口，支持自定义编译命令。</p>
<h2 id="使用说明-2"><a class="header" href="#使用说明-2">使用说明</a></h2>
<p>通过 <code>cjpm -h</code> 即可查看主界面，由几个板块组成，从上到下分别是： 当前命令说明、使用示例（Usage）、支持的可用命令（Available subcommands）、支持的配置项（Available options）、更多提示内容。</p>
<pre><code class="language-text">Cangjie Package Manager

Usage:
  cjpm [subcommand] [option]

Available subcommands:
  init             Init a new cangjie module
  check            Check the dependencies
  update           Update cjpm.lock
  tree             Display the package dependencies in the source code
  build            Compile the current module
  run              Compile and run an executable product
  test             Unittest a local package or module
  clean            Clean up the target directory
  install          Install a cangjie binary
  uninstall        Uninstall a cangjie binary

Available options:
  -h, --help       help for cjpm
  -v, --version    version for cjpm

Use &quot;cjpm [subcommand] --help&quot; for more information about a command.
</code></pre>
<p>基本的使用操作命令如下所示：</p>
<pre><code class="language-shell">cjpm build --help
</code></pre>
<p><code>cjpm</code> 是主程序的名称， <code>build</code> 是当前执行的可用命令， <code>--help</code> 是当前可用命令可用的配置项（配置项通常有长和短两种写法，效果相同）。</p>
<p>成功执行后会显示如下结果：</p>
<pre><code class="language-text">Compile a local module and all of its dependencies.

Usage:
  cjpm build [option]

Available options:
  -h, --help                    help for build
  -i, --incremental             enable incremental compilation
  -j, --jobs &lt;N&gt;                the number of jobs to spawn in parallel during the build process
  -V, --verbose                 enable verbose
  -g                            enable compile debug version target
  --coverage                    enable coverage
  --cfg                         enable the customized option 'cfg'
  -m, --member &lt;value&gt;          specify a member module of the workspace
  --target &lt;value&gt;              generate code for the given target platform
  --target-dir &lt;value&gt;          specify target directory
  -o, --output &lt;value&gt;          specify product name when compiling an executable file
  -l, --lint                    enable cjlint code check
  --mock                        enable support of mocking classes in tests
  --skip-script                 disable script 'build.cj'.
</code></pre>
<h2 id="命令说明"><a class="header" href="#命令说明">命令说明</a></h2>
<h3 id="init"><a class="header" href="#init">init</a></h3>
<p><code>init</code> 用于初始化一个新的仓颉模块或者工作空间。初始化模块时会默认在当前文件夹创建 <code>cjpm.toml</code> 文件，并且新建 <code>src</code> 源码文件夹。如果该模块的产物为可执行类型，则会在 <code>src</code> 下生成默认的 <code>main.cj</code> 文件，并在编译后打印输出 <code>hello world</code>。初始化工作空间时仅会创建 <code>cjpm.toml</code> 文件，默认会扫描该路径下已有的仓颉模块并添加到 <code>members</code> 字段中。若已存在 <code>cjpm.toml</code> 文件，或源码文件夹内已存在 <code>main.cj</code>，则会跳过对应的文件创建步骤。</p>
<p><code>init</code> 有多个可配置项：</p>
<ul>
<li><code>--name &lt;value&gt;</code> 指定新建模块的 <code>root</code> 包名，不指定时默认为上一级子文件夹名称</li>
<li><code>--path &lt;value&gt;</code> 指定新建模块的路径，不指定时默认为当前文件夹</li>
<li><code>--type=&lt;executable|static|dynamic&gt;</code> 指定新建模块的产物类型，缺省时默认为 <code>executable</code></li>
<li><code>--workspace</code> 新建一个工作空间配置文件，指定该选项时以上其它选项无效会自动忽略</li>
</ul>
<p>例如：</p>
<pre><code class="language-text">输入: cjpm init
输出: cjpm init success

输入: cjpm init --name demo --path project
输出: cjpm init success

输入: cjpm init --type=static
输出: cjpm init success
</code></pre>
<h3 id="check"><a class="header" href="#check">check</a></h3>
<p><code>check</code> 命令用于检查项目中所需的依赖项，执行成功将会打印有效的包编译顺序。</p>
<p><code>check</code> 有多个可配置项：</p>
<ul>
<li><code>-m, --member &lt;value&gt;</code> 仅可在工作空间下使用，可用于指定单个模块作为检查入口</li>
<li><code>--no-tests</code> 配置后，测试相关的依赖将不会被打印</li>
<li><code>--skip-script</code> 配置后，将会跳过构建脚本的编译运行</li>
</ul>
<p>例如：</p>
<pre><code class="language-text">输入: cjpm check
输出:
The valid serial compilation order is:
    b.pkgA -&gt; b
cjpm check success

输入: cjpm check
输出:
Error: cyclic dependency
b.B -&gt; c.C
c.C -&gt; d.D
d.D -&gt; b.B
输出说明：上述输出中，b.B 代表以 b 为 root 包的模块中的一个名为 b.B 的子包

输入: cjpm check
输出:
Error: can not find the following dependencies
    pro1.xoo
    pro1.yoo
    pro2.zoo
</code></pre>
<h3 id="update"><a class="header" href="#update">update</a></h3>
<p><code>update</code> 用于将 <code>cjpm.toml</code> 里的内容更新到 <code>cjpm.lock</code>。当 <code>cjpm.lock</code> 不存在时，将会生成该文件。<code>cjpm.lock</code> 文件记录着 git 依赖的版本号等元信息，用于下次构建使用。</p>
<p><code>update</code> 有以下可配置项：</p>
<ul>
<li><code>--skip-script</code> 配置后，将会跳过构建脚本的编译运行</li>
</ul>
<pre><code class="language-text">输入: cjpm update
输出: cjpm update success
</code></pre>
<h3 id="tree"><a class="header" href="#tree">tree</a></h3>
<p><code>tree</code> 命令用于可视化地展示仓颉源码中的包依赖关系。</p>
<p><code>tree</code> 有多个可配置项：</p>
<ul>
<li><code>-p, --package &lt;value&gt;</code> 指定某个包为根节点，从而展示它的子依赖包，需要配置的值是包名</li>
<li><code>--invert &lt;value&gt;</code> 指定某个包为根节点并反转依赖树，从而展示它被哪些包所依赖，需要配置的值是包名</li>
<li><code>--depth &lt;N&gt;</code> 指定依赖树的最大深度，可选值是非负整数。指定该选项时，默认会以所有包作为根节点。其中，N 的值代表每个依赖树的子节点最大深度</li>
<li><code>--target &lt;value&gt;</code> 将指定目标平台的依赖项加入分析，并展示依赖关系</li>
<li><code>--no-tests</code> 排除 <code>test-dependencies</code> 字段的依赖项</li>
<li><code>-V, --verbose</code> 增加包节点的详细信息，包括包名、版本号和包路径</li>
<li><code>--skip-script</code> 配置后，将会跳过构建脚本的编译运行</li>
</ul>
<pre><code class="language-text">输入: cjpm tree
输出:
|-- a
    └── a.aoo
        └── a.coo
    └── a.boo
        └── a.coo
|-- a.doo
    └── a.coo
|-- a.eoo
cjpm tree success

输入: cjpm tree --depth 2 -p a
输出:
|-- a
    └── a.aoo
        └── a.coo
    └── a.boo
        └── a.coo
cjpm tree success

输入: cjpm tree --depth 0
输出:
|-- a
|-- a.eoo
|-- a.aoo
|-- a.boo
|-- a.doo
|-- a.coo
cjpm tree success

输入: cjpm tree --invert a.coo --verbose
输出:
|-- a.coo 1.2.0 （.../src/coo）
    └── a.aoo 1.1.0 （.../src/aoo）
            └── a 1.0.0 （.../src）
    └── a.boo 1.1.0 （.../src/boo）
            └── a 1.0.0 （.../src）
    └── a.doo 1.3.0 （.../src/doo）
cjpm tree success
</code></pre>
<h3 id="build"><a class="header" href="#build">build</a></h3>
<p><code>build</code> 用于构建当前仓颉项目，执行该命令前会先检查依赖项，检查通过后调用 <code>cjc</code> 进行构建。</p>
<p><code>build</code> 有多个可配置项：</p>
<ul>
<li><code>-i, --incremental</code> 用于指定增量编译，默认情况下是全量编译</li>
<li><code>-j, --jobs &lt;N&gt;</code> 用于指定并行编译的最大并发数，最终的最大并发数取 <code>N</code> 和 <code>2倍 CPU 核数</code> 的最小值</li>
<li><code>-V, --verbose</code> 用于展示编译日志</li>
<li><code>-g</code> 用于生成 <code>debug</code> 版本的输出产物</li>
<li><code>--mock</code> 带有此选项的构建版本中的类可用于在测试中进行 <code>mock</code> 测试</li>
<li><code>--coverage</code> 用于生成覆盖率信息，默认情况下不开启覆盖率功能</li>
<li><code>--cfg</code> 指定后，能够透传 <code>cjpm.toml</code> 中的自定义 <code>cfg</code> 选项</li>
<li><code>-m, --member &lt;value&gt;</code> 仅可在工作空间下使用，可用于指定单个模块作为编译入口</li>
<li><code>--target-dir &lt;value&gt;</code> 用于指定输出产物的存放路径</li>
<li><code>-o, --output &lt;value&gt;</code> 用于指定输出可执行文件的名称，默认名称为 <code>main</code>（<code>windows</code> 下则默认为 <code>main.exe</code>）</li>
<li><code>--target &lt;value&gt;</code> 指定后，可交叉编译代码到目标平台，<code>cjpm.toml</code> 中的配置可参考<a href="source_zh_cn/tools/./cjpm_manual_cjnative_community.html#target">target</a>章节</li>
<li><code>-l, --lint</code> 用于在编译时调用仓颉语言静态检查工具进行代码检查</li>
<li><code>--skip-script</code> 配置后，将会跳过构建脚本的编译运行</li>
</ul>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li><code>-i, --incremental</code> 选项仅会开启 <code>cjpm</code> 包级别的增量编译。开发者可以在配置文件的 <code>compile-option</code> 字段自行透传 <code>--incremental-compile</code> 编译选项，从而开启 <code>cjc</code> 编译器提供的函数粒度增量功能。</li>
<li><code>-i, --incremental</code> 选项目前仅支持基于源码的增量分析。如果导入的库内容有变更，需要开发者重新使用全量方式构建。</li>
</ul>
</blockquote>
<p>编译生成的中间文件默认会存放在 <code>target</code> 文件夹，而可执行文件会根据编译模式存放到 <code>target/release/bin</code> 或 <code>target/debug/bin</code> 文件夹。为了提供可复制的构建，此命令会创建 <code>cjpm.lock</code> 文件，该文件包含所有可传递依赖项的确切版本，这些依赖项将用于所有后续构建，需要更新该文件时请使用 <code>update</code> 命令。如果有必要保证每个项目参与者都有可复制的构建，那么此文件应提交到版本控制系统中。</p>
<p>例如：</p>
<pre><code class="language-text">输入: cjpm build -V
输出:
compile package module1.package1: cjc --import-path &quot;target/release&quot; --output-dir &quot;target/release/module1&quot; -p &quot;src/package1&quot; --output-type=staticlib -o libmodule1.package1.a
compile package module1: cjc --import-path &quot;target/release&quot; --output-dir &quot;target/release/bin&quot; -p &quot;src&quot; --output-type=exe -o main
cjpm build success

输入: cjpm build
输出: cjpm build success
</code></pre>
<p><code>cjpm build</code> 配置 <code>-l, --lint</code> 选项时，会在编译期间调用仓颉语言静态检查工具 <code>cjlint</code> 进行代码检查。如果检查到【要求】级别的代码规范违规，则此次编译会失败，相应检查结果会输出至错误流；检查到【建议】级别的违规时仅会告警，并正常完成编译。<code>cjlint</code> 支持检查的代码规则列表及其级别详见 <a href="source_zh_cn/tools/./cjlint_manual.html#%E6%94%AF%E6%8C%81%E6%A3%80%E6%9F%A5%E7%9A%84%E8%A7%84%E8%8C%83%E5%88%97%E8%A1%A8%E6%8C%81%E7%BB%AD%E6%96%B0%E5%A2%9E%E4%B8%AD">cjlint 用户手册</a>。</p>
<h3 id="run"><a class="header" href="#run">run</a></h3>
<p><code>run</code> 用于运行当前项目构建出的二进制产物。</p>
<p><code>run</code> 有多个可配置项：</p>
<ul>
<li><code>--name &lt;value&gt;</code> 指定运行的二进制名称，不指定时默认为 <code>main</code>，工作空间下的二进制产物默认存放在 <code>target/release/bin</code> 路径下</li>
<li><code>--build-args &lt;value&gt;</code> 控制 <code>cjpm</code> 编译流程的参数</li>
<li><code>--skip-build</code> 跳过编译流程，直接运行</li>
<li><code>--run-args &lt;value&gt;</code> 透传参数给本次运行的二进制产物</li>
<li><code>--target-dir &lt;value&gt;</code> 用于指定运行产物的存放路径</li>
<li><code>-g</code> 用于运行 <code>debug</code> 版本的产物</li>
<li><code>-V, --verbose</code> 用于展示运行日志</li>
<li><code>--skip-script</code> 配置后，将会跳过构建脚本的编译运行</li>
</ul>
<p>例如：</p>
<pre><code class="language-text">输入: cjpm run
输出: cjpm run success

输入: cjpm run -g // 此时会默认执行 cjpm build -i -g 命令
输出: cjpm run success

输入: cjpm run --build-args=&quot;-s -j16&quot; --run-args=&quot;a b c&quot; -V
输出: cjpm run success
</code></pre>
<h3 id="test"><a class="header" href="#test">test</a></h3>
<p><code>test</code> 用于执行仓颉文件的单元测试用例，并直接打印测试结果，编译产物默认存放在 <code>target/release/unittest_bin</code> 文件夹。单元测试用例代码的写法可参考《仓颉编程语言库 API》中 <code>std.unittest</code> 库的说明。</p>
<p>该命令可以指定待测试的单包路径（支持指定多个单包，形如 <code>cjpm test path1 path2</code>），不指定路径时默认执行模块级别的单元测试。<code>test</code> 执行前提是当前项目能够 <code>build</code> 编译成功。</p>
<p>模块的单元测试代码结构如下所示，其中 <code>xxx.cj</code> 存放该包的源码，<code>xxx_test.cj</code> 存放单元测试代码：</p>
<pre><code class="language-text">│   └── src
│       ├── koo
│       │   ├── koo.cj
│       │   └── koo_test.cj
│       ├── zoo
│       │   ├── zoo.cj
│       │   └── zoo_test.cj
│       ├── main.cj
│       └── main_test.cj
│   ├── cjpm.toml
</code></pre>
<pre><code class="language-text">多模块测试场景
输入: cjpm test
输出:
--------------------------------------------------------------------------------------------------
TM: test, TP: default, time elapsed: 177921 ns, RESULT:
    TCS: TestM, time elapsed: 177921 ns, RESULT:
    [ PASSED ] CASE: sayhi (177921 ns)
    Summary: TOTAL: 1
    PASSED: 1, SKIPPED: 0, ERROR: 0
    FAILED: 0
--------------------------------------------------------------------------------------------------
TM: test, TP: koo, time elapsed: 134904 ns, RESULT:
    TCS: TestK, time elapsed: 134904 ns, RESULT:
    [ PASSED ] CASE: sayhi (134904 ns)
    Summary: TOTAL: 1
    PASSED: 1, SKIPPED: 0, ERROR: 0
    FAILED: 0
--------------------------------------------------------------------------------------------------
TM: pro0, TP: zoo, time elapsed: 132013 ns, RESULT:
    TCS: TestZ, time elapsed: 132013 ns, RESULT:
    [ PASSED ] CASE: sayhi (132013 ns)
    Summary: TOTAL: 1
    PASSED: 1, SKIPPED: 0, ERROR: 0
    FAILED: 0
--------------------------------------------------------------------------------------------------
Project tests finished, time elapsed: 444838 ns, RESULT:
TM: pro0, time elapsed: 132013 ns, RESULT:
    PASSED:
    TP: zoo, time elapsed: 132013 ns
TM: test, time elapsed: 312825 ns, RESULT:
    PASSED:
    TP: koo, time elapsed: 312825 ns
    TP: default, time elapsed: 312825 ns
Summary: TOTAL: 3
    PASSED: 3, SKIPPED: 0, ERROR: 0
    FAILED: 0
--------------------------------------------------------------------------------------------------

cjpm test success

单包测试场景
输入: cjpm test src/koo
输出:
--------------------------------------------------------------------------------------------------
TM: test, TP: koo, time elapsed: 160133 ns, RESULT:
    TCS: TestK, time elapsed: 160133 ns, RESULT:
    [ PASSED ] CASE: sayhi (160133 ns)
    Summary: TOTAL: 1
    PASSED: 1, SKIPPED: 0, ERROR: 0
    FAILED: 0
--------------------------------------------------------------------------------------------------
Project tests finished, time elapsed: 160133 ns, RESULT:
TM: test, time elapsed: 160133 ns, RESULT:
    PASSED:
    TP: koo, time elapsed: 160133 ns
Summary: TOTAL: 1
    PASSED: 1, SKIPPED: 0, ERROR: 0
    FAILED: 0
--------------------------------------------------------------------------------------------------
cjpm test success

多包测试场景
输入: cjpm test src/koo src
输出:
--------------------------------------------------------------------------------------------------
TM: test, TP: koo, time elapsed: 168204 ns, RESULT:
    TCS: TestK, time elapsed: 168204 ns, RESULT:
    [ PASSED ] CASE: sayhi (168204 ns)
    Summary: TOTAL: 1
    PASSED: 1, SKIPPED: 0, ERROR: 0
    FAILED: 0
--------------------------------------------------------------------------------------------------
TM: test, TP: default, time elapsed: 171541 ns, RESULT:
    TCS: TestM, time elapsed: 171541 ns, RESULT:
    [ PASSED ] CASE: sayhi (171541 ns)
    Summary: TOTAL: 1
    PASSED: 1, SKIPPED: 0, ERROR: 0
    FAILED: 0
--------------------------------------------------------------------------------------------------
Project tests finished, time elapsed: 339745 ns, RESULT:
TM: test, time elapsed: 339745 ns, RESULT:
    PASSED:
    TP: koo, time elapsed: 339745 ns
    TP: default, time elapsed: 339745 ns
Summary: TOTAL: 2
    PASSED: 2, SKIPPED: 0, ERROR: 0
    FAILED: 0
--------------------------------------------------------------------------------------------------
cjpm test success
</code></pre>
<p><code>test</code> 有多个可配置项：</p>
<ul>
<li><code>--no-run</code> 用于仅编译单元测试产物</li>
<li><code>--skip-build</code> 用于仅执行单元测试产物</li>
<li><code>-j, --jobs &lt;N&gt;</code> 用于指定并行编译的最大并发数，最终的最大并发数取 <code>N</code> 和 <code>2倍 CPU 核数</code> 的最小值</li>
<li><code>-V, --verbose</code> 配置项开启后，会输出单元测试的日志</li>
<li><code>-g</code> 用于生成 <code>debug</code> 版本的单元测试产物，此时的产物存放在 <code>target/debug/unittest_bin</code> 文件夹</li>
<li><code>--bench</code> 用于指定只执行 <code>@bench</code> 宏修饰用例的测试结果</li>
<li><code>--target-dir &lt;value&gt;</code> 用于指定单侧产物的存放路径</li>
<li><code>--coverage</code> 配合 <code>cjcov</code> 命令可以生成单元测试的覆盖率报告。使用 <code>cjpm test --coverage</code> 统计覆盖率时，源代码中的 <code>main</code> 不会再作为程序入口执行，因此会显示为未被覆盖。建议使用 <code>cjpm test</code> 之后，不再手写多余的 <code>main</code></li>
<li><code>--cfg</code> 指定后，能够透传 <code>cjpm.toml</code> 中的自定义 <code>cfg</code> 选项</li>
<li><code>-m, --member &lt;value&gt;</code> 仅可在工作空间下使用，可用于指定测试单个模块</li>
<li><code>--target &lt;value&gt;</code> 指定后，可交叉编译生成目标平台的单元测试结果，<code>cjpm.toml</code> 中的配置可参考<a href="source_zh_cn/tools/./cjpm_manual_cjnative_community.md.html#target">target</a>章节</li>
<li><code>--filter &lt;value&gt;</code> 用于过滤测试的子集，<code>value</code> 的形式如下所示：
<ul>
<li><code>--filter=*</code> 匹配所有测试类</li>
<li><code>--filter=*.*</code> 匹配所有测试类的所有测试用例（结果和*相同）</li>
<li><code>--filter=*.*Test,*.*case*</code> 匹配所有测试类中以 <code>Test</code> 结尾的用例，或者所有测试类中名字中带有 <code>case</code> 的测试用例</li>
<li><code>--filter=MyTest*.*Test,*.*case*,-*.*myTest</code> 匹配所有 <code>MyTest</code> 开头测试类中以 <code>Test</code> 结尾的用例，或者名字中带有 <code>case</code> 的用例，或者名字中不带有 <code>myTest</code> 的测试用例</li>
</ul>
</li>
<li><code>--random-seed &lt;N&gt;</code> 用于指定随机种子的值</li>
<li><code>--no-color</code> 关闭控制台颜色显示</li>
<li><code>--timeout-each &lt;value&gt;</code> value 的格式为 <code>%d[millis|s|m|h]</code>，为每个测试用例指定默认的超时时间</li>
<li><code>--parallel</code> 用于指定测试用例并行执行的方案， <code>value</code> 的形式如下所示：
<ul>
<li><code>&lt;BOOL&gt;</code> 可为 <code>true</code> 或 <code>false</code>，指定为 <code>true</code> 时，测试类可被并行运行，并行进程个数将受运行系统上的 CPU 核数控制</li>
<li><code>nCores</code> 指定了并行的测试进程个数应该等于可用的 CPU 核数</li>
<li><code>NUMBER</code> 指定了并行的测试进程个数值。该数值应该为正整数</li>
<li><code>NUMBERnCores</code> 指定了并行的测试进程个数值为可用的 CPU 核数的指定数值倍。该数值应该为正数（支持浮点数或整数）</li>
</ul>
</li>
<li><code>--report-path &lt;value&gt;</code> 指定测试执行后的报告生成路径</li>
<li><code>--report-format &lt;value&gt;</code> 指定报告输出格式，当前单元测试报告仅支持 <code>xml</code> 格式（可忽略大小写），使用其它值将会抛出异常, 性能测试报告仅支持 <code>csv</code> 和 <code>csv-raw</code> 格式</li>
<li><code>--skip-script</code> 配置后，将会跳过构建脚本的编译运行</li>
</ul>
<p><code>cjpm test</code> 参数选项使用示例:</p>
<pre><code class="language-text">输入：
cjpm test src --coverage
cjcov --root=./ --html-details -o html_output
输出：cjpm test success
覆盖率生成：在 html_output 目录下会生成 html 文件，总的覆盖率报告文件名固定为 index.html

输入: cjpm test --bench
输出: cjpm test success

输入: cjpm test src --bench
输出: cjpm test success

输入: cjpm test src --filter=*
输出: cjpm test success

输入: cjpm test src --report-path=reports --report-format=xml
输出: cjpm test success
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p><code>cjpm test</code> 会自动构建所有带有 <code>mock</code> 支持的包，因此在测试中，开发者可以对自定义的类或依赖源模块的类进行 <code>mock</code> 测试。为了能够从一些二进制依赖中 <code>mock</code> 类，应该通过 <code>cjpm build --mock</code> 来构建带有 <code>mock</code> 支持的类。
带有 <code>--bench</code> 选项的 <code>cjpm test</code> 并不包含完全的 <code>mock</code> 支持，以避免在基准测试中由于在编译器中的 <code>mock</code> 处理而增加的任何开销。
使用 <code>--bench</code> 选项时，如果使用 <code>mock</code> ，编译器不会报错，以便能够将常规测试和基准测试一起编译。但是要避免运行使用 <code>mock</code> 的基准测试，否则会抛出运行时异常。</p>
</blockquote>
<h3 id="install"><a class="header" href="#install">install</a></h3>
<p><code>install</code> 用于安装仓颉项目，执行该命令前会先进行编译，然后将编译产物安装到指定路径，安装产物以仓颉项目名命名（<code>windows</code> 系统上会有 <code>.exe</code> 后缀）。<code>install</code> 安装的项目产物类型需要是 <code>executable</code>。</p>
<p><code>install</code> 有多个可配置项：</p>
<ul>
<li><code>-V, --verbose</code> 用于展示安装日志</li>
<li><code>-g</code> 用于生成 <code>debug</code> 版本的安装产物</li>
<li><code>--path &lt;value&gt;</code> 用于指定本地安装项目的路径，默认为当前路径下的项目</li>
<li><code>--root &lt;value&gt;</code> 用于指定可执行文件的安装路径，不配置时 <code>linux/macOS</code> 系统下默认为 <code>$HOME/.cjpm</code>，<code>windows</code> 默认为 <code>%USERPROFILE%/.cjpm</code>，配置时将会安装于 <code>value</code></li>
<li><code>-m, --member &lt;value&gt;</code> 仅可在工作空间下使用，可用于指定单个模块作为编译入口以安装单一模块</li>
<li><code>--target-dir &lt;value&gt;</code> 用于指定编译产物的存放路径</li>
<li><code>--name &lt;value&gt;</code> 用于指定最终安装的产物名</li>
<li><code>--git &lt;value&gt;</code> 用于指定 <code>git</code> 安装的项目 <code>url</code></li>
<li><code>--branch &lt;value&gt;</code> 用于指定 <code>git</code> 安装的项目分支</li>
<li><code>--tag &lt;value&gt;</code> 用于指定 <code>git</code> 安装的项目 <code>tag</code></li>
<li><code>--commit &lt;value&gt;</code> 用于指定 <code>git</code> 安装的项目 <code>commit ID</code></li>
<li><code>--list</code> 用于打印已安装产物列表</li>
<li><code>--skip-build</code> 用于跳过编译阶段以直接安装产物，需要项目处于编译完成状态，且仅在本地安装场景下生效</li>
<li><code>-j, --jobs &lt;N&gt;</code> 用于指定并行编译的最大并发数，最终的最大并发数取 <code>N</code> 和 <code>2倍 CPU 核数</code> 的最小值</li>
<li><code>--cfg</code> 指定后，能够透传 <code>cjpm.toml</code> 中的自定义 <code>cfg</code> 选项</li>
<li><code>--skip-script</code> 配置后，将会跳过待安装模块的构建脚本的编译运行</li>
</ul>
<p><code>install</code> 功能有如下注意事项：</p>
<ul>
<li><code>install</code> 共有两种安装方式：安装本地项目（通过 <code>--path</code> 配置项目路径）和安装 <code>git</code> 项目（通过 <code>--git</code> 配置项目 <code>url</code>）。这两种安装方式至多只能配置一种，否则 <code>install</code> 将报错。任意一种均未配置时，默认安装当前目录下的本地项目。</li>
<li><code>install</code> 编译项目时，默认开启增量编译。</li>
<li><code>git</code> 相关配置仅在配置 <code>--git</code> 后生效，否则会被忽略，包括 <code>--branch</code>, <code>--tag</code> 和 <code>--commit</code>。当配置多个 <code>git</code> 相关配置时，仅会生效优先级更高的配置，优先级排序为 <code>--commit</code> &gt; <code>--branch</code> &gt; <code>--tag</code>。</li>
<li>若已存在同名可执行文件被安装，则原来的文件将被替换。</li>
<li>假设安装路径为 <code>root</code>（<code>root</code> 为配置的安装路径，不配置则为默认路径），则可执行文件将被安装于 <code>root/bin</code>。</li>
<li>若项目存在动态库依赖，可执行程序所需动态库会被安装到 <code>root/libs</code>，按程序名分隔为若干目录，开发者需要将对应目录加入相应路径（<code>linux/macOS</code> 中为 <code>LD_LIBRARY_PATH</code>，<code>windows</code> 中为 <code>PATH</code>）方可使用。</li>
<li>默认安装路径（<code>linux/macOS</code> 系统下默认为 <code>$HOME/.cjpm</code>，<code>windows</code> 默认为 <code>%USERPROFILE%/.cjpm</code>）会在 <code>envsetup</code> 中被加入 <code>PATH</code>。</li>
<li><code>install</code> 在安装 <code>git</code> 项目后，对应的编译产物目录会被清除。</li>
<li>在待安装项目仅存在一个可执行文件产物时，指定 <code>--name</code> 会将其更名后安装；若存在多个可执行文件产物，指定 <code>--name</code> 会仅安装对应名称的产物。</li>
<li>配置 <code>--list</code> 时，<code>install</code> 会打印已安装产物列表，此时除 <code>--root</code> 以外的所有配置项均会被忽略。配置 <code>--root</code> 后，<code>--list</code> 会打印配置路径下已安装的产物列表，否则会打印默认路径下的列表。</li>
</ul>
<p>例如：</p>
<pre><code class="language-text">cjpm install --path path/to/project # 从本地路径 path/to/project 中安装
cjpm install --git url              # 从 git 对应地址安装
</code></pre>
<h3 id="uninstall"><a class="header" href="#uninstall">uninstall</a></h3>
<p><code>uninstall</code> 用于卸载仓颉项目，清除对应的可执行文件和依赖文件。</p>
<p><code>uninstall</code> 需要配置参数 <code>name</code>，以卸载名为 <code>name</code> 的产物，配置多个 <code>name</code> 时会依次删除。<code>uninstall</code> 可以通过 <code>--root &lt;value&gt;</code> 指定卸载的可执行文件路径，不配置时 <code>linux/macOS</code> 系统下默认为 <code>$HOME/.cjpm</code>，<code>windows</code> 默认为 <code>%USERPROFILE%/.cjpm</code>，配置时将会卸载安装于 <code>value/bin</code> 的产物和安装于 <code>value/libs</code> 的依赖</p>
<h3 id="clean"><a class="header" href="#clean">clean</a></h3>
<p><code>clean</code> 用于清理构建过程中的临时产物（<code>target</code> 文件夹）。该命令支持通过短选项 <code>-g</code> 指定仅清理 <code>debug</code> 版本的产物。该命令支持通过长选项 <code>--target-dir &lt;value&gt;</code> 用于指定清理的产物存放路径，开发者需自身保证清理该目录行为的安全性。如果使用了 <code>cjpm build --coverage</code> 或者 <code>cjpm test --coverage</code> 功能，还会清除 <code>cov_output</code> 文件夹，以及当前目录下的 <code>*.gcno</code> 文件和 <code>*.gcda</code> 文件。同时，该命令也支持通过 <code>--skip-script</code> 配置跳过构建脚本的编译运行。</p>
<p>例如：</p>
<pre><code class="language-text">输入: cjpm clean
输出: cjpm clean success

输入: cjpm clean --target-dir temp
输出: cjpm clean success
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p>在 <code>windows</code> 平台上，在子进程执行完成后立即清理子进程的可执行文件或父目录可能会失败。如果遇到该问题，可以在一小段延迟后重新尝试 <code>clean</code> 命令。</p>
</blockquote>
<h2 id="模块配置文件说明"><a class="header" href="#模块配置文件说明">模块配置文件说明</a></h2>
<p>模块配置文件 <code>cjpm.toml</code> 用于配置一些基础信息、依赖项、编译选项等内容，<code>cjpm</code> 主要通过这个文件进行解析执行。其中，模块名可以在 <code>cjpm.toml</code> 中进行重命名，但是包名不能在 <code>cjpm.toml</code> 中进行重命名。</p>
<p>配置文件代码如下所示：</p>
<pre><code class="language-text">[package] # 单模块配置字段，与 workspace 字段不能同时存在
  cjc-version = &quot;0.49.1&quot; # 所需 `cjc` 的最低版本要求，必须
  name = &quot;demo&quot; # 模块名及模块 root 包名，必须
  description = &quot;nothing here&quot; # 描述信息，非必须
  version = &quot;1.0.0&quot; # 模块版本信息，必须
  compile-option = &quot;&quot; # 额外编译命令选项，非必须
  link-option = &quot;&quot; # 链接器透传选项，可透传安全编译命令，非必须
  output-type = &quot;executable&quot; # 编译输出产物类型，必须
  src-dir = &quot;&quot; # 指定源码存放路径，非必须
  target-dir = &quot;&quot; # 指定产物存放路径，非必须
  package-configuration = {} # 单包配置选项，非必须

[workspace] # 工作空间管理字段，与 package 字段不能同时存在
  members = [] # 工作空间成员模块列表，必须
  build-members = [] # 工作空间编译模块列表，需要是成员模块列表的子集，非必须
  test-members = [] # 工作空间测试模块列表，需要是编译模块列表的子集，非必须
  compile-option = &quot;&quot; # 应用于所有工作空间成员模块的额外编译命令选项，非必须
  link-option = &quot;&quot; # 应用于所有工作空间成员模块的链接器透传选项，非必须
  target-dir = &quot;&quot; # 指定产物存放路径，非必须

[dependencies] # 源码依赖配置项
  coo = { git = &quot;xxx&quot;，branch = &quot;dev&quot; , version = &quot;1.0.0&quot;} # 导入 `git` 依赖，`version`字段可缺省
  doo = { path = &quot;./pro1&quot; ,version = &quot;1.0.0&quot;} # 导入源码依赖，`version`字段可缺省

[test-dependencies] # 测试阶段的依赖配置项，格式同 dependencies

[ffi.c] # 导入 `c` 库依赖
  clib1.path = &quot;xxx&quot;

[profile] # 命令剖面配置项
  build = {}
  test = {}
  customized-option = {}

[target.x86_64-unknown-linux-gnu] # 后端和平台隔离配置项
  compile-option = &quot;value1&quot; # 额外编译命令选项，适用于特定 target 的编译流程和指定该 target 作为交叉编译目标平台的编译流程，非必须
  link-option = &quot;value2&quot; # 链接器透传选项，适用于特定 target 的编译流程和指定该 target 作为交叉编译目标平台的编译流程，非必须

[target.x86_64-w64-mingw32.dependencies] # 适用于对应 target 的源码依赖配置项，非必须

[target.x86_64-w64-mingw32.test-dependencies] # 适用于对应 target 的测试阶段依赖配置项，非必须

[target.x86_64-unknown-linux-gnu.bin-dependencies] # 仓颉二进制库依赖，适用于特定 target 的编译流程和指定该 target 作为交叉编译目标平台的编译流程，非必须
  path-option = [&quot;./test/pro0&quot;, &quot;./test/pro1&quot;]
[target.x86_64-unknown-linux-gnu.bin-dependencies.package-option]
  &quot;pro0.xoo&quot; = &quot;./test/pro0/pro0.xoo.cjo&quot;
  &quot;pro0.yoo&quot; = &quot;./test/pro0/pro0.yoo.cjo&quot;
  &quot;pro1.zoo&quot; = &quot;./test/pro1/pro1.zoo.cjo&quot;
</code></pre>
<p>当以上字段在 <code>cjpm.toml</code> 中没有使用时，默认为空（对于路径，默认为配置文件所在的路径）。</p>
<h3 id="cjc-version"><a class="header" href="#cjc-version">&quot;cjc-version&quot;</a></h3>
<p>仓颉编译器最低版本要求，必须和当前环境版本兼容才可以执行。一个合法的仓颉版本号是由三段数字组成，中间使用 <code>.</code> 隔开，每个数字均为自然数，且没有多余的前缀 <code>0</code>。例如：</p>
<ul>
<li><code>0.49.1</code> 是一个合法的仓颉版本号；</li>
<li><code>0.049.1</code> 不是一个合法的仓颉版本号，<code>049</code> 中含有多余的前缀 <code>0</code>；</li>
<li><code>0.2e.1</code> 不是一个合法的仓颉版本号，<code>2e</code> 不为自然数。</li>
</ul>
<h3 id="name"><a class="header" href="#name">&quot;name&quot;</a></h3>
<p>当前仓颉模块名称，同时也是模块 <code>root</code> 包名。</p>
<p>一个合法的仓颉模块名称必须是一个合法的标识符。标识符可由字母、数字、下划线组成，标识符的开头必须是字母，例如 <code>cjDemo</code> 或者 <code>cj_demo_1</code>。</p>
<h3 id="description"><a class="header" href="#description">&quot;description&quot;</a></h3>
<p>当前仓颉模块描述信息，仅作说明用，不限制格式。</p>
<h3 id="version"><a class="header" href="#version">&quot;version&quot;</a></h3>
<p>当前仓颉模块版本号，由模块所有者管理，主要供模块校验使用。模块版本号的格式同 <code>cjc-version</code>。</p>
<h3 id="compile-option"><a class="header" href="#compile-option">&quot;compile-option&quot;</a></h3>
<p>传给 <code>cjc</code> 的额外编译选项。多模块编译时，每个模块设置的 <code>compile-option</code> 对该模块内的所有包生效。</p>
<p>例如：</p>
<pre><code class="language-text">compile-option = &quot;-O1 -V&quot;
</code></pre>
<p>这里填入的命令会在 <code>build</code> 执行时插入到编译命令中间，多个命令可以用空格隔开。可用的命令参考《仓颉编程语言开发指南》的编译选项章节内容。</p>
<h3 id="link-option"><a class="header" href="#link-option">&quot;link-option&quot;</a></h3>
<p>传给链接器的编译选项，可用于透传安全编译命令，如下所示:</p>
<pre><code class="language-text">link-option = &quot;-z noexecstack -z relro -z now --strip-all&quot;
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p><code>link-option</code> 中配置的命令在编译时只会自动透传给动态库和可执行产物对应的包。</p>
</blockquote>
<h3 id="output-type"><a class="header" href="#output-type">&quot;output-type&quot;</a></h3>
<p>编译输出产物的类型，包含可执行程序和库两种形式，相关的输入如下表格所示。如果想生成 <code>cjpm.toml</code> 时该字段自动填充为 <code>static</code>，可使用命令 <code>cjpm init --type=static --name=modName</code>，不指定类型时默认生成为 <code>executable</code>。只有主模块的该字段可以为 <code>executable</code>。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">输入</th><th style="text-align: center">说明</th></tr></thead><tbody>
<tr><td style="text-align: center">&quot;executable&quot;</td><td style="text-align: center">可执行程序</td></tr>
<tr><td style="text-align: center">&quot;static&quot;</td><td style="text-align: center">静态库</td></tr>
<tr><td style="text-align: center">&quot;dynamic&quot;</td><td style="text-align: center">动态库</td></tr>
<tr><td style="text-align: center">其它</td><td style="text-align: center">报错</td></tr>
</tbody></table>
</div>
<h3 id="src-dir"><a class="header" href="#src-dir">&quot;src-dir&quot;</a></h3>
<p>该字段可以指定源码的存放路径，不指定时默认为 <code>src</code> 文件夹。</p>
<h3 id="target-dir"><a class="header" href="#target-dir">&quot;target-dir&quot;</a></h3>
<p>该字段可以指定编译产物的存放路径，不指定时默认为 <code>target</code> 文件夹。若该字段不为空，执行 <code>cjpm clean</code> 时会删除该字段所指向的文件夹，开发者需自身保证清理该目录行为的安全性。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>若在编译时同时指定了 <code>--target-dir</code> 选项，则该选项的优先级会更高。</p>
</blockquote>
<pre><code class="language-text">target-dir = &quot;temp&quot;
</code></pre>
<h3 id="package-configuration"><a class="header" href="#package-configuration">&quot;package-configuration&quot;</a></h3>
<p>每个模块的单包可配置项。该选项是个 <code>map</code> 结构，需要配置的包名作为 <code>key</code>，单包配置信息作为 <code>value</code>。当前可配置的信息包含输出类型、透传命令选项、条件选项，这几个选项可缺省按需配置。如下所示，<code>demo</code> 模块中的 <code>demo.aoo</code> 包的输出类型会被指定为动态库类型，<code>-g</code> 命令会在编译时透传给 <code>demo.aoo</code> 包。</p>
<pre><code class="language-text">[package.package-configuration.&quot;demo.aoo&quot;]
  output-type = &quot;dynamic&quot;
  compile-option = &quot;-g&quot;
</code></pre>
<p>如果在不同字段配置了相互兼容的编译选项，生成命令的优先级如下所示。</p>
<pre><code class="language-text">[package]
  compile-option = &quot;-O1&quot;
[package.package-configuration.demo]
  compile-option = &quot;-O2&quot;

# profile字段会在下文介绍
[package.profile.customized-option]
  cfg1 = &quot;-O0&quot;

输入: cjpm build --cfg1 -V
输出: cjc --import-path build -O0 -O1 -O2 ...
</code></pre>
<p>通过配置这个字段，可以同时生成多个二进制产物（生成多个二进制产物时，<code>-o, --output &lt;value&gt;</code> 选项将会失效），示例如下：</p>
<p>源码结构的示例，模块名为 <code>demo</code>：</p>
<pre><code class="language-text">`-- src
    |-- aoo
    |   `-- aoo.cj
    |-- boo
    |   `-- boo.cj
    |-- coo
    |   `-- coo.cj
    `-- main.cj
</code></pre>
<p>配置方式的示例：</p>
<pre><code class="language-text">[package.package-configuration.&quot;demo.aoo&quot;]
  output-type = &quot;executable&quot;
[package.package-configuration.&quot;demo.boo&quot;]
  output-type = &quot;executable&quot;
</code></pre>
<p>多个二进制产物的示例：</p>
<pre><code class="language-text">❯ cjpm build
cjpm build success

❯ tree target/release/bin
target/release/bin
|-- demo.aoo
|-- demo.boo
`-- demo
</code></pre>
<h3 id="workspace"><a class="header" href="#workspace">&quot;workspace&quot;</a></h3>
<p>该字段可管理多个模块作为一个工作空间，支持以下配置项：</p>
<ul>
<li><code>members = [&quot;aoo&quot;, &quot;path/to/boo&quot;]</code>：列举包含在此工作空间的本地源码模块，支持绝对路径和相对路径。该字段的成员必须是一个模块，不允许是另一个工作空间</li>
<li><code>build-members = []</code>：本次编译的模块，不指定时默认编译该工作空间内的所有模块。该字段的成员必须被包含在 <code>members</code> 字段中</li>
<li><code>test-members = []</code>：本次测试的模块，不指定时默认单元测试该工作空间内的所有模块。该字段的成员必须被包含在 <code>build-members</code> 字段中</li>
<li><code>compile-option = &quot;&quot;</code>：工作空间的公共编译选项，非必须</li>
<li><code>link-option = &quot;&quot;</code>：工作空间的公共链接选项，非必须</li>
<li><code>target-dir = &quot;&quot;</code>：工作空间的产物存放路径，非必须，默认为 <code>target</code></li>
</ul>
<p>工作空间内的公共配置项，对所有成员模块生效。例如：配置了 <code>[dependencies] xoo = { path = &quot;path_xoo&quot; }</code> 的源码依赖，则所有成员模块可以直接使用 <code>xoo</code> 模块，无需在每个子模块的 <code>cjpm.toml</code> 中再配置。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p><code>package</code> 字段用于配置模块的通用信息，不允许和 <code>workspace</code> 字段出现在同一个 <code>cjpm.toml</code> 中，除 <code>package</code> 外的其它字段均可在工作空间中使用。</p>
</blockquote>
<p>工作空间目录举例：</p>
<pre><code class="language-text">root_path
 │   └─ aoo
 │       ├─ src
 │       └─ cjpm.toml
 │   └─ boo
 │       ├─ src
 │       └─ cjpm.toml
 │   └─ coo
 │       ├─ src
 │       └─ cjpm.toml
 └─ cjpm.toml
</code></pre>
<p>工作空间的配置文件使用举例：</p>
<pre><code class="language-text">[workspace]
members = [&quot;aoo&quot;, &quot;boo&quot;, &quot;coo&quot;]
build-members = [&quot;aoo&quot;, &quot;boo&quot;]
test-members = [&quot;aoo&quot;]
compile-option = &quot;-Woff all&quot;

[dependencies]
xoo = { path = &quot;path_xoo&quot; }

[ffi.c]
abc = { path = &quot;libs&quot; }
</code></pre>
<h3 id="dependencies"><a class="header" href="#dependencies">&quot;dependencies&quot;</a></h3>
<p>该字段通过源码方式导入依赖的其它仓颉模块，里面配置了当前构建所需要的其它模块的信息。目前，该字段支持本地路径依赖和远程 git 依赖。</p>
<p>要指定本地依赖项，请使用 <code>path</code> 字段，并且它必须包含有效的本地路径。例如，下面的两个子模块 <code>pro0</code> 和 <code>pro1</code> 和主模块的代码结构如下：</p>
<pre><code class="language-text">|-- pro0
|   |-- cjpm.toml
|   `-- src
|       `-- zoo
|           `-- zoo.cj

|-- pro1
|   |-- cjpm.toml
|   `-- src
|       |-- xoo
|       |   `-- xoo.cj
|       `-- yoo
|           `-- yoo.cj

|-- cjpm.toml
`-- src
    |-- aoo
    |   `-- aoo.cj
    |-- boo
    |   `-- boo.cj
    `-- main.cj
</code></pre>
<p>在主模块的 <code>cjpm.toml</code> 中进行如下配置后，即可在源码中使用 <code>pro0</code> 和 <code>pro1</code> 模块：</p>
<pre><code class="language-text">[dependencies]
  pro0 = { path = &quot;./pro0&quot; }
  pro1 = { path = &quot;./pro1&quot; }
</code></pre>
<p>要指定远程 git 依赖项，请使用 <code>git</code> 字段，并且它必须包含 git 支持的任何格式的有效 url。要配置 git 依赖关系，最多可以有一个 <code>branch</code>、<code>tag</code> 和 <code>commitId</code> 字段，这些字段允许分别选择特定的分支、标记或提交哈希，若配置多个此类字段则仅会生效优先级最高的配置，优先级顺序为 <code>commitId</code> &gt; <code>branch</code> &gt; <code>tag</code>。此外，还有可选的 <code>version</code> 字段，用于检查依赖项是否具有正确的版本，并且没有意外更新。例如，进行如下配置后，即可在源码中使用特定 git 仓库地址的 <code>pro0</code> 和 <code>pro1</code> 模块：</p>
<pre><code class="language-text">[dependencies]
  pro0 = { git = &quot;git://github.com/org/pro0.git&quot;, tag = &quot;v1.0.0&quot;}
  pro1 = { git = &quot;https://gitee.com/anotherorg/pro1&quot;, branch = &quot;dev&quot;}
</code></pre>
<p>在这种情况下， <code>cjpm</code> 将下载对应存储库的最新版本，并将当前 <code>commit-hash</code> 保存在 <code>cjpm.lock</code> 文件中。所有后续的 <code>cjpm</code> 调用都将使用保存的版本，直到使用 <code>cjpm update</code>。</p>
<p>通常需要一些身份验证才能访问 git 存储库。 <code>cjpm</code> 不要求提供所需的凭据，因此应使用现有的 git 身份验证支持。如果用于 git 的协议是 <code>https</code> ，则需要使用一些现有的 git 凭据帮助程序。在 windows 上，可在安装 git 时一起安装凭据帮助程序，默认使用。在 linux 上，请参阅 <a href="https://git-scm.com/docs/gitcredentials"><code>git-config</code> 配置说明</a> ，了解有关设置凭据帮助程序的详细信息。如果协议是 <code>ssh</code> 或 <code>git</code> ，则应使用基于密钥的身份验证。如果密钥受密码短语保护，则开发者应确保 <code>ssh-agent</code> 正在运行，并且在使用 <code>cjpm</code> 之前通过 <code>ssh-add</code> 添加密钥。</p>
<p><code>dependencies</code> 字段可以通过 <code>output-type</code> 属性指定编译产物类型，指定的类型可以与源码依赖自身的编译产物类型不一致，且仅能为 <code>static</code> 或者 <code>dynamic</code>， 如下所示：</p>
<pre><code class="language-text">[dependencies]
  pro0 = { path = &quot;./pro0&quot;, output-type = &quot;static&quot; }
  pro1 = { git = &quot;https://gitee.com/anotherorg/pro1&quot;, output-type = &quot;dynamic&quot; }
</code></pre>
<p>进行如上配置后，将会忽略 <code>pro0</code> 和 <code>pro1</code> 的 <code>cjpm.toml</code> 中的 <code>output-type</code> 配置，将这两个模块的产物分别编译成 <code>static</code> 和 <code>dynamic</code> 类型。</p>
<h3 id="test-dependencies"><a class="header" href="#test-dependencies">&quot;test-dependencies&quot;</a></h3>
<p>具有与 <code>dependencies</code> 字段相同的格式。它用于指定仅在测试过程中使用的依赖项，而不是构建主项目所需的依赖项。模块开发者应将此字段用于此模块的下游用户不需要感知的依赖项。</p>
<p><code>test-dependencies</code> 内的依赖仅可用于文件名形如 <code>xxx_test.cj</code> 的测试文件，在编译时这些依赖将不会被编译。<code>test-dependencies</code> 在 <code>cjpm.toml</code> 中的配置格式与 <code>dependencies</code> 相同。</p>
<h3 id="script-dependencies"><a class="header" href="#script-dependencies">&quot;script-dependencies&quot;</a></h3>
<p>具有与 <code>dependencies</code> 字段相同的格式。它用于指定仅在编译构建脚本中使用的依赖项，而不是构建主项目所需的依赖项。构建脚本相关功能将在<a href="source_zh_cn/tools/./cjpm_manual_cjnative_community.html#%E6%9E%84%E5%BB%BA%E8%84%9A%E6%9C%AC">其他-构建脚本</a>章节中详述。</p>
<h3 id="ffic"><a class="header" href="#ffic">&quot;ffi.c&quot;</a></h3>
<p>当前仓颉模块外部依赖 <code>c</code> 库的配置。该字段配置了依赖该库所需要的信息，包含库名和路径。</p>
<p>开发者需要自行编出动态库或静态库放到设置的 <code>path</code> 下，可参考下面的例子。</p>
<p>仓颉调用外部 <code>c</code> 动态库的方法说明：</p>
<ul>
<li>自行将相应的 <code>hello.c</code> 文件编成 <code>.so</code>库（在该文件路径执行 <code>clang -shared -fPIC hello.c -o libhello.so</code>）</li>
<li>修改该项目的 <code>cjpm.toml</code> 文件，配置 <code>ffi.c</code> 字段，如下面的例子所示。其中，<code>./src/</code> 是编出的 <code>libhello.so</code> 相对当前目录的地址，<code>hello</code> 为库名。</li>
<li>执行 <code>cjpm build</code>，即可编译成功。</li>
</ul>
<pre><code class="language-text">[ffi.c]
hello = { path = &quot;./src/&quot; }
</code></pre>
<h3 id="profile"><a class="header" href="#profile">&quot;profile&quot;</a></h3>
<p><code>profile</code> 作为一种命令剖面配置项，用于控制某个命令执行时的默认配置项。目前支持四种场景：<code>build</code>、<code>test</code>、<code>run</code> 和 <code>customized-option</code>。</p>
<h4 id="profilebuild"><a class="header" href="#profilebuild">&quot;profile.build&quot;</a></h4>
<pre><code class="language-text">[profile.build]
lto = &quot;full&quot;  # 是否开启 LTO （Link Time Optimization 链接时优化）优化编译模式，仅 linux 平台支持该功能。
incremental = true # 是否默认开启增量编译
</code></pre>
<p>编译流程的控制项，所有字段均可缺省，不配置时不生效，顶层模块设置的 <code>profile.build</code> 项才会生效。</p>
<p><code>lto</code> 配置项的取值为 <code>full</code> 或 <code>thin</code>，对应 LTO 优化支持的两种编译模式：full LTO 将所有编译模块合并到一起，在全局上进行优化，这种方式可以获得最大的优化潜力，同时也需要更长的编译时间；thin LTO 在多模块上使用并行优化，同时默认支持链接时增量编译，编译时间比 full LTO 短，但是因为失去了更多的全局信息，所以优化效果不如 full LTO。</p>
<h4 id="profiletest"><a class="header" href="#profiletest">&quot;profile.test&quot;</a></h4>
<pre><code class="language-text">[profile.test] # 使用举例
noColor = true
timeout-each = &quot;4m&quot;
randomSeed = 10
bench = true
reportPath = &quot;reports&quot;
reportFormat = &quot;xml&quot;
[profile.test.compilation-options]
  verbose = true
  no-run = false
  lto = &quot;thin&quot;
  mock = &quot;on&quot;
[profile.test.env]
MY_ENV = { value = &quot;abc&quot; }
cjHeapSize = { value = &quot;32GB&quot;, splice-type = &quot;replace&quot; }
PATH = { value = &quot;/usr/bin&quot;, splice-type = &quot;prepend&quot; }
</code></pre>
<p>测试配置支持指定编译和运行测试用例时的选项，所有字段均可缺省，不配置时不生效，顶层模块设置的 <code>profile.test</code> 项才会生效。选项列表与 <code>cjpm test</code> 提供的控制台执行选项一致。如果选项在配置文件和控制台中同时被配置，则控制台中的选项优先级高于配置文件中的选项。<code>profile.test</code> 支持的运行时选项：</p>
<ul>
<li><code>bench</code> 指定用例按性能用例方式执行，值为 <code>true</code> 或 <code>false</code></li>
<li><code>filter</code> 指定用例过滤器，参数值类型为字符串，格式与 <a href="source_zh_cn/tools/./cjpm_manual_cjnative_community.html#test">test 命令说明</a>中 <code>--filter</code> 的值格式一致</li>
<li><code>timeout-each &lt;value&gt;</code> value 的格式为 <code>%d[millis|s|m|h]</code>，为每个测试用例指定默认的超时时间</li>
<li><code>parallel</code> 指定测试用例并行执行的方案，<code>value</code> 的形式如下所示：
<ul>
<li><code>&lt;BOOL&gt;</code> 值为 <code>true</code> 或 <code>false</code>，指定为 <code>true</code> 时，测试类可被并行运行，并行进程个数将受运行系统上的 CPU 核数控制</li>
<li><code>nCores</code> 指定并行的测试进程个数应该等于可用的 CPU 核数</li>
<li><code>NUMBER</code> 指定并行的测试进程个数值。该数值应该为正整数</li>
<li><code>NUMBERnCores</code> 指定并行的测试进程个数值为可用的 CPU 核数的指定数值倍。该数值应该为正数（支持浮点数或整数）</li>
</ul>
</li>
<li><code>option:&lt;value&gt;</code> 与 <code>@Configuration</code> 协同定义运行选项。例如，如下选项：
<ul>
<li><code>randomSeed</code> 指定随机种子的值，参数值类型为正整数</li>
<li><code>noColor</code> 指定执行结果在控制台中是否无颜色显示，值为 <code>true</code> 或 <code>false</code></li>
<li><code>reportPath</code> 指定测试执行后的报告生成路径（不能通过 <code>@Configuration</code> 配置）</li>
<li><code>reportFormat</code> 指定报告输出格式，当前当前单元测试报告仅支持 <code>xml</code> 格式（可忽略大小写），使用其它值将会抛出异常（不能通过 <code>@Configuration</code> 配置）, 性能测试报告仅支持 <code>csv</code> 和 <code>csv-raw</code> 格式</li>
</ul>
</li>
<li><code>compilation-options</code> 为支持的编译选项，其列表如下：
<ul>
<li><code>verbose</code> 指定显示编译过程详细信息，参数值类型为 <code>BOOL</code>, 即值可为 <code>true</code> 或 <code>false</code></li>
<li><code>no-run</code> 指定仅编译单元测试产物，参数值类型为 <code>BOOL</code>, 即值可为 <code>true</code> 或 <code>false</code></li>
<li><code>lto</code> 指定是否开启 LTO 优化编译模式，该值可为 <code>thin</code> 或 <code>full</code> ，windows 平台暂不支持该功能</li>
<li><code>mock</code> 显式设置 mock 模式，可能的选项：<code>on</code>、<code>off</code>、<code>runtime-error</code></li>
</ul>
</li>
<li><code>env</code> 支持在 <code>test</code> 命令时运行可执行文件时配置临时环境变量，<code>key</code> 值为需要配置的环境变量的名称，有如下配置项：
<ul>
<li><code>value</code> 指定配置的环境变量值</li>
<li><code>splice-type</code> 指定环境变量的拼接方式，非必填，不配置时默认为 <code>absent</code>，共有以下四种取值：
<ul>
<li><code>absent</code>：该配置仅在环境内不存在同名环境变量时生效，若存在同名环境变量则忽略该配置</li>
<li><code>replace</code>：该配置会替代环境中已有的同名环境变量</li>
<li><code>prepend</code>：该配置会拼接在环境中已有的同名环境变量之前</li>
<li><code>append</code>：该配置会拼接在环境中已有的同名环境变量之后</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="profilerun"><a class="header" href="#profilerun">&quot;profile.run&quot;</a></h4>
<p>运行可执行文件时的选项，支持配置在 <code>run</code> 命令时运行可执行文件时的环境变量配置 <code>env</code>，配置方式同 <code>profile.test.env</code>。</p>
<h4 id="profilecustomized-option"><a class="header" href="#profilecustomized-option">&quot;profile.customized-option&quot;</a></h4>
<pre><code class="language-text">[profile.customized-option]
cfg1 = &quot;--cfg=\&quot;feature1=lion, feature2=cat\&quot;&quot;
cfg2 = &quot;--cfg=\&quot;feature1=tiger, feature2=dog\&quot;&quot;
cfg3 = &quot;-O2&quot;
</code></pre>
<p>自定义透传给 <code>cjc</code> 的选项，通过 <code>--cfg1 --cfg3</code> 使能，每个模块设置的 <code>customized-option</code> 对该模块内的所有包生效。例如，执行 <code>cjpm build --cfg1 --cfg3</code> 命令时，透传给 <code>cjc</code> 的命令则为 <code>--cfg=&quot;feature1=lion, feature2=cat&quot; -O2</code>。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>这里的条件值必须是一个合法的标识符。</p>
</blockquote>
<h3 id="target"><a class="header" href="#target">&quot;target&quot;</a></h3>
<p>多后端、多平台隔离选项，用于配置不同后端、不同平台情况下的一系列不同配置项。<code>target</code> 配置方式如下：</p>
<pre><code class="language-text">[target.x86_64-unknown-linux-gnu] # linux 系统的配置项
  compile-option = &quot;value1&quot; # 额外编译命令选项
  link-option = &quot;value2&quot; # 链接器透传选项
  [target.x86_64-unknown-linux-gnu.dependencies] # 源码依赖配置项
  [target.x86_64-unknown-linux-gnu.test-dependencies] # 测试阶段依赖配置项
  [target.x86_64-unknown-linux-gnu.bin-dependencies] # 仓颉二进制库依赖
    path-option = [&quot;./test/pro0&quot;, &quot;./test/pro1&quot;]
  [target.x86_64-unknown-linux-gnu.bin-dependencies.package-option]
    &quot;pro0.xoo&quot; = &quot;./test/pro0/pro0.xoo.cjo&quot;
    &quot;pro0.yoo&quot; = &quot;./test/pro0/pro0.yoo.cjo&quot;
    &quot;pro1.zoo&quot; = &quot;./test/pro1/pro1.zoo.cjo&quot;

[target.x86_64-w64-mingw32] # windows 系统的配置项
  compile-option = &quot;value3&quot;
  link-option = &quot;value4&quot;

[target.x86_64-unknown-linux-gnu.debug] # linux 系统的 debug 配置项
  [target.x86_64-unknown-linux-gnu.debug.test-dependencies]

[target.x86_64-unknown-linux-gnu.release] # linux 系统的 release 配置项
  [target.x86_64-unknown-linux-gnu.release.bin-dependencies]
</code></pre>
<p>开发者可以通过配置 <code>target.target-name</code> 字段为某个 <code>target</code> 添加一系列配置项。<code>target</code> 的名称可以在相应的仓颉环境下通过命令 <code>cjc -v</code> 获取，命令输出中的 <code>Target</code> 项目即为该环境对应的 <code>target</code> 名称。</p>
<p>可为特定 <code>target</code> 配置的专用配置项，将会适用于该 <code>target</code> 下的编译流程，同时也会适用于其他 <code>target</code> 指定该 <code>target</code> 作为目标平台的交叉编译流程。配置项列表如下：</p>
<ul>
<li><code>compile-option</code>：额外编译命令选项</li>
<li><code>link-option</code>：链接器透传选项</li>
<li><code>dependencies</code>：源码依赖配置项，结构同 <code>dependencies</code> 字段</li>
<li><code>test-dependencies</code>：测试阶段依赖配置项，结构同 <code>test-dependencies</code> 字段</li>
<li><code>bin-dependencies</code>：仓颉二进制库依赖，结构在下文中介绍</li>
<li><code>compile-macros-for-target</code>：交叉编译时的宏包控制项，该选项不支持区分下述的 <code>debug</code> 和 <code>release</code> 编译模式</li>
</ul>
<p>开发者可以通过配置 <code>target.target-name.debug</code> 和 <code>target.target-name.release</code> 字段为该 <code>target</code> 额外配置在 <code>debug</code> 和 <code>release</code> 编译模式下特有的配置，可配置的配置项同上。配置于此类字段的配置项将仅应用于该 <code>target</code> 的对应编译模式。</p>
<h4 id="targettarget-namedebugreleasebin-dependencies"><a class="header" href="#targettarget-namedebugreleasebin-dependencies">&quot;target.target-name[.debug/release].bin-dependencies&quot;</a></h4>
<p>该字段用于导入已编译好的、适用于指定 <code>target</code> 的仓颉库产物文件，以导入下述的 <code>pro0</code> 模块和 <code>pro1</code> 模块的三个包来举例说明。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>非特殊需求场景，不建议使用该字段，请使用上文介绍的 <code>dependencies</code> 字段导入模块源码。</p>
</blockquote>
<pre><code class="language-text">├── test
│   └── pro0
│       ├── libpro0.xoo.so
│       └── pro0.xoo.cjo
│       ├── libpro0.yoo.so
│       └── pro0.yoo.cjo
│   └── pro1
│       ├── libpro1.zoo.so
│       └── pro1.zoo.cjo
└── src
    └── main.cj
├── cjpm.toml
</code></pre>
<p>方式一，通过 <code>package-option</code> 导入：</p>
<pre><code class="language-text">[target.x86_64-unknown-linux-gnu.bin-dependencies.package-option]
  &quot;pro0.xoo&quot; = &quot;./test/pro0/pro0.xoo.cjo&quot;
  &quot;pro0.yoo&quot; = &quot;./test/pro0/pro0.yoo.cjo&quot;
  &quot;pro1.zoo&quot; = &quot;./test/pro1/pro1.zoo.cjo&quot;
</code></pre>
<p><code>package-option</code> 选项为 <code>map</code> 结构，<code>pro0.xoo</code> 名称作为 <code>key</code> (<code>toml</code> 配置文件中含有 <code>.</code> 的字符串作为整体时，需要用 <code>&quot;&quot;</code> 包含)，值为 <code>libpro0.xoo.so</code> 。前端文件 <code>cjo</code> 的路径作为 <code>value</code>，对应于该 <code>cjo</code> 的 <code>.a</code> 或 <code>.so</code> 需放置在相同路径下。</p>
<p>方式二，通过 <code>path-option</code> 导入：</p>
<pre><code class="language-text">[target.x86_64-unknown-linux-gnu.bin-dependencies]
  path-option = [&quot;./test/pro0&quot;, &quot;./test/pro1&quot;]
</code></pre>
<p><code>path-option</code> 选项为字符串数组结构，每个元素代表待导入的路径名称。<code>cjpm</code> 会自动导入该路径下所有符合规则的仓颉库包，这里的合规性是指库名称的格式为 <code>模块名.包名</code>。库名称不满足该规则的包只能通过 <code>package-option</code> 选项进行导入。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>如果同时通过 <code>package-option</code> 和 <code>path-option</code> 导入了相同的包，则 <code>package-option</code> 字段的优先级更高。</p>
</blockquote>
<p>其中，源码<code>main.cj</code> 调用 <code>pro0.xoo</code>、<code>pro0.yoo</code>、<code>pro1.zoo</code> 包的代码示例如下所示。</p>
<pre><code class="language-cangjie">import pro0.xoo.*
import pro0.yoo.*
import pro1.zoo.*

main(): Int64 {
    var res = x + y + z // x, y, z 分别为 pro0.xoo, pro0.yoo, pro1.zoo 中定义的值
    println(res)
    return 0
}
</code></pre>
<h4 id="targettarget-namecompile-macros-for-target"><a class="header" href="#targettarget-namecompile-macros-for-target">&quot;target.target-name.compile-macros-for-target&quot;</a></h4>
<p>该字段用于配置宏包的交叉编译方式，有如下三种情况：</p>
<p>方式一：宏包在交叉编译时默认仅编译本地平台的产物，不编译目标平台的产物，对该模块内的所有宏包生效</p>
<pre><code class="language-text">[target.目标平台]
  compile-macros-for-target = &quot;&quot;
</code></pre>
<p>方式二：在交叉编译时同时编译本地平台和目标平台的产物，对该模块内的所有宏包生效</p>
<pre><code class="language-text">[target.目标平台]
  compile-macros-for-target = &quot;all&quot; # 配置项为字符串形式，可选值必须为 all
</code></pre>
<p>方式三：指定该模块内的某些宏包在交叉编译时同时编译本地平台和目标平台的产物，其它未指定的宏包采取方式一的默认模式</p>
<pre><code class="language-text">[target.目标平台]
  compile-macros-for-target = [&quot;pkg1&quot;, &quot;pkg2&quot;] # 配置项为字符串数字形式，可选值是宏包名
</code></pre>
<h4 id="target-相关字段合并规则"><a class="header" href="#target-相关字段合并规则">&quot;target&quot; 相关字段合并规则</a></h4>
<p><code>target</code> 配置项中的内容可能同时存在于 <code>cjpm.toml</code> 的其他选项中，例如 <code>compile-option</code> 字段在 <code>package</code> 字段中也可以存在，区别在于 <code>package</code> 中的该字段会应用于全部 <code>target</code>。<code>cjpm</code> 对这些重复的字段会按照特定的方式将所有可应用的配置合并。以 <code>x86_64-unknown-linux-gnu</code> 的 <code>debug</code> 编译模式为例，有如下的 <code>target</code> 配置：</p>
<pre><code class="language-text">[package]
  compile-option = &quot;compile-0&quot;
  link-option = &quot;link-0&quot;

[dependencies]
  dep0 = { path = &quot;./dep0&quot; }

[test-dependencies]
  devDep0 = { path = &quot;./devDep0&quot; }

[target.x86_64-unknown-linux-gnu]
  compile-option = &quot;compile-1&quot;
  link-option = &quot;link-1&quot;
  [target.x86_64-unknown-linux-gnu.dependencies]
    dep1 = { path = &quot;./dep1&quot; }
  [target.x86_64-unknown-linux-gnu.test-dependencies]
    devDep1 = { path = &quot;./devDep1&quot; }
  [target.x86_64-unknown-linux-gnu.bin-dependencies]
    path-option = [&quot;./test/pro1&quot;]
  [target.x86_64-unknown-linux-gnu.bin-dependencies.package-option]
    &quot;pro1.xoo&quot; = &quot;./test/pro1/pro1.xoo.cjo&quot;

[target.x86_64-unknown-linux-gnu.debug]
  compile-option = &quot;compile-2&quot;
  link-option = &quot;link-2&quot;
  [target.x86_64-unknown-linux-gnu.debug.dependencies]
    dep2 = { path = &quot;./dep2&quot; }
  [target.x86_64-unknown-linux-gnu.debug.test-dependencies]
    devDep2 = { path = &quot;./devDep2&quot; }
  [target.x86_64-unknown-linux-gnu.debug.bin-dependencies]
    path-option = [&quot;./test/pro2&quot;]
  [target.x86_64-unknown-linux-gnu.debug.bin-dependencies.package-option]
    &quot;pro2.xoo&quot; = &quot;./test/pro2/pro2.xoo.cjo&quot;
</code></pre>
<p><code>target</code> 配置项在与 <code>cjpm.toml</code> 公共配置项或者相同 <code>target</code> 的其他级别的配置项共存时，按照如下的优先级合并：</p>
<ol>
<li><code>debug/release</code> 模式下对应 <code>target</code> 的配置</li>
<li><code>debug/release</code> 无关的对应 <code>target</code> 的配置</li>
<li>公共配置项</li>
</ol>
<p>以上述的 <code>target</code> 配置为例，<code>target</code> 各个配置项按照以下规则合并：</p>
<ul>
<li><code>compile-option</code>：将所有适用的同名配置项按照优先级拼接，优先级更高的配置拼接在后方。在本例中，在 <code>x86_64-unknown-linux-gnu</code> 的 <code>debug</code> 编译模式下，最终生效的 <code>compile-option</code> 值为 <code>compile-0 compile-1 compile-2</code>，在 <code>release</code> 编译模式下为 <code>compile-0 compile-1</code>，在其他 <code>target</code> 中为 <code>compile-0</code>。</li>
<li><code>link-option</code>：同上。</li>
<li><code>dependencies</code>：源码依赖将被直接合并，如果其中存在依赖冲突则会报错。在本例中，在 <code>x86_64-unknown-linux-gnu</code> 的 <code>debug</code> 编译模式下，最终生效的 <code>dependencies</code> 为 <code>dep0</code>, <code>dep1</code> 和 <code>dep2</code>，而在 <code>release</code> 编译模式下仅有 <code>dep0</code> 和 <code>dep1</code> 生效。在其他 <code>target</code> 中，仅有 <code>dep0</code> 生效。</li>
<li><code>test-dependencies</code>：同上。</li>
<li><code>bin-dependencies</code>：二进制依赖将按照优先级合并，如果有冲突则仅有优先级更高的依赖将会被加入，同优先级的配置先加入 <code>package-option</code> 配置。在本例中，在 <code>x86_64-unknown-linux-gnu</code> 的 <code>debug</code> 编译模式下，<code>./test/pro1</code> 和 <code>./test/pro2</code> 内的二进制依赖将被加入，而在 <code>release</code> 模式下仅会加入 <code>./test/pro1</code>。由于 <code>bin-dependencies</code> 没有公共配置，因此在其他 <code>target</code> 中不会有二进制依赖生效。</li>
</ul>
<p>在本例的交叉编译场景中，若在其他平台中指定了 <code>x86_64-unknown-linux-gnu</code> 作为目标 <code>target</code>，则 <code>target.x86_64-unknown-linux-gnu</code> 的配置也会按照上述规则与公共配置项合并并应用；如果处于 <code>debug</code> 编译模式，也将应用 <code>target.x86_64-unknown-linux-gnu.debug</code> 的配置项。</p>
<h2 id="配置和缓存文件夹"><a class="header" href="#配置和缓存文件夹">配置和缓存文件夹</a></h2>
<p><code>cjpm</code> 通过 <code>git</code> 下载文件的存储路径可以通过 <code>CJPM_CONFIG</code> 环境变量指定。如果未指定，则 linux 上的默认位置为 <code>$HOME/.cjpm</code>，windows 上的默认位置为 <code>%USERPROFILE%/.cjpm</code> 。</p>
<h2 id="其他"><a class="header" href="#其他">其他</a></h2>
<h3 id="命令扩展"><a class="header" href="#命令扩展">命令扩展</a></h3>
<p><code>cjpm</code> 提供命令扩展机制，开发者可以通过文件名形如 <code>cjpm-xxx(.exe)</code> 的可执行文件扩展 <code>cjpm</code> 的命令。</p>
<p>针对可执行文件 <code>cjpm-xxx</code>（<code>windows</code> 系统中为 <code>cjpm-xxx.exe</code>），若系统环境变量 <code>PATH</code> 中配置了该文件所在的路径，则可以使用如下的命令运行该可执行文件：</p>
<pre><code class="language-shell">cjpm xxx [args]
</code></pre>
<p>其中 <code>args</code> 为可能需要的输入给 <code>cjpm-xxx(.exe)</code> 的参数列表。上述命令等价于：</p>
<pre><code class="language-shell">cjpm-xxx(.exe) [args]
</code></pre>
<p>运行 <code>cjpm-xxx(.exe)</code> 可能会依赖某些动态库，在这种情况下，开发者需要手动将需要使用的动态库所在的目录添加到环境变量中。</p>
<p>下面以 <code>cjpm-demo</code> 为例，该可执行文件由以下仓颉代码编译得到：</p>
<pre><code class="language-cangjie">import std.os.*
import std.collection.*

main(): Int64 {
    var args = ArrayList&lt;String&gt;(getArgs())

    if (args.size &lt; 1) {
        eprintln(&quot;Error: failed to get parameters&quot;)
        return 1
    }

    println(&quot;Output: ${args[0]}&quot;)

    return 0
}
</code></pre>
<p>则在将其目录添加到 <code>PATH</code> 之后，运行对应命令，会运行该可执行文件并获得对应的输出。</p>
<pre><code class="language-text">输入：cjpm demo hello,world
输出：Output: hello,world
</code></pre>
<p><code>cjpm</code> 内部已有的命令优先级更高，因此无法用此方式扩展这些命令。例如，即使系统环境变量中存在名为 <code>cjpm-build</code> 的可执行文件，<code>cjpm build</code> 也不会运行该文件，而是运行 <code>cjpm</code> 并将 <code>build</code> 作为参数输入 <code>cjpm</code>。</p>
<h3 id="构建脚本"><a class="header" href="#构建脚本">构建脚本</a></h3>
<p><code>cjpm</code> 提供构建脚本机制，开发者可以在构建脚本中定义需要 <code>cjpm</code> 在某个命令前后的行为。</p>
<p>构建脚本源文件固定命名为 <code>build.cj</code>，位于仓颉项目主目录下，即与 <code>cjpm.toml</code> 同级。执行 <code>init</code> 命令新建仓颉项目时，<code>cjpm</code> 默认不创建 <code>build.cj</code>，开发者若有相关需求，可以自行按如下的模板格式在指定位置新建并编辑 <code>build.cj</code>。</p>
<pre><code class="language-cangjie">// build.cj

import std.os.*

// Case of pre/post codes for 'cjpm build'.
/* called before `cjpm build`
 * Success: return 0
 * Error: return any number except 0
 */
// func stagePreBuild(): Int64 {
//     // process before &quot;cjpm build&quot;
//     0
// }

/*
 * called after `cjpm build`
 */
// func stagePostBuild(): Int64 {
//     // process after &quot;cjpm build&quot;
//     0
// }

// Case of pre/post codes for 'cjpm clean'.
/* called before `cjpm clean`
 * Success: return 0
 * Error: return any number except 0
 */
// func stagePreClean(): Int64 {
//     // process before &quot;cjpm clean&quot;
//     0
// }

/*
 * called after `cjpm clean`
 */
// func stagePostClean(): Int64 {
//     // process after &quot;cjpm clean&quot;
//     0
// }

// For other options, define stagePreXXX and stagePostXXX in the same way.

/*
 * Error code:
 * 0: success.
 * other: cjpm will finish running command. Check target-dir/build-script-cache/module-name/script-log for error outputs defind by user in functions.
 */

main(): Int64 {
    match (getArgs()[0]) {
        // Add operation here with format: &quot;pre-&quot;/&quot;post-&quot; + optionName
        // case &quot;pre-build&quot; =&gt; stagePreBuild()
        // case &quot;post-build&quot; =&gt; stagePostBuild()
        // case &quot;pre-clean&quot; =&gt; stagePreClean()
        // case &quot;post-clean&quot; =&gt; stagePostClean()
        case _ =&gt; 0
    }
}
</code></pre>
<p><code>cjpm</code> 针对一系列命令支持使用构建脚本定义命令前后行为。例如，针对 <code>build</code> 命令，可在 <code>main</code> 函数中的 <code>match</code> 内定义 <code>pre-build</code>，执行想要在 <code>build</code> 命令执行前需要执行的功能函数 <code>stagePreBuild</code>（功能函数的命名不做要求）。<code>build</code> 命令后的行为可以以相同的方式通过添加 <code>post-build</code> 的 <code>case</code> 选项定义。针对其他命令的命令前后行为的定义类似，只需要添加相应的 <code>pre/post</code> 选项和对应的功能函数即可。</p>
<p>在定义某一命令前后的行为后，<code>cjpm</code> 在执行该命令时会首先编译 <code>build.cj</code>，并在执行前后执行对应的行为。同样以 <code>build</code> 为例，在定义了 <code>pre-build</code> 和 <code>post-build</code> 后运行 <code>cjpm build</code>，则会按照如下步骤运行整个 <code>cjpm build</code> 流程：</p>
<ol>
<li>进行编译流程前，首先编译 <code>build.cj</code>；</li>
<li>执行 <code>pre-build</code> 对应的功能函数；</li>
<li>进行 <code>cjpm build</code> 编译流程；</li>
<li>编译流程顺利结束后，<code>cjpm</code> 会执行 <code>post-build</code> 对应的功能函数。</li>
</ol>
<p>构建脚本支持的命令如下：</p>
<ul>
<li><code>build</code>, <code>test</code>：同时支持执行依赖模块构建脚本中定义的 <code>pre</code> 和 <code>post</code> 流程</li>
<li><code>run</code>, <code>install</code>：仅支持运行对应模块的 <code>pre</code> 和 <code>post</code> 构建脚本流程，或者在进行编译时执行依赖模块的 <code>pre-build</code> 和 <code>post-build</code> 流程</li>
<li><code>check</code>, <code>tree</code>, <code>update</code>, <code>publish</code>：仅支持运行对应模块的 <code>pre</code> 和 <code>post</code> 构建脚本流程</li>
<li><code>clean</code>：仅支持运行对应模块的 <code>pre</code> 构建脚本流程</li>
</ul>
<p>在执行这些命令时，若配置了 <code>--skip-script</code> 选项，则会跳过所有构建脚本的编译运行，包括依赖模块的构建脚本。</p>
<p>构建脚本的使用说明如下：</p>
<ul>
<li>功能函数的返回值需要满足一定要求：当功能函数执行成功时，需要返回 <code>0</code>；执行失败时返回除 <code>0</code> 以外的任意 <code>Int64</code> 类型变量。</li>
<li><code>build.cj</code> 中的所有输出都将被重定向到项目目录下，路径为 <code>build-script-cache/[target|release]/[module-name]/bin/script-log</code>。开发者如果在功能函数中添加了一些输出内容，可在该文件中查看。</li>
<li>若项目根目录下不存在 <code>build.cj</code>，则 <code>cjpm</code> 将按正常流程执行；若存在 <code>build.cj</code> 并定义了某一命令的前后行为，则在 <code>build.cj</code> 编译失败或者功能函数返回值不为 <code>0</code> 时，即使该命令本身能够顺利执行，命令也将异常中止。</li>
<li>多模块场景下，被依赖模块的 <code>build.cj</code> 构建脚本会在编译和单元测试流程中生效。被依赖模块构建脚本中的输出同样重定向到 <code>build-script-cache/[target|release]</code> 下对应模块名目录中的日志文件。</li>
</ul>
<p>例如，下面的构建脚本 <code>build.cj</code> 定义了 <code>build</code> 前后的行为：</p>
<pre><code class="language-cangjie">import std.os.*

func stagePreBuild(): Int64 {
    println(&quot;PRE-BUILD&quot;)
    0
}

func stagePostBuild(): Int64 {
    println(&quot;POST-BUILD&quot;)
    0
}

main(): Int64 {
    match (getArgs()[0]) {
        case &quot;pre-build&quot; =&gt; stagePreBuild()
        case &quot;post-build&quot; =&gt; stagePostBuild()
        case _ =&gt; 0
    }
}
</code></pre>
<p>则在执行 <code>cjpm build</code> 命令时，<code>cjpm</code> 将会执行 <code>stagePreBuild</code> 和 <code>stagePostBuild</code>。<code>cjpm build</code> 执行完成后，<code>script-log</code> 日志文件内会有如下输出：</p>
<pre><code class="language-text">PRE-BUILD
POST-BUILD
</code></pre>
<p>构建脚本可以通过 <code>cjpm.toml</code> 中的 <code>script-dependencies</code> 字段导入依赖模块，格式同 <code>dependencies</code>。例如，在 <code>cjpm.toml</code> 中有如下配置，导入了 <code>aoo</code> 模块，并且 <code>aoo</code> 模块内有一个名为 <code>aaa()</code> 的方法：</p>
<pre><code class="language-text">[script-dependencies]
aoo = { path = &quot;./aoo&quot; }
</code></pre>
<p>则可以在构建脚本中导入该依赖，使用依赖中的接口 <code>aaa()</code>：</p>
<pre><code class="language-cangjie">import std.os.*
import aoo.*

func stagePreBuild(): Int64 {
    aaa()
    0
}

func stagePostBuild(): Int64 {
    println(&quot;POST-BUILD&quot;)
    0
}

main(): Int64 {
    match (getArgs()[0]) {
        case &quot;pre-build&quot; =&gt; stagePreBuild()
        case &quot;post-build&quot; =&gt; stagePostBuild()
        case _ =&gt; 0
    }
}
</code></pre>
<p>构建脚本依赖 <code>script-dependencies</code> 与源码相关依赖（源码依赖项 <code>dependencies</code> 和测试依赖项 <code>test-dependencies</code>）相互独立，源码和测试代码无法使用 <code>script-dependencies</code> 中的依赖模块，构建脚本也无法使用 <code>dependencies</code> 和 <code>test-dependencies</code> 中的依赖模块。若需要在构建脚本和源码/测试代码中使用同一模块，需要在 <code>script-dependencies</code> 和 <code>dependencies/test-dependencies</code> 中同时配置。</p>
<h2 id="使用示例"><a class="header" href="#使用示例">使用示例</a></h2>
<p>以下面仓颉项目的目录结构为例，介绍 <code>cjpm</code> 的使用方法，该目录下对应的源码文件示例可见<a href="source_zh_cn/tools/./cjpm_manual_cjnative_community.html">源代码</a>。该仓颉项目的模块名为 <code>test</code>。</p>
<pre><code class="language-text">cj_project
│   ├── pro0
│   │   ├── cjpm.toml
│   │   └── src
│   │       └── zoo
│   │           ├── zoo.cj
│   │           └── zoo_test.cj
│   │       ├── pro0.cj
│   └── src
│       ├── koo
│       │   ├── koo.cj
│       │   └── koo_test.cj
│       ├── main.cj
│       └── main_test.cj
│   ├── cjpm.toml
</code></pre>
<h3 id="initbuild-的使用"><a class="header" href="#initbuild-的使用">init、build 的使用</a></h3>
<ul>
<li>
<p>新建仓颉项目并编写源码 <code>xxx.cj</code> 文件，如示例结构所示的 <code>koo</code> 包和 <code>main.cj</code> 文件。</p>
<pre><code class="language-shell">cjpm init --name test --path .../cj_project
mkdir koo
</code></pre>
<p>此时，会自动生成 <code>src</code> 文件夹和默认的 <code>cjpm.toml</code> 配置文件。</p>
</li>
<li>
<p>当前模块需要依赖外部的 <code>pro0</code> 模块时，可以新建 <code>pro0</code> 模块及该模块的配置文件，接下来编写该模块的源码文件，需要自行在 <code>pro0</code> 下新建 <code>src</code> 文件夹，在 <code>src</code> 下新建 <code>pro0</code> 的 root 包 <code>pro0.cj</code>，并将编写的仓颉包放置在 <code>src</code> 下，如示例结构所示的 <code>zoo</code> 包。</p>
<pre><code class="language-shell">mkdir pro0 &amp;&amp; cd pro0
cjpm init --name pro0 --type=static
mkdir src/zoo
</code></pre>
</li>
<li>
<p>主模块依赖 <code>pro0</code> 时，需要按照手册说明去配置主模块配置文件的 <code>dependencies</code> 字段。配置无误后，执行 <code>cjpm build</code> 即可，生成的可执行文件在 <code>target/release/bin/</code> 目录下。</p>
<pre><code class="language-shell">cd cj_project
vim cjpm.toml
cjpm build
cjpm run
</code></pre>
</li>
</ul>
<h3 id="testclean-的使用"><a class="header" href="#testclean-的使用">test、clean 的使用</a></h3>
<ul>
<li>
<p>按示例结构，编写完每个文件对应的 <code>xxx_test.cj</code> 单元测试文件后，可以执行下述代码进行单元测试，生成的文件在 <code>target/release/unittest_bin</code> 目录下。</p>
<pre><code class="language-shell">cjpm test
</code></pre>
<p>或者</p>
<pre><code class="language-shell">cjpm test src src/koo pro/src/zoo
</code></pre>
</li>
<li>
<p>想要手动删除 <code>target</code> 、<code>cov_output</code> 文件夹、<code>*.gcno</code> 、<code>*.gcda</code> 等中间件时。</p>
<pre><code class="language-shell">cjpm clean
</code></pre>
</li>
</ul>
<h3 id="示例的源代码"><a class="header" href="#示例的源代码">示例的源代码</a></h3>
<p>cj_project/src/main.cj</p>
<pre><code class="language-cangjie">package test

import pro0.zoo.*
import test.koo.*

main(): Int64 {
    let res = z + k
    println(res)
    let res2 = concatM(&quot;a&quot;, &quot;b&quot;)
    println(res2)
    return 0
}

func concatM(s1: String, s2: String): String {
    return s1 + s2
}
</code></pre>
<p>cj_project/src/main_test.cj</p>
<pre><code class="language-cangjie">package test

import std.unittest.*//testfame
import std.unittest.testmacro.*//macro_Defintion

@Test
public class TestM{
    @TestCase
    func sayhi(): Unit {
        @Assert(concatM(&quot;1&quot;, &quot;2&quot;), &quot;12&quot;)
        @Assert(concatM(&quot;1&quot;, &quot;3&quot;), &quot;13&quot;)
    }
}
</code></pre>
<p>cj_project/src/koo/koo.cj</p>
<pre><code class="language-cangjie">package test.koo

public let k: Int32 = 12

func concatk(s1: String, s2: String): String {
    return s1 + s2
}
</code></pre>
<p>cj_project/src/koo/koo_test.cj</p>
<pre><code class="language-cangjie">package test.koo

import std.unittest.*//testfame
import std.unittest.testmacro.*//macro_Defintion

@Test
public class TestK{
    @TestCase
    func sayhi(): Unit {
        @Assert(concatk(&quot;1&quot;, &quot;2&quot;), &quot;12&quot;)
        @Assert(concatk(&quot;1&quot;, &quot;3&quot;), &quot;13&quot;)
    }
}
</code></pre>
<p>cj_project/pro0/src/pro0.cj</p>
<pre><code class="language-cangjie">package pro0
</code></pre>
<p>cj_project/pro0/src/zoo/zoo.cj</p>
<pre><code class="language-cangjie">package pro0.zoo

public let z: Int32 = 26

func concatZ(s1: String, s2: String): String {
    return s1 + s2
}
</code></pre>
<p>cj_project/pro0/src/zoo/zoo_test.cj</p>
<pre><code class="language-cangjie">package pro0.zoo

import std.unittest.*//testfame
import std.unittest.testmacro.*//macro_Defintion

@Test
public class TestZ{
    @TestCase
    func sayhi(): Unit {
        @Assert(concatZ(&quot;1&quot;, &quot;2&quot;), &quot;12&quot;)
        @Assert(concatZ(&quot;1&quot;, &quot;3&quot;), &quot;13&quot;)
    }
}
</code></pre>
<p>cj_project/cjpm.toml</p>
<pre><code class="language-text">[package]
cjc-version = &quot;0.40.2&quot;
description = &quot;nothing here&quot;
version = &quot;1.0.0&quot;
name = &quot;test&quot;
output-type = &quot;executable&quot;

[dependencies]
pro0 = { path = &quot;pro0&quot; }
</code></pre>
<p>cj_project/pro0/cjpm.toml</p>
<pre><code class="language-text">[package]
cjc-version = &quot;0.40.2&quot;
description = &quot;nothing here&quot;
version = &quot;1.0.0&quot;
name = &quot;pro0&quot;
output-type = &quot;static&quot;
</code></pre>
<h1 id="命令行模式覆盖率统计"><a class="header" href="#命令行模式覆盖率统计">命令行模式覆盖率统计</a></h1>
<h2 id="功能简介-4"><a class="header" href="#功能简介-4">功能简介</a></h2>
<p><code>cjcov</code>（Cangjie Coverage）是仓颉语言的官方覆盖率统计工具，用于生成仓颉语言程序的覆盖率报告。</p>
<h2 id="使用说明-3"><a class="header" href="#使用说明-3">使用说明</a></h2>
<p>通过 <code>cjcov -h</code> 即可查看命令使用方法，如下所示。由几个板块组成，从上到下分别是：当前命令使用形式（Usage）、当前命令用途、支持的可用参数（Options）。</p>
<pre><code class="language-text">Usage: cjcov [options]

A tool used to summarize the coverage in html reports.

Options:
  -v, --version                 Print the version number, then exit.
  -h, --help                    Show this help message, then exit.
  -r ROOT, --root=ROOT          The root directories of your source files, defaults to '.', the current directory.
                                File names are reported relative to this root.
  -o OUTPUT, --output=OUTPUT    The output directories of html reports, defaults to '.', the current directory.
  -b, --branches                Report the branch coverage. (It is an experimental feature and may generate imprecise branch coverage.)
  --verbose                     Print some detail messages, including parsing data for the gcov file.
  --html-details                Generate html reports for each source file.
  -x, --xml                     Generate a xml report.
  -j, --json                    Generate a json report.
  -k, --keep                    Keep gcov files after processing.
  -s SOURCE, --source=SOURCE    The directories of cangjie source files.
  -e EXCLUDE, --exclude=EXCLUDE
                                The cangjie source files starts with EXCLUDE will not be showed in coverage reports.
  -i INCLUDE, --include=INCLUDE
                                The cangjie source files starts with INCLUDE will be showed in coverage reports.
</code></pre>
<p>基本的命令使用方法如下所示，<code>cjcov</code> 为主程序名称，<code>--version</code> 表示为显示 <code>cjcov</code> 的版本号。部分配置项支持长短选项两种写法，效果相同，具体可以使用 <code>cjcov --help</code> 命令参考用法。</p>
<pre><code class="language-text">cjcov -version 或者 cjcov -v
</code></pre>
<h3 id="使用步骤"><a class="header" href="#使用步骤">使用步骤</a></h3>
<p>仓颉版本包准备 --&gt; 仓颉源码准备 --&gt;  使用 <code>--coverage</code> 编译选项构建仓颉源码，生成二进制文件 --&gt; 执行二进制文件 --&gt; <code>cjcov</code> 生成覆盖率统计结果</p>
<p>下面举一个 <code>hello world</code> 的覆盖率的例子（假设当前目录是 <code>WORKPATH</code>）：</p>
<ol>
<li>
<p>仓颉版本包准备</p>
<p>假设仓颉版本包解压在 <code>WORKPATH</code> 目录下，则执行 <code>source WORKPATH/cangjie/envsetup.sh</code> 命令即可。</p>
</li>
<li>
<p>仓颉源码准备</p>
<p>源码目录结构如下：</p>
<pre><code>src/
└── main.cj
</code></pre>
<p><code>main.cj</code> 源码内容如下：</p>
<pre><code>main(): Int64 {
    print(&quot;hello world\n&quot;)
    return 0
}
</code></pre>
</li>
<li>
<p>编译源码，该例子用 <code>cjpm</code> 编译举例</p>
<p>在 <code>WORKPATH</code> 目录下执行以下命令：</p>
<pre><code>cjpm init cangjie test
cjpm build --coverage
</code></pre>
<p>编译完成之后在 <code>WORKPATH</code> 目录下会生成 <code>default.gcno</code> 文件。</p>
</li>
<li>
<p>运行编译出来的二进制</p>
<p>在 <code>WORKPATH</code> 目录下执行 <code>cjpm run --skip-build</code> 命令，运行完成之后 <code>WORKPATH</code> 目录下会生成 <code>default.gcda</code> 文件。</p>
</li>
<li>
<p><code>cjcov</code> 生成 <code>html</code></p>
<p>在 <code>WORKPATH</code> 目录执行 <code>cjcov -o output --html-details</code>，更多 <code>cjcov</code> 参数使用可参考<a href="source_zh_cn/tools/./cjpm_manual_cjnative_community.html#cjcov--h----help">命令说明</a>章节。</p>
</li>
</ol>
<p>执行完 <code>cjcov</code> 命令之后，在 <code>WORKPATH/output</code> 目录会有以下文件：</p>
<pre><code>output
├── cjcov_logs （该目录存放一些 cjcov 执行过程的详细日志，可不用关注）
│   ├── cjcov.log
│   └── gcov_parse.log
├── index.html （总的覆盖率报告，通过浏览器打开）
└── src_main.cj.html （单个文件的覆盖率，可以通过打开 index.html 自动跳转到该文件）
</code></pre>
<h2 id="命令说明-1"><a class="header" href="#命令说明-1">命令说明</a></h2>
<h3 id="cjcov--h----help"><a class="header" href="#cjcov--h----help">cjcov -h | --help</a></h3>
<p>显示 <code>cjcov</code> 基本使用方法。</p>
<h3 id="cjcov--v----version"><a class="header" href="#cjcov--v----version">cjcov -v | --version</a></h3>
<p>显示 <code>cjcov</code> 的版本号，只要指定了 <code>-v</code> 或者 <code>--version</code> 参数，不管输入其他任何选项参数都不生效，只会显示版本号。如 <code>--version</code> 和 <code>--help</code> 同时使用，则显示 <code>version</code> 信息后退出。</p>
<h3 id="cjcov---verbose"><a class="header" href="#cjcov---verbose">cjcov --verbose</a></h3>
<p>指定该选项后会将一些日志信息生成到 <code>cjcov_logs</code> 目录中，该参数默认不生效，即默认不会打印中间信息。<code>gcov</code> 文件是 <code>cjcov</code> 工具生成的中间文件，<code>cjcov</code> 解析 <code>gcov</code> 文件的格式如下：</p>
<pre><code class="language-text">==================== start: main.cj.gcov =====================

noncode line numbers:
[0, 0, 0, 0, 1, 2, 6, 7, 9, 10, 11, 15, 17, 18]

uncovered line numbers:
[5]

covered data:
[(16, 1), (3, 1), (4, 1), (8, 1), (12, 1), (13, 1), (14, 1)]

branches data:
line number:    4  ==&gt;  data: [(0, 0), (1, 1)]

===================== end: main.cj.gcov =======================

</code></pre>
<p>指定该选项参数，会显示每个 <code>gcov</code> 文件的详细覆盖率数据。</p>
<p>具体字段解释如下：</p>
<ul>
<li><code>start: xxx.gcov, end: xxx.gcov</code>：两行中间的文本是对应 <code>xxx.gcov</code> 文件解析到的覆盖率数据。</li>
<li><code>noncode line numbers</code>：显示的是不统计到总代码行的行号，在 <code>html</code> 中是以白色底呈现，对应 <code>gcov</code> 中的以 <code>-</code> 开头的行数。</li>
<li><code>uncovered line numbers</code>：显示的是没有覆盖到的数据，在 <code>html</code> 中是以红色底呈现，对应 <code>gcov</code> 文件中以 <code>#####</code> 开头的行数。</li>
<li><code>covered data</code>：显示的是覆盖到的数据，以<code>(代码行数, 覆盖次数)</code>呈现，在对应 <code>html</code> 中以绿色呈现，只要覆盖次数大于 0，在 <code>html</code> 中的 <code>Exec</code> 一列中显示为 <code>Y</code>，对应于 <code>gcov</code> 文件以数字开头的行数。</li>
<li><code>branches data</code>：显示的分支覆盖数据，以<code>(代码行数, 分支覆盖次数)</code>呈现，在对应 <code>html</code> 中的 <code>Branch</code> 一列中，有一个倒三角形，显示的是分支覆盖数/总分支数。该数据对应于 <code>gcov</code> 文件中以 <code>branch</code> 开头的数据。</li>
</ul>
<h3 id="cjcov---html-details"><a class="header" href="#cjcov---html-details">cjcov --html-details</a></h3>
<p>如果指定该参数，表示会生成仓颉文件对应的 <code>html</code>。在总的 <code>index</code> 文件里面会有每个子 <code>html</code> 的索引。子 <code>html</code> 文件和 <code>index.html</code> 放在同一个目录。</p>
<p>子 <code>html</code> 文件名是由目录和文件名由下划线拼接起来。如源文件是 <code>src/main.cj</code>，生成的 <code>html</code> 名字为 <code>src_main.cj.html</code>。如果源文件路径带有特殊字符会被替换成 <code>=</code>，下文<a href="source_zh_cn/tools/./cjpm_manual_cjnative_community.html#%E6%96%87%E4%BB%B6%E5%90%8D%E5%8C%85%E5%90%AB%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6">文件名包含特殊字符</a>章节会有更详细的描述。</p>
<p>如果没有指定该参数，表示不会生成子 <code>html</code> 。在总的 <code>index</code> 文件里面会显示每个子 <code>html</code> 的覆盖率数据，但是不能跳转到对应的子 <code>html</code> 文件。</p>
<p>该参数默认不生效。即默认只会生成一个 <code>index.html</code>, 不会生成子 <code>html</code> 文件。</p>
<h3 id="cjcov--x----xml"><a class="header" href="#cjcov--x----xml">cjcov -x | --xml</a></h3>
<p>如果指定该参数，则会在指定输出路径生成 <code>coverage.xml</code> 文件，<code>coverage.xml</code> 记录的是所有文件的覆盖率数据。</p>
<h3 id="cjcov--j----json"><a class="header" href="#cjcov--j----json">cjcov -j | --json</a></h3>
<p>如果指定该参数，则会在指定输出路径生成 <code>coverage.json</code> 文件，<code>coverage.json</code> 记录的是所有文件的覆盖率数据。</p>
<h3 id="cjcov--k-----keep"><a class="header" href="#cjcov--k-----keep">cjcov -k |  --keep</a></h3>
<p>指定该参数后则不会删除生成的 <code>gcov</code> 中间文件。如果 <code>gcov</code> 文件不删除，会造成执行次数的累加，可能会影响覆盖率数据的准确性。</p>
<p>默认该参数不生效，即默认会删除 <code>gcov</code> 中间文件。</p>
<h3 id="cjcov--b----branches"><a class="header" href="#cjcov--b----branches">cjcov -b | --branches</a></h3>
<p>指定该参数后则会生成分支覆盖率信息。</p>
<p>默认该参数不生效，即默认不生成分支的覆盖率信息，此时在 <code>html</code> 报告中的分支覆盖率数据百分比显示为 <code>-</code>。</p>
<h3 id="cjcov--r-root----rootroot"><a class="header" href="#cjcov--r-root----rootroot">cjcov -r ROOT | --root=ROOT</a></h3>
<p>该参数指定的 <code>ROOT</code> 参数，表示在 <code>ROOT</code> 目录或者在其递归子目录能找到 <code>gcda</code> 文件，<code>gcda</code> 和 <code>gcno</code> 文件默认会生成在一起，建议不要手动特意去把 <code>gcda</code> 文件和 <code>gcno</code> 文件分开存放，不然可能会发生程序不能运行的情况。</p>
<p>参数指定的 <code>ROOT</code> 目录如果不存在，<code>cjcov</code> 工具会有报错提示。</p>
<p>不指定该参数，默认会以当前目录为 <code>ROOT</code> 目录。</p>
<h3 id="cjcov--o-output-----outputoutput"><a class="header" href="#cjcov--o-output-----outputoutput">cjcov -o OUTPUT |  --output=OUTPUT</a></h3>
<p>该参数指定的 <code>OUTPUT</code> 参数，表示 <code>html</code> 覆盖率报告的输出路径。</p>
<p>如果该 <code>OUTPUT</code> 目录不存在，而且其父目录也不存在，<code>cjcov</code> 工具会有报错提示；如果 <code>OUTPUT</code> 目录不存在，但其父目录存在，<code>cjcov</code> 会帮助创建 <code>OUTPUT</code> 目录。</p>
<p>不指定该参数，默认会以当前目录为 <code>OUTPUT</code> 目录来存放 <code>html</code> 文件。</p>
<h3 id="-s-source----sourcesource"><a class="header" href="#-s-source----sourcesource">-s SOURCE | --source=SOURCE</a></h3>
<p>该参数指定的 <code>SOURCE</code> 参数，表示仓颉源文件的代码路径，<code>html</code> 总覆盖率报告 <code>index.html</code> 会有各个源文件的索引，这些文件路径记录的是一个相对路径。如果指定 <code>-s SOURCE |--source SOURCE</code> 参数，优先以 <code>SOURCE</code> 路径列表中的路径作为相对路径的参考路径，如果没有指定该参数，则以 <code>-r ROOT | --root=ROOT</code> 作为相对路径的参考路径，如果都没有指定，则以当前路径作为相对路径的参考路径。</p>
<p>示例：</p>
<p>仓颉代码目录结构如下：</p>
<pre><code>/work/cangjie/tests/API/test01/src/1.cj
/work/cangjie/tests/API/test01/src/2.cj
/work/cangjie/tests/LLVM/test02/src/3.cj
/work/cangjie-tools/tests/LLVM/test01/src/4.cj
/work/cangjie-tools/tests/LLVM/test02/src/5.cj
</code></pre>
<ol>
<li>
<p>在 <code>/work</code> 目录执行命令：</p>
<pre><code>cjcov --root=./ -s &quot;/work/cangjie /work/cangjie-tools/tests&quot; --html-details --output=html_output
</code></pre>
<p>最后 html 中呈现的源文件相对路径是：</p>
<pre><code>tests/API/test01/src/1.cj
tests/API/test01/src/2.cj
tests/LLVM/test02/src/3.cj
LLVM/test01/src/4.cj
LLVM/test02/src/5.cj
</code></pre>
</li>
<li>
<p>在 <code>/work</code> 目录执行命令, 没有指定 <code>--root</code> 参数和 <code>--source</code> 参数，默认当前所在路径为相对路径的参考路径，执行命令如下：</p>
<pre><code>cjcov --html-details --output=html_output
</code></pre>
<p>最后 html 中呈现的源文件相对路径是：</p>
<pre><code>cangjie/tests/API/test01/src/1.cj
cangjie/tests/API/test01/src/2.cj
cangjie/tests/LLVM/test02/src/3.cj
cangjie-tools/tests/LLVM/test01/src/4.cj
cangjie-tools/tests/LLVM/test02/src/5.cj
</code></pre>
</li>
</ol>
<h3 id="-e-exclude----excludeexclude"><a class="header" href="#-e-exclude----excludeexclude">-e EXCLUDE | --exclude=EXCLUDE</a></h3>
<p>该参数指定的 <code>EXCLUDE</code> 参数，表示不需要生成覆盖率信息的源文件列表，支持指定目录和文件。</p>
<p>示例：</p>
<p>仓颉代码目录结构如下：</p>
<pre><code>/usr1/cangjie/tests/API/test01/src/1.cj
/usr1/cangjie/tests/API/test01/src/2.cj
/usr1/cangjie/tests/LLVM/test02/src/3.cj
/usr1/cangjie-tools/tests/LLVM/test01/src/4.cj
/usr1/cangjie-tools/tests/LLVM/test02/src/5.cj
</code></pre>
<p>在 <code>/usr1</code> 目录执行命令：</p>
<pre><code>cjcov --root=./ -s &quot;/usr1/cangjie&quot; -e &quot;/usr1/cangjie-tools/tests/LLVM&quot; --html-details --output=html_output
</code></pre>
<p>最后 <code>html</code> 中呈现的源文件相对路径是,其中以 <code>/usr1/cangjie-tools/tests/LLVM</code> 路径开头的文件不会出现在 <code>html</code> 的文件列表中。</p>
<pre><code>tests/API/test01/src/1.cj
tests/API/test01/src/2.cj
tests/LLVM/test02/src/3.cj
</code></pre>
<h3 id="-i-include----includeinclude"><a class="header" href="#-i-include----includeinclude">-i INCLUDE | --include=INCLUDE</a></h3>
<p>该参数指定的 <code>INCLUDE</code> 参数，表示以 <code>INCLUDE</code> 开头的文件会显示在 <code>index.html</code> 的文件列表中，支持指定目录和文件。如果 <code>-e | --exclude</code> 和 <code>-i | --include</code> 指定的参数有路径重复，会有报错提示。</p>
<p>示例：</p>
<p>仓颉代码目录 <code>/usr1/cangjie/tests</code> 结构如下：</p>
<pre><code>├── API
│   └── test01
│       └── src
│           ├── 1.cj
│           └── 2.cj
└── LLVM
    └── test02
        └── src
            └── 3.cj
</code></pre>
<p>在 <code>/usr1</code> 目录执行命令, 其中 <code>-i</code> 参数表示需要体现在覆盖率报告 <code>index.html</code> 的文件，命令如下：</p>
<pre><code>cjcov --root=./ -s &quot;/usr1/cangjie&quot; -i &quot;/usr1/cangjie/tests/API/test01/src/1.cj /usr1/cangjie/tests/LLVM/test02&quot; --html-details --output=html_output
</code></pre>
<p>上面命令执行后, 在 <code>index.html</code> 中文件路径列表如下(<code>tests/API/test01/src/2.cj</code> 不在 <code>-i</code> 参数指定的列表里面，所以不会出现在 <code>html</code> 的文件列表中):</p>
<pre><code>tests/API/test01/src/1.cj
tests/LLVM/test02/src/3.cj
</code></pre>
<h2 id="特殊场景"><a class="header" href="#特殊场景">特殊场景</a></h2>
<h3 id="二进制无法正常执行结束"><a class="header" href="#二进制无法正常执行结束">二进制无法正常执行结束</a></h3>
<p>对于常驻的网络服务程序无法正常结束二进制文件并生成 <code>gcda</code> 覆盖率数据的场景，需要手动执行退出脚本生成 <code>gcda</code> 覆盖率数据。</p>
<p>1）将以下脚本内容保存为 <code>stop.sh</code>（此脚本执行依赖 <code>gdb</code>）</p>
<pre><code class="language-shell">#!/bin/sh
SERVER_NAME=$1

pid=`ps -ef | grep $SERVER_NAME | grep -v &quot;grep&quot; | awk '{print $2}'`
echo $pid
gdb -q attach $pid &lt;&lt;__EOF__
p exit(0)
__EOF__
</code></pre>
<p>2）常驻服务程序完成业务逻辑操作覆盖后，执行 <code>stop.sh {service_name}</code>，如通过 <code>./main</code> 启动常驻服务进程，通过如下方式停止进程产生 <code>gcda</code> 数据</p>
<pre><code class="language-shell">sh stop.sh ./main
</code></pre>
<h3 id="文件名包含特殊字符"><a class="header" href="#文件名包含特殊字符">文件名包含特殊字符</a></h3>
<p>建议遵循仓颉编程规范命名文件，不建议包含除 [0-9a-zA-Z_] 之外的字符，特殊字符会被替换成 <code>=</code>。</p>
<p>如果文件名有特殊字符，为保证 <code>html</code> 跳转正确，<code>index.html</code> 中呈现的 <code>html</code> 名字和 <code>html</code> 本身文件名会不一致，<code>html</code> 文件名的特殊字符都会被替换成 <code>=</code>。</p>
<p>示例如下：</p>
<p>代码结构：</p>
<pre><code>src
├── 1file#.cj
├── file10_abc.cj
├── file11_.aaa-bbb.cj
├── file12!#aaa!bbb.cj
├── file13~####.cj
├── file14*aa.cj
├── file15`.cj
├── file16(#).cj
├── file2;aa.cj
├── file3,?.cj
├── file4@###.cj
├── file5&amp;cc.cj
├── file6=.cj
├── file7+=.cj
├── file8$.cj
├── file9-aaa.cj
└── main.cj
</code></pre>
<p>生成 html 文件名，其中除了 <code>[0-9a-zA-Z_.=]</code> 之外，其他特殊字符都被替换成了 <code>'='</code>：</p>
<pre><code>.
├── index.html
├── src_1file=.cj.html
├── src_file10_abc.cj.html
├── src_file11_.aaa=bbb.cj.html
├── src_file12==aaa=bbb.cj.html
├── src_file13=####.cj.html
├── src_file14=aa.cj.html
├── src_file15=.cj.html
├── src_file16===.cj.html
├── src_file2=aa.cj.html
├── src_file3==.cj.html
├── src_file4=###.cj.html
├── src_file5=cc.cj.html
├── src_file6=.cj.html
├── src_file7==.cj.html
├── src_file8=.cj.html
├── src_file9=aaa.cj.html
└── src_main.cj.html
</code></pre>
<h3 id="分支覆盖率功能"><a class="header" href="#分支覆盖率功能">分支覆盖率功能</a></h3>
<p>分支覆盖率是一个试验阶段的功能，会出现分支覆盖率数据不准确的情况。</p>
<p>目前已知会出现分支覆盖率数据不准确的场景包含以下几种表达式：</p>
<ul>
<li>
<p><code>try-catch-finally</code> 表达式</p>
</li>
<li>
<p>循环表达式（包括 <code>for</code> 表达式、<code>while</code> 表达式）</p>
</li>
<li>
<p><code>if-else</code> 表达式</p>
</li>
</ul>
<h3 id="部分代码未记录到行覆盖率数据中"><a class="header" href="#部分代码未记录到行覆盖率数据中">部分代码未记录到行覆盖率数据中</a></h3>
<p>部分代码不会记录到行覆盖率数据中，属于正常情况。整体而言，如果一行代码<em>仅包含定义、声明</em>而没有实际的可执行代码，那么这一行代码不会被统计到覆盖率中。目前已知不会统计的场景有：</p>
<ul>
<li>
<p>全局变量的定义，示例如下：</p>
<pre><code class="language-cangjie">let HIGH_1_UInt8: UInt8 = 0b10000000;
</code></pre>
</li>
<li>
<p>成员变量仅声明未初始化赋值，示例如下：</p>
<pre><code class="language-cangjie">public class StringBuilder &lt;: Collection &amp; ToString {
    private var myData: Array
    private var mySize: Int64
    private var endIndex: Int64
}
</code></pre>
</li>
<li>
<p>仅有函数声明未包含函数体（包括 <code>foreign</code> 函数等），示例如下：</p>
<pre><code class="language-cangjie">foreign func cj_core_free(p: CPointer): Unit
</code></pre>
</li>
<li>
<p>枚举类型定义，示例如下：</p>
<pre><code class="language-cangjie">enum Numeric {
    NumDay | NumYearDay | NumYearWeek | NumHour12 | NumHour24 | NumMinute | NumSecond
}
</code></pre>
</li>
<li>
<p>class、extend 等定义，其中 extend 和 class 所在的一行不会记录到覆盖率数据中，示例如下：</p>
<pre><code class="language-cangjie">extend Int8 &lt;: Formatter { // This line wil not account for the coverage.
  ...
}

public class StringBuilder &lt;: Collection &amp; ToString { // This line will not account for the coverage.
   ...
}
</code></pre>
</li>
</ul>
<h3 id="源代码中的-main-函数未被覆盖"><a class="header" href="#源代码中的-main-函数未被覆盖">源代码中的 <code>main</code> 函数未被覆盖</a></h3>
<p><strong>原因：</strong> 使用 <code>cjc --test</code> 编译，仓颉测试框架会生成一个新的 <code>main</code> 作为程序入口，源代码中的 <code>main</code> 不再作为程序入口并且不会被执行。</p>
<p><strong>建议：</strong> 在使用 <code>cjc --test</code> 之后，建议不用再手写多余的 <code>main</code> 。</p>
<h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<h3 id="报错找不到-llvm-cov-命令"><a class="header" href="#报错找不到-llvm-cov-命令">报错找不到 <code>llvm-cov</code> 命令</a></h3>
<p><strong>解决方法：</strong></p>
<p>方法1：设置 <code>CANGJIE_HOME</code> 环境变量, <code>cjcov</code> 可通过 <code>CANGJIE_HOME</code> 环境变量找到 <code>llvm-cov</code> 命令，设置方法如下：
假设 <code>which cjc</code> 显示 <code>/work/cangjie/bin/cjc</code>, 并且 <code>/work/cangjie/bin/llvm/bin</code> 和 <code>/work/cangjie/bin/llvm/lib</code> 目录都存在，则可设置：</p>
<pre><code>export CANGJIE_HOME=/work/cangjie
</code></pre>
<p>方法2：在 <code>/root/.bashrc</code> 里面直接设置环境变量，如 <code>cjc</code> 放在 <code>/work/cangjie/bin/cjc</code> 目录下，则设置方法如下：</p>
<pre><code>export PATH=/work/cangjie/bin/llvm/bin:$PATH
export LIBRARY_PATH=/work/cangjie/bin/llvm/lib:$LIBRARY_PATH
export LD_LIBRARY_PATH=/work/cangjie/bin/llvm/lib:$LD_LIBRARY_PATH
</code></pre>
<p>方法3：手动安装 <code>llvm-cov</code> 命令，如 <code>ubuntu</code> 上可执行命令：</p>
<pre><code>apt install llvm-cov
</code></pre>
<h3 id="出现-virtualmachineerror-outofmemoryerror"><a class="header" href="#出现-virtualmachineerror-outofmemoryerror">出现 VirtualMachineError OutOfMemoryError</a></h3>
<p><strong>问题现象：</strong></p>
<pre><code class="language-text">An exception has occurred:
Error VirtualMachineError OutOfMemoryError
</code></pre>
<p><strong>解决方法：</strong> 仓颉默认规格  stack 1MB，heap 256 MB，建议根据文件数量大小将堆内存调到合适的大小。通常 2GB 的内存能够满足大多数情况，如果不够用则根据具体情况再增加内存大小。</p>
<p>示例：</p>
<pre><code class="language-text">把堆内存扩大到2GB：
export cjHeapSize=2GB
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="调试工具"><a class="header" href="#调试工具">调试工具</a></h1>
<h2 id="功能简介-5"><a class="header" href="#功能简介-5">功能简介</a></h2>
<p><code>cjdb</code> 是一款基于 <code>lldb</code> 开发的仓颉程序命令行调试工具，为仓颉开发者提供程序调试的能力，特性列表如下：</p>
<ul>
<li>调试器启动被调程序（launch，attach）</li>
<li>源码断点/函数断点/条件断点（breakpoint）</li>
<li>观察点（watchpoint）</li>
<li>程序运行（s，n， finish， continue）</li>
<li>变量查看/变量修改（print，set）</li>
<li>仓颉线程查看（cjthread）</li>
</ul>
<h2 id="使用说明-4"><a class="header" href="#使用说明-4">使用说明</a></h2>
<h3 id="调试器加载被调程序launchattach"><a class="header" href="#调试器加载被调程序launchattach">调试器加载被调程序（launch，attach）</a></h3>
<h4 id="launch-方式加载被调程序"><a class="header" href="#launch-方式加载被调程序">launch 方式加载被调程序</a></h4>
<p>launch 方式有两种加载方式，如下：</p>
<p>&lt;1&gt; 启动调试器的同时加载被调程序。</p>
<pre><code class="language-text">~/0901/cangjie_test$ cjdb test
(cjdb) target create &quot;test&quot;
Current executable set to '/0901/cangjie-linux-x86_64-release/bin/test' (x86_64).
(cjdb)
</code></pre>
<p>&lt;2&gt; 先启动调试器，然后通过 file 命令加载被调程序。</p>
<pre><code class="language-text">~/0901/cangjie_test$ cjdb
(cjdb) file test
Current executable set to '/0901/cangjie/test' (x86_64).
(cjdb)
</code></pre>
<h4 id="attach-方式调试被调程序"><a class="header" href="#attach-方式调试被调程序">attach 方式调试被调程序</a></h4>
<p>针对正在运行的程序，支持 attach 方式调试被调程序，如下：</p>
<pre><code class="language-text">~/0901/cangjie-linux-x86_64-release/bin$ cjdb
(cjdb) attach 15325
Process 15325 stopped
* thread #1, name = 'test', stop reason = signal SIGSTOP
    frame #0: 0x00000000004014cd test`default.main() at test.cj:7:9
   4      var a : Int32 = 12
   5      a = a + 23
   6      while (true) {
-&gt; 7        a = 1
   8      }
   9      a = test(10, 34)
   10     return 1
  thread #2, name = 'FinalProcessor', stop reason = signal SIGSTOP
    frame #0: 0x00007f48c12fc065 libpthread.so.0`__pthread_cond_timedwait at futex-internal.h:205
  thread #3, name = 'PoolGC_1', stop reason = signal SIGSTOP
    frame #0: 0x00007f48c12fbad3 libpthread.so.0`__pthread_cond_wait at futex-internal.h:88
  thread #4, name = 'MainGC', stop reason = signal SIGSTOP
    frame #0: 0x00007f48c12fc065 libpthread.so.0`__pthread_cond_timedwait at futex-internal.h:205
  thread #5, name = 'schmon', stop reason = signal SIGSTOP
    frame #0: 0x00007f48c0fe17a0 libc.so.6`__GI___nanosleep(requested_time=0x00007f48a8ffcb70, remaining=0x0000000000000000) at nanosleep.c:28

Executable module set to &quot;/0901/cangjie-linux-x86_64-release/bin/test&quot;.
Architecture set to: x86_64-unknown-linux-gnu.
</code></pre>
<h3 id="设置断点"><a class="header" href="#设置断点">设置断点</a></h3>
<h4 id="设置源码断点"><a class="header" href="#设置源码断点">设置源码断点</a></h4>
<pre><code class="language-text">breakpoint set --file test.cj --line line_number
</code></pre>
<p><code>--line</code> 指定行号。
<code>--file</code> 指定文件。
对于单文件，只需要输入行号即可，对于多文件，需要加上文件名字。
<code>b test.cj:4</code>是<code>breakpoint set --file test.cj --line 4</code>的缩写。</p>
<p>例：<strong>breakpoint set --line 2</strong></p>
<pre><code class="language-text">(cjdb) b 2
Breakpoint 1: where = test`default.main() + 13 at test.cj:4:3, address = 0x0000000000401491
(cjdb) b test.cj : 4
Breakpoint 2: where = test`default.main() + 13 at test.cj:4:3, address = 0x0000000000401491
(cjdb)
</code></pre>
<h4 id="设置函数断点"><a class="header" href="#设置函数断点">设置函数断点</a></h4>
<pre><code class="language-text">breakpoint set --name function_name
</code></pre>
<p><code>--name</code> 指定要设置函数断点的函数名。
<code>b test</code>是<code>breakpoint set --name test</code>的缩写。</p>
<p>例：<strong>breakpoint set --method test</strong></p>
<pre><code class="language-text">(cjdb) b test
Breakpoint 3: where = test`default.test(int, int) + 19 at test.cj:12:10, address = 0x0000000000401547
(cjdb)
</code></pre>
<h4 id="设置条件断点"><a class="header" href="#设置条件断点">设置条件断点</a></h4>
<pre><code class="language-text">breakpoint set --file xx.cj --line line_number --condition expression
</code></pre>
<p><code>--file</code> 指定文件。
<code>--condition</code> 指定条件，支持 <code>==, !=, &gt;, &lt;, &gt;=, &lt;=, and, or</code>。
缩写是 <code>b -f test.cj -l 4 -c a==12</code>。</p>
<p>例：<strong>breakpoint set --file test.cj --line 4 --condition a==12</strong></p>
<pre><code class="language-text">(cjdb) breakpoint set --file test.cj --line 4 --condition a==12
Breakpoint 2: where = main`default::main() + 60 at test.cj:4:9, address = 0x00005555555b62d0
(cjdb) c
Process 3128551 resuming
Process 3128551 stopped
* thread #1, name = 'schmon', stop reason = breakpoint 2.1
    frame #0: 0x00005555555b62d0 main`default::main() at test.cj:4:9
   1    main(): Int64 {
   2
   3        var a : Int32 = 12
-&gt; 4        a = a + 23
   5        return 1
   6    }
</code></pre>
<p>仅支持基础类型变量条件设置（Int8，Int16，Int32，Int64，UInt8，UInt16，UInt32，UInt64，Float32，Float64，Bool，Rune），暂时不支持 Float16 变量类型条件设置。</p>
<h3 id="设置观察点"><a class="header" href="#设置观察点">设置观察点</a></h3>
<pre><code class="language-text">watchpoint set variable -w read variable_name
</code></pre>
<p><code>-w</code> 指定观察点点类型，有 <code>read、write、read_write</code> 三种类型。
<code>wa s v</code>是<code>watchpoint set variable</code>的缩写。</p>
<p>例：<strong>watchpoint set variable -w read a</strong></p>
<pre><code class="language-text">(cjdb) wa s v -w read a
Watchpoint created: Watchpoint 1: addr = 0x7fffddffed70 size = 8 state = enabled type = r
    declare @ 'test.cj:27'
    watchpoint spec = 'a'
    new value: 10
(cjdb)
</code></pre>
<p>只支持在基础类型设置观察点。</p>
<h3 id="启动被调程序"><a class="header" href="#启动被调程序">启动被调程序</a></h3>
<p>执行 <code>r（run）</code>命令</p>
<pre><code class="language-text">(cjdb) r
Process 2884 launched: '/0901/cangjie-linux-x86_64-release/bin/test' (x86_64)
Process 2884 stopped
* thread #1, name = 'test', stop reason = breakpoint 1.1 2.1
    frame #0: 0x0000000000401491 test`default.main() at test.cj:4:3
   1
   2    main(): Int64 {
   3
-&gt; 4        var a : Int32 = 12
   5        a = a + 23
   6        a = test(10, 34)
   7
</code></pre>
<p>可以看到程序停到初始化断点处。</p>
<h3 id="执行"><a class="header" href="#执行">执行</a></h3>
<h4 id="单步执行nnext"><a class="header" href="#单步执行nnext">单步执行，<code>n（next）</code></a></h4>
<pre><code class="language-text">(cjdb) n
Process 2884 stopped
* thread #1, name = 'test', stop reason = step over
    frame #0: 0x0000000000401498 test`default.main() at test.cj:5:7
   2    main(): Int64 {
   3
   4       var a : Int32 = 12
-&gt; 5       a = a + 23
   6       a = test(10, 34)
   7       return 1
   8    }
(cjdb)
</code></pre>
<p>从第 4 行运行到第 5 行。</p>
<h4 id="执行到下一个断点停止ccontinue"><a class="header" href="#执行到下一个断点停止ccontinue">执行到下一个断点停止，<code>c（continue）</code></a></h4>
<pre><code class="language-text">(cjdb) c
Process 2884 resuming
Process 2884 stopped
* thread #1, name = 'test', stop reason = breakpoint 3.1
    frame #0: 0x0000000000401547 test`default.test(a=10, b=34) at test.cj:12:10
   9
   10   func test(a : Int32, b : Int32) : Int32 {
   11
-&gt; 12     return a + b
   13   }
   14
(cjdb)
</code></pre>
<h4 id="函数进入s"><a class="header" href="#函数进入s">函数进入，<code>s</code></a></h4>
<pre><code class="language-text">(cjdb) n
Process 5240 stopped
* thread #1, name = 'test', stop reason = step over
    frame #0: 0x00000000004014d8 test`default.main() at test.cj:6:7
   3
   4      var a : Int32 = 12
   5      a = a + 23
-&gt; 6      a = test(10, 34)
   7      return 1
   8    }
   9
(cjdb) s
Process 5240 stopped
* thread #1, name = 'test', stop reason = step in
    frame #0: 0x0000000000401547 test`default.test(a=10, b=34) at test.cj:12:10
   9
   10   func test(a : Int32, b : Int32) : Int32 {
   11
-&gt; 12     return a + b
   13   }
   14
(cjdb)
</code></pre>
<p>当遇到函数调用的时候，可通过<code>s</code>命令进入到被调函数的定义声明处。</p>
<h4 id="函数退出finish"><a class="header" href="#函数退出finish">函数退出，<code>finish</code></a></h4>
<pre><code class="language-text">(cjdb) s
Process 5240 stopped
* thread #1, name = 'test', stop reason = step in
    frame #0: 0x0000000000401547 test`default.test(a=10, b=34) at test.cj:12:10
   9
   10   func test(a : Int32, b : Int32) : Int32 {
   11
-&gt; 12     return a + b
   13   }
   14
(cjdb) finish
Process 5240 stopped
* thread #1, name = 'test', stop reason = step out

Return value: (int) $0 = 44

    frame #0: 0x00000000004014dd test`default.main() at test.cj:6:7
   3
   4      var a : Int32 = 12
   5      a = a + 23
-&gt; 6      a = test(10, 34)
   7      return 1
   8    }
   9
(cjdb)
</code></pre>
<p>执行<code>finish</code>命令，退出当前函数，返回到上一个调用栈函数。</p>
<h3 id="变量查看"><a class="header" href="#变量查看">变量查看</a></h3>
<h4 id="查看局部变量locals"><a class="header" href="#查看局部变量locals">查看局部变量，<code>locals</code></a></h4>
<pre><code class="language-text">(cjdb) locals
(Int32) a = 12
(Int64) b = 68
(Int32) c = 13
(Array&lt;Int64&gt;) array = {
  [0] = 2
  [1] = 4
  [2] = 6
}
(pkgs.Rec) newR2 = {
  age = 5
  name = &quot;string&quot;
}
(cjdb)
</code></pre>
<p>当调试器停到程序的某个位置时，使用<code>locals</code>可以看到程序当前位置所在函数生命周期范围内，所有的局部变量，只能正确查看当前位置已经初始化的变量，当前未初始化的变量无法正确查看。</p>
<h4 id="查看单个变量print-variable_name"><a class="header" href="#查看单个变量print-variable_name">查看单个变量，<code>print variable_name</code></a></h4>
<p>例：<strong>print b</strong></p>
<pre><code class="language-text">(cjdb) print b
(Int64) $0 = 110
(cjdb)
</code></pre>
<p>使用<code>print</code>命令(简写<code>p</code>)，后跟要查看具体变量的名字。</p>
<h5 id="查看-string-类型变量"><a class="header" href="#查看-string-类型变量">查看 String 类型变量</a></h5>
<pre><code class="language-text">(cjdb) print newR2.name
(String) $0 = &quot;string&quot;
(cjdb)
</code></pre>
<h5 id="查看-structclass-类型变量"><a class="header" href="#查看-structclass-类型变量">查看 struct、class 类型变量</a></h5>
<pre><code class="language-text">(cjdb) print newR2
(pkgs.Rec) $0 = {
  age = 5
  name = &quot;string&quot;
}
(cjdb)
</code></pre>
<h5 id="查看数组"><a class="header" href="#查看数组">查看数组</a></h5>
<pre><code class="language-text">(cjdb) print array
(Array&lt;Int64&gt;) $0 = {
  [0] = 2
  [1] = 4
  [2] = 6
  [3] = 8
}
(cjdb) print array[1..3]
(Array&lt;Int64&gt;) $1 = {
  [1] = 4
  [2] = 6
}
(cjdb)
</code></pre>
<p>支持查看基础类型（Int8，Int16，Int32，Int64，UInt8，UInt16，UInt32，UInt64，Float16，Float32，Float64，Bool，Unit，Rune）。</p>
<p>支持范围查看，区间 <code>[start..end)</code> 为左闭右开区间，暂不支持逆序。</p>
<p>对于非法区间或对非数组类型查看区间会有报错提示。</p>
<pre><code class="language-text">(cjdb) print array
(Array&lt;Int64&gt;) $0 = {
  [0] = 0
  [1] = 1
}
(cjdb) print array[1..3]
error: unsupported expression
(cjdb) print array[0][0]
error: unsupported expression
</code></pre>
<h5 id="查看-cstring-类型变量"><a class="header" href="#查看-cstring-类型变量">查看 CString 类型变量</a></h5>
<pre><code class="language-text">(cjdb) p cstr
(cro.CString) $0 = &quot;abc&quot;
(cjdb) p cstr
(cro.CString) $1 = null
</code></pre>
<h4 id="查看全局变量globals"><a class="header" href="#查看全局变量globals">查看全局变量，<code>globals</code></a></h4>
<pre><code class="language-text">(cjdb) globals
(Int64) pkgs.Rec.g_age = 100
(Int64) pkgs.g_var = 123
(cjdb)
</code></pre>
<p>使用 <code>print</code> 命令查看单个全局变量时，不支持 <code>print</code> + 包名 + 变量名查看全局变量，仅支持 <code>print</code> + 变量名 进行查看，例如查看全局变量 <code>g_age</code> 应该用如下命令查看。</p>
<pre><code class="language-text">(cjdb) p g_age
(Int64) $0 = 100
(cjdb)
</code></pre>
<h3 id="变量修改"><a class="header" href="#变量修改">变量修改</a></h3>
<pre><code class="language-text">(cjdb) set a=30
(Int32) $4 = 30
(cjdb)
</code></pre>
<p>可以使用<code>set</code>修改某个局部变量的值，只支持基础数值类型（Int8，Int16，Int32，Int64，UInt8，UInt16，UInt32，UInt64，Float32，Float64）。</p>
<p>对于 <code>Bool</code> 类型的变量，可以使用数值 0（false）和非 0（true）进行修改，<code>Rune</code> 类型变量，可以使用对应的 <code>ASCII</code> 码进行修改。</p>
<pre><code class="language-text">(cjdb) set b = 0
(Bool) $0 = false
(cjdb) set b = 1
(Bool) $1 = true
(cjdb) set c = 0x41
(Rune) $2 = 'A'
(cjdb)
</code></pre>
<p>如果修改的值为非数值，或是超出变量的范围，则会报错提示。</p>
<pre><code class="language-text">(cjdb) p c
(Rune) $0 = 'A'
(cjdb) set c = 'B'
error: unsupported expression
(cjdb) p b
(Bool) $1 = false
(cjdb) set b = true
error: unsupported expression
(cjdb) p u8
(UInt8) $3 = 123
(cjdb) set u8 = 256
error: unsupported expression
(cjdb) set u8 = -1
error: unsupported expression
</code></pre>
<h3 id="仓颉线程查看"><a class="header" href="#仓颉线程查看">仓颉线程查看</a></h3>
<p>支持查看仓颉线程 <code>id</code> 状态以及 <code>frame</code> 信息，暂不支持仓颉线程切换。</p>
<h4 id="查看所有仓颉线程"><a class="header" href="#查看所有仓颉线程">查看所有仓颉线程</a></h4>
<pre><code class="language-text">(cjdb) cjthread list
cjthread id: 1, state: running name: cjthread1
    frame #0: 0x000055555557c140 main`ab::main() at varray.cj:16:1
cjthread id: 2, state: pending name: cjthread2
    frame #0: 0x00007ffff7d8b9d5 libcangjie-runtime.so`CJ_CJThreadPark + 117
(cjdb)
</code></pre>
<h4 id="查看仓颉线程调用栈"><a class="header" href="#查看仓颉线程调用栈">查看仓颉线程调用栈</a></h4>
<p>查看指定仓颉线程调用栈。</p>
<pre><code class="language-text">(cjdb) cjthread backtrace 1
cjthread #1 state: pending name: cangjie
  frame #0: 0x00007ffff7d8b9d5 libcangjie-runtime.so`CJ_CJThreadPark + 117
  frame #1: 0x00007ffff7d97252 libcangjie-runtime.so`CJ_TimerSleep + 66
  frame #2: 0x00007ffff7d51b5d libcangjie-runtime.so`CJ_MRT_FuncSleep + 33
  frame #3: 0x0000555555591031 main`std/sync::sleep(std/time::Duration) + 45
  frame #4: 0x0000555555560941 main`default::lambda.0() at complex.cj:9:3
  frame #5: 0x000055555555f68b main`default::std/core::Future&lt;Unit&gt;::execute(this=&lt;unavailable&gt;) at future.cj:124:35
  frame #6: 0x00007ffff7d514f1 libcangjie-runtime.so`___lldb_unnamed_symbol1219 + 7
  frame #7: 0x00007ffff7d4dc52 libcangjie-runtime.so`___lldb_unnamed_symbol1192 + 114
  frame #8: 0x00007ffff7d8b09a libcangjie-runtime.so`CJ_CJThreadEntry + 26
(cjdb)
</code></pre>
<p><code>cjthread backtrace 1</code> 命令中 <code>1</code> 为指定的 <code>cjthread ID</code>。</p>
<h2 id="注意事项"><a class="header" href="#注意事项">注意事项</a></h2>
<ol>
<li>
<p>进行调试的程序必须已经经过编译的 <code>debug</code> 版本，如使用下述命令编译的程序文件：</p>
<pre><code class="language-shell">cjc -g test.cj -o test
</code></pre>
</li>
<li>
<p>开发者定义了一个泛型对象后，调试单步进入该对象的 <code>init</code> 函数时，栈信息显示的函数名称会包含两个包名，一个是实例化该泛型对象所在的包名，另外一个是泛型定义所在的包名。</p>
<pre><code class="language-text">* thread #1, name = 'main', stop reason = step in
    frame #0: 0x0000000000404057 main`default.p1.Pair&lt;String, Int64&gt;.init(a=&quot;hello&quot;, b=0) at a.cj:21:9
   18       let x: T
   19       let y: U
   20       public init(a: T, b: U) {
-&gt; 21           x = a
   22           y = b
   23       }
</code></pre>
</li>
<li>
<p>对于 <code>Enum</code> 类型的显示, 如果该 <code>Enum</code> 的构造器存在参数的情况下, 会显示成如下样式:</p>
<pre><code class="language-cangjie">enum E {
    Ctor(Int64, String) | Ctor
}

main() {
    var temp = E.Ctor(10, &quot;String&quot;)
    0
}

========================================
(cjdb) p temp
(E) $0 = Ctor {
  arg_1 = 10
  arg_2 = &quot;String&quot;
}
</code></pre>
<p>其中 <code>arg_x</code> 并非是一个可打印的成员变量，<code>Enum</code> 内实际并没有命名为 <code>arg_x</code> 的成员变量。</p>
</li>
<li>
<p>仓颉 <code>CJDB</code> 基于 <code>lldb</code> 构建, 所以支持 <code>lldb</code> 原生基础功能，详情见 <a href="https://lldb.llvm.org">lldb 官方文档</a>。</p>
</li>
</ol>
<h2 id="faq-1"><a class="header" href="#faq-1">FAQ</a></h2>
<ol>
<li>
<p><code>docker</code> 环境下 cjdb 报 <code>error: process launch failed: 'A' packet returned an error: 8</code>。</p>
<pre><code class="language-text">root@xxx:/home/cj/cangjie-example#cjdb ./hello
(cjdb) target create &quot;./hello&quot;
Current executable set to '/home/cj/cangjie-example/hello' (x86_64).
(cjdb) b main
Breakpoint 1: 2 locations.
(cjdb) r
error: process launch failed: 'A' packet returned an error: 8
(cjdb)
</code></pre>
<p>问题原因：<code>docker</code> 创建容器时，未开启 SYS_PTRACE 权限。</p>
<p>解决方案：创建新容器时加上如下选项，并且删除已存在容器。</p>
<pre><code class="language-shell">docker run --cap-add=SYS_PTRACE --security-opt seccomp=unconfined --security-opt apparmor=unconfined
</code></pre>
</li>
<li>
<p>cjdb 报 <code>stop reason = signal XXX</code>。</p>
<pre><code class="language-text">Process 32491 stopped
* thread #2, name = 'PoolGC_1', stop reason = signal SIGABRT
    frame #0: 0x00007ffff450bfb7 lib.so.6`__GI_raise(sig=2) at raise.c:51
</code></pre>
<p>问题原因：程序持续产生 <code>SIGABRT</code> 信号触发调试器暂停。</p>
<p>解决方案：可执行如下命令屏蔽此类信号。</p>
<pre><code class="language-text">(cjdb) process handle --pass true --stop false --notify true SIGBUS
NAME         PASS   STOP   NOTIFY
===========  =====  =====  ======
SIGBUS       true   false  true
(cjdb)
</code></pre>
</li>
<li>
<p>cjdb 没有捕获 <code>SIGSEGV</code> 信号。</p>
<p>问题原因：cjdb 在启动时会默认不捕获 <code>SIGSEGV</code> 信号。</p>
<p>解决方案：开发者如果需要在调试时捕获此信号，可使用如下命令重新设置。</p>
<pre><code class="language-text">(cjdb)process handle -p true -s true -n true SIGSEGV
NAME         PASS   STOP   NOTIFY
===========  =====  =====  ======
SIGSEGV      true   true   true
(cjdb)
</code></pre>
</li>
<li>
<p>cjdb 无法通过 <code>next/s</code> 等调试指令进入 <code>catch</code> 块。</p>
<p>问题原因：仓颉使用 <code>LLVM</code> 的 <code>LandingPad</code> 机制的来实现异常处理, 而该机制无法通过控制流明确 try 语句块中的抛出的异常会由哪一个 catch 语句块捕获，所以无法明确执行的代码。类似问题在 clang++ 中也存在。</p>
<p>解决方案：开发者如果需要调试 <code>catch</code> 块中的代码，可以在 <code>catch</code> 中打上断点。</p>
<pre><code class="language-text">(cjdb) b 31
Breakpoint 2: where = main`default::test(Int64) + 299 at a.cj:31:18, address = 0x000055555557caff
(cjdb) n
Process 1761640 stopped
* thread #1, name = 'schmon', stop reason = breakpoint 2.1
    frame #0: 0x000055555557caff main`default::test(a=0) at a.cj:31:18
  28      s = 12/a
  29    } catch (e:Exception) {
  30
-&gt;31     error_result = e.toString()
  32     println(error_result)
  33    }
  34    s
(cjdb)
</code></pre>
</li>
<li>
<p><code>windows</code> 平台表达式计算报错 <code>Expression can't be run, because there is no JIT compiled function</code> 。</p>
<p>问题原因：部分表达式暂不支持在 <code>windows</code> 平台使用，主要涉及类型转换表达式，赋值表达式，函数调用，自定义类型变量查看， <code>collection</code> 类型变量查看。</p>
</li>
</ol>
<h2 id="附录"><a class="header" href="#附录">附录</a></h2>
<blockquote>
<p><strong>cjdb 特有命令</strong></p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>命令</th><th>简写</th><th>简要描述</th><th>参数说明</th></tr></thead><tbody>
<tr><td>globals</td><td>无</td><td>查看全局变量</td><td>无参数</td></tr>
<tr><td>locals</td><td>无</td><td>查看局部变量</td><td>无参数</td></tr>
<tr><td>print</td><td>p</td><td>查看单个变量</td><td>参数为变量名称，例 print variable_name</td></tr>
<tr><td>set</td><td>无</td><td>修改变量</td><td>参数为表达式，例 set variable_name = value</td></tr>
<tr><td>finish</td><td>无</td><td>函数退出</td><td>无参数</td></tr>
<tr><td>cjthread</td><td>无</td><td>轻量级线程查看</td><td>无参数</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="静态检查工具"><a class="header" href="#静态检查工具">静态检查工具</a></h1>
<h2 id="功能简介-6"><a class="header" href="#功能简介-6">功能简介</a></h2>
<p><code>CJLint(Cangjie Lint)</code>是一款静态检查工具，该工具是基于仓颉语言编程规范开发。通过它可以识别代码中不符合编程规范的问题，帮助开发者发现代码中的漏洞，写出满足 Clean Source 要求的仓颉代码。</p>
<h2 id="使用说明-5"><a class="header" href="#使用说明-5">使用说明</a></h2>
<p><code>cjlint -h</code> 帮助信息，选项介绍。</p>
<pre><code class="language-text">Options:
   -h              Show usage
                       eg: ./cjlint -h
   -f &lt;value&gt;      Detected file directory, it can be absolute path or relative path, if it is directory, default file name is cjReport
                       eg: ./cjlint -f fileDir -c . -m .
   -e &lt;v1:v2:...&gt;  Excluded files, directories or configurations, splitted by ':'. Regular expressions are supported
                       eg: ./cjlint -f fileDir -e fileDir/a/:fileDir/b/*.cj
   -o &lt;value&gt;      Output file path, it can be absolute path or relative path
                       eg: ./cjlint -f fileDir -o ./out
   -r [csv|json]   Report file format, it can be csv or json, default is json
                       eg: ./cjlint -f fileDir -r csv -o ./out
   -c &lt;value&gt;      Directory path where the config directory is located, it can be absolute path or relative path to the executable file
                       eg: ./cjlint -f fileDir -c .
   -m &lt;value&gt;      Directory path where the modules directory is located, it can be absolute path or relative path to the executable file
                       eg: ./cjlint -f fileDir -m .
</code></pre>
<p><code>cjlint -f</code> 指定检查目录。</p>
<pre><code class="language-bash">cjlint -f fileDir [option] fileDir...
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p><code>-f</code> 后面指定的是*.cj 文件所在<code>src</code>目录。</p>
</blockquote>
<p>正例：</p>
<pre><code class="language-bash">cjlint -f xxx/xxx/src
</code></pre>
<p>反例：</p>
<pre><code class="language-bash">cjlint -f xxx/xxx/src/xxx.cj
</code></pre>
<blockquote>
<p><strong>说明：</strong></p>
<p>上述限制来自编译器模块编译限制， 因为当前编译器编译选项正在重构，相关 API 不稳定；而模块编译较为稳定，因此工具当前仅支持模块编译方式。最终工具支持的编译选项会与编译器一致，支持其他编译方式。</p>
</blockquote>
<p><code>-r</code> 用来指定生成扫描报告的格式，目前支持<code>json</code>格式和<code>csv</code>格式。</p>
<p><code>-r</code>需要与<code>-o</code>选项配合使用，如果没有<code>-o</code>指定输出到文件，即使指定了<code>-r</code>也不会生成扫描报告。如果指定了<code>-o</code>没有指定<code>-r</code>，那么默认生成<code>json</code>格式的扫描报告。</p>
<pre><code class="language-bash">cjlint -f ./src -r csv -o ./report         // 生成report.csv文件
cjlint -f ./src -r csv -o ./output/report  // 在output目录下生成report.csv文件
</code></pre>
<p><code>-c</code>, <code>-m</code> 在开发者需要时用以指定<code>config</code>和<code>modules</code>所在的目录路径。</p>
<p>在默认情况下，<code>cjlint</code>会调用其所在目录下的<code>config</code>和<code>modules</code>作为默认的配置目录和依赖目录。若有需要，开发者可以用命令行选项 <code>-c</code>， <code>-m</code>来指定<code>config</code>和<code>modules</code>所在的目录路径。</p>
<p>例：指定的 config 和 modules 的路径分别为：<code>./tools/cjlint/config</code> 和 <code>./tools/cjlint/modules</code>。</p>
<p>则<code>config</code>和<code>modules</code>所在的目录路径同为<code>./tools/cjlint</code>, 所以命令应为：</p>
<pre><code class="language-bash">cjlint -f ./src -c ./tools/cjlint -m ./tools/cjlint
</code></pre>
<h2 id="规则级告警屏蔽"><a class="header" href="#规则级告警屏蔽">规则级告警屏蔽</a></h2>
<p>可执行文件<code>cjlint</code>同目录下的<code>config</code>配置目录中，有<code>cjlint_rule_list.json</code>和<code>exclude_lists.json</code>两个配置文件。其中，<code>cjlint_rule_list.json</code>为规则列表配置文件，开发者可以通过增减其中的配置信息来决定进行哪些规则的检查。<code>exclude_lists.json</code>为告警屏蔽配置文件，开发者可以通过添加告警信息来屏蔽某一条规则的某一条告警。</p>
<p>例： 若开发者只想检查如下 5 条规则，则<code>cjlint_rule_list.json</code>配置文件中只添加要检查的 5 条规则。</p>
<pre><code class="language-json">{
  &quot;RuleList&quot;: [
    &quot;G.FMT.01&quot;,
    &quot;G.ENU.01&quot;,
    &quot;G.EXP.03&quot;,
    &quot;G.OTH.01&quot;,
    &quot;G.OTH.02&quot;
  ]
}
</code></pre>
<p>例： 若开发者想要屏蔽某一条规则的某一条告警，可以在<code>exclude_lists.json</code>配置文件中添加屏蔽信息。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p><code>path</code>不必填写绝对路径，但必须有<code>xxx.cj</code>格式，为模糊匹配。<code>line</code>为告警行号，为精确匹配。<code>colum</code>为告警列号，可选择性填写进行列号精确匹配。</p>
</blockquote>
<pre><code class="language-json">{
  &quot;G.OTH.01&quot; : [
    {&quot;path&quot;:&quot;xxx/example.cj&quot;, &quot;line&quot;:&quot;42&quot;},
    {&quot;path&quot;:&quot;xxx/example.cj&quot;, &quot;line&quot;:&quot;42&quot;, &quot;colum&quot;: &quot;2&quot;},
    {&quot;path&quot;:&quot;example.cj&quot;, &quot;line&quot;:&quot;42&quot;, &quot;colum&quot;: &quot;2&quot;}
  ]
}
</code></pre>
<h2 id="源代码注释告警屏蔽"><a class="header" href="#源代码注释告警屏蔽">源代码注释告警屏蔽</a></h2>
<p><strong>特殊注释 BNF</strong></p>
<pre><code>&lt;content of cjlint-ignore comment&gt; ::=  &quot;cjlint-ignore&quot;  [-start] &lt;ignore-rule&gt;{...} [description] | cjlint-ignore  &lt;-end&gt; [description]
&lt;ignore-rule&gt; ::=&quot;!&quot;&lt;rule-name&gt;
&lt;rule-name&gt; ::= &lt;letters&gt;
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>特殊注释的 <code>cjlint-ignore</code> 与选项 <code>-start</code> 和 <code>-end</code> 以及屏蔽的规则需要写在同一行上，否则无法进行告警屏蔽。描述信息可以写在不同行。</li>
<li>单行屏蔽，屏蔽规则与屏蔽规则间需要用空格隔开，<code>cjlint</code> 会将特殊注释所在行的对应规则告警进行屏蔽。</li>
<li>多行屏蔽，<code>cjlint</code> 会以含有 <code>-start</code> 的特殊注释为起始行，以含有 <code>-end</code> 的特殊注释为结束行，将其间对应的规则进行屏蔽。含有 <code>-end</code> 的特殊注释会与其上方最近的含有 <code>-start</code> 的特殊注释相匹配。</li>
</ul>
</blockquote>
<p><strong>单行屏蔽正确示例 1</strong>，屏蔽 G.CHK.04 告警</p>
<pre><code>void fetctl_process(const void *para)
{
    if (para == NULL)
    {
        return; /*cjlint-ignore !G.CHK.04 */
    }
}
</code></pre>
<p><strong>单行屏蔽正确示例 2</strong>，屏蔽 G.CHK.04 告警</p>
<pre><code>void fetctl_process(const void *para)
{
    if (para == NULL)
    {
        return; // cjlint-ignore !G.CHK.04 description
    }
}
</code></pre>
<p><strong>多行屏蔽正确示例 1</strong>，屏蔽 G.CHK.04 告警</p>
<pre><code>/*cjlint-ignore -start !G.CHK.04 description */
void fetctl_process(const void *para)
{
    if (para == NULL)
    {
        return;
    }
}
/* cjlint-ignore -end description */
</code></pre>
<p><strong>多行屏蔽正确示例 2</strong>，屏蔽 G.CHK.04 告警</p>
<pre><code>// cjlint-ignore -start !G.CHK.04 description
void fetctl_process(const void *para)
{
    if (para == NULL)
    {
        return;
    }
}
// cjlint-ignore -end description
</code></pre>
<p><strong>多行屏蔽正确示例 3</strong>，屏蔽 G.CHK.04 告警</p>
<pre><code>/**
 *  cjlint-ignore -start !G.CHK.04 description
 */
void fetctl_process(const void *para)
{
    if (para == NULL)
    {
        return;
    }
}
// cjlint-ignore -end description
</code></pre>
<p><strong>单行屏蔽<font color="#dd0000">错误</font>示例 1</strong>，屏蔽 G.CHK.04 告警</p>
<pre><code>void fetctl_process(const void *para)
{
    if (para == NULL)
    {
        return; /*cjlint-ignore !G.CHK.04!G.CHK.02 */
                // ERROR: 规则间没用空格隔开，屏蔽告警失败
    }
}
</code></pre>
<p><strong>单行屏蔽<font color="#dd0000">错误</font>示例 2</strong>，屏蔽 G.CHK.04 告警</p>
<pre><code>void fetctl_process(const void *para)
{
    if (para == NULL)
    {
        return; /*cjlint-ignore !G.CHK.04description */
                // ERROR: 规则与描述信息没用空格隔开，屏蔽告警失败
    }
}
</code></pre>
<p><strong>多行屏蔽<font color="#dd0000">错误</font>示例 1</strong>，屏蔽 G.CHK.04 告警</p>
<pre><code>/* cjlint-ignore -start
 * !G.CHK.04 description */
void fetctl_process(const void *para)
{
    if (para == NULL)
    {
        return;
    }
}
/* cjlint-ignore -end description */
// ERROR: 屏蔽规则没与 'cjlint-ignore' 在同一行，屏蔽告警失败
</code></pre>
<h2 id="文件级告警屏蔽"><a class="header" href="#文件级告警屏蔽">文件级告警屏蔽</a></h2>
<ol>
<li>
<p><code>cjlint</code> 可以通过 <code>-e</code> 选项支持文件级别的告警屏蔽。</p>
<p>通过在 <code>-e</code> 后添加屏蔽规则，即可将规则匹配的仓颉文件屏蔽，不会产生关于这些文件的告警。输入的规则为相对 <code>-f</code> 源码目录的相对路径（支持正则），输入字符串需要用双引号包含，多条屏蔽规则用空格分隔。例如，下面这条命令屏蔽了 <code>src/dir1/</code> 目录内的所有仓颉文件， <code>src/dir2/a.cj</code> 文件和 <code>src/</code> 目录下所有形如 <code>test*.cj</code> 的仓颉文件。</p>
<pre><code>cjlint -f src/ -e &quot;dir1/ dir2/a.cj test*.cj&quot;
</code></pre>
</li>
<li>
<p><code>cjlint</code> 可以通过后缀为 <code>.cfg</code> 的配置文件批量导入屏蔽规则。</p>
<p>通过 <code>-e</code> 选项导入配置文件，与其他屏蔽规则或配置文件用空格分隔。例如，下面这条命令屏蔽了 <code>src/dir1</code> 目录和 <code>src/exclude_config_1.cfg</code>、<code>src/dir2/exclude_config_2.cfg</code> 内配置的所有屏蔽规则对应的文件。</p>
<pre><code>cjlint -f src/ -e &quot;dir1/ exclude_config_1.cfg dir2/exclude_config_2.cfg&quot;
</code></pre>
<p><code>.cfg</code> 配置文件中可以配置多条屏蔽规则，每行均为一条屏蔽规则，屏蔽规则为相对该配置文件所在目录的相对路径（支持正则），无需双引号包含。例如在 <code>src/dir2/exclude_config_2.cfg</code> 中有以下配置，则上述的命令会将 <code>src/dir2/subdir1/</code> 目录和 <code>src/dir2/subdir2/a.cj</code> 文件加入屏蔽。</p>
<pre><code>subdir1/
subdir2/a.cj
</code></pre>
</li>
<li>
<p><code>cjlint</code> 可以通过默认配置文件批量导入屏蔽规则。</p>
<p><code>cjlint</code> 屏蔽功能的默认配置文件名为 <code>cjlint_file_exclude.cfg</code>，位置在 <code>-f</code> 源码目录下。例如，当 <code>src/</code> 目录下存在 <code>src/cjlint_file_exclude.cfg</code> 这一配置文件时，<code>cjlint -f src/</code> 命令会屏蔽 <code>src/cjlint_file_exclude.cfg</code> 内配置的屏蔽规则对应的文件。如果开发者已经在 <code>-e</code> 选项中配置了其他有效的 <code>.cfg</code> 配置文件，则 <code>cjlint</code> 不会检查默认配置文件。</p>
</li>
<li>
<p><code>cjlint</code> 的屏蔽规则语法对标 <code>gitignore</code>，详见 <a href="https://git-scm.com/docs/gitignore">gitignore 语法官方文档</a>。</p>
</li>
</ol>
<h2 id="支持检查的规范列表持续新增中"><a class="header" href="#支持检查的规范列表持续新增中">支持检查的规范列表（持续新增中）</a></h2>
<p><code>cjlint</code> 默认启用的规范列表：</p>
<ul>
<li>G.NAM.01 包名采用全小写单词，允许包含数字和下划线。</li>
<li>G.NAM.02 源文件名采用全小写加下划线风格。</li>
<li>G.NAM.03 接口，类，struct、枚举类型和枚举成员构造，类型别名，采用大驼峰命名。</li>
<li>G.NAM.04 函数名称应采用小驼峰命名。</li>
<li>G.NAM.05 let 的全局变量和 static let 变量的名称采用全大写。</li>
<li>G.FMT.01 源文件编码格式（包括注释）必须是 UTF-8。</li>
<li>G.FUN.01 函数功能要单一。</li>
<li>G.FUN.02 禁止函数有未被使用的参数。</li>
<li>G.CLS.01 override 父类函数时不要增加函数的可访问性。</li>
<li>G.ITF.02 尽量在类型定义处就实现接口，而不是通过扩展实现接口。</li>
<li>G.ITF.03 类型定义时避免同时声明实现父接口和子接口。</li>
<li>G.ITF.04 尽量通过泛型约束使用接口，而不是直接将接口作为类型使用。</li>
<li>G.OPR.01 尽量避免违反使用习惯的操作符重载。</li>
<li>G.OPR.02 尽量避免在枚举类型内定义<code>()</code>操作符重载函数。</li>
<li>G.ENU.01 避免枚举的构造成员与顶层元素同名。</li>
<li>G.ENU.02 尽量避免不同的 enum 的 constructor 之间不必要的重载。</li>
<li>G.VAR.01 优先使用不可变变量。</li>
<li>G.EXP.01 match 表达式同一层尽量避免不同类别的 pattern 混用。</li>
<li>G.EXP.02 不要期望浮点运算得到精确的值。</li>
<li>G.EXP.03 &amp;&amp; 、 ||、? 和 ?? 操作符的右侧操作数不要包含副作用。</li>
<li>G.EXP.05 用括号明确表达式的操作顺序，避免过分依赖默认优先级。</li>
<li>G.EXP.06 Bool 类型比较应避免多余的 == 或 !=。</li>
<li>G.EXP.07 比较两个表达式时，左侧倾向于变化，右侧倾向于不变。</li>
<li>G.ERR.02 防止通过异常抛出的内容泄露敏感信息。</li>
<li>G.ERR.03 避免对 Option 类型使用 getorthrow 函数。</li>
<li>G.PKG.01 避免在 import 声明中使用通配符*。</li>
<li>G.CON.01 禁止将系统内部使用的锁对象暴露给不可信代码。</li>
<li>P.01 使用相同的顺序请求锁，避免死锁。</li>
<li>G.CON.02 在异常可能出现的情况下，保证释放已持有的锁。</li>
<li>G.CON.03 禁止使用非线程安全的函数来覆写线程安全的函数。</li>
<li>P.02 避免数据竞争（data race）。</li>
<li>G.CHK.01 跨信任边界传递的不可信数据使用前必须进行校验。</li>
<li>G.CHK.02 禁止直接使用外部数据记录日志。</li>
<li>G.CHK.04 禁止直接使用不可信数据构造正则表达式。</li>
<li>G.FIO.01 临时文件使用完毕必须及时删除。</li>
<li>G.SER.01 禁止序列化未加密的敏感数据。</li>
<li>G.SER.02 防止反序列化被利用来绕过构造方法中的安全操作。</li>
<li>G.SER.03 保证序列化和反序列化的变量类型一致。</li>
<li>G.SEC.01 进行安全检查的方法禁止声明为<code>open</code>。</li>
<li>G.OTH.01 禁止在日志中保存口令、密钥和其他敏感数据。</li>
<li>G.OTH.02 禁止将敏感信息硬编码在程序中。</li>
<li>G.OTH.03 禁止代码中包含公网地址。</li>
<li>G.OTH.04 不要使用 String 存储敏感数据，敏感数据使用结束后应立即清 0。</li>
</ul>
<p><code>cjlint</code> 能够检测，但默认不启用的规范列表（开发者可通过将规范添加至 <code>cjlint_rule_list.json</code> 以启用这类规则）：</p>
<ul>
<li>G.VAR.03 避免使用全局变量。</li>
</ul>
<h2 id="规格说明"><a class="header" href="#规格说明">规格说明</a></h2>
<ul>
<li>
<p>G.CON.02 在异常可能出现的情况下，保证释放已持有的锁。</p>
<p>lock() 函数和 unlock() 函数赋值给变量，赋值后的变量再去加解锁的场景，该规则检查不覆盖。</p>
</li>
<li>
<p>G.OTH.03 暂不支持宏检查。</p>
</li>
<li>
<p>只有当宏包在正确的路径下时，<code>cjlint</code>才能支持宏检查。</p>
<p>例：a.cj 为宏包源码，其正确路径应为 xxx/src/a/a.cj。</p>
</li>
<li>
<p><code>cjlint</code>只有在宏被调用时才能对其进行检查，且无法对宏包中的冗余代码进行检查。</p>
</li>
</ul>
<h2 id="支持语法禁用检查"><a class="header" href="#支持语法禁用检查">支持语法禁用检查</a></h2>
<ol>
<li>
<p><code>cjlint</code> 可以通过将 G.SYN.01 添加至 <code>cjlint_rule_list.json</code> 以启用禁用语法的检查。如果使用了禁用的语法元素，<code>cjlint</code> 将会报错。</p>
</li>
<li>
<p>当前所支持<code>cjlint</code>检查的禁用语法如表中所示:</p>
<div class="table-wrapper"><table><thead><tr><th>禁用语法</th><th>关键词</th><th>说明</th></tr></thead><tbody>
<tr><td>导入包</td><td>Import</td><td>不允许随意导入包</td></tr>
<tr><td>let 变量</td><td>Let</td><td>只用 var 变量，不引入不可写变量的概念</td></tr>
<tr><td>创建线程</td><td>Spawn</td><td>不允许创建线程</td></tr>
<tr><td>线程同步</td><td>Synchronized</td><td>防止死锁</td></tr>
<tr><td>主函数</td><td>Main</td><td>禁止提供入口主函数</td></tr>
<tr><td>定义宏</td><td>MacroQuote</td><td>禁止定义宏（但允许使用宏）</td></tr>
<tr><td>跨语言</td><td>Foreign</td><td>禁止跨语言混合编程</td></tr>
<tr><td>while 循环</td><td>While</td><td>防止复杂循环和死循环</td></tr>
<tr><td>扩展</td><td>Extend</td><td>禁止使用扩展语法</td></tr>
<tr><td>类型别名</td><td>Type</td><td>禁止自行定义类型别名</td></tr>
<tr><td>操作符重载</td><td>Operator</td><td>禁止重载操作符</td></tr>
<tr><td>全局变量</td><td>GlobalVariable</td><td>禁止声明和使用全局变量，防止副作用和内存泄漏</td></tr>
<tr><td>定义枚举</td><td>Enum</td><td>禁用 Enum，避免复杂代码</td></tr>
<tr><td>定义类</td><td>Class</td><td>禁用 Class，避免复杂代码</td></tr>
<tr><td>定义接口</td><td>Interface</td><td>禁用 Interface，避免复杂代码</td></tr>
<tr><td>定义结构</td><td>Struct</td><td>禁用 Struct，避免复杂代码</td></tr>
<tr><td>定义泛型</td><td>Generic</td><td>禁用 Generic，避免复杂代码</td></tr>
<tr><td>条件编译</td><td>When</td><td>禁止平台相关代码</td></tr>
<tr><td>自动微分</td><td>Differentiable</td><td>禁用 Differentiable</td></tr>
<tr><td>模式匹配</td><td>Match</td><td>函数式编程范式，开发者不易掌握</td></tr>
<tr><td>捕获异常</td><td>TryCatch</td><td>避免自行处理异常，易导致错误被忽略</td></tr>
<tr><td>高阶函数</td><td>HigherOrderFunc</td><td>函数类型的参数或返回值, 避免复杂代码</td></tr>
<tr><td>其他基础类型</td><td>PrimitiveType</td><td>不应使用 Int64、float64、bool 之外的其他基础类型</td></tr>
<tr><td>其他容器类型</td><td>ContainerType</td><td>应使用 List，Map，Set</td></tr>
</tbody></table>
</div></li>
<li>
<p>通过将上述表格中的关键字添加到 <code>structural_rule_G_SYN_01.json</code> 中启用对应语法的禁用检查。举例：禁用导入包</p>
</li>
</ol>
<pre><code>{
  &quot;SyntaxKeyword&quot;: [
    &quot;Import&quot;
  ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="格式化工具"><a class="header" href="#格式化工具">格式化工具</a></h1>
<h2 id="功能简介-7"><a class="header" href="#功能简介-7">功能简介</a></h2>
<p><code>CJFMT(Cangjie Formatter)</code>仓颉格式化工具是一款基于仓颉语言编程规范开发的代码自动格式化工具。</p>
<h2 id="使用说明-6"><a class="header" href="#使用说明-6">使用说明</a></h2>
<ol>
<li>可以在 DevEco 安装本工具插件进行使用</li>
<li>使用命令行操作 <code>cjfmt [option] file [option] file</code></li>
</ol>
<p><code>cjfmt -h</code> 帮助信息，选项介绍</p>
<pre><code class="language-text">Usage:
     cjfmt -f fileName [-o fileName]
     cjfmt -d fileDir [-o fileDir]
Options:
   -h            Show usage
                     eg: cjfmt -h
   -f            Specifies the file in the required format. The value can be a relative path or an absolute path.
                     eg: cjfmt -f test.cj
   -d            Specifies the file directory in the required format. The value can be a relative path or an absolute path.
                     eg: cjfmt -d test/
   -o &lt;value&gt;    Output. If a single file is formatted, '-o' is followed by the file name. Relative and absolute paths are supported;
                 If a file in the file directory is formatted, a path must be added after -o. The path can be a relative path or an absolute path.
                     eg: cjfmt -f a.cj -o ./fmta.cj
                     eg: cjfmt -d ~/testsrc -o ./testout
   -l &lt;region&gt;   Only format lines in the specified region for the provided file. Only valid if a single file was specified.
                 Region has a format of [start:end] where 'start' and 'end' are integer numbers representing first and last lines to be formated in the specified file.
                 Line count starts with 1.
                     eg: cjfmt -f a.cj -o ./fmta.cj -l 1:25
</code></pre>
<h3 id="文件格式化"><a class="header" href="#文件格式化">文件格式化</a></h3>
<p><code>cjfmt -f</code></p>
<ul>
<li>格式化并覆盖源文件，支持相对路径和绝对路径。</li>
</ul>
<pre><code>cjfmt -f ../../../test/uilang/Thread.cj
</code></pre>
<ul>
<li>选项<code>-o</code> 新建一个<code>.cj</code>文件导出格式化后的代码，源文件和输出文件支持相对路径和绝对路径。</li>
</ul>
<pre><code class="language-text">cjfmt -f ../../../test/uilang/Thread.cj -o ../../../test/formated/Thread.cj
</code></pre>
<h3 id="目录格式化"><a class="header" href="#目录格式化">目录格式化</a></h3>
<p><code>cjfmt -d</code></p>
<ul>
<li>选项<code>-d</code> 让开发者指定扫描仓颉源代码目录，对文件夹下的仓颉源码格式化，支持相对路径和绝对路径。</li>
</ul>
<pre><code>cjfmt -d test/              //源文件目录为相对目录。

cjfmt -d /home/xxx/test     //源文件目录为绝对目录。
</code></pre>
<ul>
<li>选项<code>-o</code> 为输出目录，可以是已存在的路径，若不存在则会创建相关的目录结构，支持相对路径和绝对路径；目录的最大长度 MAX_PATH 不同的系统之间存在差异，如 Windows 上这个值一般不能超过 260；在 Linux 上这个值一般建议不能超过 4096。</li>
</ul>
<pre><code>cjfmt -d test/ -o /home/xxx/testout

cjfmt -d /home/xxx/test -o ../testout/

cjfmt -d testsrc/ -o /home/../testout   // 源文件文件夹testsrc/不存在；报错：error: Source file path not exist!
</code></pre>
<h3 id="片段格式化"><a class="header" href="#片段格式化">片段格式化</a></h3>
<p><code>cjfmt -l</code></p>
<ul>
<li>选项<code>-l</code>允许开发者指定应格式化文件的某一部分进行格式化，格式化程序将仅对提供的行范围内的源代码应用规则。</li>
<li><code>-l</code>选项仅适用于格式化单个文件（选项<code>-f</code>）。如果指定了目录（选项<code>-d</code>），则<code>-l</code>选项无效。</li>
</ul>
<pre><code>cjfmt -f a.cj -o .cj -l 10:25 //仅格式化第10行至第25行
</code></pre>
<h2 id="格式化规则"><a class="header" href="#格式化规则">格式化规则</a></h2>
<ul>
<li>一个源文件按顺序包含版权、package、import、顶层元素，且用空行分隔。</li>
</ul>
<p>【正例】</p>
<pre><code class="language-cangjie">// 第一部分，版权信息
/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2020-2020. All rights reserved.
 */

// 第二部分，package 声明
package com.huawei.myproduct.mymodule

// 第三部分，import 声明
from std import collection.HashMap   // 标准库

// 第四部分，public 元素定义
public class ListItem &lt;: Component {
   // ...
}

// 第五部分，internal 元素定义
class Helper {
    // CODE
}
</code></pre>
<blockquote>
<p><strong>说明：</strong></p>
<p>仓颉格式化工具不会强制用空行将版权信息部分与其他部分分隔，若开发者在版权信息下方留有一个或多个空行，则格式化工具会保留一个空行。</p>
</blockquote>
<ul>
<li>采用一致的空格缩进，每次缩进 4 个空格。</li>
</ul>
<p>【正例】</p>
<pre><code class="language-cangjie">class ListItem  {
    var content: Array&lt;Int64&gt;   // 符合：相对类声明缩进 4 个空格
    init(
        content: Array&lt;Int64&gt;,  // 符合：函数参数相对函数声明缩进 4 个空格
        isShow!: Bool = true,
        id!: String = &quot;&quot;
    ) {
        this.content = content
    }
}
</code></pre>
<ul>
<li>使用统一的大括号换行风格，对于非空块状结构，大括号使用 K&amp;R 风格。</li>
</ul>
<p>【正例】</p>
<pre><code class="language-cangjie">enum TimeUnit {             // 符合：跟随声明放行末，前置 1 空格
    Year | Month | Day | Hour
}                           // 符合：右大括号独占一行

class A {                   // 符合：跟随声明放行末，前置 1 空格
    var count = 1
}

func fn(a: Int64): Unit {       // 符合：跟随声明放行末，前置 1 空格
    if (a &gt; 0) {            // 符合：跟随声明放行末，前置 1 空格
        // CODE
    } else {                  // 符合：右大括号和 else 在同一行
        // CODE
    }                         // 符合：右大括号独占一行
}

// lambda 函数
let add = { base: Int64, bonus: Int64 =&gt;     // 符合: lambda 表达式中非空块遵循 K&amp;R 风格
    print(&quot;符合 news&quot;)
    base + bonus
}
</code></pre>
<ul>
<li>按照仓颉语言编程规范中的规则 G.FMT.10，使用空格突出关键字和重要信息。</li>
</ul>
<p>【正例】</p>
<pre><code class="language-cangjie">var isPresent: Bool = false  // 符合：变量声明冒号之后有一个空格
func method(isEmpty!: Bool): RetType { ... } // 符合：函数定义（命名参数 / 返回类型）中的冒号之后有一个空格

method(isEmpty: isPresent) // 符合: 命名参数传值中的冒号之后有一个空格

0..MAX_COUNT : -1 // 符合: range 操作符区间前后没有空格，步长冒号前后两侧有一个空格

var hundred = 0
do { // 符合：关键字 do 和后面的括号之间有一个空格
    hundred++
} while (hundred &lt; 100) // 符合：关键字 while 和前面的括号之间有一个空格

func fn(paramName1: ArgType, paramName2: ArgType): ReturnType { // 符合：圆括号和内部相邻字符之间不出现空格
    ...
    for (i in 1..4) { // 符合：range 操作符左右两侧不留空格
        ...
    }
}

let listOne: Array&lt;Int64&gt; = [1, 2, 3, 4] // 符合：方括号和圆括号内部两侧不出现空格

let salary = base + bonus // 符合：二元操作符左右两侧留空格

x++ // 符合：一元操作符和操作数之间不留空格
</code></pre>
<ul>
<li>减少不必要的空行，保持代码紧凑。</li>
</ul>
<p>【反例】</p>
<pre><code class="language-cangjie">class MyApp &lt;: App {
    let album = albumCreate()
    let page: Router
    // 空行
    // 空行
    // 空行
    init() {           // 不符合：类型定义内部使用连续空行
        this.page = Router(&quot;album&quot;, album)
    }

    override func onCreate(): Unit {

        println( &quot;album Init.&quot; )  // 不符合：大括号内部首尾存在空行

    }
}
</code></pre>
<ul>
<li>按照仓颉语言编程规范中的规则 G.FMT.12 规定的优先级排列修饰符关键字。</li>
</ul>
<p>以下是推荐的顶层元素的修饰符排列优先级：</p>
<pre><code class="language-cangjie">public
open/abstract
</code></pre>
<p>以下是推荐的实例成员函数或实例成员属性的修饰符排序优先级：</p>
<pre><code class="language-cangjie">public/protected/private
open
override
</code></pre>
<p>以下是推荐的静态成员函数的修饰符排序优先级：</p>
<pre><code class="language-cangjie">public/protected/private
static
redef
</code></pre>
<p>以下是推荐的成员变量的修饰符排序优先级：</p>
<pre><code class="language-cangjie">public/protected/private
static
</code></pre>
<ul>
<li>多行注释的格式化行为</li>
</ul>
<p>以 <code>*</code> 开头的注释， <code>*</code> 会互相对齐， 不以 <code>*</code> 开头的注释，则会保持注释原样。</p>
<pre><code class="language-cangjie">// 格式化前
/*
      * comment
      */

/*
        comment
        */

//格式化后
/*
 * comment
 */

 /*
        comment
  */
</code></pre>
<h2 id="注意事项-1"><a class="header" href="#注意事项-1">注意事项</a></h2>
<ul>
<li>
<p>仓颉格式化工具暂不支持语法错误的代码的格式化。</p>
</li>
<li>
<p>仓颉格式化工具暂不支持元编程的格式化。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="覆盖率统计工具"><a class="header" href="#覆盖率统计工具">覆盖率统计工具</a></h1>
<h2 id="功能简介-8"><a class="header" href="#功能简介-8">功能简介</a></h2>
<p><code>cjcov</code>（Cangjie Coverage）是仓颉语言的官方覆盖率统计工具，用于生成仓颉语言程序的覆盖率报告。</p>
<h2 id="使用说明-7"><a class="header" href="#使用说明-7">使用说明</a></h2>
<p>通过 <code>cjcov -h</code> 即可查看命令使用方法，如下所示。由几个板块组成，从上到下分别是：当前命令使用形式（Usage）、当前命令用途、支持的可用参数（Options）。</p>
<pre><code class="language-text">Usage: cjcov [options]

A tool used to summarize the coverage in html reports.

Options:
  -v, --version                 Print the version number, then exit.
  -h, --help                    Show this help message, then exit.
  -r ROOT, --root=ROOT          The root directories of your source files, defaults to '.', the current directory.
                                File names are reported relative to this root.
  -o OUTPUT, --output=OUTPUT    The output directories of html reports, defaults to '.', the current directory.
  -b, --branches                Report the branch coverage. (It is an experimental feature and may generate imprecise branch coverage.)
  --verbose                     Print some detail messages, including parsing data for the gcov file.
  --html-details                Generate html reports for each source file.
  -x, --xml                     Generate a xml report.
  -j, --json                    Generate a json report.
  -k, --keep                    Keep gcov files after processing.
  -s SOURCE, --source=SOURCE    The directories of cangjie source files.
  -e EXCLUDE, --exclude=EXCLUDE
                                The cangjie source files starts with EXCLUDE will not be showed in coverage reports.
  -i INCLUDE, --include=INCLUDE
                                The cangjie source files starts with INCLUDE will be showed in coverage reports.
</code></pre>
<p>基本的命令使用方法如下所示，<code>cjcov</code> 为主程序名称，<code>--version</code> 表示为显示 <code>cjcov</code> 的版本号。部分配置项支持长短选项两种写法，效果相同，具体可以使用 <code>cjcov --help</code> 命令参考用法。</p>
<pre><code class="language-text">cjcov -version 或者 cjcov -v
</code></pre>
<h3 id="使用步骤-1"><a class="header" href="#使用步骤-1">使用步骤</a></h3>
<p>仓颉版本包准备 --&gt; 仓颉源码准备 --&gt;  使用 <code>--coverage</code> 编译选项构建仓颉源码，生成二进制文件 --&gt; 执行二进制文件 --&gt; <code>cjcov</code> 生成覆盖率统计结果</p>
<p>下面举一个 <code>hello world</code> 的覆盖率的例子：</p>
<pre><code class="language-text">假设当前目录是 WORKPATH 。
1）仓颉版本包准备
假设仓颉版本包解压在 WORKPATH 目录下，则执行 source WORKPATH/cangjie/envsetup.sh 命令即可。

2）仓颉源码准备
源码目录结构如下：
src/
└── main.cj

main.cj 源码内容如下：
main(): Int64 {
    print(&quot;hello world\n&quot;)
    return 0
}

3）编译源码，该例子用 cjpm 编译举例
在 WORKPATH 目录下执行以下命令：
cjpm init cangjie test
cjpm build --coverage

编译完成之后在 WORKPATH 目录下会生成 default.gcno 文件。

4）运行编译出来的二进制
在 WORKPATH 目录下执行 cjpm run --skip-build 命令，运行完成之后 WORKPATH 目录下会生成 default.gcda 文件。

5）cjcov 生成 html
在 WORKPATH 目录执行 cjcov -o output --html-details，更多 cjcov 参数使用可参考下一章节 &quot;命令介绍&quot;。

执行完 cjcov 命令之后，在 WORKPATH/output 目录会有以下文件：
output
├── cjcov_logs （该目录存放一些 cjcov 执行过程的详细日志，可不用关注）
│   ├── cjcov.log
│   └── gcov_parse.log
├── index.html （总的覆盖率报告，通过浏览器打开）
└── src_main.cj.html （单个文件的覆盖率，可以通过打开 index.html 自动跳转到该文件）
</code></pre>
<h2 id="命令说明-2"><a class="header" href="#命令说明-2">命令说明</a></h2>
<h3 id="cjcov--h----help-1"><a class="header" href="#cjcov--h----help-1">cjcov -h | --help</a></h3>
<p>显示 <code>cjcov</code> 基本使用方法。</p>
<h3 id="cjcov--v----version-1"><a class="header" href="#cjcov--v----version-1">cjcov -v | --version</a></h3>
<p>显示 <code>cjcov</code> 的版本号，只要指定了 <code>-v</code> 或者 <code>--version</code> 参数，不管输入其他任何选项参数都不生效，只会显示版本号。如 <code>--version</code> 和 <code>--help</code> 同时使用，则显示 <code>version</code> 信息后退出。</p>
<h3 id="cjcov---verbose-1"><a class="header" href="#cjcov---verbose-1">cjcov --verbose</a></h3>
<p>指定该选项后会将一些日志信息生成到 <code>cjcov_logs</code> 目录中，该参数默认不生效, 即默认不会打印中间信息。<code>gcov</code> 文件是 <code>cjcov</code> 工具生成的中间文件，<code>cjcov</code> 解析 <code>gcov</code> 文件的格式如下：</p>
<pre><code class="language-text">==================== start: main.cj.gcov =====================

noncode line numbers:
[0, 0, 0, 0, 1, 2, 6, 7, 9, 10, 11, 15, 17, 18]

uncovered line numbers:
[5]

covered data:
[(16, 1), (3, 1), (4, 1), (8, 1), (12, 1), (13, 1), (14, 1)]

branches data:
line number:    4  ==&gt;  data: [(0, 0), (1, 1)]

===================== end: main.cj.gcov =======================

</code></pre>
<p>指定该选项参数，会显示每个 <code>gcov</code> 文件的详细覆盖率数据。</p>
<p>具体字段解释如下：</p>
<ul>
<li><code>start: xxx.gcov, end: xxx.gcov</code>：两行中间的文本是对应 <code>xxx.gcov</code> 文件解析到的覆盖率数据。</li>
<li><code>noncode line numbers</code>：显示的是不统计到总代码行的行号，在 <code>html</code> 中是以白色底呈现，对应 <code>gcov</code> 中的以 <code>-</code> 开头的行数。</li>
<li><code>uncovered line numbers</code>：显示的是没有覆盖到的数据，在 <code>html</code> 中是以红色底呈现，对应 <code>gcov</code> 文件中以 <code>#####</code> 开头的行数。</li>
<li><code>covered data</code>：显示的是覆盖到的数据，以（代码行数，覆盖次数）呈现，在对应 <code>html</code> 中以绿色呈现，只要覆盖次数大于 0，在 <code>html</code> 中的 <code>Exec</code> 一列中显示为 <code>Y</code>，对应于 <code>gcov</code> 文件以数字开头的行数。</li>
<li><code>branches data</code>：显示的分支覆盖数据，以（代码行数，分支覆盖次数）呈现，在对应 <code>html</code> 中的 <code>Branch</code> 一列中，有一个倒三角形，显示的是分支覆盖数/总分支数。该数据对应于 <code>gcov</code> 文件中以 <code>branch</code> 开头的数据。</li>
</ul>
<h3 id="cjcov---html-details-1"><a class="header" href="#cjcov---html-details-1">cjcov --html-details</a></h3>
<p>如果指定该参数，表示会生成仓颉文件对应的 <code>html</code>。在总的 <code>index</code> 文件里面会有每个子 <code>html</code> 的索引。子 <code>html</code> 文件和 <code>index.html</code> 放在同一个目录。</p>
<p>子 <code>html</code> 文件名是由目录和文件名由下划线拼接起来。如源文件是 <code>src/main.cj</code>，生成的 <code>html</code> 名字为 <code>src_main.cj.html</code>。如果源文件路径带有特殊字符会被替换成 <code>=</code>，下文的特殊场景章节会有更详细的描述<a href="source_zh_cn/tools/cjcov_manual_cjnative.html#%E6%96%87%E4%BB%B6%E5%90%8D%E5%8C%85%E5%90%AB%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6">说明</a>。</p>
<p>如果没有指定该参数，表示不会生成子 <code>html</code> 。在总的 <code>index</code> 文件里面会显示每个子 <code>html</code> 的覆盖率数据，但是不能跳转到对应的子 <code>html</code> 文件。</p>
<p>该参数默认不生效。即默认只会生成一个 <code>index.html</code>, 不会生成子 <code>html</code> 文件。</p>
<h3 id="cjcov--x----xml-1"><a class="header" href="#cjcov--x----xml-1">cjcov -x | --xml</a></h3>
<p>如果指定该参数，则会在指定输出路径生成 <code>coverage.xml</code> 文件，<code>coverage.xml</code> 记录的是所有文件的覆盖率数据。</p>
<h3 id="cjcov--j----json-1"><a class="header" href="#cjcov--j----json-1">cjcov -j | --json</a></h3>
<p>如果指定该参数，则会在指定输出路径生成 <code>coverage.json</code> 文件，<code>coverage.json</code> 记录的是所有文件的覆盖率数据。</p>
<h3 id="cjcov--k-----keep-1"><a class="header" href="#cjcov--k-----keep-1">cjcov -k |  --keep</a></h3>
<p>指定该参数后则不会删除生成的 <code>gcov</code> 中间文件。如果 <code>gcov</code> 文件不删除，会造成执行次数的累加，可能会影响覆盖率数据的准确性。</p>
<p>默认该参数不生效，即默认会删除 <code>gcov</code> 中间文件。</p>
<h3 id="cjcov--b----branches-1"><a class="header" href="#cjcov--b----branches-1">cjcov -b | --branches</a></h3>
<p>指定该参数后则会生成分支覆盖率信息。</p>
<p>默认该参数不生效，即默认不生成分支的覆盖率信息，此时在 <code>html</code> 报告中的分支覆盖率数据百分比显示为 <code>-</code>。</p>
<h3 id="cjcov--r-root----rootroot-1"><a class="header" href="#cjcov--r-root----rootroot-1">cjcov -r ROOT | --root=ROOT</a></h3>
<p>该参数指定的 <code>ROOT</code> 参数，表示在 <code>ROOT</code> 目录或者在其递归子目录能找到 <code>gcda</code> 文件，<code>gcda</code> 和 <code>gcno</code> 文件默认会生成在一起，建议不要手动特意去把 <code>gcda</code> 文件和 <code>gcno</code> 文件分开存放，不然可能会发生程序不能运行的情况。</p>
<p>参数指定的 <code>ROOT</code> 目录如果不存在，<code>cjcov</code> 工具会有报错提示。</p>
<p>不指定该参数，默认会以当前目录为 <code>ROOT</code> 目录。</p>
<h3 id="cjcov--o-output-----outputoutput-1"><a class="header" href="#cjcov--o-output-----outputoutput-1">cjcov -o OUTPUT |  --output=OUTPUT</a></h3>
<p>该参数指定的 <code>OUTPUT</code> 参数，表示 <code>html</code> 覆盖率报告的输出路径。</p>
<p>如果该 <code>OUTPUT</code> 目录不存在，而且其父目录也不存在，<code>cjcov</code> 工具会有报错提示；如果 <code>OUTPUT</code> 目录不存在，但其父目录存在，<code>cjcov</code> 会帮助创建 <code>OUTPUT</code> 目录。</p>
<p>不指定该参数，默认会以当前目录为 <code>OUTPUT</code> 目录来存放 <code>html</code> 文件。</p>
<h3 id="-s-source----sourcesource-1"><a class="header" href="#-s-source----sourcesource-1">-s SOURCE | --source=SOURCE</a></h3>
<p>该参数指定的 <code>SOURCE</code> 参数，表示仓颉源文件的代码路径，<code>html</code> 总覆盖率报告 <code>index.html</code> 会有各个源文件的索引，这些文件路径记录的是一个相对路径。如果指定 <code>-s SOURCE |--source SOURCE</code> 参数，优先以 <code>SOURCE</code> 路径列表中的路径作为相对路径的参考路径，如果没有指定该参数，则以 <code>-r ROOT | --root=ROOT</code> 作为相对路径的参考路径，如果都没有指定，则以当前路径作为相对路径的参考路径。</p>
<p>示例：</p>
<pre><code class="language-text">仓颉代码目录结构如下：
/work/cangjie/tests/API/test01/src/1.cj
/work/cangjie/tests/API/test01/src/2.cj
/work/cangjie/tests/LLVM/test02/src/3.cj
/work/cangjie-tools/tests/LLVM/test01/src/4.cj
/work/cangjie-tools/tests/LLVM/test02/src/5.cj

1）在 /work 目录执行命令：
cjcov --root=./ -s &quot;/work/cangjie /work/cangjie-tools/tests&quot; --html-details --output=html_output

最后 html 中呈现的源文件相对路径是
tests/API/test01/src/1.cj
tests/API/test01/src/2.cj
tests/LLVM/test02/src/3.cj
LLVM/test01/src/4.cj
LLVM/test02/src/5.cj

2）在 /work 目录执行命令, 没有指定 --root 参数和 --source 参数，默认当前所在路径为相对路径的参考路径，执行命令如下：
cjcov --html-details --output=html_output

最后 html 中呈现的源文件相对路径是：
cangjie/tests/API/test01/src/1.cj
cangjie/tests/API/test01/src/2.cj
cangjie/tests/LLVM/test02/src/3.cj
cangjie-tools/tests/LLVM/test01/src/4.cj
cangjie-tools/tests/LLVM/test02/src/5.cj
</code></pre>
<h3 id="-e-exclude----excludeexclude-1"><a class="header" href="#-e-exclude----excludeexclude-1">-e EXCLUDE | --exclude=EXCLUDE</a></h3>
<p>该参数指定的 <code>EXCLUDE</code> 参数，表示不需要生成覆盖率信息的源文件列表，支持指定目录和文件。</p>
<p>示例：</p>
<pre><code class="language-text">仓颉代码目录结构如下：
/usr1/cangjie/tests/API/test01/src/1.cj
/usr1/cangjie/tests/API/test01/src/2.cj
/usr1/cangjie/tests/LLVM/test02/src/3.cj
/usr1/cangjie-tools/tests/LLVM/test01/src/4.cj
/usr1/cangjie-tools/tests/LLVM/test02/src/5.cj

在 /usr1 目录执行命令：
cjcov --root=./ -s &quot;/usr1/cangjie&quot; -e &quot;/usr1/cangjie-tools/tests/LLVM&quot; --html-details --output=html_output

最后 html 中呈现的源文件相对路径是,其中以 /usr1/cangjie-tools/tests/LLVM 路径开头的文件不会出现在 html 的文件列表中。
tests/API/test01/src/1.cj
tests/API/test01/src/2.cj
tests/LLVM/test02/src/3.cj
</code></pre>
<h3 id="-i-include----includeinclude-1"><a class="header" href="#-i-include----includeinclude-1">-i INCLUDE | --include=INCLUDE</a></h3>
<p>该参数指定的 <code>INCLUDE</code> 参数，表示以 <code>INCLUDE</code> 开头的文件会显示在 <code>index.html</code> 的文件列表中，支持指定目录和文件。如果 <code>-e | --exclude</code> 和 <code>-i | --include</code> 指定的参数有路径重复，会有报错提示。</p>
<p>示例：</p>
<pre><code class="language-text">目录/usr1/cangjie/tests仓颉代码目录结构如下：
├── API
│   └── test01
│       └── src
│           ├── 1.cj
│           └── 2.cj
└── LLVM
    └── test02
        └── src
            └── 3.cj

在 /usr1 目录执行命令, 其中 -i 参数表示需要体现在覆盖率报告 index.html 的文件，命令如下：
cjcov --root=./ -s &quot;/usr1/cangjie&quot; -i &quot;/usr1/cangjie/tests/API/test01/src/1.cj /usr1/cangjie/tests/LLVM/test02&quot; --html-details --output=html_output

上面命令执行后, 在 index.html 中文件路径列表如下(tests/API/test01/src/2.cj 不在 -i 参数指定的列表里面，所以不会出现在 html 的文件列表中):
tests/API/test01/src/1.cj
tests/LLVM/test02/src/3.cj
</code></pre>
<h2 id="特殊场景-1"><a class="header" href="#特殊场景-1">特殊场景</a></h2>
<h3 id="二进制无法正常执行结束-1"><a class="header" href="#二进制无法正常执行结束-1">二进制无法正常执行结束</a></h3>
<p>对于常驻的网络服务程序无法正常结束二进制文件并生成 <code>gcda</code> 覆盖率数据的场景，需要手动执行退出脚本生成 <code>gcda</code> 覆盖率数据。</p>
<p>1）将以下脚本内容保存为 <code>stop.sh</code> （此脚本执行依赖 <code>gdb</code> ）</p>
<pre><code class="language-shell">#!/bin/sh
SERVER_NAME=$1

pid=`ps -ef | grep $SERVER_NAME | grep -v &quot;grep&quot; | awk '{print $2}'`
echo $pid
gdb -q attach $pid &lt;&lt;__EOF__
p exit(0)
__EOF__
</code></pre>
<p>2）常驻服务程序完成业务逻辑操作覆盖后，执行 <code>stop.sh {service_name}</code>，如通过 <code>./main</code> 启动常驻服务进程，通过如下方式停止进程产生 <code>gcda</code> 数据</p>
<pre><code class="language-shell">sh stop.sh ./main
</code></pre>
<h3 id="文件名包含特殊字符-1"><a class="header" href="#文件名包含特殊字符-1">文件名包含特殊字符</a></h3>
<p>建议遵循仓颉编程规范命名文件，不建议包含除 [0-9a-zA-Z_] 之外的字符，特殊字符会被替换成 <code>=</code>。</p>
<p>如果文件名有特殊字符，为保证 <code>html</code> 跳转正确，<code>index.html</code> 中呈现的 <code>html</code> 名字和 <code>html</code> 本身文件名会不一致，<code>html</code> 文件名的特殊字符都会被替换成 <code>=</code>。</p>
<p>示例如下：</p>
<pre><code class="language-text">代码结构：
src
├── 1file#.cj
├── file10_abc.cj
├── file11_.aaa-bbb.cj
├── file12!#aaa!bbb.cj
├── file13~####.cj
├── file14*aa.cj
├── file15`.cj
├── file16(#).cj
├── file2;aa.cj
├── file3,?.cj
├── file4@###.cj
├── file5&amp;cc.cj
├── file6=.cj
├── file7+=.cj
├── file8$.cj
├── file9-aaa.cj
└── main.cj

生成 html 文件名,其中除了[0-9a-zA-Z_.=]之外，其他特殊字符都被替换成了'='
.
├── index.html
├── src_1file=.cj.html
├── src_file10_abc.cj.html
├── src_file11_.aaa=bbb.cj.html
├── src_file12==aaa=bbb.cj.html
├── src_file13=####.cj.html
├── src_file14=aa.cj.html
├── src_file15=.cj.html
├── src_file16===.cj.html
├── src_file2=aa.cj.html
├── src_file3==.cj.html
├── src_file4=###.cj.html
├── src_file5=cc.cj.html
├── src_file6=.cj.html
├── src_file7==.cj.html
├── src_file8=.cj.html
├── src_file9=aaa.cj.html
└── src_main.cj.html
</code></pre>
<h3 id="分支覆盖率功能-1"><a class="header" href="#分支覆盖率功能-1">分支覆盖率功能</a></h3>
<p>分支覆盖率是一个试验阶段的功能，会出现分支覆盖率数据不准确的情况</p>
<p>目前已知会出现分支覆盖率数据不准确的场景包含以下几种表达式：</p>
<ul>
<li>
<p><code>try-catch-finally</code> 表达式</p>
</li>
<li>
<p>循环表达式（包括 <code>for</code> 表达式、<code>while</code> 表达式）</p>
</li>
<li>
<p><code>if-else</code> 表达式</p>
</li>
</ul>
<h3 id="部分代码未记录到行覆盖率数据中-1"><a class="header" href="#部分代码未记录到行覆盖率数据中-1">部分代码未记录到行覆盖率数据中</a></h3>
<p>部分代码不会记录到行覆盖率数据中，属于正常情况。整体而言，如果一行代码<em>仅包含定义、声明</em>而没有实际的可执行代码，那么这一行代码不会被统计到覆盖率中。目前已知不会统计的场景有：</p>
<ul>
<li>
<p>全局变量的定义 ，示例如下：</p>
<pre><code class="language-cangjie">let HIGH_1_UInt8: UInt8 = 0b10000000;
</code></pre>
</li>
<li>
<p>成员变量仅声明未初始化赋值 ，示例如下：</p>
<pre><code class="language-cangjie">public class StringBuilder &lt;: Collection &amp; ToString {
    private var myData: Array
    private var mySize: Int64
    private var endIndex: Int64
}
</code></pre>
</li>
<li>
<p>仅有函数声明未包含函数体（包括 <code>foreign</code> 函数等），示例如下：</p>
<pre><code class="language-cangjie">foreign func cj_core_free(p: CPointer): Unit
</code></pre>
</li>
<li>
<p>枚举类型定义 ，示例如下：</p>
<pre><code class="language-cangjie">enum Numeric {
    NumDay | NumYearDay | NumYearWeek | NumHour12 | NumHour24 | NumMinute | NumSecond
}
</code></pre>
</li>
<li>
<p>class、extend 等定义，其中 extend 和 class 所在的一行不会记录到覆盖率数据中，示例如下：</p>
<pre><code class="language-cangjie">extend Int8 &lt;: Formatter { // This line wil not account for the coverage.
  ...
}

public class StringBuilder &lt;: Collection &amp; ToString { // This line will not account for the coverage.
   ...
}
</code></pre>
</li>
</ul>
<h3 id="源代码中的-main-函数未被覆盖-1"><a class="header" href="#源代码中的-main-函数未被覆盖-1">源代码中的 <code>main</code> 函数未被覆盖</a></h3>
<p><strong>原因：</strong> 使用 <code>cjc --test</code> 编译，仓颉测试框架会生成一个新的 <code>main</code> 作为程序入口，源代码中的 <code>main</code> 不再作为程序入口并且不会被执行。</p>
<p><strong>建议：</strong> 在使用 <code>cjc --test</code> 之后，建议不用再手写多余的 <code>main</code> 。</p>
<h2 id="faq-2"><a class="header" href="#faq-2">FAQ</a></h2>
<h3 id="报错找不到-llvm-cov-命令-1"><a class="header" href="#报错找不到-llvm-cov-命令-1">报错找不到 <code>llvm-cov</code> 命令</a></h3>
<p><strong>解决方法：</strong></p>
<pre><code class="language-text">方法1：设置 CANGJIE_HOME 环境变量, cjcov 可通过 CANGJIE_HOME 环境变量找到 llvm-cov 命令，设置方法如下：
假设 which cjc 显示 /work/cangjie/bin/cjc, 并且 /work/cangjie/bin/llvm/bin和 /work/cangjie/bin/llvm/lib 目录都存在，则可设置：
export CANGJIE_HOME=/work/cangjie

方法2：在 /root/.bashrc 里面直接设置环境变量，如 cjc 放在 /work/cangjie/bin/cjc 目录下，则设置方法如下：
export PATH=/work/cangjie/bin/llvm/bin:$PATH
export LIBRARY_PATH=/work/cangjie/bin/llvm/lib:$LIBRARY_PATH
export LD_LIBRARY_PATH=/work/cangjie/bin/llvm/lib:$LD_LIBRARY_PATH

方法3：手动安装 llvm-cov 命令，如 ubuntu 上可执行命令：
apt install llvm-cov
</code></pre>
<h3 id="出现-virtualmachineerror-outofmemoryerror-1"><a class="header" href="#出现-virtualmachineerror-outofmemoryerror-1">出现 VirtualMachineError OutOfMemoryError</a></h3>
<p><strong>问题现象：</strong></p>
<pre><code class="language-text">An exception has occurred:
Error VirtualMachineError OutOfMemoryError
</code></pre>
<p><strong>解决方法：</strong> 仓颉默认规格  stack 1MB，heap 256 MB，建议根据文件数量大小将堆内存调到合适的大小。通常 2GB 的内存能够满足大多数情况，如果不够用则根据具体情况再增加内存大小。</p>
<p>示例：</p>
<pre><code class="language-text">把堆内存扩大到2GB：
export cjHeapSize=2GB
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="性能分析工具"><a class="header" href="#性能分析工具">性能分析工具</a></h1>
<h2 id="功能简介-9"><a class="header" href="#功能简介-9">功能简介</a></h2>
<p><code>cjprof</code>（Cangjie Profile）是仓颉语言的性能分析工具，支持以下功能：</p>
<ul>
<li>
<p>对仓颉语言程序进行 CPU 热点函数采样，导出采样数据。</p>
</li>
<li>
<p>对热点函数采样数据进行分析，生成 CPU 热点函数统计报告或火焰图。</p>
</li>
<li>
<p>导出仓颉语言应用程序堆内存，并对其进行分析生成分析报告。</p>
</li>
</ul>
<p>目前 <code>cjprof</code> 仅支持 <code>Linux</code> 系统。</p>
<h2 id="使用说明-8"><a class="header" href="#使用说明-8">使用说明</a></h2>
<p>通过 <code>cjprof --help</code> 即可查看命令使用方法。支持 <code>record</code>，<code>report</code> 和 <code>heap</code> 子命令，分别用于采集 CPU 热点函数信息， 生成 CPU 热点函数报告（包含火焰图）和导出与分析堆内存。</p>
<pre><code class="language-text">cjprof --help
 Usage: cjprof [--help] COMMAND [ARGS]

The supported commands are:
  heap      Dump heap into a dump file or analyze the heap dump file
  record    Run a command and record its profile data into data file
  report    Read profile data file (created by cjprof record) and display the profile

</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p>由于 <code>cjprof record</code> 依赖系统的 <code>perf</code> 权限，因此使用需要满足以下两个条件之一：</p>
<ul>
<li>使用 <code>root</code> 用户或 <code>sudo</code> 权限执行。</li>
<li>系统的 <code>perf_event_paranoid</code> 参数（通过 <code>/proc/sys/kernel/perf_event_paranoid</code> 文件）配置为 -1 。</li>
</ul>
<p>否则可能会出现权限不足的问题。</p>
</blockquote>
<h3 id="采集-cpu-热点函数信息"><a class="header" href="#采集-cpu-热点函数信息">采集 CPU 热点函数信息</a></h3>
<h4 id="命令"><a class="header" href="#命令">命令</a></h4>
<pre><code class="language-text">cjprof record
</code></pre>
<h4 id="格式"><a class="header" href="#格式">格式</a></h4>
<pre><code class="language-text">cjprof record [&lt;options&gt;] [&lt;command&gt;]
cjprof record [&lt;options&gt;] -- &lt;command&gt; [&lt;options&gt;]
</code></pre>
<h4 id="选项"><a class="header" href="#选项">选项</a></h4>
<p><code>-f, --freq &lt;freq&gt;</code> 指定采样频率，单位为赫兹（Hz），即每秒采样次数，默认为 1000 Hz，当指定为 max 或超过系统支持的最大频率时，取系统支持的最大频率。</p>
<p><code>-o, --output &lt;file&gt;</code> 指定采样结束后生成的采样数据文件名，默认为 <code>cjprof.data</code> 。</p>
<p><code>-p, --pid &lt;pid&gt;</code> 指定被采样应用程序的进程 ID，当指定 <code>&lt;command&gt;</code> 新启动应用程序进行采样时，该选项会被忽略。</p>
<h4 id="示例"><a class="header" href="#示例">示例</a></h4>
<ul>
<li>采样正在运行的应用程序。</li>
</ul>
<pre><code class="language-text"># 以 10000 Hz 的采样频率对正在运行的应用程序（进程号为 12345）进行采样，采样结束后将采样数据生成在当前路径下名为 sample.data 的文件中。
cjprof record -f 10000 -p 12345 -o sample.data
</code></pre>
<ul>
<li>新启动应用程序并对其进行采样。</li>
</ul>
<pre><code class="language-text"># 执行当前路径下的 `test` 应用程序，参数为 `arg1 arg2` ，并以系统支持的最大采样频率对其进行采样，采样结束后将采样数据生成在当前路径下名为 `cjprof.data` （默认文件名）的文件中。
cjprof record -f max -- ./test arg1 arg2
</code></pre>
<h4 id="注意事项-2"><a class="header" href="#注意事项-2">注意事项</a></h4>
<ul>
<li>开始采样后，只有被采样程序退出后才会结束采样，如果需要提前结束采样，可以在采样过程中通过按 <code>Ctrl+C</code> 主动停止采样。</li>
</ul>
<h3 id="生成-cpu-热点函数报告"><a class="header" href="#生成-cpu-热点函数报告">生成 CPU 热点函数报告</a></h3>
<h4 id="命令-1"><a class="header" href="#命令-1">命令</a></h4>
<pre><code class="language-text">cjprof report
</code></pre>
<h4 id="格式-1"><a class="header" href="#格式-1">格式</a></h4>
<pre><code class="language-text">cjprof report [&lt;options&gt;]
</code></pre>
<h4 id="选项-1"><a class="header" href="#选项-1">选项</a></h4>
<p><code>-F, --flame-graph</code> 生成 CPU 热点函数火焰图，而非默认的文本报告。</p>
<p><code>-i, --input &lt;file&gt;</code> 采样数据文件名，默认为 <code>cjprof.data</code> 。</p>
<p><code>-o, --output &lt;file&gt;</code> 生成的 CPU 热点函数火焰图文件名，默认为 <code>FlameGraph.svg</code>，仅当生成火焰图时才有效。</p>
<h4 id="示例-1"><a class="header" href="#示例-1">示例</a></h4>
<ul>
<li>生成默认的 CPU 热点函数文本报告。</li>
</ul>
<pre><code class="language-text"># 分析 sample.data 中的采样数据，生成 CPU 热点函数文本报告。
cjprof report -i sample.data
</code></pre>
<ul>
<li>生成 CPU 热点函数火焰图。</li>
</ul>
<pre><code class="language-text"># 分析 cjprof.data（默认文件）中的采样数据，生成名为 test.svg 的 CPU 热点函数火焰图。
cjprof report -F -o test.svg
</code></pre>
<h4 id="报告形式说明"><a class="header" href="#报告形式说明">报告形式说明</a></h4>
<ul>
<li>
<p>文本形式的报告包含函数采样总占比（包含子函数）、函数采样占比（自身）以及函数名（如果没有对应的符号信息则显示为地址）三部分，报告结果以函数采样总占比降序排列。</p>
</li>
<li>
<p>火焰图中的横轴代表采样占比大小，越宽表示采样占比越大，即运行时间越长，纵轴表示调用栈，父函数在下，子函数在上。</p>
</li>
</ul>
<h3 id="导出和分析堆内存"><a class="header" href="#导出和分析堆内存">导出和分析堆内存</a></h3>
<h4 id="命令-2"><a class="header" href="#命令-2">命令</a></h4>
<pre><code class="language-text">cjprof heap
</code></pre>
<h4 id="格式-2"><a class="header" href="#格式-2">格式</a></h4>
<pre><code class="language-text">cjprof heap [&lt;options&gt;]
</code></pre>
<h4 id="选项-2"><a class="header" href="#选项-2">选项</a></h4>
<p><code>-D, --depth &lt;depth&gt;</code> 指定对象的引用/被引用关系最大展示深度，默认为 10 层，仅在指定了 <code>--show-reference</code> 时才能生效。</p>
<p><code>-d, --dump &lt;pid&gt;</code> 导出仓颉应用程序当前时刻的堆内存，<code>pid</code> 为应用程序进程号，当指定为应用程序的子线程号时，同样可导出。</p>
<p><code>-i, --input &lt;file&gt;</code> 指定进行分析的堆内存数据文件名，默认为 <code>cjprof.data</code> 。</p>
<p><code>-o, --output &lt;file&gt;</code> 指定导出的堆内存数据文件名，默认为 <code>cjprof.data</code> 。</p>
<p><code>--show-reference[=&lt;objnames&gt;]</code> 分析报告中展示对象的引用关系，<code>objnames</code> 为需要展示的对象名，多个对象使用 <code>;</code> 隔开，不指定时默认展示所有对象。</p>
<p><code>--incoming-reference</code> 展示对象的被引用关系，而非引用关系，需要与 <code>--show-reference</code> 配合使用。</p>
<p><code>-t, --show-thread</code> 分析报告中展示仓颉线程栈，以及在栈中引用的对象。</p>
<p><code>-V, --verbose</code> 维测选项，解析堆内存数据文件时打印解析日志。</p>
<h4 id="示例-2"><a class="header" href="#示例-2">示例</a></h4>
<ul>
<li>导出堆内存数据。</li>
</ul>
<pre><code class="language-text"># 将正在运行的应用程序（进程号为 12345）当前时刻的堆内存导出到当前路径下名为 heap.data 的文件中
cjprof heap -d 12345 -o heap.data
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p>导出堆内存时会向进程发送 <code>SIG_USR1</code> 信号，在不确定目标进程是否为仓颉应用程序时，需要谨慎操作，否则可能会给目标进程误发送信号导致非预期错误。</p>
</blockquote>
<ul>
<li>分析堆内存数据，展示对象信息。</li>
</ul>
<pre><code class="language-text"># 解析并分析 ~ 目录下名为 heap.data 的堆内存数据文件，展示堆中各激活对象的对象类型名、实例个数、浅堆大小和深堆大小。
cjprof heap -i ~/heap.data
</code></pre>
<p>执行上述命令的效果如下：</p>
<pre><code class="language-text">Object Type           Objects        Shallow Heap   Retained Heap
====================  =============  =============  =============
AAA                               1            80             400
BBB                               4            32             196
CCC                               2            16              32
</code></pre>
<ul>
<li>分析堆内存数据，展示仓颉线程栈及对象引用。</li>
</ul>
<pre><code class="language-text"># 解析并分析当前目录下名为 cjprof.data（默认文件）的堆内存数据文件，展示仓颉线程栈与栈中引用的对象。
cjprof heap --show-thread
</code></pre>
<p>执行上述命令的效果如下：</p>
<pre><code class="language-text">Object/Stack Frame                   Shallow Heap   Retained Heap
===================================  =============  =============
thread0
  at Func2() (/home/test/test.cj:10)
    &lt;local&gt; AAA @ 0x7f1234567800                80            400
  at Func1() (/home/test/test.cj:20)
    &lt;local&gt; CCC @ 0x7f12345678c0                16             16
  at main (/home/test/test.cj:30)
</code></pre>
<ul>
<li>分析堆内存数据，展示对象的引用关系。</li>
</ul>
<pre><code class="language-text"># 解析并分析当前目录下名为 cjprof.data（默认文件）的堆内存数据文件，展示 AAA 和 BBB 类型对象的引用关系。
cjprof heap --show-reference=&quot;AAA;BBB&quot;
</code></pre>
<p>执行上述命令的效果如下：</p>
<pre><code class="language-text">Objects with outgoing references:
Object Type                          Shallow Heap   Retained Heap
===================================  =============  =============
AAA @ 0x7f1234567800                            80            400
  BBB @ 0x7f1234567880                          32             48
    CCC @ 0x7f12345678c0                        16             16
  CCC @ 0x7f12345678e0                          16             16
BBB @ 0x7f1234567880                            32             48
  CCC @ 0x7f12345678c0                          16             16
</code></pre>
<ul>
<li>分析堆内存数据，展示对象的被引用关系。</li>
</ul>
<pre><code class="language-text"># 解析并分析当前目录下名为 cjprof.data（默认文件）的堆内存数据文件，展示 CCC 类型对象的被引用关系。
cjprof heap --show-reference=&quot;CCC&quot; --incoming-reference
</code></pre>
<p>执行上述命令的效果如下：</p>
<pre><code class="language-text">Objects with incoming references:
Object Type                          Shallow Heap   Retained Heap
===================================  =============  =============
CCC @ 0x7f12345678c0                            16             16
  BBB @ 0x7f1234567880                          32             48
    AAA @ 0x7f1234567800                        80            400
CCC @ 0x7f12345678e0                            16             16
  AAA @ 0x7f1234567800                          80            400
</code></pre>
<h4 id="堆内存分析报告说明"><a class="header" href="#堆内存分析报告说明">堆内存分析报告说明</a></h4>
<ul>
<li>
<p>对象类型名使用 <code>RawArray&lt;Byte&gt;[]</code>，<code>RawArray&lt;Half&gt;[]</code>，<code>RawArray&lt;Word&gt;[]</code> 和 <code>RawArray&lt;DWord&gt;[]</code> 分别表示 1 字节、2 字节、4 字节和 8 字节大小的基础数据类型原始数组。</p>
</li>
<li>
<p>浅堆是指对象自身所占用的堆内存大小，深堆是指对象被垃圾回收后，可以被释放的所有对象（即仅能通过该对象直接或间接引用到的对象）的浅堆大小之和。</p>
</li>
<li>
<p>当对象的引用关系层级超出最大展示深度后，或是存在循环引用出现重复对象后，会使用 <code>...</code> 来省略后续引用。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-文档生成工具"><a class="header" href="#api-文档生成工具">API 文档生成工具</a></h1>
<h2 id="功能简介-10"><a class="header" href="#功能简介-10">功能简介</a></h2>
<p><code>cjdoc(Cangjie Doc)</code> 是一个支持仓颉语言的 API 文档生成器。</p>
<p><code>cjdoc</code> 能提取源文件的全局变量、函数、类、结构体、接口、枚举、扩展等语法的文档注释，并输出 HTML 格式的 API 接口文档。</p>
<h2 id="文档注释介绍"><a class="header" href="#文档注释介绍">文档注释介绍</a></h2>
<h3 id="什么是文档注释"><a class="header" href="#什么是文档注释">什么是文档注释</a></h3>
<p>文档注释是为自动生成文档而写的注释，它是一种带有特殊功能的注释。 <code>cjdoc</code> 能够识别遵循 <code>cjdoc</code> 风格注释的文档注释。</p>
<p><code>cjdoc</code> 风格文档注释以  <code>/**</code> 开头、以 <code>*/</code> 结尾，并且当编辑多行注释时，每行要以星号开头。文档注释与一般注释的最大区别在于起始符号是<code>/**</code>而不是<code>/*</code>或<code>//</code>。</p>
<pre><code>/**
 * 这是文档注释
 */

/** 这是文档注释 */

/*
 * 这是一般注释
 */

// 这是一般注释
</code></pre>
<h3 id="文档注释格式"><a class="header" href="#文档注释格式">文档注释格式</a></h3>
<p><code>cjdoc</code>  的一个文档注释由两部分组成，分别为描述部分和注解部分，描述部分又可分为简要描述和详细描述。不同的写法举例如下：</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>以下写法的描述部分如果需要有换行效果，需要在换行地方加上<code>\n</code>。</p>
</blockquote>
<ul>
<li>写法 1： 描述部分不区分简要描述和详细描述</li>
</ul>
<pre><code>/**
 * this is description （描述部分）
 *
 * @param parameter-name explanation （注解部分）
 * @return explanation （注解部分）
 */
</code></pre>
<ul>
<li>写法 2：只有描述部分</li>
</ul>
<pre><code>/**
 * this is description （描述部分）
 */
</code></pre>
<ul>
<li>写法 3：文档注释只有一行，描述部分不区分简要描述和详细描述</li>
</ul>
<pre><code>/** this is description （描述部分）*/
</code></pre>
<ul>
<li>写法 4：描述部分区分简要描述和详细描述</li>
</ul>
<pre><code>/**
 * @brief this is brief description （简要描述）
 *
 * this is detailed description （详细描述）
 *
 * @param parameter-name explanation （注解部分）
 */
</code></pre>
<ul>
<li>写法 5：描述部分需要换行，需要在换行地方加上<code>\n</code></li>
</ul>
<p>正例:</p>
<pre><code>/**
 * this is description.\n
 * add a new line
 */
</code></pre>
<p>html 文档效果:</p>
<pre><code>this is description
add a new line
</code></pre>
<p>反例：</p>
<pre><code>/**
 * this is description.
 * add a new line
 */
</code></pre>
<p>html 文档效果:</p>
<pre><code>this is description. add a new line
</code></pre>
<h3 id="cjdoc-支持的注解"><a class="header" href="#cjdoc-支持的注解">cjdoc 支持的注解</a></h3>
<div class="table-wrapper"><table><thead><tr><th><strong>标签</strong></th><th><strong>描述</strong></th><th><strong>示例</strong></th></tr></thead><tbody>
<tr><td>@file</td><td>文件描述信息</td><td>@file file description</td></tr>
<tr><td>@author</td><td>标识作者</td><td>@author description</td></tr>
<tr><td>@version</td><td>指定版本</td><td>@version info</td></tr>
<tr><td>@date</td><td>指定日期</td><td>@date datetime</td></tr>
<tr><td>@since</td><td>标记当引入一个特定的变化时</td><td>@since release</td></tr>
<tr><td>@see</td><td>指定一个到另一个主题的链接</td><td>@see anchor</td></tr>
<tr><td>@brief</td><td>标记简要描述</td><td>@brief  brief description</td></tr>
<tr><td>@param</td><td>说明一个方法的参数</td><td>@param parameter-name explanation</td></tr>
<tr><td>@return</td><td>说明返回值类型</td><td>@return explanation</td></tr>
<tr><td>@throws</td><td>和 @exception 标签一样</td><td>The @throws tag has the same meaning as the @exception tag</td></tr>
<tr><td>@exception</td><td>标志抛出的异常</td><td>@exception exception-name explanation</td></tr>
<tr><td>@note</td><td>标记提示信息</td><td>@note note text</td></tr>
<tr><td>@warning</td><td>标记告警信息</td><td>@warning  warning text</td></tr>
<tr><td>@attention</td><td>标记需要注意的信息</td><td>@attention attention text</td></tr>
</tbody></table>
</div>
<p>以下 3 个注解正式代码中不建议用，但是 <code>cjdoc</code> 也支持:</p>
<div class="table-wrapper"><table><thead><tr><th><strong>标签</strong></th><th><strong>描述</strong></th><th><strong>示例</strong></th></tr></thead><tbody>
<tr><td>@todo</td><td>标记后续需要做的事</td><td>@todo paragraph describing what is to be done</td></tr>
<tr><td>@bug</td><td>标记代码中未解决的 bug</td><td>@bug  bug description</td></tr>
<tr><td>@deprecated</td><td>标记过期的用法</td><td>@deprecated description</td></tr>
</tbody></table>
</div>
<h2 id="使用说明-9"><a class="header" href="#使用说明-9">使用说明</a></h2>
<p>使用<code>cjdoc -h</code> 查看 <code>cjdoc</code> 工具的命令帮助。</p>
<pre><code class="language-text">Doxygen version 1.9.3 (cd5f678d1ce70159572e23563d4e21735e8dfe29*)
Copyright Dimitri van Heesch 1997-2021

You can use doxygen in a number of ways:

1) Use doxygen to generate a template configuration file:
    ./cjdoc [-s] -g [configName]

2) Use doxygen to update an old configuration file:
    ./cjdoc [-s] -u [configName]

3) Use doxygen to generate documentation using an existing configuration file:
    ./cjdoc [configName]

4) Use doxygen to generate a template file controlling the layout of the
   generated documentation:
    ./cjdoc -l [layoutFileName]

    In case layoutFileName is omitted layoutFileName.xml will be used as filename.
    If - is used for layoutFileName doxygen will write to standard output.

5) Use doxygen to generate a template style sheet file for RTF, HTML or Latex.
    RTF:        ./cjdoc -w rtf styleSheetFile
    HTML:       ./cjdoc -w html headerFile footerFile styleSheetFile [configFile]
    LaTeX:      ./cjdoc -w latex headerFile footerFile styleSheetFile [configFile]

6) Use doxygen to generate a rtf extensions file
    ./cjdoc -e rtf extensionsFile

    If - is used for extensionsFile doxygen will write to standard output.

7) Use doxygen to compare the used configuration file with the template configuration file
    ./cjdoc -x [configFile]

8) Use doxygen to show a list of built-in emojis.
    ./cjdoc -f emoji outputFileName

    If - is used for outputFileName doxygen will write to standard output.

If -s is specified the comments of the configuration items in the config file will be omitted.
If configName is omitted 'Doxyfile' will be used as a default.
If - is used for configFile doxygen will write / read the configuration to /from standard output / input.

If -q is used for a doxygen documentation run, doxygen will see this as if QUIET=YES has been set.

-v print version string, -V print extended version information
</code></pre>
<p>下面是几个常用的和配置文件相关的命令。</p>
<h3 id="生成配置文件"><a class="header" href="#生成配置文件">生成配置文件</a></h3>
<p>生成配置文件模板，如果没有输入 configName ，则默认生成文件名为 Doxyfile 的配置文件。</p>
<pre><code>cjdoc -g [configName]
</code></pre>
<p>使用配置文件 configName 生成文档。</p>
<pre><code>cjdoc [configName]
</code></pre>
<p>将 configFile 和默认配置比较，可以看到当前配置修改了哪些条目。</p>
<pre><code>cjdoc -x [configFile]
</code></pre>
<blockquote>
<p><strong>说明：</strong></p>
<p>若使用<code>-g</code>命令时，<code>configName</code>或<code>Doxyfile</code>已存在，则会生成<code>.bak</code>配置文件以备份旧的配置文件信息，并生成新的默认配置文件<code>configName</code>或<code>Doxyfile</code>。</p>
</blockquote>
<h3 id="常用配置选项"><a class="header" href="#常用配置选项">常用配置选项</a></h3>
<h4 id="建议配置的选项"><a class="header" href="#建议配置的选项">建议配置的选项</a></h4>
<p>| 配置选项         | 默认值                     | 描述                         |
| ---------------- | -------------------------- |----------------------------|
| RECURSIVE        | 默认 NO，建议配置成 YES    | 是否递归扫描 INPUT 配置的路径         |
| EXTRACT_ALL      | 默认 NO，建议配置成 YES    | 如果配置 NO，只会显示带有文档注释的 API 接口 |
| GENERATE_LATEX   | 默认 YES，建议配置成 NO    | 是否生成 latex 文件              |
| INPUT            | 默认空，不配置默认当前路径 | 用于指定生成文档的源文件的路径    |
| OUTPUT_DIRECTORY | 默认空，不配置默认当前路径 | 文档输出路径                     |</p>
<ul>
<li>
<p><code>INPUT</code>使用示例</p>
<blockquote>
<p><strong>说明：</strong></p>
<p>若有多个源文件路径，可以在<code>INPUT</code>输入多个路径（文件或目录），以空格相隔， 也可以使用<code>INPUT +=</code>添加多个路径。</p>
</blockquote>
<p>例 1：添加以执行<code>cjdoc</code>所在的相对路径。</p>
<pre><code>INPUT = src/spirit/annotation src/spirit/dbconnection src/spirit/util/enum_enhance.cj
</code></pre>
<p>例 2：添加绝对路径。</p>
<pre><code>INPUT = /home/project/src/spirit/annotation /home/project/src/spirit/dbconnection /home/project/src/spirit/util
</code></pre>
<p>例 3：INPUT += 添加多个路径。</p>
<pre><code>INPUT = src/spirit/annotation
INPUT += src/spirit/dbconnection
INPUT += src/spirit/util
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p>若所输入路径是不存在的路径，会在执行 cjdoc 过程中显示：warning: source 'xxx' is not a readable file or directory... skipping。</p>
</blockquote>
</li>
<li>
<p><code>EXCLUDE</code>使用示例</p>
<blockquote>
<p><strong>说明：</strong></p>
<p><code>EXCLUDE</code>配置选项可用于从<code>INPUT</code>中排除相应的文件或目录。</p>
</blockquote>
<p>例 1：添加以执行<code>cjdoc</code>所在的相对路径。</p>
<pre><code>EXCLUDE = src/spirit/annotation src/spirit/dbconnection src/spirit/util/enum_enhance.cj
</code></pre>
<p>例 2：添加绝对路径。</p>
<pre><code>EXCLUDE = /home/project/src/spirit/annotation /home/project/src/spirit/dbconnection /home/project/src/spirit/util
</code></pre>
<p>例 3：EXCLUDE += 添加多个路径。</p>
<pre><code>EXCLUDE = src/spirit/annotation
EXCLUDE += src/spirit/dbconnection
EXCLUDE += src/spirit/util
</code></pre>
</li>
</ul>
<h4 id="其他常用选项"><a class="header" href="#其他常用选项">其他常用选项</a></h4>
<div class="table-wrapper"><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody>
<tr><td>PROJECT_NAME</td><td>默认空，可不配</td><td>工程名，最后会显示在 html 页面标题上</td></tr>
<tr><td>GENERATE_HTML</td><td>默认 YES</td><td>生成 html 格式的 API 文档</td></tr>
<tr><td>HTML_OUTPUT</td><td>默认 html</td><td>html 文件生成在 {OUTPUT_DIRECTORY}/{HTML_OUTPUT} 目录下</td></tr>
<tr><td>EXTRACT_PRIVATE</td><td>默认 NO</td><td>是否显示属性为 private 的接口</td></tr>
<tr><td>EXTRACT_PROTECTED</td><td>默认 NO</td><td>是否显示属性为 protected 的接口</td></tr>
<tr><td>EXTRACT_PACKAGE</td><td>默认 NO</td><td>是否显示属性为 package 的接口</td></tr>
<tr><td>EXTRACT_STATIC</td><td>默认 NO</td><td>是否显示属性为 static 的接口</td></tr>
</tbody></table>
</div>
<h3 id="执行-cjdoc"><a class="header" href="#执行-cjdoc">执行 cjdoc</a></h3>
<pre><code>cjdoc [configName]
</code></pre>
<p>使用配置文件 <code>configName</code> 生成 API 文档。如果没有指定 <code>configName</code>，默认使用当前目录下文件名为 <code>Doxyfile</code> 的配置文件，<code>configName</code>文件可以命名为任何 Linux 支持的文件名。</p>
<p>执行完<code>cjdoc</code>后，在输出路径下生成<code>html</code>格式文档，可在<code>html</code>目录下点击<code>index.html</code>查看文档构建效果。</p>
<h2 id="相关资料"><a class="header" href="#相关资料">相关资料</a></h2>
<p><code>cjdoc</code> 是基于开源工具 doxygen 扩展了仓颉语言。doxygen 本身功能非常庞大，资料丰富，cjdoc 中非语言相关的特性，与 doxygen 是互通的。
doxygen 的参考手册可参照: <a href="https://www.doxygen.nl/manual/index.html">doxygen 用户手册</a>。</p>
<h2 id="注意事项-3"><a class="header" href="#注意事项-3">注意事项</a></h2>
<p>Windows 版本不支持包含中文的路径生成 API 文档，如需对路径中包含中文的源码文件生成 API 文档，请使用 Linux 版本。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="highlight.js"></script>
        <script src="assets/elasticlunr.js"></script>
        <script src="assets/fzf.umd.js"></script>
        <script src="assets/sidebar.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
