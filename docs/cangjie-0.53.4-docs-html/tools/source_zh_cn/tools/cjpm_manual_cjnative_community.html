<!DOCTYPE HTML>
<html lang="zh-cn" class="ayu" dir="ltr">
    <head>
            <script type="text/x-mathjax-config">
                MathJax.Hub.Config({
                    showProcessingMessages: false,
                    messageStyle: "none",
                    extensions: ['tex2jax.js'],
                    jax: ['input/TeX', 'output/HTML-CSS'],
                    tex2jax: {
                        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
                        processEscapes: true
                    },
                    "HTML-CSS": { availableFonts: ["STIX", "TeX"] }
                });
            </script>
            
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>包管理工具 - 仓颉语言工具使用指南</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../assets/style.css">
        <link rel="stylesheet" href="../../assets/theme.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('ayu')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../../source_zh_cn/IDE/user_manual_community.html"><strong aria-hidden="true">1.</strong> IDE 插件使用指南</a></li><li class="chapter-item expanded "><a href="../../source_zh_cn/tools/user_manual_cjnative.html"><strong aria-hidden="true">2.</strong> 命令行工具使用指南</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../source_zh_cn/tools/cjpm_manual_cjnative_community.html" class="active"><strong aria-hidden="true">2.1.</strong> 包管理工具</a></li><li class="chapter-item "><a href="../../source_zh_cn/tools/cjdb_manual_cjnative.html"><strong aria-hidden="true">2.2.</strong> 调试工具</a></li><li class="chapter-item "><a href="../../source_zh_cn/tools/cjlint_manual_community.html"><strong aria-hidden="true">2.3.</strong> 静态检查工具</a></li><li class="chapter-item "><a href="../../source_zh_cn/tools/cjfmt_manual.html"><strong aria-hidden="true">2.4.</strong> 格式化工具</a></li><li class="chapter-item "><a href="../../source_zh_cn/tools/cjcov_manual_cjnative.html"><strong aria-hidden="true">2.5.</strong> 覆盖率工具</a></li><li class="chapter-item "><a href="../../source_zh_cn/tools/cjprof_manual_cjnative.html"><strong aria-hidden="true">2.6.</strong> 性能分析工具</a></li><li class="chapter-item "><a href="../../source_zh_cn/tools/cjdoc_manual.html"><strong aria-hidden="true">2.7.</strong> API文档生成工具</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">仓颉语言工具使用指南</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="命令行模式编译"><a class="header" href="#命令行模式编译">命令行模式编译</a></h1>
<h2 id="功能简介"><a class="header" href="#功能简介">功能简介</a></h2>
<p><code>CJPM（Cangjie Package Manager）</code> 是仓颉语言的官方包管理工具，用于管理、维护仓颉项目的模块系统，并且提供简易统一的编译入口，支持自定义编译命令。</p>
<h2 id="使用说明"><a class="header" href="#使用说明">使用说明</a></h2>
<p>通过 <code>cjpm -h</code> 即可查看主界面，由几个板块组成，从上到下分别是： 当前命令说明、使用示例（Usage）、支持的可用命令（Available subcommands）、支持的配置项（Available options）、更多提示内容。</p>
<pre><code class="language-text">Cangjie Package Manager

Usage:
  cjpm [subcommand] [option]

Available subcommands:
  init             Init a new cangjie module
  check            Check the dependencies
  update           Update cjpm.lock
  tree             Display the package dependencies in the source code
  build            Compile the current module
  run              Compile and run an executable product
  test             Unittest a local package or module
  clean            Clean up the target directory
  install          Install a cangjie binary
  uninstall        Uninstall a cangjie binary

Available options:
  -h, --help       help for cjpm
  -v, --version    version for cjpm

Use &quot;cjpm [subcommand] --help&quot; for more information about a command.
</code></pre>
<p>基本的使用操作命令如下所示：</p>
<pre><code class="language-shell">cjpm build --help
</code></pre>
<p><code>cjpm</code> 是主程序的名称， <code>build</code> 是当前执行的可用命令， <code>--help</code> 是当前可用命令可用的配置项（配置项通常有长和短两种写法，效果相同）。</p>
<p>成功执行后会显示如下结果：</p>
<pre><code class="language-text">Compile a local module and all of its dependencies.

Usage:
  cjpm build [option]

Available options:
  -h, --help                    help for build
  -i, --incremental             enable incremental compilation
  -j, --jobs &lt;N&gt;                the number of jobs to spawn in parallel during the build process
  -V, --verbose                 enable verbose
  -g                            enable compile debug version target
  --coverage                    enable coverage
  --cfg                         enable the customized option 'cfg'
  -m, --member &lt;value&gt;          specify a member module of the workspace
  --target &lt;value&gt;              generate code for the given target platform
  --target-dir &lt;value&gt;          specify target directory
  -o, --output &lt;value&gt;          specify product name when compiling an executable file
  -l, --lint                    enable cjlint code check
  --mock                        enable support of mocking classes in tests
  --skip-script                 disable script 'build.cj'.
</code></pre>
<h2 id="命令说明"><a class="header" href="#命令说明">命令说明</a></h2>
<h3 id="init"><a class="header" href="#init">init</a></h3>
<p><code>init</code> 用于初始化一个新的仓颉模块或者工作空间。初始化模块时会默认在当前文件夹创建 <code>cjpm.toml</code> 文件，并且新建 <code>src</code> 源码文件夹。如果该模块的产物为可执行类型，则会在 <code>src</code> 下生成默认的 <code>main.cj</code> 文件，并在编译后打印输出 <code>hello world</code>。初始化工作空间时仅会创建 <code>cjpm.toml</code> 文件，默认会扫描该路径下已有的仓颉模块并添加到 <code>members</code> 字段中。若已存在 <code>cjpm.toml</code> 文件，或源码文件夹内已存在 <code>main.cj</code>，则会跳过对应的文件创建步骤。</p>
<p><code>init</code> 有多个可配置项：</p>
<ul>
<li><code>--name &lt;value&gt;</code> 指定新建模块的 <code>root</code> 包名，不指定时默认为上一级子文件夹名称</li>
<li><code>--path &lt;value&gt;</code> 指定新建模块的路径，不指定时默认为当前文件夹</li>
<li><code>--type=&lt;executable|static|dynamic&gt;</code> 指定新建模块的产物类型，缺省时默认为 <code>executable</code></li>
<li><code>--workspace</code> 新建一个工作空间配置文件，指定该选项时以上其它选项无效会自动忽略</li>
</ul>
<p>例如：</p>
<pre><code class="language-text">输入: cjpm init
输出: cjpm init success

输入: cjpm init --name demo --path project
输出: cjpm init success

输入: cjpm init --type=static
输出: cjpm init success
</code></pre>
<h3 id="check"><a class="header" href="#check">check</a></h3>
<p><code>check</code> 命令用于检查项目中所需的依赖项，执行成功将会打印有效的包编译顺序。</p>
<p><code>check</code> 有多个可配置项：</p>
<ul>
<li><code>-m, --member &lt;value&gt;</code> 仅可在工作空间下使用，可用于指定单个模块作为检查入口</li>
<li><code>--no-tests</code> 配置后，测试相关的依赖将不会被打印</li>
<li><code>--skip-script</code> 配置后，将会跳过构建脚本的编译运行</li>
</ul>
<p>例如：</p>
<pre><code class="language-text">输入: cjpm check
输出:
The valid serial compilation order is:
    b.pkgA -&gt; b
cjpm check success

输入: cjpm check
输出:
Error: cyclic dependency
b.B -&gt; c.C
c.C -&gt; d.D
d.D -&gt; b.B
输出说明：上述输出中，b.B 代表以 b 为 root 包的模块中的一个名为 b.B 的子包

输入: cjpm check
输出:
Error: can not find the following dependencies
    pro1.xoo
    pro1.yoo
    pro2.zoo
</code></pre>
<h3 id="update"><a class="header" href="#update">update</a></h3>
<p><code>update</code> 用于将 <code>cjpm.toml</code> 里的内容更新到 <code>cjpm.lock</code>。当 <code>cjpm.lock</code> 不存在时，将会生成该文件。<code>cjpm.lock</code> 文件记录着 git 依赖的版本号等元信息，用于下次构建使用。</p>
<p><code>update</code> 有以下可配置项：</p>
<ul>
<li><code>--skip-script</code> 配置后，将会跳过构建脚本的编译运行</li>
</ul>
<pre><code class="language-text">输入: cjpm update
输出: cjpm update success
</code></pre>
<h3 id="tree"><a class="header" href="#tree">tree</a></h3>
<p><code>tree</code> 命令用于可视化地展示仓颉源码中的包依赖关系。</p>
<p><code>tree</code> 有多个可配置项：</p>
<ul>
<li><code>-p, --package &lt;value&gt;</code> 指定某个包为根节点，从而展示它的子依赖包，需要配置的值是包名</li>
<li><code>--invert &lt;value&gt;</code> 指定某个包为根节点并反转依赖树，从而展示它被哪些包所依赖，需要配置的值是包名</li>
<li><code>--depth &lt;N&gt;</code> 指定依赖树的最大深度，可选值是非负整数。指定该选项时，默认会以所有包作为根节点。其中，N 的值代表每个依赖树的子节点最大深度</li>
<li><code>--target &lt;value&gt;</code> 将指定目标平台的依赖项加入分析，并展示依赖关系</li>
<li><code>--no-tests</code> 排除 <code>test-dependencies</code> 字段的依赖项</li>
<li><code>-V, --verbose</code> 增加包节点的详细信息，包括包名、版本号和包路径</li>
<li><code>--skip-script</code> 配置后，将会跳过构建脚本的编译运行</li>
</ul>
<pre><code class="language-text">输入: cjpm tree
输出:
|-- a
    └── a.aoo
        └── a.coo
    └── a.boo
        └── a.coo
|-- a.doo
    └── a.coo
|-- a.eoo
cjpm tree success

输入: cjpm tree --depth 2 -p a
输出:
|-- a
    └── a.aoo
        └── a.coo
    └── a.boo
        └── a.coo
cjpm tree success

输入: cjpm tree --depth 0
输出:
|-- a
|-- a.eoo
|-- a.aoo
|-- a.boo
|-- a.doo
|-- a.coo
cjpm tree success

输入: cjpm tree --invert a.coo --verbose
输出:
|-- a.coo 1.2.0 （.../src/coo）
    └── a.aoo 1.1.0 （.../src/aoo）
            └── a 1.0.0 （.../src）
    └── a.boo 1.1.0 （.../src/boo）
            └── a 1.0.0 （.../src）
    └── a.doo 1.3.0 （.../src/doo）
cjpm tree success
</code></pre>
<h3 id="build"><a class="header" href="#build">build</a></h3>
<p><code>build</code> 用于构建当前仓颉项目，执行该命令前会先检查依赖项，检查通过后调用 <code>cjc</code> 进行构建。</p>
<p><code>build</code> 有多个可配置项：</p>
<ul>
<li><code>-i, --incremental</code> 用于指定增量编译，默认情况下是全量编译</li>
<li><code>-j, --jobs &lt;N&gt;</code> 用于指定并行编译的最大并发数，最终的最大并发数取 <code>N</code> 和 <code>2倍 CPU 核数</code> 的最小值</li>
<li><code>-V, --verbose</code> 用于展示编译日志</li>
<li><code>-g</code> 用于生成 <code>debug</code> 版本的输出产物</li>
<li><code>--mock</code> 带有此选项的构建版本中的类可用于在测试中进行 <code>mock</code> 测试</li>
<li><code>--coverage</code> 用于生成覆盖率信息，默认情况下不开启覆盖率功能</li>
<li><code>--cfg</code> 指定后，能够透传 <code>cjpm.toml</code> 中的自定义 <code>cfg</code> 选项</li>
<li><code>-m, --member &lt;value&gt;</code> 仅可在工作空间下使用，可用于指定单个模块作为编译入口</li>
<li><code>--target-dir &lt;value&gt;</code> 用于指定输出产物的存放路径</li>
<li><code>-o, --output &lt;value&gt;</code> 用于指定输出可执行文件的名称，默认名称为 <code>main</code>（<code>windows</code> 下则默认为 <code>main.exe</code>）</li>
<li><code>--target &lt;value&gt;</code> 指定后，可交叉编译代码到目标平台，<code>cjpm.toml</code> 中的配置可参考<a href="./cjpm_manual_cjnative_community.html#target">target</a>章节</li>
<li><code>-l, --lint</code> 用于在编译时调用仓颉语言静态检查工具进行代码检查</li>
<li><code>--skip-script</code> 配置后，将会跳过构建脚本的编译运行</li>
</ul>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li><code>-i, --incremental</code> 选项仅会开启 <code>cjpm</code> 包级别的增量编译。开发者可以在配置文件的 <code>compile-option</code> 字段自行透传 <code>--incremental-compile</code> 编译选项，从而开启 <code>cjc</code> 编译器提供的函数粒度增量功能。</li>
<li><code>-i, --incremental</code> 选项目前仅支持基于源码的增量分析。如果导入的库内容有变更，需要开发者重新使用全量方式构建。</li>
</ul>
</blockquote>
<p>编译生成的中间文件默认会存放在 <code>target</code> 文件夹，而可执行文件会根据编译模式存放到 <code>target/release/bin</code> 或 <code>target/debug/bin</code> 文件夹。为了提供可复制的构建，此命令会创建 <code>cjpm.lock</code> 文件，该文件包含所有可传递依赖项的确切版本，这些依赖项将用于所有后续构建，需要更新该文件时请使用 <code>update</code> 命令。如果有必要保证每个项目参与者都有可复制的构建，那么此文件应提交到版本控制系统中。</p>
<p>例如：</p>
<pre><code class="language-text">输入: cjpm build -V
输出:
compile package module1.package1: cjc --import-path &quot;target/release&quot; --output-dir &quot;target/release/module1&quot; -p &quot;src/package1&quot; --output-type=staticlib -o libmodule1.package1.a
compile package module1: cjc --import-path &quot;target/release&quot; --output-dir &quot;target/release/bin&quot; -p &quot;src&quot; --output-type=exe -o main
cjpm build success

输入: cjpm build
输出: cjpm build success
</code></pre>
<p><code>cjpm build</code> 配置 <code>-l, --lint</code> 选项时，会在编译期间调用仓颉语言静态检查工具 <code>cjlint</code> 进行代码检查。如果检查到【要求】级别的代码规范违规，则此次编译会失败，相应检查结果会输出至错误流；检查到【建议】级别的违规时仅会告警，并正常完成编译。<code>cjlint</code> 支持检查的代码规则列表及其级别详见 <a href="./cjlint_manual.html#%E6%94%AF%E6%8C%81%E6%A3%80%E6%9F%A5%E7%9A%84%E8%A7%84%E8%8C%83%E5%88%97%E8%A1%A8%E6%8C%81%E7%BB%AD%E6%96%B0%E5%A2%9E%E4%B8%AD">cjlint 用户手册</a>。</p>
<h3 id="run"><a class="header" href="#run">run</a></h3>
<p><code>run</code> 用于运行当前项目构建出的二进制产物。</p>
<p><code>run</code> 有多个可配置项：</p>
<ul>
<li><code>--name &lt;value&gt;</code> 指定运行的二进制名称，不指定时默认为 <code>main</code>，工作空间下的二进制产物默认存放在 <code>target/release/bin</code> 路径下</li>
<li><code>--build-args &lt;value&gt;</code> 控制 <code>cjpm</code> 编译流程的参数</li>
<li><code>--skip-build</code> 跳过编译流程，直接运行</li>
<li><code>--run-args &lt;value&gt;</code> 透传参数给本次运行的二进制产物</li>
<li><code>--target-dir &lt;value&gt;</code> 用于指定运行产物的存放路径</li>
<li><code>-g</code> 用于运行 <code>debug</code> 版本的产物</li>
<li><code>-V, --verbose</code> 用于展示运行日志</li>
<li><code>--skip-script</code> 配置后，将会跳过构建脚本的编译运行</li>
</ul>
<p>例如：</p>
<pre><code class="language-text">输入: cjpm run
输出: cjpm run success

输入: cjpm run -g // 此时会默认执行 cjpm build -i -g 命令
输出: cjpm run success

输入: cjpm run --build-args=&quot;-s -j16&quot; --run-args=&quot;a b c&quot; -V
输出: cjpm run success
</code></pre>
<h3 id="test"><a class="header" href="#test">test</a></h3>
<p><code>test</code> 用于执行仓颉文件的单元测试用例，并直接打印测试结果，编译产物默认存放在 <code>target/release/unittest_bin</code> 文件夹。单元测试用例代码的写法可参考《仓颉编程语言库 API》中 <code>std.unittest</code> 库的说明。</p>
<p>该命令可以指定待测试的单包路径（支持指定多个单包，形如 <code>cjpm test path1 path2</code>），不指定路径时默认执行模块级别的单元测试。<code>test</code> 执行前提是当前项目能够 <code>build</code> 编译成功。</p>
<p>模块的单元测试代码结构如下所示，其中 <code>xxx.cj</code> 存放该包的源码，<code>xxx_test.cj</code> 存放单元测试代码：</p>
<pre><code class="language-text">│   └── src
│       ├── koo
│       │   ├── koo.cj
│       │   └── koo_test.cj
│       ├── zoo
│       │   ├── zoo.cj
│       │   └── zoo_test.cj
│       ├── main.cj
│       └── main_test.cj
│   ├── cjpm.toml
</code></pre>
<pre><code class="language-text">多模块测试场景
输入: cjpm test
输出:
--------------------------------------------------------------------------------------------------
TM: test, TP: default, time elapsed: 177921 ns, RESULT:
    TCS: TestM, time elapsed: 177921 ns, RESULT:
    [ PASSED ] CASE: sayhi (177921 ns)
    Summary: TOTAL: 1
    PASSED: 1, SKIPPED: 0, ERROR: 0
    FAILED: 0
--------------------------------------------------------------------------------------------------
TM: test, TP: koo, time elapsed: 134904 ns, RESULT:
    TCS: TestK, time elapsed: 134904 ns, RESULT:
    [ PASSED ] CASE: sayhi (134904 ns)
    Summary: TOTAL: 1
    PASSED: 1, SKIPPED: 0, ERROR: 0
    FAILED: 0
--------------------------------------------------------------------------------------------------
TM: pro0, TP: zoo, time elapsed: 132013 ns, RESULT:
    TCS: TestZ, time elapsed: 132013 ns, RESULT:
    [ PASSED ] CASE: sayhi (132013 ns)
    Summary: TOTAL: 1
    PASSED: 1, SKIPPED: 0, ERROR: 0
    FAILED: 0
--------------------------------------------------------------------------------------------------
Project tests finished, time elapsed: 444838 ns, RESULT:
TM: pro0, time elapsed: 132013 ns, RESULT:
    PASSED:
    TP: zoo, time elapsed: 132013 ns
TM: test, time elapsed: 312825 ns, RESULT:
    PASSED:
    TP: koo, time elapsed: 312825 ns
    TP: default, time elapsed: 312825 ns
Summary: TOTAL: 3
    PASSED: 3, SKIPPED: 0, ERROR: 0
    FAILED: 0
--------------------------------------------------------------------------------------------------

cjpm test success

单包测试场景
输入: cjpm test src/koo
输出:
--------------------------------------------------------------------------------------------------
TM: test, TP: koo, time elapsed: 160133 ns, RESULT:
    TCS: TestK, time elapsed: 160133 ns, RESULT:
    [ PASSED ] CASE: sayhi (160133 ns)
    Summary: TOTAL: 1
    PASSED: 1, SKIPPED: 0, ERROR: 0
    FAILED: 0
--------------------------------------------------------------------------------------------------
Project tests finished, time elapsed: 160133 ns, RESULT:
TM: test, time elapsed: 160133 ns, RESULT:
    PASSED:
    TP: koo, time elapsed: 160133 ns
Summary: TOTAL: 1
    PASSED: 1, SKIPPED: 0, ERROR: 0
    FAILED: 0
--------------------------------------------------------------------------------------------------
cjpm test success

多包测试场景
输入: cjpm test src/koo src
输出:
--------------------------------------------------------------------------------------------------
TM: test, TP: koo, time elapsed: 168204 ns, RESULT:
    TCS: TestK, time elapsed: 168204 ns, RESULT:
    [ PASSED ] CASE: sayhi (168204 ns)
    Summary: TOTAL: 1
    PASSED: 1, SKIPPED: 0, ERROR: 0
    FAILED: 0
--------------------------------------------------------------------------------------------------
TM: test, TP: default, time elapsed: 171541 ns, RESULT:
    TCS: TestM, time elapsed: 171541 ns, RESULT:
    [ PASSED ] CASE: sayhi (171541 ns)
    Summary: TOTAL: 1
    PASSED: 1, SKIPPED: 0, ERROR: 0
    FAILED: 0
--------------------------------------------------------------------------------------------------
Project tests finished, time elapsed: 339745 ns, RESULT:
TM: test, time elapsed: 339745 ns, RESULT:
    PASSED:
    TP: koo, time elapsed: 339745 ns
    TP: default, time elapsed: 339745 ns
Summary: TOTAL: 2
    PASSED: 2, SKIPPED: 0, ERROR: 0
    FAILED: 0
--------------------------------------------------------------------------------------------------
cjpm test success
</code></pre>
<p><code>test</code> 有多个可配置项：</p>
<ul>
<li><code>--no-run</code> 用于仅编译单元测试产物</li>
<li><code>--skip-build</code> 用于仅执行单元测试产物</li>
<li><code>-j, --jobs &lt;N&gt;</code> 用于指定并行编译的最大并发数，最终的最大并发数取 <code>N</code> 和 <code>2倍 CPU 核数</code> 的最小值</li>
<li><code>-V, --verbose</code> 配置项开启后，会输出单元测试的日志</li>
<li><code>-g</code> 用于生成 <code>debug</code> 版本的单元测试产物，此时的产物存放在 <code>target/debug/unittest_bin</code> 文件夹</li>
<li><code>--bench</code> 用于指定只执行 <code>@bench</code> 宏修饰用例的测试结果</li>
<li><code>--target-dir &lt;value&gt;</code> 用于指定单侧产物的存放路径</li>
<li><code>--coverage</code> 配合 <code>cjcov</code> 命令可以生成单元测试的覆盖率报告。使用 <code>cjpm test --coverage</code> 统计覆盖率时，源代码中的 <code>main</code> 不会再作为程序入口执行，因此会显示为未被覆盖。建议使用 <code>cjpm test</code> 之后，不再手写多余的 <code>main</code></li>
<li><code>--cfg</code> 指定后，能够透传 <code>cjpm.toml</code> 中的自定义 <code>cfg</code> 选项</li>
<li><code>-m, --member &lt;value&gt;</code> 仅可在工作空间下使用，可用于指定测试单个模块</li>
<li><code>--target &lt;value&gt;</code> 指定后，可交叉编译生成目标平台的单元测试结果，<code>cjpm.toml</code> 中的配置可参考<a href="./cjpm_manual_cjnative_community.md.html#target">target</a>章节</li>
<li><code>--filter &lt;value&gt;</code> 用于过滤测试的子集，<code>value</code> 的形式如下所示：
<ul>
<li><code>--filter=*</code> 匹配所有测试类</li>
<li><code>--filter=*.*</code> 匹配所有测试类的所有测试用例（结果和*相同）</li>
<li><code>--filter=*.*Test,*.*case*</code> 匹配所有测试类中以 <code>Test</code> 结尾的用例，或者所有测试类中名字中带有 <code>case</code> 的测试用例</li>
<li><code>--filter=MyTest*.*Test,*.*case*,-*.*myTest</code> 匹配所有 <code>MyTest</code> 开头测试类中以 <code>Test</code> 结尾的用例，或者名字中带有 <code>case</code> 的用例，或者名字中不带有 <code>myTest</code> 的测试用例</li>
</ul>
</li>
<li><code>--random-seed &lt;N&gt;</code> 用于指定随机种子的值</li>
<li><code>--no-color</code> 关闭控制台颜色显示</li>
<li><code>--timeout-each &lt;value&gt;</code> value 的格式为 <code>%d[millis|s|m|h]</code>，为每个测试用例指定默认的超时时间</li>
<li><code>--parallel</code> 用于指定测试用例并行执行的方案， <code>value</code> 的形式如下所示：
<ul>
<li><code>&lt;BOOL&gt;</code> 可为 <code>true</code> 或 <code>false</code>，指定为 <code>true</code> 时，测试类可被并行运行，并行进程个数将受运行系统上的 CPU 核数控制</li>
<li><code>nCores</code> 指定了并行的测试进程个数应该等于可用的 CPU 核数</li>
<li><code>NUMBER</code> 指定了并行的测试进程个数值。该数值应该为正整数</li>
<li><code>NUMBERnCores</code> 指定了并行的测试进程个数值为可用的 CPU 核数的指定数值倍。该数值应该为正数（支持浮点数或整数）</li>
</ul>
</li>
<li><code>--report-path &lt;value&gt;</code> 指定测试执行后的报告生成路径</li>
<li><code>--report-format &lt;value&gt;</code> 指定报告输出格式，当前单元测试报告仅支持 <code>xml</code> 格式（可忽略大小写），使用其它值将会抛出异常, 性能测试报告仅支持 <code>csv</code> 和 <code>csv-raw</code> 格式</li>
<li><code>--skip-script</code> 配置后，将会跳过构建脚本的编译运行</li>
</ul>
<p><code>cjpm test</code> 参数选项使用示例:</p>
<pre><code class="language-text">输入：
cjpm test src --coverage
cjcov --root=./ --html-details -o html_output
输出：cjpm test success
覆盖率生成：在 html_output 目录下会生成 html 文件，总的覆盖率报告文件名固定为 index.html

输入: cjpm test --bench
输出: cjpm test success

输入: cjpm test src --bench
输出: cjpm test success

输入: cjpm test src --filter=*
输出: cjpm test success

输入: cjpm test src --report-path=reports --report-format=xml
输出: cjpm test success
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p><code>cjpm test</code> 会自动构建所有带有 <code>mock</code> 支持的包，因此在测试中，开发者可以对自定义的类或依赖源模块的类进行 <code>mock</code> 测试。为了能够从一些二进制依赖中 <code>mock</code> 类，应该通过 <code>cjpm build --mock</code> 来构建带有 <code>mock</code> 支持的类。
带有 <code>--bench</code> 选项的 <code>cjpm test</code> 并不包含完全的 <code>mock</code> 支持，以避免在基准测试中由于在编译器中的 <code>mock</code> 处理而增加的任何开销。
使用 <code>--bench</code> 选项时，如果使用 <code>mock</code> ，编译器不会报错，以便能够将常规测试和基准测试一起编译。但是要避免运行使用 <code>mock</code> 的基准测试，否则会抛出运行时异常。</p>
</blockquote>
<h3 id="install"><a class="header" href="#install">install</a></h3>
<p><code>install</code> 用于安装仓颉项目，执行该命令前会先进行编译，然后将编译产物安装到指定路径，安装产物以仓颉项目名命名（<code>windows</code> 系统上会有 <code>.exe</code> 后缀）。<code>install</code> 安装的项目产物类型需要是 <code>executable</code>。</p>
<p><code>install</code> 有多个可配置项：</p>
<ul>
<li><code>-V, --verbose</code> 用于展示安装日志</li>
<li><code>-g</code> 用于生成 <code>debug</code> 版本的安装产物</li>
<li><code>--path &lt;value&gt;</code> 用于指定本地安装项目的路径，默认为当前路径下的项目</li>
<li><code>--root &lt;value&gt;</code> 用于指定可执行文件的安装路径，不配置时 <code>linux/macOS</code> 系统下默认为 <code>$HOME/.cjpm</code>，<code>windows</code> 默认为 <code>%USERPROFILE%/.cjpm</code>，配置时将会安装于 <code>value</code></li>
<li><code>-m, --member &lt;value&gt;</code> 仅可在工作空间下使用，可用于指定单个模块作为编译入口以安装单一模块</li>
<li><code>--target-dir &lt;value&gt;</code> 用于指定编译产物的存放路径</li>
<li><code>--name &lt;value&gt;</code> 用于指定最终安装的产物名</li>
<li><code>--git &lt;value&gt;</code> 用于指定 <code>git</code> 安装的项目 <code>url</code></li>
<li><code>--branch &lt;value&gt;</code> 用于指定 <code>git</code> 安装的项目分支</li>
<li><code>--tag &lt;value&gt;</code> 用于指定 <code>git</code> 安装的项目 <code>tag</code></li>
<li><code>--commit &lt;value&gt;</code> 用于指定 <code>git</code> 安装的项目 <code>commit ID</code></li>
<li><code>--list</code> 用于打印已安装产物列表</li>
<li><code>--skip-build</code> 用于跳过编译阶段以直接安装产物，需要项目处于编译完成状态，且仅在本地安装场景下生效</li>
<li><code>-j, --jobs &lt;N&gt;</code> 用于指定并行编译的最大并发数，最终的最大并发数取 <code>N</code> 和 <code>2倍 CPU 核数</code> 的最小值</li>
<li><code>--cfg</code> 指定后，能够透传 <code>cjpm.toml</code> 中的自定义 <code>cfg</code> 选项</li>
<li><code>--skip-script</code> 配置后，将会跳过待安装模块的构建脚本的编译运行</li>
</ul>
<p><code>install</code> 功能有如下注意事项：</p>
<ul>
<li><code>install</code> 共有两种安装方式：安装本地项目（通过 <code>--path</code> 配置项目路径）和安装 <code>git</code> 项目（通过 <code>--git</code> 配置项目 <code>url</code>）。这两种安装方式至多只能配置一种，否则 <code>install</code> 将报错。任意一种均未配置时，默认安装当前目录下的本地项目。</li>
<li><code>install</code> 编译项目时，默认开启增量编译。</li>
<li><code>git</code> 相关配置仅在配置 <code>--git</code> 后生效，否则会被忽略，包括 <code>--branch</code>, <code>--tag</code> 和 <code>--commit</code>。当配置多个 <code>git</code> 相关配置时，仅会生效优先级更高的配置，优先级排序为 <code>--commit</code> &gt; <code>--branch</code> &gt; <code>--tag</code>。</li>
<li>若已存在同名可执行文件被安装，则原来的文件将被替换。</li>
<li>假设安装路径为 <code>root</code>（<code>root</code> 为配置的安装路径，不配置则为默认路径），则可执行文件将被安装于 <code>root/bin</code>。</li>
<li>若项目存在动态库依赖，可执行程序所需动态库会被安装到 <code>root/libs</code>，按程序名分隔为若干目录，开发者需要将对应目录加入相应路径（<code>linux/macOS</code> 中为 <code>LD_LIBRARY_PATH</code>，<code>windows</code> 中为 <code>PATH</code>）方可使用。</li>
<li>默认安装路径（<code>linux/macOS</code> 系统下默认为 <code>$HOME/.cjpm</code>，<code>windows</code> 默认为 <code>%USERPROFILE%/.cjpm</code>）会在 <code>envsetup</code> 中被加入 <code>PATH</code>。</li>
<li><code>install</code> 在安装 <code>git</code> 项目后，对应的编译产物目录会被清除。</li>
<li>在待安装项目仅存在一个可执行文件产物时，指定 <code>--name</code> 会将其更名后安装；若存在多个可执行文件产物，指定 <code>--name</code> 会仅安装对应名称的产物。</li>
<li>配置 <code>--list</code> 时，<code>install</code> 会打印已安装产物列表，此时除 <code>--root</code> 以外的所有配置项均会被忽略。配置 <code>--root</code> 后，<code>--list</code> 会打印配置路径下已安装的产物列表，否则会打印默认路径下的列表。</li>
</ul>
<p>例如：</p>
<pre><code class="language-text">cjpm install --path path/to/project # 从本地路径 path/to/project 中安装
cjpm install --git url              # 从 git 对应地址安装
</code></pre>
<h3 id="uninstall"><a class="header" href="#uninstall">uninstall</a></h3>
<p><code>uninstall</code> 用于卸载仓颉项目，清除对应的可执行文件和依赖文件。</p>
<p><code>uninstall</code> 需要配置参数 <code>name</code>，以卸载名为 <code>name</code> 的产物，配置多个 <code>name</code> 时会依次删除。<code>uninstall</code> 可以通过 <code>--root &lt;value&gt;</code> 指定卸载的可执行文件路径，不配置时 <code>linux/macOS</code> 系统下默认为 <code>$HOME/.cjpm</code>，<code>windows</code> 默认为 <code>%USERPROFILE%/.cjpm</code>，配置时将会卸载安装于 <code>value/bin</code> 的产物和安装于 <code>value/libs</code> 的依赖</p>
<h3 id="clean"><a class="header" href="#clean">clean</a></h3>
<p><code>clean</code> 用于清理构建过程中的临时产物（<code>target</code> 文件夹）。该命令支持通过短选项 <code>-g</code> 指定仅清理 <code>debug</code> 版本的产物。该命令支持通过长选项 <code>--target-dir &lt;value&gt;</code> 用于指定清理的产物存放路径，开发者需自身保证清理该目录行为的安全性。如果使用了 <code>cjpm build --coverage</code> 或者 <code>cjpm test --coverage</code> 功能，还会清除 <code>cov_output</code> 文件夹，以及当前目录下的 <code>*.gcno</code> 文件和 <code>*.gcda</code> 文件。同时，该命令也支持通过 <code>--skip-script</code> 配置跳过构建脚本的编译运行。</p>
<p>例如：</p>
<pre><code class="language-text">输入: cjpm clean
输出: cjpm clean success

输入: cjpm clean --target-dir temp
输出: cjpm clean success
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p>在 <code>windows</code> 平台上，在子进程执行完成后立即清理子进程的可执行文件或父目录可能会失败。如果遇到该问题，可以在一小段延迟后重新尝试 <code>clean</code> 命令。</p>
</blockquote>
<h2 id="模块配置文件说明"><a class="header" href="#模块配置文件说明">模块配置文件说明</a></h2>
<p>模块配置文件 <code>cjpm.toml</code> 用于配置一些基础信息、依赖项、编译选项等内容，<code>cjpm</code> 主要通过这个文件进行解析执行。其中，模块名可以在 <code>cjpm.toml</code> 中进行重命名，但是包名不能在 <code>cjpm.toml</code> 中进行重命名。</p>
<p>配置文件代码如下所示：</p>
<pre><code class="language-text">[package] # 单模块配置字段，与 workspace 字段不能同时存在
  cjc-version = &quot;0.49.1&quot; # 所需 `cjc` 的最低版本要求，必须
  name = &quot;demo&quot; # 模块名及模块 root 包名，必须
  description = &quot;nothing here&quot; # 描述信息，非必须
  version = &quot;1.0.0&quot; # 模块版本信息，必须
  compile-option = &quot;&quot; # 额外编译命令选项，非必须
  link-option = &quot;&quot; # 链接器透传选项，可透传安全编译命令，非必须
  output-type = &quot;executable&quot; # 编译输出产物类型，必须
  src-dir = &quot;&quot; # 指定源码存放路径，非必须
  target-dir = &quot;&quot; # 指定产物存放路径，非必须
  package-configuration = {} # 单包配置选项，非必须

[workspace] # 工作空间管理字段，与 package 字段不能同时存在
  members = [] # 工作空间成员模块列表，必须
  build-members = [] # 工作空间编译模块列表，需要是成员模块列表的子集，非必须
  test-members = [] # 工作空间测试模块列表，需要是编译模块列表的子集，非必须
  compile-option = &quot;&quot; # 应用于所有工作空间成员模块的额外编译命令选项，非必须
  link-option = &quot;&quot; # 应用于所有工作空间成员模块的链接器透传选项，非必须
  target-dir = &quot;&quot; # 指定产物存放路径，非必须

[dependencies] # 源码依赖配置项
  coo = { git = &quot;xxx&quot;，branch = &quot;dev&quot; , version = &quot;1.0.0&quot;} # 导入 `git` 依赖，`version`字段可缺省
  doo = { path = &quot;./pro1&quot; ,version = &quot;1.0.0&quot;} # 导入源码依赖，`version`字段可缺省

[test-dependencies] # 测试阶段的依赖配置项，格式同 dependencies

[ffi.c] # 导入 `c` 库依赖
  clib1.path = &quot;xxx&quot;

[profile] # 命令剖面配置项
  build = {}
  test = {}
  customized-option = {}

[target.x86_64-unknown-linux-gnu] # 后端和平台隔离配置项
  compile-option = &quot;value1&quot; # 额外编译命令选项，适用于特定 target 的编译流程和指定该 target 作为交叉编译目标平台的编译流程，非必须
  link-option = &quot;value2&quot; # 链接器透传选项，适用于特定 target 的编译流程和指定该 target 作为交叉编译目标平台的编译流程，非必须

[target.x86_64-w64-mingw32.dependencies] # 适用于对应 target 的源码依赖配置项，非必须

[target.x86_64-w64-mingw32.test-dependencies] # 适用于对应 target 的测试阶段依赖配置项，非必须

[target.x86_64-unknown-linux-gnu.bin-dependencies] # 仓颉二进制库依赖，适用于特定 target 的编译流程和指定该 target 作为交叉编译目标平台的编译流程，非必须
  path-option = [&quot;./test/pro0&quot;, &quot;./test/pro1&quot;]
[target.x86_64-unknown-linux-gnu.bin-dependencies.package-option]
  &quot;pro0.xoo&quot; = &quot;./test/pro0/pro0.xoo.cjo&quot;
  &quot;pro0.yoo&quot; = &quot;./test/pro0/pro0.yoo.cjo&quot;
  &quot;pro1.zoo&quot; = &quot;./test/pro1/pro1.zoo.cjo&quot;
</code></pre>
<p>当以上字段在 <code>cjpm.toml</code> 中没有使用时，默认为空（对于路径，默认为配置文件所在的路径）。</p>
<h3 id="cjc-version"><a class="header" href="#cjc-version">&quot;cjc-version&quot;</a></h3>
<p>仓颉编译器最低版本要求，必须和当前环境版本兼容才可以执行。一个合法的仓颉版本号是由三段数字组成，中间使用 <code>.</code> 隔开，每个数字均为自然数，且没有多余的前缀 <code>0</code>。例如：</p>
<ul>
<li><code>0.49.1</code> 是一个合法的仓颉版本号；</li>
<li><code>0.049.1</code> 不是一个合法的仓颉版本号，<code>049</code> 中含有多余的前缀 <code>0</code>；</li>
<li><code>0.2e.1</code> 不是一个合法的仓颉版本号，<code>2e</code> 不为自然数。</li>
</ul>
<h3 id="name"><a class="header" href="#name">&quot;name&quot;</a></h3>
<p>当前仓颉模块名称，同时也是模块 <code>root</code> 包名。</p>
<p>一个合法的仓颉模块名称必须是一个合法的标识符。标识符可由字母、数字、下划线组成，标识符的开头必须是字母，例如 <code>cjDemo</code> 或者 <code>cj_demo_1</code>。</p>
<h3 id="description"><a class="header" href="#description">&quot;description&quot;</a></h3>
<p>当前仓颉模块描述信息，仅作说明用，不限制格式。</p>
<h3 id="version"><a class="header" href="#version">&quot;version&quot;</a></h3>
<p>当前仓颉模块版本号，由模块所有者管理，主要供模块校验使用。模块版本号的格式同 <code>cjc-version</code>。</p>
<h3 id="compile-option"><a class="header" href="#compile-option">&quot;compile-option&quot;</a></h3>
<p>传给 <code>cjc</code> 的额外编译选项。多模块编译时，每个模块设置的 <code>compile-option</code> 对该模块内的所有包生效。</p>
<p>例如：</p>
<pre><code class="language-text">compile-option = &quot;-O1 -V&quot;
</code></pre>
<p>这里填入的命令会在 <code>build</code> 执行时插入到编译命令中间，多个命令可以用空格隔开。可用的命令参考《仓颉编程语言开发指南》的编译选项章节内容。</p>
<h3 id="link-option"><a class="header" href="#link-option">&quot;link-option&quot;</a></h3>
<p>传给链接器的编译选项，可用于透传安全编译命令，如下所示:</p>
<pre><code class="language-text">link-option = &quot;-z noexecstack -z relro -z now --strip-all&quot;
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p><code>link-option</code> 中配置的命令在编译时只会自动透传给动态库和可执行产物对应的包。</p>
</blockquote>
<h3 id="output-type"><a class="header" href="#output-type">&quot;output-type&quot;</a></h3>
<p>编译输出产物的类型，包含可执行程序和库两种形式，相关的输入如下表格所示。如果想生成 <code>cjpm.toml</code> 时该字段自动填充为 <code>static</code>，可使用命令 <code>cjpm init --type=static --name=modName</code>，不指定类型时默认生成为 <code>executable</code>。只有主模块的该字段可以为 <code>executable</code>。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">输入</th><th style="text-align: center">说明</th></tr></thead><tbody>
<tr><td style="text-align: center">&quot;executable&quot;</td><td style="text-align: center">可执行程序</td></tr>
<tr><td style="text-align: center">&quot;static&quot;</td><td style="text-align: center">静态库</td></tr>
<tr><td style="text-align: center">&quot;dynamic&quot;</td><td style="text-align: center">动态库</td></tr>
<tr><td style="text-align: center">其它</td><td style="text-align: center">报错</td></tr>
</tbody></table>
</div>
<h3 id="src-dir"><a class="header" href="#src-dir">&quot;src-dir&quot;</a></h3>
<p>该字段可以指定源码的存放路径，不指定时默认为 <code>src</code> 文件夹。</p>
<h3 id="target-dir"><a class="header" href="#target-dir">&quot;target-dir&quot;</a></h3>
<p>该字段可以指定编译产物的存放路径，不指定时默认为 <code>target</code> 文件夹。若该字段不为空，执行 <code>cjpm clean</code> 时会删除该字段所指向的文件夹，开发者需自身保证清理该目录行为的安全性。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>若在编译时同时指定了 <code>--target-dir</code> 选项，则该选项的优先级会更高。</p>
</blockquote>
<pre><code class="language-text">target-dir = &quot;temp&quot;
</code></pre>
<h3 id="package-configuration"><a class="header" href="#package-configuration">&quot;package-configuration&quot;</a></h3>
<p>每个模块的单包可配置项。该选项是个 <code>map</code> 结构，需要配置的包名作为 <code>key</code>，单包配置信息作为 <code>value</code>。当前可配置的信息包含输出类型、透传命令选项、条件选项，这几个选项可缺省按需配置。如下所示，<code>demo</code> 模块中的 <code>demo.aoo</code> 包的输出类型会被指定为动态库类型，<code>-g</code> 命令会在编译时透传给 <code>demo.aoo</code> 包。</p>
<pre><code class="language-text">[package.package-configuration.&quot;demo.aoo&quot;]
  output-type = &quot;dynamic&quot;
  compile-option = &quot;-g&quot;
</code></pre>
<p>如果在不同字段配置了相互兼容的编译选项，生成命令的优先级如下所示。</p>
<pre><code class="language-text">[package]
  compile-option = &quot;-O1&quot;
[package.package-configuration.demo]
  compile-option = &quot;-O2&quot;

# profile字段会在下文介绍
[package.profile.customized-option]
  cfg1 = &quot;-O0&quot;

输入: cjpm build --cfg1 -V
输出: cjc --import-path build -O0 -O1 -O2 ...
</code></pre>
<p>通过配置这个字段，可以同时生成多个二进制产物（生成多个二进制产物时，<code>-o, --output &lt;value&gt;</code> 选项将会失效），示例如下：</p>
<p>源码结构的示例，模块名为 <code>demo</code>：</p>
<pre><code class="language-text">`-- src
    |-- aoo
    |   `-- aoo.cj
    |-- boo
    |   `-- boo.cj
    |-- coo
    |   `-- coo.cj
    `-- main.cj
</code></pre>
<p>配置方式的示例：</p>
<pre><code class="language-text">[package.package-configuration.&quot;demo.aoo&quot;]
  output-type = &quot;executable&quot;
[package.package-configuration.&quot;demo.boo&quot;]
  output-type = &quot;executable&quot;
</code></pre>
<p>多个二进制产物的示例：</p>
<pre><code class="language-text">❯ cjpm build
cjpm build success

❯ tree target/release/bin
target/release/bin
|-- demo.aoo
|-- demo.boo
`-- demo
</code></pre>
<h3 id="workspace"><a class="header" href="#workspace">&quot;workspace&quot;</a></h3>
<p>该字段可管理多个模块作为一个工作空间，支持以下配置项：</p>
<ul>
<li><code>members = [&quot;aoo&quot;, &quot;path/to/boo&quot;]</code>：列举包含在此工作空间的本地源码模块，支持绝对路径和相对路径。该字段的成员必须是一个模块，不允许是另一个工作空间</li>
<li><code>build-members = []</code>：本次编译的模块，不指定时默认编译该工作空间内的所有模块。该字段的成员必须被包含在 <code>members</code> 字段中</li>
<li><code>test-members = []</code>：本次测试的模块，不指定时默认单元测试该工作空间内的所有模块。该字段的成员必须被包含在 <code>build-members</code> 字段中</li>
<li><code>compile-option = &quot;&quot;</code>：工作空间的公共编译选项，非必须</li>
<li><code>link-option = &quot;&quot;</code>：工作空间的公共链接选项，非必须</li>
<li><code>target-dir = &quot;&quot;</code>：工作空间的产物存放路径，非必须，默认为 <code>target</code></li>
</ul>
<p>工作空间内的公共配置项，对所有成员模块生效。例如：配置了 <code>[dependencies] xoo = { path = &quot;path_xoo&quot; }</code> 的源码依赖，则所有成员模块可以直接使用 <code>xoo</code> 模块，无需在每个子模块的 <code>cjpm.toml</code> 中再配置。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p><code>package</code> 字段用于配置模块的通用信息，不允许和 <code>workspace</code> 字段出现在同一个 <code>cjpm.toml</code> 中，除 <code>package</code> 外的其它字段均可在工作空间中使用。</p>
</blockquote>
<p>工作空间目录举例：</p>
<pre><code class="language-text">root_path
 │   └─ aoo
 │       ├─ src
 │       └─ cjpm.toml
 │   └─ boo
 │       ├─ src
 │       └─ cjpm.toml
 │   └─ coo
 │       ├─ src
 │       └─ cjpm.toml
 └─ cjpm.toml
</code></pre>
<p>工作空间的配置文件使用举例：</p>
<pre><code class="language-text">[workspace]
members = [&quot;aoo&quot;, &quot;boo&quot;, &quot;coo&quot;]
build-members = [&quot;aoo&quot;, &quot;boo&quot;]
test-members = [&quot;aoo&quot;]
compile-option = &quot;-Woff all&quot;

[dependencies]
xoo = { path = &quot;path_xoo&quot; }

[ffi.c]
abc = { path = &quot;libs&quot; }
</code></pre>
<h3 id="dependencies"><a class="header" href="#dependencies">&quot;dependencies&quot;</a></h3>
<p>该字段通过源码方式导入依赖的其它仓颉模块，里面配置了当前构建所需要的其它模块的信息。目前，该字段支持本地路径依赖和远程 git 依赖。</p>
<p>要指定本地依赖项，请使用 <code>path</code> 字段，并且它必须包含有效的本地路径。例如，下面的两个子模块 <code>pro0</code> 和 <code>pro1</code> 和主模块的代码结构如下：</p>
<pre><code class="language-text">|-- pro0
|   |-- cjpm.toml
|   `-- src
|       `-- zoo
|           `-- zoo.cj

|-- pro1
|   |-- cjpm.toml
|   `-- src
|       |-- xoo
|       |   `-- xoo.cj
|       `-- yoo
|           `-- yoo.cj

|-- cjpm.toml
`-- src
    |-- aoo
    |   `-- aoo.cj
    |-- boo
    |   `-- boo.cj
    `-- main.cj
</code></pre>
<p>在主模块的 <code>cjpm.toml</code> 中进行如下配置后，即可在源码中使用 <code>pro0</code> 和 <code>pro1</code> 模块：</p>
<pre><code class="language-text">[dependencies]
  pro0 = { path = &quot;./pro0&quot; }
  pro1 = { path = &quot;./pro1&quot; }
</code></pre>
<p>要指定远程 git 依赖项，请使用 <code>git</code> 字段，并且它必须包含 git 支持的任何格式的有效 url。要配置 git 依赖关系，最多可以有一个 <code>branch</code>、<code>tag</code> 和 <code>commitId</code> 字段，这些字段允许分别选择特定的分支、标记或提交哈希，若配置多个此类字段则仅会生效优先级最高的配置，优先级顺序为 <code>commitId</code> &gt; <code>branch</code> &gt; <code>tag</code>。此外，还有可选的 <code>version</code> 字段，用于检查依赖项是否具有正确的版本，并且没有意外更新。例如，进行如下配置后，即可在源码中使用特定 git 仓库地址的 <code>pro0</code> 和 <code>pro1</code> 模块：</p>
<pre><code class="language-text">[dependencies]
  pro0 = { git = &quot;git://github.com/org/pro0.git&quot;, tag = &quot;v1.0.0&quot;}
  pro1 = { git = &quot;https://gitee.com/anotherorg/pro1&quot;, branch = &quot;dev&quot;}
</code></pre>
<p>在这种情况下， <code>cjpm</code> 将下载对应存储库的最新版本，并将当前 <code>commit-hash</code> 保存在 <code>cjpm.lock</code> 文件中。所有后续的 <code>cjpm</code> 调用都将使用保存的版本，直到使用 <code>cjpm update</code>。</p>
<p>通常需要一些身份验证才能访问 git 存储库。 <code>cjpm</code> 不要求提供所需的凭据，因此应使用现有的 git 身份验证支持。如果用于 git 的协议是 <code>https</code> ，则需要使用一些现有的 git 凭据帮助程序。在 windows 上，可在安装 git 时一起安装凭据帮助程序，默认使用。在 linux 上，请参阅 <a href="https://git-scm.com/docs/gitcredentials"><code>git-config</code> 配置说明</a> ，了解有关设置凭据帮助程序的详细信息。如果协议是 <code>ssh</code> 或 <code>git</code> ，则应使用基于密钥的身份验证。如果密钥受密码短语保护，则开发者应确保 <code>ssh-agent</code> 正在运行，并且在使用 <code>cjpm</code> 之前通过 <code>ssh-add</code> 添加密钥。</p>
<p><code>dependencies</code> 字段可以通过 <code>output-type</code> 属性指定编译产物类型，指定的类型可以与源码依赖自身的编译产物类型不一致，且仅能为 <code>static</code> 或者 <code>dynamic</code>， 如下所示：</p>
<pre><code class="language-text">[dependencies]
  pro0 = { path = &quot;./pro0&quot;, output-type = &quot;static&quot; }
  pro1 = { git = &quot;https://gitee.com/anotherorg/pro1&quot;, output-type = &quot;dynamic&quot; }
</code></pre>
<p>进行如上配置后，将会忽略 <code>pro0</code> 和 <code>pro1</code> 的 <code>cjpm.toml</code> 中的 <code>output-type</code> 配置，将这两个模块的产物分别编译成 <code>static</code> 和 <code>dynamic</code> 类型。</p>
<h3 id="test-dependencies"><a class="header" href="#test-dependencies">&quot;test-dependencies&quot;</a></h3>
<p>具有与 <code>dependencies</code> 字段相同的格式。它用于指定仅在测试过程中使用的依赖项，而不是构建主项目所需的依赖项。模块开发者应将此字段用于此模块的下游用户不需要感知的依赖项。</p>
<p><code>test-dependencies</code> 内的依赖仅可用于文件名形如 <code>xxx_test.cj</code> 的测试文件，在编译时这些依赖将不会被编译。<code>test-dependencies</code> 在 <code>cjpm.toml</code> 中的配置格式与 <code>dependencies</code> 相同。</p>
<h3 id="script-dependencies"><a class="header" href="#script-dependencies">&quot;script-dependencies&quot;</a></h3>
<p>具有与 <code>dependencies</code> 字段相同的格式。它用于指定仅在编译构建脚本中使用的依赖项，而不是构建主项目所需的依赖项。构建脚本相关功能将在<a href="./cjpm_manual_cjnative_community.html#%E6%9E%84%E5%BB%BA%E8%84%9A%E6%9C%AC">其他-构建脚本</a>章节中详述。</p>
<h3 id="ffic"><a class="header" href="#ffic">&quot;ffi.c&quot;</a></h3>
<p>当前仓颉模块外部依赖 <code>c</code> 库的配置。该字段配置了依赖该库所需要的信息，包含库名和路径。</p>
<p>开发者需要自行编出动态库或静态库放到设置的 <code>path</code> 下，可参考下面的例子。</p>
<p>仓颉调用外部 <code>c</code> 动态库的方法说明：</p>
<ul>
<li>自行将相应的 <code>hello.c</code> 文件编成 <code>.so</code>库（在该文件路径执行 <code>clang -shared -fPIC hello.c -o libhello.so</code>）</li>
<li>修改该项目的 <code>cjpm.toml</code> 文件，配置 <code>ffi.c</code> 字段，如下面的例子所示。其中，<code>./src/</code> 是编出的 <code>libhello.so</code> 相对当前目录的地址，<code>hello</code> 为库名。</li>
<li>执行 <code>cjpm build</code>，即可编译成功。</li>
</ul>
<pre><code class="language-text">[ffi.c]
hello = { path = &quot;./src/&quot; }
</code></pre>
<h3 id="profile"><a class="header" href="#profile">&quot;profile&quot;</a></h3>
<p><code>profile</code> 作为一种命令剖面配置项，用于控制某个命令执行时的默认配置项。目前支持四种场景：<code>build</code>、<code>test</code>、<code>run</code> 和 <code>customized-option</code>。</p>
<h4 id="profilebuild"><a class="header" href="#profilebuild">&quot;profile.build&quot;</a></h4>
<pre><code class="language-text">[profile.build]
lto = &quot;full&quot;  # 是否开启 LTO （Link Time Optimization 链接时优化）优化编译模式，仅 linux 平台支持该功能。
incremental = true # 是否默认开启增量编译
</code></pre>
<p>编译流程的控制项，所有字段均可缺省，不配置时不生效，顶层模块设置的 <code>profile.build</code> 项才会生效。</p>
<p><code>lto</code> 配置项的取值为 <code>full</code> 或 <code>thin</code>，对应 LTO 优化支持的两种编译模式：full LTO 将所有编译模块合并到一起，在全局上进行优化，这种方式可以获得最大的优化潜力，同时也需要更长的编译时间；thin LTO 在多模块上使用并行优化，同时默认支持链接时增量编译，编译时间比 full LTO 短，但是因为失去了更多的全局信息，所以优化效果不如 full LTO。</p>
<h4 id="profiletest"><a class="header" href="#profiletest">&quot;profile.test&quot;</a></h4>
<pre><code class="language-text">[profile.test] # 使用举例
noColor = true
timeout-each = &quot;4m&quot;
randomSeed = 10
bench = true
reportPath = &quot;reports&quot;
reportFormat = &quot;xml&quot;
[profile.test.compilation-options]
  verbose = true
  no-run = false
  lto = &quot;thin&quot;
  mock = &quot;on&quot;
[profile.test.env]
MY_ENV = { value = &quot;abc&quot; }
cjHeapSize = { value = &quot;32GB&quot;, splice-type = &quot;replace&quot; }
PATH = { value = &quot;/usr/bin&quot;, splice-type = &quot;prepend&quot; }
</code></pre>
<p>测试配置支持指定编译和运行测试用例时的选项，所有字段均可缺省，不配置时不生效，顶层模块设置的 <code>profile.test</code> 项才会生效。选项列表与 <code>cjpm test</code> 提供的控制台执行选项一致。如果选项在配置文件和控制台中同时被配置，则控制台中的选项优先级高于配置文件中的选项。<code>profile.test</code> 支持的运行时选项：</p>
<ul>
<li><code>bench</code> 指定用例按性能用例方式执行，值为 <code>true</code> 或 <code>false</code></li>
<li><code>filter</code> 指定用例过滤器，参数值类型为字符串，格式与 <a href="./cjpm_manual_cjnative_community.html#test">test 命令说明</a>中 <code>--filter</code> 的值格式一致</li>
<li><code>timeout-each &lt;value&gt;</code> value 的格式为 <code>%d[millis|s|m|h]</code>，为每个测试用例指定默认的超时时间</li>
<li><code>parallel</code> 指定测试用例并行执行的方案，<code>value</code> 的形式如下所示：
<ul>
<li><code>&lt;BOOL&gt;</code> 值为 <code>true</code> 或 <code>false</code>，指定为 <code>true</code> 时，测试类可被并行运行，并行进程个数将受运行系统上的 CPU 核数控制</li>
<li><code>nCores</code> 指定并行的测试进程个数应该等于可用的 CPU 核数</li>
<li><code>NUMBER</code> 指定并行的测试进程个数值。该数值应该为正整数</li>
<li><code>NUMBERnCores</code> 指定并行的测试进程个数值为可用的 CPU 核数的指定数值倍。该数值应该为正数（支持浮点数或整数）</li>
</ul>
</li>
<li><code>option:&lt;value&gt;</code> 与 <code>@Configuration</code> 协同定义运行选项。例如，如下选项：
<ul>
<li><code>randomSeed</code> 指定随机种子的值，参数值类型为正整数</li>
<li><code>noColor</code> 指定执行结果在控制台中是否无颜色显示，值为 <code>true</code> 或 <code>false</code></li>
<li><code>reportPath</code> 指定测试执行后的报告生成路径（不能通过 <code>@Configuration</code> 配置）</li>
<li><code>reportFormat</code> 指定报告输出格式，当前当前单元测试报告仅支持 <code>xml</code> 格式（可忽略大小写），使用其它值将会抛出异常（不能通过 <code>@Configuration</code> 配置）, 性能测试报告仅支持 <code>csv</code> 和 <code>csv-raw</code> 格式</li>
</ul>
</li>
<li><code>compilation-options</code> 为支持的编译选项，其列表如下：
<ul>
<li><code>verbose</code> 指定显示编译过程详细信息，参数值类型为 <code>BOOL</code>, 即值可为 <code>true</code> 或 <code>false</code></li>
<li><code>no-run</code> 指定仅编译单元测试产物，参数值类型为 <code>BOOL</code>, 即值可为 <code>true</code> 或 <code>false</code></li>
<li><code>lto</code> 指定是否开启 LTO 优化编译模式，该值可为 <code>thin</code> 或 <code>full</code> ，windows 平台暂不支持该功能</li>
<li><code>mock</code> 显式设置 mock 模式，可能的选项：<code>on</code>、<code>off</code>、<code>runtime-error</code></li>
</ul>
</li>
<li><code>env</code> 支持在 <code>test</code> 命令时运行可执行文件时配置临时环境变量，<code>key</code> 值为需要配置的环境变量的名称，有如下配置项：
<ul>
<li><code>value</code> 指定配置的环境变量值</li>
<li><code>splice-type</code> 指定环境变量的拼接方式，非必填，不配置时默认为 <code>absent</code>，共有以下四种取值：
<ul>
<li><code>absent</code>：该配置仅在环境内不存在同名环境变量时生效，若存在同名环境变量则忽略该配置</li>
<li><code>replace</code>：该配置会替代环境中已有的同名环境变量</li>
<li><code>prepend</code>：该配置会拼接在环境中已有的同名环境变量之前</li>
<li><code>append</code>：该配置会拼接在环境中已有的同名环境变量之后</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="profilerun"><a class="header" href="#profilerun">&quot;profile.run&quot;</a></h4>
<p>运行可执行文件时的选项，支持配置在 <code>run</code> 命令时运行可执行文件时的环境变量配置 <code>env</code>，配置方式同 <code>profile.test.env</code>。</p>
<h4 id="profilecustomized-option"><a class="header" href="#profilecustomized-option">&quot;profile.customized-option&quot;</a></h4>
<pre><code class="language-text">[profile.customized-option]
cfg1 = &quot;--cfg=\&quot;feature1=lion, feature2=cat\&quot;&quot;
cfg2 = &quot;--cfg=\&quot;feature1=tiger, feature2=dog\&quot;&quot;
cfg3 = &quot;-O2&quot;
</code></pre>
<p>自定义透传给 <code>cjc</code> 的选项，通过 <code>--cfg1 --cfg3</code> 使能，每个模块设置的 <code>customized-option</code> 对该模块内的所有包生效。例如，执行 <code>cjpm build --cfg1 --cfg3</code> 命令时，透传给 <code>cjc</code> 的命令则为 <code>--cfg=&quot;feature1=lion, feature2=cat&quot; -O2</code>。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>这里的条件值必须是一个合法的标识符。</p>
</blockquote>
<h3 id="target"><a class="header" href="#target">&quot;target&quot;</a></h3>
<p>多后端、多平台隔离选项，用于配置不同后端、不同平台情况下的一系列不同配置项。<code>target</code> 配置方式如下：</p>
<pre><code class="language-text">[target.x86_64-unknown-linux-gnu] # linux 系统的配置项
  compile-option = &quot;value1&quot; # 额外编译命令选项
  link-option = &quot;value2&quot; # 链接器透传选项
  [target.x86_64-unknown-linux-gnu.dependencies] # 源码依赖配置项
  [target.x86_64-unknown-linux-gnu.test-dependencies] # 测试阶段依赖配置项
  [target.x86_64-unknown-linux-gnu.bin-dependencies] # 仓颉二进制库依赖
    path-option = [&quot;./test/pro0&quot;, &quot;./test/pro1&quot;]
  [target.x86_64-unknown-linux-gnu.bin-dependencies.package-option]
    &quot;pro0.xoo&quot; = &quot;./test/pro0/pro0.xoo.cjo&quot;
    &quot;pro0.yoo&quot; = &quot;./test/pro0/pro0.yoo.cjo&quot;
    &quot;pro1.zoo&quot; = &quot;./test/pro1/pro1.zoo.cjo&quot;

[target.x86_64-w64-mingw32] # windows 系统的配置项
  compile-option = &quot;value3&quot;
  link-option = &quot;value4&quot;

[target.x86_64-unknown-linux-gnu.debug] # linux 系统的 debug 配置项
  [target.x86_64-unknown-linux-gnu.debug.test-dependencies]

[target.x86_64-unknown-linux-gnu.release] # linux 系统的 release 配置项
  [target.x86_64-unknown-linux-gnu.release.bin-dependencies]
</code></pre>
<p>开发者可以通过配置 <code>target.target-name</code> 字段为某个 <code>target</code> 添加一系列配置项。<code>target</code> 的名称可以在相应的仓颉环境下通过命令 <code>cjc -v</code> 获取，命令输出中的 <code>Target</code> 项目即为该环境对应的 <code>target</code> 名称。</p>
<p>可为特定 <code>target</code> 配置的专用配置项，将会适用于该 <code>target</code> 下的编译流程，同时也会适用于其他 <code>target</code> 指定该 <code>target</code> 作为目标平台的交叉编译流程。配置项列表如下：</p>
<ul>
<li><code>compile-option</code>：额外编译命令选项</li>
<li><code>link-option</code>：链接器透传选项</li>
<li><code>dependencies</code>：源码依赖配置项，结构同 <code>dependencies</code> 字段</li>
<li><code>test-dependencies</code>：测试阶段依赖配置项，结构同 <code>test-dependencies</code> 字段</li>
<li><code>bin-dependencies</code>：仓颉二进制库依赖，结构在下文中介绍</li>
<li><code>compile-macros-for-target</code>：交叉编译时的宏包控制项，该选项不支持区分下述的 <code>debug</code> 和 <code>release</code> 编译模式</li>
</ul>
<p>开发者可以通过配置 <code>target.target-name.debug</code> 和 <code>target.target-name.release</code> 字段为该 <code>target</code> 额外配置在 <code>debug</code> 和 <code>release</code> 编译模式下特有的配置，可配置的配置项同上。配置于此类字段的配置项将仅应用于该 <code>target</code> 的对应编译模式。</p>
<h4 id="targettarget-namedebugreleasebin-dependencies"><a class="header" href="#targettarget-namedebugreleasebin-dependencies">&quot;target.target-name[.debug/release].bin-dependencies&quot;</a></h4>
<p>该字段用于导入已编译好的、适用于指定 <code>target</code> 的仓颉库产物文件，以导入下述的 <code>pro0</code> 模块和 <code>pro1</code> 模块的三个包来举例说明。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>非特殊需求场景，不建议使用该字段，请使用上文介绍的 <code>dependencies</code> 字段导入模块源码。</p>
</blockquote>
<pre><code class="language-text">├── test
│   └── pro0
│       ├── libpro0.xoo.so
│       └── pro0.xoo.cjo
│       ├── libpro0.yoo.so
│       └── pro0.yoo.cjo
│   └── pro1
│       ├── libpro1.zoo.so
│       └── pro1.zoo.cjo
└── src
    └── main.cj
├── cjpm.toml
</code></pre>
<p>方式一，通过 <code>package-option</code> 导入：</p>
<pre><code class="language-text">[target.x86_64-unknown-linux-gnu.bin-dependencies.package-option]
  &quot;pro0.xoo&quot; = &quot;./test/pro0/pro0.xoo.cjo&quot;
  &quot;pro0.yoo&quot; = &quot;./test/pro0/pro0.yoo.cjo&quot;
  &quot;pro1.zoo&quot; = &quot;./test/pro1/pro1.zoo.cjo&quot;
</code></pre>
<p><code>package-option</code> 选项为 <code>map</code> 结构，<code>pro0.xoo</code> 名称作为 <code>key</code> (<code>toml</code> 配置文件中含有 <code>.</code> 的字符串作为整体时，需要用 <code>&quot;&quot;</code> 包含)，值为 <code>libpro0.xoo.so</code> 。前端文件 <code>cjo</code> 的路径作为 <code>value</code>，对应于该 <code>cjo</code> 的 <code>.a</code> 或 <code>.so</code> 需放置在相同路径下。</p>
<p>方式二，通过 <code>path-option</code> 导入：</p>
<pre><code class="language-text">[target.x86_64-unknown-linux-gnu.bin-dependencies]
  path-option = [&quot;./test/pro0&quot;, &quot;./test/pro1&quot;]
</code></pre>
<p><code>path-option</code> 选项为字符串数组结构，每个元素代表待导入的路径名称。<code>cjpm</code> 会自动导入该路径下所有符合规则的仓颉库包，这里的合规性是指库名称的格式为 <code>模块名.包名</code>。库名称不满足该规则的包只能通过 <code>package-option</code> 选项进行导入。</p>
<blockquote>
<p><strong>注意：</strong></p>
<p>如果同时通过 <code>package-option</code> 和 <code>path-option</code> 导入了相同的包，则 <code>package-option</code> 字段的优先级更高。</p>
</blockquote>
<p>其中，源码<code>main.cj</code> 调用 <code>pro0.xoo</code>、<code>pro0.yoo</code>、<code>pro1.zoo</code> 包的代码示例如下所示。</p>
<pre><code class="language-cangjie">import pro0.xoo.*
import pro0.yoo.*
import pro1.zoo.*

main(): Int64 {
    var res = x + y + z // x, y, z 分别为 pro0.xoo, pro0.yoo, pro1.zoo 中定义的值
    println(res)
    return 0
}
</code></pre>
<h4 id="targettarget-namecompile-macros-for-target"><a class="header" href="#targettarget-namecompile-macros-for-target">&quot;target.target-name.compile-macros-for-target&quot;</a></h4>
<p>该字段用于配置宏包的交叉编译方式，有如下三种情况：</p>
<p>方式一：宏包在交叉编译时默认仅编译本地平台的产物，不编译目标平台的产物，对该模块内的所有宏包生效</p>
<pre><code class="language-text">[target.目标平台]
  compile-macros-for-target = &quot;&quot;
</code></pre>
<p>方式二：在交叉编译时同时编译本地平台和目标平台的产物，对该模块内的所有宏包生效</p>
<pre><code class="language-text">[target.目标平台]
  compile-macros-for-target = &quot;all&quot; # 配置项为字符串形式，可选值必须为 all
</code></pre>
<p>方式三：指定该模块内的某些宏包在交叉编译时同时编译本地平台和目标平台的产物，其它未指定的宏包采取方式一的默认模式</p>
<pre><code class="language-text">[target.目标平台]
  compile-macros-for-target = [&quot;pkg1&quot;, &quot;pkg2&quot;] # 配置项为字符串数字形式，可选值是宏包名
</code></pre>
<h4 id="target-相关字段合并规则"><a class="header" href="#target-相关字段合并规则">&quot;target&quot; 相关字段合并规则</a></h4>
<p><code>target</code> 配置项中的内容可能同时存在于 <code>cjpm.toml</code> 的其他选项中，例如 <code>compile-option</code> 字段在 <code>package</code> 字段中也可以存在，区别在于 <code>package</code> 中的该字段会应用于全部 <code>target</code>。<code>cjpm</code> 对这些重复的字段会按照特定的方式将所有可应用的配置合并。以 <code>x86_64-unknown-linux-gnu</code> 的 <code>debug</code> 编译模式为例，有如下的 <code>target</code> 配置：</p>
<pre><code class="language-text">[package]
  compile-option = &quot;compile-0&quot;
  link-option = &quot;link-0&quot;

[dependencies]
  dep0 = { path = &quot;./dep0&quot; }

[test-dependencies]
  devDep0 = { path = &quot;./devDep0&quot; }

[target.x86_64-unknown-linux-gnu]
  compile-option = &quot;compile-1&quot;
  link-option = &quot;link-1&quot;
  [target.x86_64-unknown-linux-gnu.dependencies]
    dep1 = { path = &quot;./dep1&quot; }
  [target.x86_64-unknown-linux-gnu.test-dependencies]
    devDep1 = { path = &quot;./devDep1&quot; }
  [target.x86_64-unknown-linux-gnu.bin-dependencies]
    path-option = [&quot;./test/pro1&quot;]
  [target.x86_64-unknown-linux-gnu.bin-dependencies.package-option]
    &quot;pro1.xoo&quot; = &quot;./test/pro1/pro1.xoo.cjo&quot;

[target.x86_64-unknown-linux-gnu.debug]
  compile-option = &quot;compile-2&quot;
  link-option = &quot;link-2&quot;
  [target.x86_64-unknown-linux-gnu.debug.dependencies]
    dep2 = { path = &quot;./dep2&quot; }
  [target.x86_64-unknown-linux-gnu.debug.test-dependencies]
    devDep2 = { path = &quot;./devDep2&quot; }
  [target.x86_64-unknown-linux-gnu.debug.bin-dependencies]
    path-option = [&quot;./test/pro2&quot;]
  [target.x86_64-unknown-linux-gnu.debug.bin-dependencies.package-option]
    &quot;pro2.xoo&quot; = &quot;./test/pro2/pro2.xoo.cjo&quot;
</code></pre>
<p><code>target</code> 配置项在与 <code>cjpm.toml</code> 公共配置项或者相同 <code>target</code> 的其他级别的配置项共存时，按照如下的优先级合并：</p>
<ol>
<li><code>debug/release</code> 模式下对应 <code>target</code> 的配置</li>
<li><code>debug/release</code> 无关的对应 <code>target</code> 的配置</li>
<li>公共配置项</li>
</ol>
<p>以上述的 <code>target</code> 配置为例，<code>target</code> 各个配置项按照以下规则合并：</p>
<ul>
<li><code>compile-option</code>：将所有适用的同名配置项按照优先级拼接，优先级更高的配置拼接在后方。在本例中，在 <code>x86_64-unknown-linux-gnu</code> 的 <code>debug</code> 编译模式下，最终生效的 <code>compile-option</code> 值为 <code>compile-0 compile-1 compile-2</code>，在 <code>release</code> 编译模式下为 <code>compile-0 compile-1</code>，在其他 <code>target</code> 中为 <code>compile-0</code>。</li>
<li><code>link-option</code>：同上。</li>
<li><code>dependencies</code>：源码依赖将被直接合并，如果其中存在依赖冲突则会报错。在本例中，在 <code>x86_64-unknown-linux-gnu</code> 的 <code>debug</code> 编译模式下，最终生效的 <code>dependencies</code> 为 <code>dep0</code>, <code>dep1</code> 和 <code>dep2</code>，而在 <code>release</code> 编译模式下仅有 <code>dep0</code> 和 <code>dep1</code> 生效。在其他 <code>target</code> 中，仅有 <code>dep0</code> 生效。</li>
<li><code>test-dependencies</code>：同上。</li>
<li><code>bin-dependencies</code>：二进制依赖将按照优先级合并，如果有冲突则仅有优先级更高的依赖将会被加入，同优先级的配置先加入 <code>package-option</code> 配置。在本例中，在 <code>x86_64-unknown-linux-gnu</code> 的 <code>debug</code> 编译模式下，<code>./test/pro1</code> 和 <code>./test/pro2</code> 内的二进制依赖将被加入，而在 <code>release</code> 模式下仅会加入 <code>./test/pro1</code>。由于 <code>bin-dependencies</code> 没有公共配置，因此在其他 <code>target</code> 中不会有二进制依赖生效。</li>
</ul>
<p>在本例的交叉编译场景中，若在其他平台中指定了 <code>x86_64-unknown-linux-gnu</code> 作为目标 <code>target</code>，则 <code>target.x86_64-unknown-linux-gnu</code> 的配置也会按照上述规则与公共配置项合并并应用；如果处于 <code>debug</code> 编译模式，也将应用 <code>target.x86_64-unknown-linux-gnu.debug</code> 的配置项。</p>
<h2 id="配置和缓存文件夹"><a class="header" href="#配置和缓存文件夹">配置和缓存文件夹</a></h2>
<p><code>cjpm</code> 通过 <code>git</code> 下载文件的存储路径可以通过 <code>CJPM_CONFIG</code> 环境变量指定。如果未指定，则 linux 上的默认位置为 <code>$HOME/.cjpm</code>，windows 上的默认位置为 <code>%USERPROFILE%/.cjpm</code> 。</p>
<h2 id="其他"><a class="header" href="#其他">其他</a></h2>
<h3 id="命令扩展"><a class="header" href="#命令扩展">命令扩展</a></h3>
<p><code>cjpm</code> 提供命令扩展机制，开发者可以通过文件名形如 <code>cjpm-xxx(.exe)</code> 的可执行文件扩展 <code>cjpm</code> 的命令。</p>
<p>针对可执行文件 <code>cjpm-xxx</code>（<code>windows</code> 系统中为 <code>cjpm-xxx.exe</code>），若系统环境变量 <code>PATH</code> 中配置了该文件所在的路径，则可以使用如下的命令运行该可执行文件：</p>
<pre><code class="language-shell">cjpm xxx [args]
</code></pre>
<p>其中 <code>args</code> 为可能需要的输入给 <code>cjpm-xxx(.exe)</code> 的参数列表。上述命令等价于：</p>
<pre><code class="language-shell">cjpm-xxx(.exe) [args]
</code></pre>
<p>运行 <code>cjpm-xxx(.exe)</code> 可能会依赖某些动态库，在这种情况下，开发者需要手动将需要使用的动态库所在的目录添加到环境变量中。</p>
<p>下面以 <code>cjpm-demo</code> 为例，该可执行文件由以下仓颉代码编译得到：</p>
<pre><code class="language-cangjie">import std.os.*
import std.collection.*

main(): Int64 {
    var args = ArrayList&lt;String&gt;(getArgs())

    if (args.size &lt; 1) {
        eprintln(&quot;Error: failed to get parameters&quot;)
        return 1
    }

    println(&quot;Output: ${args[0]}&quot;)

    return 0
}
</code></pre>
<p>则在将其目录添加到 <code>PATH</code> 之后，运行对应命令，会运行该可执行文件并获得对应的输出。</p>
<pre><code class="language-text">输入：cjpm demo hello,world
输出：Output: hello,world
</code></pre>
<p><code>cjpm</code> 内部已有的命令优先级更高，因此无法用此方式扩展这些命令。例如，即使系统环境变量中存在名为 <code>cjpm-build</code> 的可执行文件，<code>cjpm build</code> 也不会运行该文件，而是运行 <code>cjpm</code> 并将 <code>build</code> 作为参数输入 <code>cjpm</code>。</p>
<h3 id="构建脚本"><a class="header" href="#构建脚本">构建脚本</a></h3>
<p><code>cjpm</code> 提供构建脚本机制，开发者可以在构建脚本中定义需要 <code>cjpm</code> 在某个命令前后的行为。</p>
<p>构建脚本源文件固定命名为 <code>build.cj</code>，位于仓颉项目主目录下，即与 <code>cjpm.toml</code> 同级。执行 <code>init</code> 命令新建仓颉项目时，<code>cjpm</code> 默认不创建 <code>build.cj</code>，开发者若有相关需求，可以自行按如下的模板格式在指定位置新建并编辑 <code>build.cj</code>。</p>
<pre><code class="language-cangjie">// build.cj

import std.os.*

// Case of pre/post codes for 'cjpm build'.
/* called before `cjpm build`
 * Success: return 0
 * Error: return any number except 0
 */
// func stagePreBuild(): Int64 {
//     // process before &quot;cjpm build&quot;
//     0
// }

/*
 * called after `cjpm build`
 */
// func stagePostBuild(): Int64 {
//     // process after &quot;cjpm build&quot;
//     0
// }

// Case of pre/post codes for 'cjpm clean'.
/* called before `cjpm clean`
 * Success: return 0
 * Error: return any number except 0
 */
// func stagePreClean(): Int64 {
//     // process before &quot;cjpm clean&quot;
//     0
// }

/*
 * called after `cjpm clean`
 */
// func stagePostClean(): Int64 {
//     // process after &quot;cjpm clean&quot;
//     0
// }

// For other options, define stagePreXXX and stagePostXXX in the same way.

/*
 * Error code:
 * 0: success.
 * other: cjpm will finish running command. Check target-dir/build-script-cache/module-name/script-log for error outputs defind by user in functions.
 */

main(): Int64 {
    match (getArgs()[0]) {
        // Add operation here with format: &quot;pre-&quot;/&quot;post-&quot; + optionName
        // case &quot;pre-build&quot; =&gt; stagePreBuild()
        // case &quot;post-build&quot; =&gt; stagePostBuild()
        // case &quot;pre-clean&quot; =&gt; stagePreClean()
        // case &quot;post-clean&quot; =&gt; stagePostClean()
        case _ =&gt; 0
    }
}
</code></pre>
<p><code>cjpm</code> 针对一系列命令支持使用构建脚本定义命令前后行为。例如，针对 <code>build</code> 命令，可在 <code>main</code> 函数中的 <code>match</code> 内定义 <code>pre-build</code>，执行想要在 <code>build</code> 命令执行前需要执行的功能函数 <code>stagePreBuild</code>（功能函数的命名不做要求）。<code>build</code> 命令后的行为可以以相同的方式通过添加 <code>post-build</code> 的 <code>case</code> 选项定义。针对其他命令的命令前后行为的定义类似，只需要添加相应的 <code>pre/post</code> 选项和对应的功能函数即可。</p>
<p>在定义某一命令前后的行为后，<code>cjpm</code> 在执行该命令时会首先编译 <code>build.cj</code>，并在执行前后执行对应的行为。同样以 <code>build</code> 为例，在定义了 <code>pre-build</code> 和 <code>post-build</code> 后运行 <code>cjpm build</code>，则会按照如下步骤运行整个 <code>cjpm build</code> 流程：</p>
<ol>
<li>进行编译流程前，首先编译 <code>build.cj</code>；</li>
<li>执行 <code>pre-build</code> 对应的功能函数；</li>
<li>进行 <code>cjpm build</code> 编译流程；</li>
<li>编译流程顺利结束后，<code>cjpm</code> 会执行 <code>post-build</code> 对应的功能函数。</li>
</ol>
<p>构建脚本支持的命令如下：</p>
<ul>
<li><code>build</code>, <code>test</code>：同时支持执行依赖模块构建脚本中定义的 <code>pre</code> 和 <code>post</code> 流程</li>
<li><code>run</code>, <code>install</code>：仅支持运行对应模块的 <code>pre</code> 和 <code>post</code> 构建脚本流程，或者在进行编译时执行依赖模块的 <code>pre-build</code> 和 <code>post-build</code> 流程</li>
<li><code>check</code>, <code>tree</code>, <code>update</code>, <code>publish</code>：仅支持运行对应模块的 <code>pre</code> 和 <code>post</code> 构建脚本流程</li>
<li><code>clean</code>：仅支持运行对应模块的 <code>pre</code> 构建脚本流程</li>
</ul>
<p>在执行这些命令时，若配置了 <code>--skip-script</code> 选项，则会跳过所有构建脚本的编译运行，包括依赖模块的构建脚本。</p>
<p>构建脚本的使用说明如下：</p>
<ul>
<li>功能函数的返回值需要满足一定要求：当功能函数执行成功时，需要返回 <code>0</code>；执行失败时返回除 <code>0</code> 以外的任意 <code>Int64</code> 类型变量。</li>
<li><code>build.cj</code> 中的所有输出都将被重定向到项目目录下，路径为 <code>build-script-cache/[target|release]/[module-name]/bin/script-log</code>。开发者如果在功能函数中添加了一些输出内容，可在该文件中查看。</li>
<li>若项目根目录下不存在 <code>build.cj</code>，则 <code>cjpm</code> 将按正常流程执行；若存在 <code>build.cj</code> 并定义了某一命令的前后行为，则在 <code>build.cj</code> 编译失败或者功能函数返回值不为 <code>0</code> 时，即使该命令本身能够顺利执行，命令也将异常中止。</li>
<li>多模块场景下，被依赖模块的 <code>build.cj</code> 构建脚本会在编译和单元测试流程中生效。被依赖模块构建脚本中的输出同样重定向到 <code>build-script-cache/[target|release]</code> 下对应模块名目录中的日志文件。</li>
</ul>
<p>例如，下面的构建脚本 <code>build.cj</code> 定义了 <code>build</code> 前后的行为：</p>
<pre><code class="language-cangjie">import std.os.*

func stagePreBuild(): Int64 {
    println(&quot;PRE-BUILD&quot;)
    0
}

func stagePostBuild(): Int64 {
    println(&quot;POST-BUILD&quot;)
    0
}

main(): Int64 {
    match (getArgs()[0]) {
        case &quot;pre-build&quot; =&gt; stagePreBuild()
        case &quot;post-build&quot; =&gt; stagePostBuild()
        case _ =&gt; 0
    }
}
</code></pre>
<p>则在执行 <code>cjpm build</code> 命令时，<code>cjpm</code> 将会执行 <code>stagePreBuild</code> 和 <code>stagePostBuild</code>。<code>cjpm build</code> 执行完成后，<code>script-log</code> 日志文件内会有如下输出：</p>
<pre><code class="language-text">PRE-BUILD
POST-BUILD
</code></pre>
<p>构建脚本可以通过 <code>cjpm.toml</code> 中的 <code>script-dependencies</code> 字段导入依赖模块，格式同 <code>dependencies</code>。例如，在 <code>cjpm.toml</code> 中有如下配置，导入了 <code>aoo</code> 模块，并且 <code>aoo</code> 模块内有一个名为 <code>aaa()</code> 的方法：</p>
<pre><code class="language-text">[script-dependencies]
aoo = { path = &quot;./aoo&quot; }
</code></pre>
<p>则可以在构建脚本中导入该依赖，使用依赖中的接口 <code>aaa()</code>：</p>
<pre><code class="language-cangjie">import std.os.*
import aoo.*

func stagePreBuild(): Int64 {
    aaa()
    0
}

func stagePostBuild(): Int64 {
    println(&quot;POST-BUILD&quot;)
    0
}

main(): Int64 {
    match (getArgs()[0]) {
        case &quot;pre-build&quot; =&gt; stagePreBuild()
        case &quot;post-build&quot; =&gt; stagePostBuild()
        case _ =&gt; 0
    }
}
</code></pre>
<p>构建脚本依赖 <code>script-dependencies</code> 与源码相关依赖（源码依赖项 <code>dependencies</code> 和测试依赖项 <code>test-dependencies</code>）相互独立，源码和测试代码无法使用 <code>script-dependencies</code> 中的依赖模块，构建脚本也无法使用 <code>dependencies</code> 和 <code>test-dependencies</code> 中的依赖模块。若需要在构建脚本和源码/测试代码中使用同一模块，需要在 <code>script-dependencies</code> 和 <code>dependencies/test-dependencies</code> 中同时配置。</p>
<h2 id="使用示例"><a class="header" href="#使用示例">使用示例</a></h2>
<p>以下面仓颉项目的目录结构为例，介绍 <code>cjpm</code> 的使用方法，该目录下对应的源码文件示例可见<a href="./cjpm_manual_cjnative_community.html">源代码</a>。该仓颉项目的模块名为 <code>test</code>。</p>
<pre><code class="language-text">cj_project
│   ├── pro0
│   │   ├── cjpm.toml
│   │   └── src
│   │       └── zoo
│   │           ├── zoo.cj
│   │           └── zoo_test.cj
│   │       ├── pro0.cj
│   └── src
│       ├── koo
│       │   ├── koo.cj
│       │   └── koo_test.cj
│       ├── main.cj
│       └── main_test.cj
│   ├── cjpm.toml
</code></pre>
<h3 id="initbuild-的使用"><a class="header" href="#initbuild-的使用">init、build 的使用</a></h3>
<ul>
<li>
<p>新建仓颉项目并编写源码 <code>xxx.cj</code> 文件，如示例结构所示的 <code>koo</code> 包和 <code>main.cj</code> 文件。</p>
<pre><code class="language-shell">cjpm init --name test --path .../cj_project
mkdir koo
</code></pre>
<p>此时，会自动生成 <code>src</code> 文件夹和默认的 <code>cjpm.toml</code> 配置文件。</p>
</li>
<li>
<p>当前模块需要依赖外部的 <code>pro0</code> 模块时，可以新建 <code>pro0</code> 模块及该模块的配置文件，接下来编写该模块的源码文件，需要自行在 <code>pro0</code> 下新建 <code>src</code> 文件夹，在 <code>src</code> 下新建 <code>pro0</code> 的 root 包 <code>pro0.cj</code>，并将编写的仓颉包放置在 <code>src</code> 下，如示例结构所示的 <code>zoo</code> 包。</p>
<pre><code class="language-shell">mkdir pro0 &amp;&amp; cd pro0
cjpm init --name pro0 --type=static
mkdir src/zoo
</code></pre>
</li>
<li>
<p>主模块依赖 <code>pro0</code> 时，需要按照手册说明去配置主模块配置文件的 <code>dependencies</code> 字段。配置无误后，执行 <code>cjpm build</code> 即可，生成的可执行文件在 <code>target/release/bin/</code> 目录下。</p>
<pre><code class="language-shell">cd cj_project
vim cjpm.toml
cjpm build
cjpm run
</code></pre>
</li>
</ul>
<h3 id="testclean-的使用"><a class="header" href="#testclean-的使用">test、clean 的使用</a></h3>
<ul>
<li>
<p>按示例结构，编写完每个文件对应的 <code>xxx_test.cj</code> 单元测试文件后，可以执行下述代码进行单元测试，生成的文件在 <code>target/release/unittest_bin</code> 目录下。</p>
<pre><code class="language-shell">cjpm test
</code></pre>
<p>或者</p>
<pre><code class="language-shell">cjpm test src src/koo pro/src/zoo
</code></pre>
</li>
<li>
<p>想要手动删除 <code>target</code> 、<code>cov_output</code> 文件夹、<code>*.gcno</code> 、<code>*.gcda</code> 等中间件时。</p>
<pre><code class="language-shell">cjpm clean
</code></pre>
</li>
</ul>
<h3 id="示例的源代码"><a class="header" href="#示例的源代码">示例的源代码</a></h3>
<p>cj_project/src/main.cj</p>
<pre><code class="language-cangjie">package test

import pro0.zoo.*
import test.koo.*

main(): Int64 {
    let res = z + k
    println(res)
    let res2 = concatM(&quot;a&quot;, &quot;b&quot;)
    println(res2)
    return 0
}

func concatM(s1: String, s2: String): String {
    return s1 + s2
}
</code></pre>
<p>cj_project/src/main_test.cj</p>
<pre><code class="language-cangjie">package test

import std.unittest.*//testfame
import std.unittest.testmacro.*//macro_Defintion

@Test
public class TestM{
    @TestCase
    func sayhi(): Unit {
        @Assert(concatM(&quot;1&quot;, &quot;2&quot;), &quot;12&quot;)
        @Assert(concatM(&quot;1&quot;, &quot;3&quot;), &quot;13&quot;)
    }
}
</code></pre>
<p>cj_project/src/koo/koo.cj</p>
<pre><code class="language-cangjie">package test.koo

public let k: Int32 = 12

func concatk(s1: String, s2: String): String {
    return s1 + s2
}
</code></pre>
<p>cj_project/src/koo/koo_test.cj</p>
<pre><code class="language-cangjie">package test.koo

import std.unittest.*//testfame
import std.unittest.testmacro.*//macro_Defintion

@Test
public class TestK{
    @TestCase
    func sayhi(): Unit {
        @Assert(concatk(&quot;1&quot;, &quot;2&quot;), &quot;12&quot;)
        @Assert(concatk(&quot;1&quot;, &quot;3&quot;), &quot;13&quot;)
    }
}
</code></pre>
<p>cj_project/pro0/src/pro0.cj</p>
<pre><code class="language-cangjie">package pro0
</code></pre>
<p>cj_project/pro0/src/zoo/zoo.cj</p>
<pre><code class="language-cangjie">package pro0.zoo

public let z: Int32 = 26

func concatZ(s1: String, s2: String): String {
    return s1 + s2
}
</code></pre>
<p>cj_project/pro0/src/zoo/zoo_test.cj</p>
<pre><code class="language-cangjie">package pro0.zoo

import std.unittest.*//testfame
import std.unittest.testmacro.*//macro_Defintion

@Test
public class TestZ{
    @TestCase
    func sayhi(): Unit {
        @Assert(concatZ(&quot;1&quot;, &quot;2&quot;), &quot;12&quot;)
        @Assert(concatZ(&quot;1&quot;, &quot;3&quot;), &quot;13&quot;)
    }
}
</code></pre>
<p>cj_project/cjpm.toml</p>
<pre><code class="language-text">[package]
cjc-version = &quot;0.40.2&quot;
description = &quot;nothing here&quot;
version = &quot;1.0.0&quot;
name = &quot;test&quot;
output-type = &quot;executable&quot;

[dependencies]
pro0 = { path = &quot;pro0&quot; }
</code></pre>
<p>cj_project/pro0/cjpm.toml</p>
<pre><code class="language-text">[package]
cjc-version = &quot;0.40.2&quot;
description = &quot;nothing here&quot;
version = &quot;1.0.0&quot;
name = &quot;pro0&quot;
output-type = &quot;static&quot;
</code></pre>
<h1 id="命令行模式覆盖率统计"><a class="header" href="#命令行模式覆盖率统计">命令行模式覆盖率统计</a></h1>
<h2 id="功能简介-1"><a class="header" href="#功能简介-1">功能简介</a></h2>
<p><code>cjcov</code>（Cangjie Coverage）是仓颉语言的官方覆盖率统计工具，用于生成仓颉语言程序的覆盖率报告。</p>
<h2 id="使用说明-1"><a class="header" href="#使用说明-1">使用说明</a></h2>
<p>通过 <code>cjcov -h</code> 即可查看命令使用方法，如下所示。由几个板块组成，从上到下分别是：当前命令使用形式（Usage）、当前命令用途、支持的可用参数（Options）。</p>
<pre><code class="language-text">Usage: cjcov [options]

A tool used to summarize the coverage in html reports.

Options:
  -v, --version                 Print the version number, then exit.
  -h, --help                    Show this help message, then exit.
  -r ROOT, --root=ROOT          The root directories of your source files, defaults to '.', the current directory.
                                File names are reported relative to this root.
  -o OUTPUT, --output=OUTPUT    The output directories of html reports, defaults to '.', the current directory.
  -b, --branches                Report the branch coverage. (It is an experimental feature and may generate imprecise branch coverage.)
  --verbose                     Print some detail messages, including parsing data for the gcov file.
  --html-details                Generate html reports for each source file.
  -x, --xml                     Generate a xml report.
  -j, --json                    Generate a json report.
  -k, --keep                    Keep gcov files after processing.
  -s SOURCE, --source=SOURCE    The directories of cangjie source files.
  -e EXCLUDE, --exclude=EXCLUDE
                                The cangjie source files starts with EXCLUDE will not be showed in coverage reports.
  -i INCLUDE, --include=INCLUDE
                                The cangjie source files starts with INCLUDE will be showed in coverage reports.
</code></pre>
<p>基本的命令使用方法如下所示，<code>cjcov</code> 为主程序名称，<code>--version</code> 表示为显示 <code>cjcov</code> 的版本号。部分配置项支持长短选项两种写法，效果相同，具体可以使用 <code>cjcov --help</code> 命令参考用法。</p>
<pre><code class="language-text">cjcov -version 或者 cjcov -v
</code></pre>
<h3 id="使用步骤"><a class="header" href="#使用步骤">使用步骤</a></h3>
<p>仓颉版本包准备 --&gt; 仓颉源码准备 --&gt;  使用 <code>--coverage</code> 编译选项构建仓颉源码，生成二进制文件 --&gt; 执行二进制文件 --&gt; <code>cjcov</code> 生成覆盖率统计结果</p>
<p>下面举一个 <code>hello world</code> 的覆盖率的例子（假设当前目录是 <code>WORKPATH</code>）：</p>
<ol>
<li>
<p>仓颉版本包准备</p>
<p>假设仓颉版本包解压在 <code>WORKPATH</code> 目录下，则执行 <code>source WORKPATH/cangjie/envsetup.sh</code> 命令即可。</p>
</li>
<li>
<p>仓颉源码准备</p>
<p>源码目录结构如下：</p>
<pre><code>src/
└── main.cj
</code></pre>
<p><code>main.cj</code> 源码内容如下：</p>
<pre><code>main(): Int64 {
    print(&quot;hello world\n&quot;)
    return 0
}
</code></pre>
</li>
<li>
<p>编译源码，该例子用 <code>cjpm</code> 编译举例</p>
<p>在 <code>WORKPATH</code> 目录下执行以下命令：</p>
<pre><code>cjpm init cangjie test
cjpm build --coverage
</code></pre>
<p>编译完成之后在 <code>WORKPATH</code> 目录下会生成 <code>default.gcno</code> 文件。</p>
</li>
<li>
<p>运行编译出来的二进制</p>
<p>在 <code>WORKPATH</code> 目录下执行 <code>cjpm run --skip-build</code> 命令，运行完成之后 <code>WORKPATH</code> 目录下会生成 <code>default.gcda</code> 文件。</p>
</li>
<li>
<p><code>cjcov</code> 生成 <code>html</code></p>
<p>在 <code>WORKPATH</code> 目录执行 <code>cjcov -o output --html-details</code>，更多 <code>cjcov</code> 参数使用可参考<a href="./cjpm_manual_cjnative_community.html#cjcov--h----help">命令说明</a>章节。</p>
</li>
</ol>
<p>执行完 <code>cjcov</code> 命令之后，在 <code>WORKPATH/output</code> 目录会有以下文件：</p>
<pre><code>output
├── cjcov_logs （该目录存放一些 cjcov 执行过程的详细日志，可不用关注）
│   ├── cjcov.log
│   └── gcov_parse.log
├── index.html （总的覆盖率报告，通过浏览器打开）
└── src_main.cj.html （单个文件的覆盖率，可以通过打开 index.html 自动跳转到该文件）
</code></pre>
<h2 id="命令说明-1"><a class="header" href="#命令说明-1">命令说明</a></h2>
<h3 id="cjcov--h----help"><a class="header" href="#cjcov--h----help">cjcov -h | --help</a></h3>
<p>显示 <code>cjcov</code> 基本使用方法。</p>
<h3 id="cjcov--v----version"><a class="header" href="#cjcov--v----version">cjcov -v | --version</a></h3>
<p>显示 <code>cjcov</code> 的版本号，只要指定了 <code>-v</code> 或者 <code>--version</code> 参数，不管输入其他任何选项参数都不生效，只会显示版本号。如 <code>--version</code> 和 <code>--help</code> 同时使用，则显示 <code>version</code> 信息后退出。</p>
<h3 id="cjcov---verbose"><a class="header" href="#cjcov---verbose">cjcov --verbose</a></h3>
<p>指定该选项后会将一些日志信息生成到 <code>cjcov_logs</code> 目录中，该参数默认不生效，即默认不会打印中间信息。<code>gcov</code> 文件是 <code>cjcov</code> 工具生成的中间文件，<code>cjcov</code> 解析 <code>gcov</code> 文件的格式如下：</p>
<pre><code class="language-text">==================== start: main.cj.gcov =====================

noncode line numbers:
[0, 0, 0, 0, 1, 2, 6, 7, 9, 10, 11, 15, 17, 18]

uncovered line numbers:
[5]

covered data:
[(16, 1), (3, 1), (4, 1), (8, 1), (12, 1), (13, 1), (14, 1)]

branches data:
line number:    4  ==&gt;  data: [(0, 0), (1, 1)]

===================== end: main.cj.gcov =======================

</code></pre>
<p>指定该选项参数，会显示每个 <code>gcov</code> 文件的详细覆盖率数据。</p>
<p>具体字段解释如下：</p>
<ul>
<li><code>start: xxx.gcov, end: xxx.gcov</code>：两行中间的文本是对应 <code>xxx.gcov</code> 文件解析到的覆盖率数据。</li>
<li><code>noncode line numbers</code>：显示的是不统计到总代码行的行号，在 <code>html</code> 中是以白色底呈现，对应 <code>gcov</code> 中的以 <code>-</code> 开头的行数。</li>
<li><code>uncovered line numbers</code>：显示的是没有覆盖到的数据，在 <code>html</code> 中是以红色底呈现，对应 <code>gcov</code> 文件中以 <code>#####</code> 开头的行数。</li>
<li><code>covered data</code>：显示的是覆盖到的数据，以<code>(代码行数, 覆盖次数)</code>呈现，在对应 <code>html</code> 中以绿色呈现，只要覆盖次数大于 0，在 <code>html</code> 中的 <code>Exec</code> 一列中显示为 <code>Y</code>，对应于 <code>gcov</code> 文件以数字开头的行数。</li>
<li><code>branches data</code>：显示的分支覆盖数据，以<code>(代码行数, 分支覆盖次数)</code>呈现，在对应 <code>html</code> 中的 <code>Branch</code> 一列中，有一个倒三角形，显示的是分支覆盖数/总分支数。该数据对应于 <code>gcov</code> 文件中以 <code>branch</code> 开头的数据。</li>
</ul>
<h3 id="cjcov---html-details"><a class="header" href="#cjcov---html-details">cjcov --html-details</a></h3>
<p>如果指定该参数，表示会生成仓颉文件对应的 <code>html</code>。在总的 <code>index</code> 文件里面会有每个子 <code>html</code> 的索引。子 <code>html</code> 文件和 <code>index.html</code> 放在同一个目录。</p>
<p>子 <code>html</code> 文件名是由目录和文件名由下划线拼接起来。如源文件是 <code>src/main.cj</code>，生成的 <code>html</code> 名字为 <code>src_main.cj.html</code>。如果源文件路径带有特殊字符会被替换成 <code>=</code>，下文<a href="./cjpm_manual_cjnative_community.html#%E6%96%87%E4%BB%B6%E5%90%8D%E5%8C%85%E5%90%AB%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6">文件名包含特殊字符</a>章节会有更详细的描述。</p>
<p>如果没有指定该参数，表示不会生成子 <code>html</code> 。在总的 <code>index</code> 文件里面会显示每个子 <code>html</code> 的覆盖率数据，但是不能跳转到对应的子 <code>html</code> 文件。</p>
<p>该参数默认不生效。即默认只会生成一个 <code>index.html</code>, 不会生成子 <code>html</code> 文件。</p>
<h3 id="cjcov--x----xml"><a class="header" href="#cjcov--x----xml">cjcov -x | --xml</a></h3>
<p>如果指定该参数，则会在指定输出路径生成 <code>coverage.xml</code> 文件，<code>coverage.xml</code> 记录的是所有文件的覆盖率数据。</p>
<h3 id="cjcov--j----json"><a class="header" href="#cjcov--j----json">cjcov -j | --json</a></h3>
<p>如果指定该参数，则会在指定输出路径生成 <code>coverage.json</code> 文件，<code>coverage.json</code> 记录的是所有文件的覆盖率数据。</p>
<h3 id="cjcov--k-----keep"><a class="header" href="#cjcov--k-----keep">cjcov -k |  --keep</a></h3>
<p>指定该参数后则不会删除生成的 <code>gcov</code> 中间文件。如果 <code>gcov</code> 文件不删除，会造成执行次数的累加，可能会影响覆盖率数据的准确性。</p>
<p>默认该参数不生效，即默认会删除 <code>gcov</code> 中间文件。</p>
<h3 id="cjcov--b----branches"><a class="header" href="#cjcov--b----branches">cjcov -b | --branches</a></h3>
<p>指定该参数后则会生成分支覆盖率信息。</p>
<p>默认该参数不生效，即默认不生成分支的覆盖率信息，此时在 <code>html</code> 报告中的分支覆盖率数据百分比显示为 <code>-</code>。</p>
<h3 id="cjcov--r-root----rootroot"><a class="header" href="#cjcov--r-root----rootroot">cjcov -r ROOT | --root=ROOT</a></h3>
<p>该参数指定的 <code>ROOT</code> 参数，表示在 <code>ROOT</code> 目录或者在其递归子目录能找到 <code>gcda</code> 文件，<code>gcda</code> 和 <code>gcno</code> 文件默认会生成在一起，建议不要手动特意去把 <code>gcda</code> 文件和 <code>gcno</code> 文件分开存放，不然可能会发生程序不能运行的情况。</p>
<p>参数指定的 <code>ROOT</code> 目录如果不存在，<code>cjcov</code> 工具会有报错提示。</p>
<p>不指定该参数，默认会以当前目录为 <code>ROOT</code> 目录。</p>
<h3 id="cjcov--o-output-----outputoutput"><a class="header" href="#cjcov--o-output-----outputoutput">cjcov -o OUTPUT |  --output=OUTPUT</a></h3>
<p>该参数指定的 <code>OUTPUT</code> 参数，表示 <code>html</code> 覆盖率报告的输出路径。</p>
<p>如果该 <code>OUTPUT</code> 目录不存在，而且其父目录也不存在，<code>cjcov</code> 工具会有报错提示；如果 <code>OUTPUT</code> 目录不存在，但其父目录存在，<code>cjcov</code> 会帮助创建 <code>OUTPUT</code> 目录。</p>
<p>不指定该参数，默认会以当前目录为 <code>OUTPUT</code> 目录来存放 <code>html</code> 文件。</p>
<h3 id="-s-source----sourcesource"><a class="header" href="#-s-source----sourcesource">-s SOURCE | --source=SOURCE</a></h3>
<p>该参数指定的 <code>SOURCE</code> 参数，表示仓颉源文件的代码路径，<code>html</code> 总覆盖率报告 <code>index.html</code> 会有各个源文件的索引，这些文件路径记录的是一个相对路径。如果指定 <code>-s SOURCE |--source SOURCE</code> 参数，优先以 <code>SOURCE</code> 路径列表中的路径作为相对路径的参考路径，如果没有指定该参数，则以 <code>-r ROOT | --root=ROOT</code> 作为相对路径的参考路径，如果都没有指定，则以当前路径作为相对路径的参考路径。</p>
<p>示例：</p>
<p>仓颉代码目录结构如下：</p>
<pre><code>/work/cangjie/tests/API/test01/src/1.cj
/work/cangjie/tests/API/test01/src/2.cj
/work/cangjie/tests/LLVM/test02/src/3.cj
/work/cangjie-tools/tests/LLVM/test01/src/4.cj
/work/cangjie-tools/tests/LLVM/test02/src/5.cj
</code></pre>
<ol>
<li>
<p>在 <code>/work</code> 目录执行命令：</p>
<pre><code>cjcov --root=./ -s &quot;/work/cangjie /work/cangjie-tools/tests&quot; --html-details --output=html_output
</code></pre>
<p>最后 html 中呈现的源文件相对路径是：</p>
<pre><code>tests/API/test01/src/1.cj
tests/API/test01/src/2.cj
tests/LLVM/test02/src/3.cj
LLVM/test01/src/4.cj
LLVM/test02/src/5.cj
</code></pre>
</li>
<li>
<p>在 <code>/work</code> 目录执行命令, 没有指定 <code>--root</code> 参数和 <code>--source</code> 参数，默认当前所在路径为相对路径的参考路径，执行命令如下：</p>
<pre><code>cjcov --html-details --output=html_output
</code></pre>
<p>最后 html 中呈现的源文件相对路径是：</p>
<pre><code>cangjie/tests/API/test01/src/1.cj
cangjie/tests/API/test01/src/2.cj
cangjie/tests/LLVM/test02/src/3.cj
cangjie-tools/tests/LLVM/test01/src/4.cj
cangjie-tools/tests/LLVM/test02/src/5.cj
</code></pre>
</li>
</ol>
<h3 id="-e-exclude----excludeexclude"><a class="header" href="#-e-exclude----excludeexclude">-e EXCLUDE | --exclude=EXCLUDE</a></h3>
<p>该参数指定的 <code>EXCLUDE</code> 参数，表示不需要生成覆盖率信息的源文件列表，支持指定目录和文件。</p>
<p>示例：</p>
<p>仓颉代码目录结构如下：</p>
<pre><code>/usr1/cangjie/tests/API/test01/src/1.cj
/usr1/cangjie/tests/API/test01/src/2.cj
/usr1/cangjie/tests/LLVM/test02/src/3.cj
/usr1/cangjie-tools/tests/LLVM/test01/src/4.cj
/usr1/cangjie-tools/tests/LLVM/test02/src/5.cj
</code></pre>
<p>在 <code>/usr1</code> 目录执行命令：</p>
<pre><code>cjcov --root=./ -s &quot;/usr1/cangjie&quot; -e &quot;/usr1/cangjie-tools/tests/LLVM&quot; --html-details --output=html_output
</code></pre>
<p>最后 <code>html</code> 中呈现的源文件相对路径是,其中以 <code>/usr1/cangjie-tools/tests/LLVM</code> 路径开头的文件不会出现在 <code>html</code> 的文件列表中。</p>
<pre><code>tests/API/test01/src/1.cj
tests/API/test01/src/2.cj
tests/LLVM/test02/src/3.cj
</code></pre>
<h3 id="-i-include----includeinclude"><a class="header" href="#-i-include----includeinclude">-i INCLUDE | --include=INCLUDE</a></h3>
<p>该参数指定的 <code>INCLUDE</code> 参数，表示以 <code>INCLUDE</code> 开头的文件会显示在 <code>index.html</code> 的文件列表中，支持指定目录和文件。如果 <code>-e | --exclude</code> 和 <code>-i | --include</code> 指定的参数有路径重复，会有报错提示。</p>
<p>示例：</p>
<p>仓颉代码目录 <code>/usr1/cangjie/tests</code> 结构如下：</p>
<pre><code>├── API
│   └── test01
│       └── src
│           ├── 1.cj
│           └── 2.cj
└── LLVM
    └── test02
        └── src
            └── 3.cj
</code></pre>
<p>在 <code>/usr1</code> 目录执行命令, 其中 <code>-i</code> 参数表示需要体现在覆盖率报告 <code>index.html</code> 的文件，命令如下：</p>
<pre><code>cjcov --root=./ -s &quot;/usr1/cangjie&quot; -i &quot;/usr1/cangjie/tests/API/test01/src/1.cj /usr1/cangjie/tests/LLVM/test02&quot; --html-details --output=html_output
</code></pre>
<p>上面命令执行后, 在 <code>index.html</code> 中文件路径列表如下(<code>tests/API/test01/src/2.cj</code> 不在 <code>-i</code> 参数指定的列表里面，所以不会出现在 <code>html</code> 的文件列表中):</p>
<pre><code>tests/API/test01/src/1.cj
tests/LLVM/test02/src/3.cj
</code></pre>
<h2 id="特殊场景"><a class="header" href="#特殊场景">特殊场景</a></h2>
<h3 id="二进制无法正常执行结束"><a class="header" href="#二进制无法正常执行结束">二进制无法正常执行结束</a></h3>
<p>对于常驻的网络服务程序无法正常结束二进制文件并生成 <code>gcda</code> 覆盖率数据的场景，需要手动执行退出脚本生成 <code>gcda</code> 覆盖率数据。</p>
<p>1）将以下脚本内容保存为 <code>stop.sh</code>（此脚本执行依赖 <code>gdb</code>）</p>
<pre><code class="language-shell">#!/bin/sh
SERVER_NAME=$1

pid=`ps -ef | grep $SERVER_NAME | grep -v &quot;grep&quot; | awk '{print $2}'`
echo $pid
gdb -q attach $pid &lt;&lt;__EOF__
p exit(0)
__EOF__
</code></pre>
<p>2）常驻服务程序完成业务逻辑操作覆盖后，执行 <code>stop.sh {service_name}</code>，如通过 <code>./main</code> 启动常驻服务进程，通过如下方式停止进程产生 <code>gcda</code> 数据</p>
<pre><code class="language-shell">sh stop.sh ./main
</code></pre>
<h3 id="文件名包含特殊字符"><a class="header" href="#文件名包含特殊字符">文件名包含特殊字符</a></h3>
<p>建议遵循仓颉编程规范命名文件，不建议包含除 [0-9a-zA-Z_] 之外的字符，特殊字符会被替换成 <code>=</code>。</p>
<p>如果文件名有特殊字符，为保证 <code>html</code> 跳转正确，<code>index.html</code> 中呈现的 <code>html</code> 名字和 <code>html</code> 本身文件名会不一致，<code>html</code> 文件名的特殊字符都会被替换成 <code>=</code>。</p>
<p>示例如下：</p>
<p>代码结构：</p>
<pre><code>src
├── 1file#.cj
├── file10_abc.cj
├── file11_.aaa-bbb.cj
├── file12!#aaa!bbb.cj
├── file13~####.cj
├── file14*aa.cj
├── file15`.cj
├── file16(#).cj
├── file2;aa.cj
├── file3,?.cj
├── file4@###.cj
├── file5&amp;cc.cj
├── file6=.cj
├── file7+=.cj
├── file8$.cj
├── file9-aaa.cj
└── main.cj
</code></pre>
<p>生成 html 文件名，其中除了 <code>[0-9a-zA-Z_.=]</code> 之外，其他特殊字符都被替换成了 <code>'='</code>：</p>
<pre><code>.
├── index.html
├── src_1file=.cj.html
├── src_file10_abc.cj.html
├── src_file11_.aaa=bbb.cj.html
├── src_file12==aaa=bbb.cj.html
├── src_file13=####.cj.html
├── src_file14=aa.cj.html
├── src_file15=.cj.html
├── src_file16===.cj.html
├── src_file2=aa.cj.html
├── src_file3==.cj.html
├── src_file4=###.cj.html
├── src_file5=cc.cj.html
├── src_file6=.cj.html
├── src_file7==.cj.html
├── src_file8=.cj.html
├── src_file9=aaa.cj.html
└── src_main.cj.html
</code></pre>
<h3 id="分支覆盖率功能"><a class="header" href="#分支覆盖率功能">分支覆盖率功能</a></h3>
<p>分支覆盖率是一个试验阶段的功能，会出现分支覆盖率数据不准确的情况。</p>
<p>目前已知会出现分支覆盖率数据不准确的场景包含以下几种表达式：</p>
<ul>
<li>
<p><code>try-catch-finally</code> 表达式</p>
</li>
<li>
<p>循环表达式（包括 <code>for</code> 表达式、<code>while</code> 表达式）</p>
</li>
<li>
<p><code>if-else</code> 表达式</p>
</li>
</ul>
<h3 id="部分代码未记录到行覆盖率数据中"><a class="header" href="#部分代码未记录到行覆盖率数据中">部分代码未记录到行覆盖率数据中</a></h3>
<p>部分代码不会记录到行覆盖率数据中，属于正常情况。整体而言，如果一行代码<em>仅包含定义、声明</em>而没有实际的可执行代码，那么这一行代码不会被统计到覆盖率中。目前已知不会统计的场景有：</p>
<ul>
<li>
<p>全局变量的定义，示例如下：</p>
<pre><code class="language-cangjie">let HIGH_1_UInt8: UInt8 = 0b10000000;
</code></pre>
</li>
<li>
<p>成员变量仅声明未初始化赋值，示例如下：</p>
<pre><code class="language-cangjie">public class StringBuilder &lt;: Collection &amp; ToString {
    private var myData: Array
    private var mySize: Int64
    private var endIndex: Int64
}
</code></pre>
</li>
<li>
<p>仅有函数声明未包含函数体（包括 <code>foreign</code> 函数等），示例如下：</p>
<pre><code class="language-cangjie">foreign func cj_core_free(p: CPointer): Unit
</code></pre>
</li>
<li>
<p>枚举类型定义，示例如下：</p>
<pre><code class="language-cangjie">enum Numeric {
    NumDay | NumYearDay | NumYearWeek | NumHour12 | NumHour24 | NumMinute | NumSecond
}
</code></pre>
</li>
<li>
<p>class、extend 等定义，其中 extend 和 class 所在的一行不会记录到覆盖率数据中，示例如下：</p>
<pre><code class="language-cangjie">extend Int8 &lt;: Formatter { // This line wil not account for the coverage.
  ...
}

public class StringBuilder &lt;: Collection &amp; ToString { // This line will not account for the coverage.
   ...
}
</code></pre>
</li>
</ul>
<h3 id="源代码中的-main-函数未被覆盖"><a class="header" href="#源代码中的-main-函数未被覆盖">源代码中的 <code>main</code> 函数未被覆盖</a></h3>
<p><strong>原因：</strong> 使用 <code>cjc --test</code> 编译，仓颉测试框架会生成一个新的 <code>main</code> 作为程序入口，源代码中的 <code>main</code> 不再作为程序入口并且不会被执行。</p>
<p><strong>建议：</strong> 在使用 <code>cjc --test</code> 之后，建议不用再手写多余的 <code>main</code> 。</p>
<h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<h3 id="报错找不到-llvm-cov-命令"><a class="header" href="#报错找不到-llvm-cov-命令">报错找不到 <code>llvm-cov</code> 命令</a></h3>
<p><strong>解决方法：</strong></p>
<p>方法1：设置 <code>CANGJIE_HOME</code> 环境变量, <code>cjcov</code> 可通过 <code>CANGJIE_HOME</code> 环境变量找到 <code>llvm-cov</code> 命令，设置方法如下：
假设 <code>which cjc</code> 显示 <code>/work/cangjie/bin/cjc</code>, 并且 <code>/work/cangjie/bin/llvm/bin</code> 和 <code>/work/cangjie/bin/llvm/lib</code> 目录都存在，则可设置：</p>
<pre><code>export CANGJIE_HOME=/work/cangjie
</code></pre>
<p>方法2：在 <code>/root/.bashrc</code> 里面直接设置环境变量，如 <code>cjc</code> 放在 <code>/work/cangjie/bin/cjc</code> 目录下，则设置方法如下：</p>
<pre><code>export PATH=/work/cangjie/bin/llvm/bin:$PATH
export LIBRARY_PATH=/work/cangjie/bin/llvm/lib:$LIBRARY_PATH
export LD_LIBRARY_PATH=/work/cangjie/bin/llvm/lib:$LD_LIBRARY_PATH
</code></pre>
<p>方法3：手动安装 <code>llvm-cov</code> 命令，如 <code>ubuntu</code> 上可执行命令：</p>
<pre><code>apt install llvm-cov
</code></pre>
<h3 id="出现-virtualmachineerror-outofmemoryerror"><a class="header" href="#出现-virtualmachineerror-outofmemoryerror">出现 VirtualMachineError OutOfMemoryError</a></h3>
<p><strong>问题现象：</strong></p>
<pre><code class="language-text">An exception has occurred:
Error VirtualMachineError OutOfMemoryError
</code></pre>
<p><strong>解决方法：</strong> 仓颉默认规格  stack 1MB，heap 256 MB，建议根据文件数量大小将堆内存调到合适的大小。通常 2GB 的内存能够满足大多数情况，如果不够用则根据具体情况再增加内存大小。</p>
<p>示例：</p>
<pre><code class="language-text">把堆内存扩大到2GB：
export cjHeapSize=2GB
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../source_zh_cn/tools/user_manual_cjnative.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../source_zh_cn/tools/cjdb_manual_cjnative.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../source_zh_cn/tools/user_manual_cjnative.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../source_zh_cn/tools/cjdb_manual_cjnative.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../highlight.js"></script>
        <script src="../../assets/elasticlunr.js"></script>
        <script src="../../assets/fzf.umd.js"></script>
        <script src="../../assets/sidebar.js"></script>


    </div>
    </body>
</html>
